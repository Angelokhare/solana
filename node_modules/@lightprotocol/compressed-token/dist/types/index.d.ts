import { Signer, PublicKey, ConfirmOptions, TransactionSignature, Commitment, Keypair, AccountMeta, TransactionInstruction, Connection } from '@solana/web3.js';
import { Rpc, TreeInfo, ParsedTokenAccount, PackedMerkleContextLegacy, CompressedCpiContext, ValidityProof, InputTokenDataWithContext as InputTokenDataWithContext$1, CompressedProof } from '@lightprotocol/stateless.js';
import BN from 'bn.js';
import { Buffer } from 'buffer';
import * as buffer_layout from 'buffer-layout';

/**
 * Approve a delegate to spend tokens
 *
 * @param rpc                   Rpc to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param amount                Number of tokens to delegate
 * @param owner                 Owner of the SPL token account.
 * @param delegate              Address of the delegate
 * @param confirmOptions        Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function approve(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN, owner: Signer, delegate: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Check if the token pool info is initialized and has a balance.
 * @param mint The mint of the token pool
 * @param tokenPoolInfo The token pool info
 * @returns True if the token pool info is initialized and has a balance
 */
declare function checkTokenPoolInfo(tokenPoolInfo: TokenPoolInfo, mint: PublicKey): boolean;
/**
 * Get the token pool infos for a given mint.
 * @param rpc         The RPC client
 * @param mint        The mint of the token pool
 * @param commitment  The commitment to use
 *
 * @returns The token pool infos
 */
declare function getTokenPoolInfos(rpc: Rpc, mint: PublicKey, commitment?: Commitment): Promise<TokenPoolInfo[]>;
type TokenPoolActivity = {
    signature: string;
    amount: BN;
    action: Action;
};
/**
 * Token pool pda info.
 */
type TokenPoolInfo = {
    /**
     * The mint of the token pool
     */
    mint: PublicKey;
    /**
     * The token pool address
     */
    tokenPoolPda: PublicKey;
    /**
     * The token program of the token pool
     */
    tokenProgram: PublicKey;
    /**
     * count of txs and volume in the past 60 seconds.
     */
    activity?: {
        txs: number;
        amountAdded: BN;
        amountRemoved: BN;
    };
    /**
     * Whether the token pool is initialized
     */
    isInitialized: boolean;
    /**
     * The balance of the token pool
     */
    balance: BN;
    /**
     * The index of the token pool
     */
    poolIndex: number;
    /**
     * The bump used to derive the token pool pda
     */
    bump: number;
};
/**
 * @internal
 */
declare enum Action {
    Compress = 1,
    Decompress = 2,
    Transfer = 3
}
/**
 * For `compress` and `mintTo` instructions only.
 * Select a random token pool info from the token pool infos.
 *
 * For `decompress`, use {@link selectTokenPoolInfosForDecompression} instead.
 *
 * @param infos The token pool infos
 *
 * @returns A random token pool info
 */
declare function selectTokenPoolInfo(infos: TokenPoolInfo[]): TokenPoolInfo;
/**
 * Select one or multiple token pool infos from the token pool infos.
 *
 * Use this function for `decompress`.
 *
 * For `compress`, `mintTo` use {@link selectTokenPoolInfo} instead.
 *
 * @param infos             The token pool infos
 * @param decompressAmount  The amount of tokens to withdraw
 *
 * @returns Array with one or more token pool infos.
 */
declare function selectTokenPoolInfosForDecompression(infos: TokenPoolInfo[], decompressAmount: number | BN): TokenPoolInfo[];

/**
 * Mint compressed tokens to a solana address from an external mint authority
 *
 * @param rpc                   Rpc to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param toPubkey              Address of the account to mint to
 * @param authority             Minting authority
 * @param amount                Amount to mint
 * @param outputStateTreeInfo   Optional: State tree account that the compressed
 *                              tokens should be inserted into. Defaults to a
 *                              shared state tree account.
 * @param tokenPoolInfo         Optional: Token pool info.
 * @param confirmOptions        Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function approveAndMintTo(rpc: Rpc, payer: Signer, mint: PublicKey, toPubkey: PublicKey, authority: Signer, amount: number | BN, outputStateTreeInfo?: TreeInfo, tokenPoolInfo?: TokenPoolInfo, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Compress SPL tokens
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param amount                Number of tokens to compress.
 * @param owner                 Owner of the SPL token account.
 * @param sourceTokenAccount    Source SPL token account. (ATA)
 * @param toAddress             Recipient owner address.
 * @param outputStateTreeInfo   Optional: State tree account that the compressed
 *                              tokens should be inserted into. Defaults to a
 *                              shared state tree account.
 * @param tokenPoolInfo         Optional: Token pool info.
 * @param confirmOptions        Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function compress(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN | number[] | BN[], owner: Signer, sourceTokenAccount: PublicKey, toAddress: PublicKey | Array<PublicKey>, outputStateTreeInfo?: TreeInfo, tokenPoolInfo?: TokenPoolInfo, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Compress SPL tokens into compressed token format
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param owner                 Owner of the token account
 * @param tokenAccount          Token account to compress
 * @param remainingAmount       Optional: amount to leave in token account.
 *                              Default: 0
 * @param outputStateTreeInfo   Optional: State tree account that the compressed
 *                              account into
 * @param tokenPoolInfo         Optional: Token pool info.
 * @param confirmOptions        Options for confirming the transaction

 *
 * @return Signature of the confirmed transaction
 */
declare function compressSplTokenAccount(rpc: Rpc, payer: Signer, mint: PublicKey, owner: Signer, tokenAccount: PublicKey, remainingAmount?: BN, outputStateTreeInfo?: TreeInfo, tokenPoolInfo?: TokenPoolInfo, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Create and initialize a new compressed token mint
 *
 * @param rpc               RPC connection to use
 * @param payer             Fee payer
 * @param mintAuthority     Account that will control minting
 * @param decimals          Location of the decimal place
 * @param keypair           Optional: Mint keypair. Defaults to a random
 *                          keypair.
 * @param confirmOptions    Options for confirming the transaction
 * @param tokenProgramId    Optional: Program ID for the token. Defaults to
 *                          TOKEN_PROGRAM_ID.
 * @param freezeAuthority   Optional: Account that will control freeze and thaw.
 *                          Defaults to none.
 *
 * @return Object with mint address and transaction signature
 */
declare function createMint(rpc: Rpc, payer: Signer, mintAuthority: PublicKey | Signer, decimals: number, keypair?: Keypair, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey | boolean, freezeAuthority?: PublicKey | Signer): Promise<{
    mint: PublicKey;
    transactionSignature: TransactionSignature;
}>;

/**
 * Register an existing mint with the CompressedToken program
 *
 * @param rpc             RPC connection to use
 * @param payer           Fee payer
 * @param mint            SPL Mint address
 * @param confirmOptions  Options for confirming the transaction
 * @param tokenProgramId  Optional: Address of the token program. Default:
 *                        TOKEN_PROGRAM_ID
 *
 * @return transaction signature
 */
declare function createTokenPool(rpc: Rpc, payer: Signer, mint: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;
/**
 * Create additional token pools for an existing mint
 *
 * @param rpc                   RPC connection to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param numMaxAdditionalPools Number of additional token pools to create. Max
 *                              3.
 * @param confirmOptions        Optional: Options for confirming the transaction
 * @param tokenProgramId        Optional: Address of the token program. Default:
 *                              TOKEN_PROGRAM_ID
 *
 * @return transaction signature
 */
declare function addTokenPools(rpc: Rpc, payer: Signer, mint: PublicKey, numMaxAdditionalPools: number, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<string>;

/**
 * Create a lookup table for the token program's default accounts
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Fee payer
 * @param authority             Authority of the lookup table
 * @param mints                 Optional array of mint public keys to include in
 *                              the lookup table
 * @param additionalAccounts    Optional array of additional account public keys
 *                              to include in the lookup table
 *
 * @return Object with transaction signatures and the address of the created
 *         lookup table
 */
declare function createTokenProgramLookupTable(rpc: Rpc, payer: Signer, authority: Signer, mints?: PublicKey[], additionalAccounts?: PublicKey[]): Promise<{
    txIds: TransactionSignature[];
    address: PublicKey;
}>;

/**
 * Decompress compressed tokens
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param amount                Number of tokens to transfer
 * @param owner                 Owner of the compressed tokens
 * @param toAddress             Destination **uncompressed** token account
 *                              address. (ATA)
 * @param tokenPoolInfos        Optional: Token pool infos.
 * @param confirmOptions        Options for confirming the transaction
 *
 * @return confirmed transaction signature
 */
declare function decompress(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN, owner: Signer, toAddress: PublicKey, tokenPoolInfos?: TokenPoolInfo[], confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Merge multiple compressed token accounts for a given mint into a single
 * account
 *
 * @param rpc                   RPC connection to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param owner                 Owner of the token accounts to be merged
 * @param confirmOptions        Options for confirming the transaction
 *
 * @return confirmed transaction signature
 */
declare function mergeTokenAccounts(rpc: Rpc, payer: Signer, mint: PublicKey, owner: Signer, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Mint compressed tokens to a solana address
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param toPubkey              Address of the account to mint to. Can be an
 *                              array of addresses if the amount is an array of
 *                              amounts.
 * @param authority             Mint authority
 * @param amount                Amount to mint. Pass an array of amounts if the
 *                              toPubkey is an array of addresses.
 * @param outputStateTreeInfo   Optional: State tree account that the compressed
 *                              tokens should be part of. Defaults to the
 *                              default state tree account.
 * @param tokenPoolInfo         Optional: Token pool information
 * @param confirmOptions        Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function mintTo(rpc: Rpc, payer: Signer, mint: PublicKey, toPubkey: PublicKey | PublicKey[], authority: Signer, amount: number | BN | number[] | BN[], outputStateTreeInfo?: TreeInfo, tokenPoolInfo?: TokenPoolInfo, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Revoke one or more delegated token accounts
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Fee payer
 * @param accounts              Delegated compressed token accounts to revoke
 * @param owner                 Owner of the compressed tokens
 * @param confirmOptions        Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function revoke(rpc: Rpc, payer: Signer, accounts: ParsedTokenAccount[], owner: Signer, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Transfer compressed tokens from one owner to another
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param amount                Number of tokens to transfer
 * @param owner                 Owner of the compressed tokens
 * @param toAddress             Destination address of the recipient
 * @param confirmOptions        Options for confirming the transaction
 *
 * @return confirmed transaction signature
 */
declare function transfer(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN, owner: Signer, toAddress: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Transfer delegated compressed tokens to another owner
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param amount                Number of tokens to transfer
 * @param owner                 Owner of the compressed tokens
 * @param toAddress             Destination address of the recipient
 * @param confirmOptions        Options for confirming the transaction
 *
 * @return confirmed transaction signature
 */
declare function transferDelegated(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN, owner: Signer, toAddress: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Decompress delegated compressed tokens. Remaining compressed tokens are
 * returned to the owner without delegation.
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Fee payer
 * @param mint                  SPL Mint address
 * @param amount                Number of tokens to decompress
 * @param owner                 Owner of the compressed tokens
 * @param toAddress             Destination **uncompressed** token account
 *                              address. (ATA)
 * @param tokenPoolInfos        Optional: Token pool infos.
 * @param confirmOptions        Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function decompressDelegated(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN, owner: Signer, toAddress: PublicKey, tokenPoolInfos?: TokenPoolInfo[], confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

declare const ERROR_NO_ACCOUNTS_FOUND = "Could not find accounts to select for transfer.";
/**
 * Selects token accounts for approval, first trying to find an exact match, then falling back to minimum selection.
 *
 * @param {ParsedTokenAccount[]} accounts - Token accounts to choose from.
 * @param {BN} approveAmount - Amount to approve.
 * @param {number} [maxInputs=4] - Max accounts to select when falling back to minimum selection.
 * @returns {[
 *   selectedAccounts: ParsedTokenAccount[],
 *   total: BN,
 *   totalLamports: BN | null,
 *   maxPossibleAmount: BN
 * ]} - Returns:
 *   - selectedAccounts: Accounts chosen for approval.
 *   - total: Total amount from selected accounts.
 *   - totalLamports: Total lamports from selected accounts.
 *   - maxPossibleAmount: Max approvable amount given maxInputs.
 */
declare function selectTokenAccountsForApprove(accounts: ParsedTokenAccount[], approveAmount: BN, maxInputs?: number): [
    selectedAccounts: ParsedTokenAccount[],
    total: BN,
    totalLamports: BN | null,
    maxPossibleAmount: BN
];
/**
 * Selects the minimum number of compressed token accounts required for a
 * decompress instruction, up to a specified maximum.
 *
 * @param {ParsedTokenAccount[]} accounts   Token accounts to choose from.
 * @param {BN} amount                       Amount to decompress.
 * @param {number} [maxInputs=4]            Max accounts to select. Default
 *                                          is 4.
 *
 * @returns Returns selected accounts and their totals.
 */
declare function selectMinCompressedTokenAccountsForDecompression(accounts: ParsedTokenAccount[], amount: BN, maxInputs?: number): {
    selectedAccounts: ParsedTokenAccount[];
    total: BN;
    totalLamports: BN | null;
    maxPossibleAmount: BN;
};
/**
 * Selects the minimum number of compressed token accounts required for a
 * transfer or decompression instruction, up to a specified maximum.
 *
 * @param {ParsedTokenAccount[]} accounts   Token accounts to choose from.
 * @param {BN} transferAmount               Amount to transfer or decompress.
 * @param {number} [maxInputs=4]            Max accounts to select. Default
 *                                          is 4.
 *
 * @returns Returns selected accounts and their totals. [
 *   selectedAccounts: ParsedTokenAccount[],
 *   total: BN,
 *   totalLamports: BN | null,
 *   maxPossibleAmount: BN
 * ]
 */
declare function selectMinCompressedTokenAccountsForTransfer(accounts: ParsedTokenAccount[], transferAmount: BN, maxInputs?: number): [
    selectedAccounts: ParsedTokenAccount[],
    total: BN,
    totalLamports: BN | null,
    maxPossibleAmount: BN
];
/**
 * Executes {@link selectMinCompressedTokenAccountsForTransfer} strategy,
 * returns partial amounts if insufficient accounts are found instead of
 * throwing an error.
 */
declare function selectMinCompressedTokenAccountsForTransferOrPartial(accounts: ParsedTokenAccount[], transferAmount: BN, maxInputs?: number): [
    selectedAccounts: ParsedTokenAccount[],
    total: BN,
    totalLamports: BN | null,
    maxPossibleAmount: BN
];
/**
 * Selects compressed token accounts for a transfer, ensuring one extra account
 * if possible, up to maxInputs.
 *
 * 1. Sorts accounts by amount (desc)
 * 2. Selects accounts until transfer amount is met or maxInputs is reached,
 *    attempting to add one extra account if possible.
 *
 * @param {ParsedTokenAccount[]} accounts - The list of token accounts to select from.
 * @param {BN} transferAmount - The token amount to be transferred.
 * @param {number} [maxInputs=4] - The maximum number of accounts to select. Default: 4.
 * @returns {[
 *   selectedAccounts: ParsedTokenAccount[],
 *   total: BN,
 *   totalLamports: BN | null,
 *   maxPossibleAmount: BN
 * ]} - An array containing:
 *   - selectedAccounts: The accounts selected for the transfer.
 *   - total: The total amount accumulated from the selected accounts.
 *   - totalLamports: The total lamports accumulated from the selected accounts.
 *   - maxPossibleAmount: The maximum possible amount that can be transferred considering maxInputs.
 *
 * @example
 * const accounts = [
 *   { parsed: { amount: new BN(100) }, compressedAccount: { lamports: new BN(10) } },
 *   { parsed: { amount: new BN(50) }, compressedAccount: { lamports: new BN(5) } },
 *   { parsed: { amount: new BN(25) }, compressedAccount: { lamports: new BN(2) } },
 * ];
 * const transferAmount = new BN(75);
 * const maxInputs = 2;
 *
 * const [selectedAccounts, total, totalLamports, maxPossibleAmount] =
 *   selectSmartCompressedTokenAccountsForTransfer(accounts, transferAmount, maxInputs);
 *
 * console.log(selectedAccounts.length); // 2
 * console.log(total.toString()); // '150'
 * console.log(totalLamports!.toString()); // '15'
 * console.log(maxPossibleAmount.toString()); // '150'
 */
declare function selectSmartCompressedTokenAccountsForTransfer(accounts: ParsedTokenAccount[], transferAmount: BN, maxInputs?: number): [
    selectedAccounts: ParsedTokenAccount[],
    total: BN,
    totalLamports: BN | null,
    maxPossibleAmount: BN
];
/**
 * Executes {@link selectMinCompressedTokenAccountsForTransfer} strategy,
 * returns partial amounts if insufficient accounts are found instead of
 * throwing an error.
 */
declare function selectSmartCompressedTokenAccountsForTransferOrPartial(accounts: ParsedTokenAccount[], transferAmount: BN, maxInputs?: number): [
    selectedAccounts: ParsedTokenAccount[],
    total: BN,
    totalLamports: BN | null,
    maxPossibleAmount: BN
];

type TokenTransferOutputData = {
    /**
     * The owner of the output token account
     */
    owner: PublicKey;
    /**
     * The amount of tokens of the output token account
     */
    amount: BN;
    /**
     * lamports associated with the output token account
     */
    lamports: BN | null;
    /**
     * TokenExtension tlv
     */
    tlv: Buffer | null;
};
type PackedTokenTransferOutputData = {
    /**
     * The owner of the output token account
     */
    owner: PublicKey;
    /**
     * The amount of tokens of the output token account
     */
    amount: BN;
    /**
     * lamports associated with the output token account
     */
    lamports: BN | null;
    /**
     * Merkle tree pubkey index in remaining accounts
     */
    merkleTreeIndex: number;
    /**
     * TokenExtension tlv
     */
    tlv: Buffer | null;
};
type InputTokenDataWithContext = {
    amount: BN;
    delegateIndex: number | null;
    merkleContext: PackedMerkleContextLegacy;
    rootIndex: number;
    lamports: BN | null;
    tlv: Buffer | null;
};
type DelegatedTransfer = {
    owner: PublicKey;
    delegateChangeAccountIndex: number | null;
};
type BatchCompressInstructionData = {
    pubkeys: PublicKey[];
    amounts: BN[] | null;
    lamports: BN | null;
    amount: BN | null;
    index: number;
    bump: number;
};
type MintToInstructionData = {
    recipients: PublicKey[];
    amounts: BN[];
    lamports: BN | null;
};
type CompressSplTokenAccountInstructionData = {
    owner: PublicKey;
    remainingAmount: BN | null;
    cpiContext: CompressedCpiContext | null;
};
declare function isSingleTokenPoolInfo(tokenPoolInfos: TokenPoolInfo | TokenPoolInfo[]): tokenPoolInfos is TokenPoolInfo;
type CompressedTokenInstructionDataTransfer = {
    /**
     * Validity proof
     */
    proof: ValidityProof | null;
    /**
     * The mint of the transfer
     */
    mint: PublicKey;
    /**
     * Whether the signer is a delegate
     */
    delegatedTransfer: DelegatedTransfer | null;
    /**
     * Input token data with packed merkle context
     */
    inputTokenDataWithContext: InputTokenDataWithContext[];
    /**
     * Data of the output token accounts
     */
    outputCompressedAccounts: PackedTokenTransferOutputData[];
    /**
     * Whether it's a compress or decompress action if compressOrDecompressAmount is non-null
     */
    isCompress: boolean;
    /**
     * If null, it's a transfer.
     * If some, the amount that is being deposited into (compress) or withdrawn from (decompress) the token escrow
     */
    compressOrDecompressAmount: BN | null;
    /**
     * CPI context if
     */
    cpiContext: CompressedCpiContext | null;
    /**
     * The index of the Merkle tree for a lamport change account.
     */
    lamportsChangeAccountMerkleTreeIndex: number | null;
};
type TokenData = {
    /**
     * The mint associated with this account
     */
    mint: PublicKey;
    /**
     * The owner of this account
     */
    owner: PublicKey;
    /**
     * The amount of tokens this account holds
     */
    amount: BN;
    /**
     * If `delegate` is `Some` then `delegated_amount` represents the amount
     * authorized by the delegate
     */
    delegate: PublicKey | null;
    /**
     * The account's state
     */
    state: number;
    /**
     * TokenExtension tlv
     */
    tlv: Buffer | null;
};
type CompressedTokenInstructionDataApprove = {
    proof: ValidityProof | null;
    mint: PublicKey;
    inputTokenDataWithContext: InputTokenDataWithContext[];
    cpiContext: CompressedCpiContext | null;
    delegate: PublicKey;
    delegatedAmount: BN;
    delegateMerkleTreeIndex: number;
    changeAccountMerkleTreeIndex: number;
    delegateLamports: BN | null;
};
type CompressedTokenInstructionDataRevoke = {
    proof: ValidityProof | null;
    mint: PublicKey;
    inputTokenDataWithContext: InputTokenDataWithContext[];
    cpiContext: CompressedCpiContext | null;
    outputAccountMerkleTreeIndex: number;
};

type PackCompressedTokenAccountsParams = {
    /** Input state to be consumed */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * State trees that the output should be inserted into. Defaults to the 0th
     * state tree of the input state. Gets padded to the length of
     * outputCompressedAccounts.
     */
    outputStateTreeInfo?: TreeInfo;
    /** Optional remaining accounts to append to */
    remainingAccounts?: PublicKey[];
    /**
     *  Root indices that are used on-chain to fetch the correct root
     *  from the state Merkle tree account for validity proof verification.
     */
    rootIndices: number[];
    tokenTransferOutputs: TokenTransferOutputData[];
};
/**
 * Packs Compressed Token Accounts.
 */
declare function packCompressedTokenAccounts(params: PackCompressedTokenAccountsParams): {
    inputTokenDataWithContext: InputTokenDataWithContext$1[];
    remainingAccountMetas: AccountMeta[];
    packedOutputTokenData: PackedTokenTransferOutputData[];
};

/**
 * Check if all input accounts belong to the same mint.
 *
 * @param compressedTokenAccounts   The compressed token accounts
 * @param mint                      The mint of the token pool
 * @returns True if all input accounts belong to the same mint
 */
declare function checkMint(compressedTokenAccounts: ParsedTokenAccount[], mint: PublicKey): boolean;

declare const POOL_SEED: Buffer;
declare const CPI_AUTHORITY_SEED: Buffer;
declare const SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE = 1461600;
declare const CREATE_TOKEN_POOL_DISCRIMINATOR: Buffer;
declare const MINT_TO_DISCRIMINATOR: Buffer;
declare const BATCH_COMPRESS_DISCRIMINATOR: Buffer;
declare const TRANSFER_DISCRIMINATOR: Buffer;
declare const COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR: Buffer;
declare const APPROVE_DISCRIMINATOR: Buffer;
declare const REVOKE_DISCRIMINATOR: Buffer;
declare const ADD_TOKEN_POOL_DISCRIMINATOR: Buffer;

type LightCompressedToken = {
    version: '1.2.0';
    name: 'light_compressed_token';
    instructions: [
        {
            name: 'createTokenPool';
            docs: [
                'This instruction creates a token pool for a given mint. Every spl mint',
                'can have one token pool. When a token is compressed the tokens are',
                'transferrred to the token pool, and their compressed equivalent is',
                'minted into a Merkle tree.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'addTokenPool';
            docs: [
                'This instruction creates an additional token pool for a given mint.',
                'The maximum number of token pools per mint is 5.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'existingTokenPoolPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'tokenPoolIndex';
                    type: 'u8';
                }
            ];
        },
        {
            name: 'mintTo';
            docs: [
                'Mints tokens from an spl token mint to a list of compressed accounts.',
                'Minted tokens are transferred to a pool account owned by the compressed',
                'token program. The instruction creates one compressed output account for',
                'every amount and pubkey input pair. A constant amount of lamports can be',
                'transferred to each output account to enable. A use case to add lamports',
                'to a compressed token account is to prevent spam. This is the only way',
                'to add lamports to a compressed token account.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['programs'];
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'publicKeys';
                    type: {
                        vec: 'publicKey';
                    };
                },
                {
                    name: 'amounts';
                    type: {
                        vec: 'u64';
                    };
                },
                {
                    name: 'lamports';
                    type: {
                        option: 'u64';
                    };
                }
            ];
        },
        {
            name: 'compressSplTokenAccount';
            docs: [
                'Compresses the balance of an spl token account sub an optional remaining',
                'amount. This instruction does not close the spl token account. To close',
                'the account bundle a close spl account instruction in your transaction.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'owner';
                    type: 'publicKey';
                },
                {
                    name: 'remainingAmount';
                    type: {
                        option: 'u64';
                    };
                },
                {
                    name: 'cpiContext';
                    type: {
                        option: {
                            defined: 'CompressedCpiContext';
                        };
                    };
                }
            ];
        },
        {
            name: 'transfer';
            docs: [
                'Transfers compressed tokens from one account to another. All accounts',
                'must be of the same mint. Additional spl tokens can be compressed or',
                'decompressed. In one transaction only compression or decompression is',
                'possible. Lamports can be transferred alongside tokens. If output token',
                'accounts specify less lamports than inputs the remaining lamports are',
                'transferred to an output compressed account. Signer must be owner or',
                'delegate. If a delegated token account is transferred the delegate is',
                'not preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'approve';
            docs: [
                'Delegates an amount to a delegate. A compressed token account is either',
                'completely delegated or not. Prior delegates are not preserved. Cannot',
                'be called by a delegate.',
                'The instruction creates two output accounts:',
                '1. one account with delegated amount',
                '2. one account with remaining(change) amount'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'revoke';
            docs: [
                'Revokes a delegation. The instruction merges all inputs into one output',
                'account. Cannot be called by a delegate. Delegates are not preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'freeze';
            docs: [
                'Freezes compressed token accounts. Inputs must not be frozen. Creates as',
                'many outputs as inputs. Balances and delegates are preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['that this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'thaw';
            docs: [
                'Thaws frozen compressed token accounts. Inputs must be frozen. Creates',
                'as many outputs as inputs. Balances and delegates are preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['that this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'burn';
            docs: [
                'Burns compressed tokens and spl tokens from the pool account. Delegates',
                'can burn tokens. The output compressed token account remains delegated.',
                'Creates one output compressed token account.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'stubIdlBuild';
            docs: [
                'This function is a stub to allow Anchor to include the input types in',
                'the IDL. It should not be included in production builds nor be called in',
                'practice.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs1';
                    type: {
                        defined: 'CompressedTokenInstructionDataTransfer';
                    };
                },
                {
                    name: 'inputs2';
                    type: {
                        defined: 'TokenData';
                    };
                }
            ];
        }
    ];
    types: [
        {
            name: 'AccountState';
            type: {
                kind: 'enum';
                variants: [
                    {
                        name: 'Initialized';
                    },
                    {
                        name: 'Frozen';
                    }
                ];
            };
        },
        {
            name: 'CompressedAccount';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'lamports';
                        type: 'u64';
                    },
                    {
                        name: 'address';
                        type: {
                            option: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'data';
                        type: {
                            option: {
                                defined: 'CompressedAccountData';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedAccountData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'discriminator';
                        type: {
                            array: ['u8', 8];
                        };
                    },
                    {
                        name: 'data';
                        type: 'bytes';
                    },
                    {
                        name: 'dataHash';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedCpiContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'setContext';
                        docs: [
                            'Is set by the program that is invoking the CPI to signal that is should',
                            'set the cpi context.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'firstSetContext';
                        docs: [
                            'Is set to wipe the cpi context since someone could have set it before',
                            'with unrelated data.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'cpiContextAccountIndex';
                        docs: [
                            'Index of cpi context account in remaining accounts.'
                        ];
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'CompressedProof';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'a';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'b';
                        type: {
                            array: ['u8', 64];
                        };
                    },
                    {
                        name: 'c';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedTokenInstructionDataTransfer';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'mint';
                        type: 'publicKey';
                    },
                    {
                        name: 'delegatedTransfer';
                        docs: [
                            'Is required if the signer is delegate,',
                            '-> delegate is authority account,',
                            'owner = Some(owner) is the owner of the token account.'
                        ];
                        type: {
                            option: {
                                defined: 'DelegatedTransfer';
                            };
                        };
                    },
                    {
                        name: 'inputTokenDataWithContext';
                        type: {
                            vec: {
                                defined: 'InputTokenDataWithContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'PackedTokenTransferOutputData';
                            };
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'compressOrDecompressAmount';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    },
                    {
                        name: 'lamportsChangeAccountMerkleTreeIndex';
                        type: {
                            option: 'u8';
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedTokenInstructionDataRevoke';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'mint';
                        type: 'publicKey';
                    },
                    {
                        name: 'inputTokenDataWithContext';
                        type: {
                            vec: {
                                defined: 'InputTokenDataWithContext';
                            };
                        };
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    },
                    {
                        name: 'outputAccountMerkleTreeIndex';
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'CompressedTokenInstructionDataApprove';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'mint';
                        type: 'publicKey';
                    },
                    {
                        name: 'inputTokenDataWithContext';
                        type: {
                            vec: {
                                defined: 'InputTokenDataWithContext';
                            };
                        };
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    },
                    {
                        name: 'delegate';
                        type: 'publicKey';
                    },
                    {
                        name: 'delegatedAmount';
                        type: 'u64';
                    },
                    {
                        name: 'delegateMerkleTreeIndex';
                        type: 'u8';
                    },
                    {
                        name: 'changeAccountMerkleTreeIndex';
                        type: 'u8';
                    },
                    {
                        name: 'delegateLamports';
                        type: {
                            option: 'u64';
                        };
                    }
                ];
            };
        },
        {
            name: 'DelegatedTransfer';
            docs: [
                'Struct to provide the owner when the delegate is signer of the transaction.'
            ];
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'delegateChangeAccountIndex';
                        docs: [
                            'Index of change compressed account in output compressed accounts. In',
                            "case that the delegate didn't spend the complete delegated compressed",
                            'account balance the change compressed account will be delegated to her',
                            'as well.'
                        ];
                        type: {
                            option: 'u8';
                        };
                    }
                ];
            };
        },
        {
            name: 'InputTokenDataWithContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'amount';
                        type: 'u64';
                    },
                    {
                        name: 'delegateIndex';
                        type: {
                            option: 'u8';
                        };
                    },
                    {
                        name: 'merkleContext';
                        type: {
                            defined: 'PackedMerkleContext';
                        };
                    },
                    {
                        name: 'rootIndex';
                        type: 'u16';
                    },
                    {
                        name: 'lamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvoke';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvokeCpi';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'MerkleTreeSequenceNumber';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'pubkey';
                        type: 'publicKey';
                    },
                    {
                        name: 'seq';
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'NewAddressParamsPacked';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'seed';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'addressQueueAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeRootIndex';
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'OutputCompressedAccountWithPackedContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleTreeIndex';
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'PackedCompressedAccountWithMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleContext';
                        type: {
                            defined: 'PackedMerkleContext';
                        };
                    },
                    {
                        name: 'rootIndex';
                        docs: [
                            'Index of root used in inclusion validity proof.'
                        ];
                        type: 'u16';
                    },
                    {
                        name: 'readOnly';
                        docs: [
                            'Placeholder to mark accounts read-only unimplemented set to false.'
                        ];
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'PackedMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'merkleTreePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'queuePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'leafIndex';
                        type: 'u32';
                    },
                    {
                        name: 'proveByIndex';
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'PackedTokenTransferOutputData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'amount';
                        type: 'u64';
                    },
                    {
                        name: 'lamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'merkleTreeIndex';
                        type: 'u8';
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'PublicTransactionEvent';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'inputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'outputLeafIndices';
                        type: {
                            vec: 'u32';
                        };
                    },
                    {
                        name: 'sequenceNumbers';
                        type: {
                            vec: {
                                defined: 'MerkleTreeSequenceNumber';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'pubkeyArray';
                        type: {
                            vec: 'publicKey';
                        };
                    },
                    {
                        name: 'message';
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'QueueIndex';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'queueId';
                        docs: ['Id of queue in queue account.'];
                        type: 'u8';
                    },
                    {
                        name: 'index';
                        docs: ['Index of compressed account hash in queue.'];
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'TokenData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'mint';
                        docs: ['The mint associated with this account'];
                        type: 'publicKey';
                    },
                    {
                        name: 'owner';
                        docs: ['The owner of this account.'];
                        type: 'publicKey';
                    },
                    {
                        name: 'amount';
                        docs: ['The amount of tokens this account holds.'];
                        type: 'u64';
                    },
                    {
                        name: 'delegate';
                        docs: [
                            'If `delegate` is `Some` then `delegated_amount` represents',
                            'the amount authorized by the delegate'
                        ];
                        type: {
                            option: 'publicKey';
                        };
                    },
                    {
                        name: 'state';
                        docs: ["The account's state"];
                        type: {
                            defined: 'AccountState';
                        };
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        }
    ];
    errors: [
        {
            code: 6000;
            name: 'PublicKeyAmountMissmatch';
            msg: 'public keys and amounts must be of same length';
        },
        {
            code: 6001;
            name: 'ComputeInputSumFailed';
            msg: 'ComputeInputSumFailed';
        },
        {
            code: 6002;
            name: 'ComputeOutputSumFailed';
            msg: 'ComputeOutputSumFailed';
        },
        {
            code: 6003;
            name: 'ComputeCompressSumFailed';
            msg: 'ComputeCompressSumFailed';
        },
        {
            code: 6004;
            name: 'ComputeDecompressSumFailed';
            msg: 'ComputeDecompressSumFailed';
        },
        {
            code: 6005;
            name: 'SumCheckFailed';
            msg: 'SumCheckFailed';
        },
        {
            code: 6006;
            name: 'DecompressRecipientUndefinedForDecompress';
            msg: 'DecompressRecipientUndefinedForDecompress';
        },
        {
            code: 6007;
            name: 'CompressedPdaUndefinedForDecompress';
            msg: 'CompressedPdaUndefinedForDecompress';
        },
        {
            code: 6008;
            name: 'DeCompressAmountUndefinedForDecompress';
            msg: 'DeCompressAmountUndefinedForDecompress';
        },
        {
            code: 6009;
            name: 'CompressedPdaUndefinedForCompress';
            msg: 'CompressedPdaUndefinedForCompress';
        },
        {
            code: 6010;
            name: 'DeCompressAmountUndefinedForCompress';
            msg: 'DeCompressAmountUndefinedForCompress';
        },
        {
            code: 6011;
            name: 'DelegateSignerCheckFailed';
            msg: 'DelegateSignerCheckFailed';
        },
        {
            code: 6012;
            name: 'MintTooLarge';
            msg: 'Minted amount greater than u64::MAX';
        },
        {
            code: 6013;
            name: 'SplTokenSupplyMismatch';
            msg: 'SplTokenSupplyMismatch';
        },
        {
            code: 6014;
            name: 'HeapMemoryCheckFailed';
            msg: 'HeapMemoryCheckFailed';
        },
        {
            code: 6015;
            name: 'InstructionNotCallable';
            msg: 'The instruction is not callable';
        },
        {
            code: 6016;
            name: 'ArithmeticUnderflow';
            msg: 'ArithmeticUnderflow';
        },
        {
            code: 6017;
            name: 'HashToFieldError';
            msg: 'HashToFieldError';
        },
        {
            code: 6018;
            name: 'InvalidAuthorityMint';
            msg: 'Expected the authority to be also a mint authority';
        },
        {
            code: 6019;
            name: 'InvalidFreezeAuthority';
            msg: 'Provided authority is not the freeze authority';
        },
        {
            code: 6020;
            name: 'InvalidDelegateIndex';
        },
        {
            code: 6021;
            name: 'TokenPoolPdaUndefined';
        },
        {
            code: 6022;
            name: 'IsTokenPoolPda';
            msg: 'Compress or decompress recipient is the same account as the token pool pda.';
        },
        {
            code: 6023;
            name: 'InvalidTokenPoolPda';
        },
        {
            code: 6024;
            name: 'NoInputTokenAccountsProvided';
        },
        {
            code: 6025;
            name: 'NoInputsProvided';
        },
        {
            code: 6026;
            name: 'MintHasNoFreezeAuthority';
        },
        {
            code: 6027;
            name: 'MintWithInvalidExtension';
        },
        {
            code: 6028;
            name: 'InsufficientTokenAccountBalance';
            msg: 'The token account balance is less than the remaining amount.';
        },
        {
            code: 6029;
            name: 'InvalidTokenPoolBump';
            msg: 'Max number of token pools reached.';
        },
        {
            code: 6030;
            name: 'FailedToDecompress';
        },
        {
            code: 6031;
            name: 'FailedToBurnSplTokensFromTokenPool';
        },
        {
            code: 6032;
            name: 'NoMatchingBumpFound';
        }
    ];
};
declare const IDL: LightCompressedToken;

declare const DelegatedTransferLayout: buffer_layout.Layout<unknown>;
declare const CpiContextLayout: buffer_layout.Layout<unknown>;
declare const CompressedTokenInstructionDataTransferLayout: buffer_layout.Layout<unknown>;
declare const mintToLayout: buffer_layout.Layout<unknown>;
declare const batchCompressLayout: buffer_layout.Layout<unknown>;
declare const compressSplTokenAccountInstructionDataLayout: buffer_layout.Layout<unknown>;
declare function encodeMintToInstructionData(data: MintToInstructionData): Buffer;
declare function decodeMintToInstructionData(buffer: Buffer): MintToInstructionData;
declare function encodeBatchCompressInstructionData(data: BatchCompressInstructionData): Buffer;
declare function decodeBatchCompressInstructionData(buffer: Buffer): BatchCompressInstructionData;
declare function encodeCompressSplTokenAccountInstructionData(data: CompressSplTokenAccountInstructionData): Buffer;
declare function decodeCompressSplTokenAccountInstructionData(buffer: Buffer): CompressSplTokenAccountInstructionData;
declare function encodeTransferInstructionData(data: CompressedTokenInstructionDataTransfer): Buffer;
declare function decodeTransferInstructionData(buffer: Buffer): CompressedTokenInstructionDataTransfer;
interface BaseAccountsLayoutParams {
    feePayer: PublicKey;
    authority: PublicKey;
    cpiAuthorityPda: PublicKey;
    lightSystemProgram: PublicKey;
    registeredProgramPda: PublicKey;
    noopProgram: PublicKey;
    accountCompressionAuthority: PublicKey;
    accountCompressionProgram: PublicKey;
    selfProgram: PublicKey;
    systemProgram: PublicKey;
}
type createTokenPoolAccountsLayoutParams = {
    feePayer: PublicKey;
    tokenPoolPda: PublicKey;
    systemProgram: PublicKey;
    mint: PublicKey;
    tokenProgram: PublicKey;
    cpiAuthorityPda: PublicKey;
};
type addTokenPoolAccountsLayoutParams = createTokenPoolAccountsLayoutParams & {
    existingTokenPoolPda: PublicKey;
};
type mintToAccountsLayoutParams = BaseAccountsLayoutParams & {
    mint: PublicKey;
    tokenPoolPda: PublicKey;
    tokenProgram: PublicKey;
    merkleTree: PublicKey;
    solPoolPda: PublicKey | null;
};
type transferAccountsLayoutParams = BaseAccountsLayoutParams & {
    tokenPoolPda?: PublicKey;
    compressOrDecompressTokenAccount?: PublicKey;
    tokenProgram?: PublicKey;
};
type approveAccountsLayoutParams = BaseAccountsLayoutParams;
type revokeAccountsLayoutParams = approveAccountsLayoutParams;
type freezeAccountsLayoutParams = BaseAccountsLayoutParams & {
    mint: PublicKey;
};
type thawAccountsLayoutParams = freezeAccountsLayoutParams;
declare const createTokenPoolAccountsLayout: (accounts: createTokenPoolAccountsLayoutParams) => AccountMeta[];
declare const addTokenPoolAccountsLayout: (accounts: addTokenPoolAccountsLayoutParams) => AccountMeta[];
declare const mintToAccountsLayout: (accounts: mintToAccountsLayoutParams) => AccountMeta[];
declare const transferAccountsLayout: (accounts: transferAccountsLayoutParams) => AccountMeta[];
declare const approveAccountsLayout: (accounts: approveAccountsLayoutParams) => AccountMeta[];
declare const revokeAccountsLayout: (accounts: approveAccountsLayoutParams) => AccountMeta[];
declare const freezeAccountsLayout: (accounts: freezeAccountsLayoutParams) => AccountMeta[];
declare const thawAccountsLayout: (accounts: freezeAccountsLayoutParams) => AccountMeta[];
declare const CompressedTokenInstructionDataApproveLayout: buffer_layout.Layout<unknown>;
declare const CompressedTokenInstructionDataRevokeLayout: buffer_layout.Layout<unknown>;
declare function encodeApproveInstructionData(data: CompressedTokenInstructionDataApprove): Buffer;
declare function decodeApproveInstructionData(buffer: Buffer): CompressedTokenInstructionDataApprove;
declare function encodeRevokeInstructionData(data: CompressedTokenInstructionDataRevoke): Buffer;
declare function decodeRevokeInstructionData(buffer: Buffer): CompressedTokenInstructionDataRevoke;

type CompressParams = {
    /**
     * Fee payer
     */
    payer: PublicKey;
    /**
     * Owner of uncompressed token account
     */
    owner: PublicKey;
    /**
     * Source SPL Token account address
     */
    source: PublicKey;
    /**
     * Recipient address(es)
     */
    toAddress: PublicKey | PublicKey[];
    /**
     * Token amount(s) to compress
     */
    amount: number | BN | number[] | BN[];
    /**
     * SPL Token mint address
     */
    mint: PublicKey;
    /**
     * State tree to write to
     */
    outputStateTreeInfo: TreeInfo;
    /**
     * Token pool
     */
    tokenPoolInfo: TokenPoolInfo;
};
type CompressSplTokenAccountParams = {
    /**
     * Fee payer
     */
    feePayer: PublicKey;
    /**
     * SPL Token account owner
     */
    authority: PublicKey;
    /**
     * SPL Token account to compress
     */
    tokenAccount: PublicKey;
    /**
     * SPL Token mint address
     */
    mint: PublicKey;
    /**
     * Amount to leave in token account
     */
    remainingAmount?: BN;
    /**
     * State tree to write to
     */
    outputStateTreeInfo: TreeInfo;
    /**
     * Token pool
     */
    tokenPoolInfo: TokenPoolInfo;
};
type DecompressParams = {
    /**
     * Fee payer
     */
    payer: PublicKey;
    /**
     * Source compressed token accounts
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * Destination uncompressed token account
     */
    toAddress: PublicKey;
    /**
     * Token amount to decompress
     */
    amount: number | BN;
    /**
     * Validity proof for input state
     */
    recentValidityProof: ValidityProof | CompressedProof | null;
    /**
     * Recent state root indices
     */
    recentInputStateRootIndices: number[];
    /**
     * Token pool(s)
     */
    tokenPoolInfos: TokenPoolInfo | TokenPoolInfo[];
};
type TransferParams = {
    /**
     * Fee payer
     */
    payer: PublicKey;
    /**
     * Source compressed token accounts
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * Recipient address
     */
    toAddress: PublicKey;
    /**
     * Token amount to transfer
     */
    amount: BN | number;
    /**
     * Validity proof for input state
     */
    recentValidityProof: ValidityProof | CompressedProof | null;
    /**
     * Recent state root indices
     */
    recentInputStateRootIndices: number[];
};
type ApproveParams = {
    /**
     * Fee payer
     */
    payer: PublicKey;
    /**
     * Source compressed token accounts
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * Recipient address
     */
    toAddress: PublicKey;
    /**
     * Token amount to approve
     */
    amount: BN | number;
    /**
     * Validity proof for input state
     */
    recentValidityProof: ValidityProof | CompressedProof | null;
    /**
     * Recent state root indices
     */
    recentInputStateRootIndices: number[];
};
type RevokeParams = {
    /**
     * Fee payer
     */
    payer: PublicKey;
    /**
     * Input compressed token accounts
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * Validity proof for input state
     */
    recentValidityProof: ValidityProof | CompressedProof | null;
    /**
     * Recent state root indices
     */
    recentInputStateRootIndices: number[];
};
/**
 * Create Mint account for compressed Tokens
 */
type CreateMintParams = {
    /**
     * Fee payer
     */
    feePayer: PublicKey;
    /**
     * SPL Mint address
     */
    mint: PublicKey;
    /**
     * Mint authority
     */
    authority: PublicKey;
    /**
     * Optional: freeze authority
     */
    freezeAuthority: PublicKey | null;
    /**
     * Mint decimals
     */
    decimals: number;
    /**
     * lamport amount for mint account rent exemption
     */
    rentExemptBalance: number;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
    /**
     * Optional: Mint size to use, defaults to MINT_SIZE
     */
    mintSize?: number;
};
/**
 * Parameters for merging compressed token accounts
 */
type MergeTokenAccountsParams = {
    /**
     * Fee payer
     */
    payer: PublicKey;
    /**
     * Owner of the compressed token accounts to be merged
     */
    owner: PublicKey;
    /**
     * SPL Token mint address
     */
    mint: PublicKey;
    /**
     * Array of compressed token accounts to merge
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * Validity proof for state inclusion
     */
    recentValidityProof: ValidityProof | CompressedProof | null;
    /**
     * State root indices of the input state
     */
    recentInputStateRootIndices: number[];
};
/**
 * Create compressed token accounts
 */
type MintToParams = {
    /**
     * Fee payer
     */
    feePayer: PublicKey;
    /**
     * Token mint address
     */
    mint: PublicKey;
    /**
     * Mint authority
     */
    authority: PublicKey;
    /**
     * Recipient address(es)
     */
    toPubkey: PublicKey[] | PublicKey;
    /**
     * Token amount(s) to mint
     */
    amount: BN | BN[] | number | number[];
    /**
     * State tree for minted tokens
     */
    outputStateTreeInfo: TreeInfo;
    /**
     * Token pool
     */
    tokenPoolInfo: TokenPoolInfo;
};
/**
 * Register an existing SPL mint account to the compressed token program
 * Creates an omnibus account for the mint
 */
type CreateTokenPoolParams = {
    /**
     * Fee payer
     */
    feePayer: PublicKey;
    /**
     * SPL Mint address
     */
    mint: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
type AddTokenPoolParams = {
    /**
     * Fee payer
     */
    feePayer: PublicKey;
    /**
     * Token mint address
     */
    mint: PublicKey;
    /**
     * Token pool index
     */
    poolIndex: number;
    /**
     * Optional: Token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
/**
 * Mint from existing SPL mint to compressed token accounts
 */
type ApproveAndMintToParams = {
    /**
     * Fee payer
     */
    feePayer: PublicKey;
    /**
     * SPL Mint address
     */
    mint: PublicKey;
    /**
     * Mint authority
     */
    authority: PublicKey;
    /**
     * Mint authority (associated) token account
     */
    authorityTokenAccount: PublicKey;
    /**
     * Recipient address
     */
    toPubkey: PublicKey;
    /**
     * Token amount to mint
     */
    amount: BN | number;
    /**
     * State tree to write to
     */
    outputStateTreeInfo: TreeInfo;
    /**
     * Token pool
     */
    tokenPoolInfo: TokenPoolInfo;
};
type CreateTokenProgramLookupTableParams = {
    /**
     * Fee payer
     */
    payer: PublicKey;
    /**
     * Authority of the transaction
     */
    authority: PublicKey;
    /**
     * Optional Mint addresses to store in the lookup table
     */
    mints?: PublicKey[];
    /**
     * Recently finalized Solana slot
     */
    recentSlot: number;
    /**
     * Optional additional addresses to store in the lookup table
     */
    remainingAccounts?: PublicKey[];
};
/**
 * Sum up the token amounts of the compressed token accounts
 */
declare const sumUpTokenAmount: (accounts: ParsedTokenAccount[]) => BN;
/**
 * Validate that all the compressed token accounts are owned by the same owner.
 */
declare const validateSameTokenOwner: (accounts: ParsedTokenAccount[]) => void;
/**
 * Parse compressed token accounts to get the mint, current owner and delegate.
 */
declare const parseTokenData: (compressedTokenAccounts: ParsedTokenAccount[]) => {
    mint: PublicKey;
    currentOwner: PublicKey;
    delegate: PublicKey | null;
};
declare const parseMaybeDelegatedTransfer: (inputs: ParsedTokenAccount[], outputs: TokenTransferOutputData[]) => {
    delegatedTransfer: DelegatedTransfer | null;
    authority: PublicKey;
};
/**
 * Create the output state for a transfer transaction.
 * @param inputCompressedTokenAccounts  Input state
 * @param toAddress                     Recipient address
 * @param amount                        Amount of tokens to transfer
 * @returns                             Output token data for the transfer
 *                                      instruction
 */
declare function createTransferOutputState(inputCompressedTokenAccounts: ParsedTokenAccount[], toAddress: PublicKey, amount: number | BN): TokenTransferOutputData[];
/**
 * Create the output state for a compress transaction.
 * @param inputCompressedTokenAccounts  Input state
 * @param amount                        Amount of tokens to compress
 * @returns                             Output token data for the compress
 *                                      instruction
 */
declare function createDecompressOutputState(inputCompressedTokenAccounts: ParsedTokenAccount[], amount: number | BN): TokenTransferOutputData[];
declare class CompressedTokenProgram {
    /**
     * @internal
     */
    constructor();
    /**
     * Public key that identifies the CompressedPda program
     */
    static programId: PublicKey;
    /**
     * Set a custom programId via PublicKey or base58 encoded string.
     * This method is not required for regular usage.
     *
     * Use this only if you know what you are doing.
     */
    static setProgramId(programId: PublicKey | string): void;
    /**
     * Derive the token pool pda.
     * To derive the token pool pda with bump, use {@link deriveTokenPoolPdaWithIndex}.
     *
     * @param mint The mint of the token pool
     *
     * @returns The token pool pda
     */
    static deriveTokenPoolPda(mint: PublicKey): PublicKey;
    /**
     * Find the index and bump for a given token pool pda and mint.
     *
     * @param poolPda The token pool pda to find the index and bump for
     * @param mint The mint of the token pool
     *
     * @returns The index and bump number.
     */
    static findTokenPoolIndexAndBump(poolPda: PublicKey, mint: PublicKey): [number, number];
    /**
     * Derive the token pool pda with index.
     *
     * @param mint The mint of the token pool
     * @param index Index. starts at 0. The Protocol supports 4 indexes aka token pools
     * per mint.
     *
     * @returns The token pool pda and bump.
     */
    static deriveTokenPoolPdaWithIndex(mint: PublicKey, index: number): [PublicKey, number];
    /** @internal */
    static get deriveCpiAuthorityPda(): PublicKey;
    /**
     * Construct createMint instruction for compressed tokens.
     *
     * @param feePayer              Fee payer.
     * @param mint                  SPL Mint address.
     * @param authority             Mint authority.
     * @param freezeAuthority       Optional: freeze authority.
     * @param decimals              Decimals.
     * @param rentExemptBalance     Lamport amount for mint account rent exemption.
     * @param tokenProgramId        Optional: Token program ID. Default: SPL Token Program ID
     * @param mintSize              Optional: mint size. Default: MINT_SIZE
     *
     * @returns [createMintAccountInstruction, initializeMintInstruction,
     * createTokenPoolInstruction]
     *
     * Note that `createTokenPoolInstruction` must be executed after
     * `initializeMintInstruction`.
     */
    static createMint({ feePayer, mint, authority, freezeAuthority, decimals, rentExemptBalance, tokenProgramId, mintSize, }: CreateMintParams): Promise<TransactionInstruction[]>;
    /**
     * Enable compression for an existing SPL mint, creating an omnibus account.
     * For new mints, use `CompressedTokenProgram.createMint`.
     *
     * @param feePayer              Fee payer.
     * @param mint                  SPL Mint address.
     * @param tokenProgramId        Optional: Token program ID. Default: SPL
     *                              Token Program ID
     *
     * @returns The createTokenPool instruction
     */
    static createTokenPool({ feePayer, mint, tokenProgramId, }: CreateTokenPoolParams): Promise<TransactionInstruction>;
    /**
     * Add a token pool to an existing SPL mint.  For new mints, use
     * {@link createTokenPool}.
     *
     * @param feePayer              Fee payer.
     * @param mint                  SPL Mint address.
     * @param poolIndex             Pool index.
     * @param tokenProgramId        Optional: Token program ID. Default: SPL
     *                              Token Program ID
     *
     * @returns The addTokenPool instruction
     */
    static addTokenPool({ feePayer, mint, poolIndex, tokenProgramId, }: AddTokenPoolParams): Promise<TransactionInstruction>;
    /**
     * Construct mintTo instruction for compressed tokens
     *
     * @param feePayer              Fee payer.
     * @param mint                  SPL Mint address.
     * @param authority             Mint authority.
     * @param toPubkey              Recipient owner address.
     * @param amount                Amount of tokens to mint.
     * @param outputStateTreeInfo   State tree to write to.
     * @param tokenPoolInfo         Token pool info.
     *
     * @returns The mintTo instruction
     */
    static mintTo({ feePayer, mint, authority, toPubkey, amount, outputStateTreeInfo, tokenPoolInfo, }: MintToParams): Promise<TransactionInstruction>;
    /**
     * Mint tokens from registered SPL mint account to a compressed account
     *
     * @param feePayer              Fee payer.
     * @param mint                  SPL Mint address.
     * @param authority             Mint authority.
     * @param authorityTokenAccount The mint authority's associated token
     *                              account (ATA).
     * @param toPubkey              Recipient owner address.
     * @param amount                Amount of tokens to mint.
     * @param outputStateTreeInfo   State tree to write to.
     * @param tokenPoolInfo         Token pool info.
     *
     * @returns The mintTo instruction
     */
    static approveAndMintTo({ feePayer, mint, authority, authorityTokenAccount, toPubkey, amount, outputStateTreeInfo, tokenPoolInfo, }: ApproveAndMintToParams): Promise<TransactionInstruction[]>;
    /**
     * Construct transfer instruction for compressed tokens
     *
     * @param payer                         Fee payer.
     * @param inputCompressedTokenAccounts  Source compressed token accounts.
     * @param toAddress                     Recipient owner address.
     * @param amount                        Amount of tokens to transfer.
     * @param recentValidityProof           Recent validity proof.
     * @param recentInputStateRootIndices   Recent state root indices.
     *
     * @returns The transfer instruction
     */
    static transfer({ payer, inputCompressedTokenAccounts, toAddress, amount, recentValidityProof, recentInputStateRootIndices, }: TransferParams): Promise<TransactionInstruction>;
    /**
     * Create lookup table instructions for the token program's default
     * accounts.
     *
     * @param payer                     Fee payer.
     * @param authority                 Authority.
     * @param mints                     Mints.
     * @param recentSlot                Recent slot.
     * @param remainingAccounts         Remaining accounts.
     *
     * @returns [createInstruction, extendInstruction, option(extendInstruction2)]
     */
    static createTokenProgramLookupTable({ payer, authority, mints, recentSlot, remainingAccounts, }: CreateTokenProgramLookupTableParams): Promise<{
        instructions: TransactionInstruction[];
        address: PublicKey;
    }>;
    /**
     * Create compress instruction
     *
     * @param payer                         Fee payer.
     * @param owner                         Owner of uncompressed token account.
     * @param source                        Source SPL Token account address.
     * @param toAddress                     Recipient owner address(es).
     * @param amount                        Amount of tokens to compress.
     * @param mint                          SPL Token mint address.
     * @param outputStateTreeInfo           State tree to write to.
     * @param tokenPoolInfo                 Token pool info.
     *
     * @returns The compress instruction
     */
    static compress({ payer, owner, source, toAddress, amount, mint, outputStateTreeInfo, tokenPoolInfo, }: CompressParams): Promise<TransactionInstruction>;
    /**
     * Construct decompress instruction
     *
     * @param payer                         Fee payer.
     * @param inputCompressedTokenAccounts  Source compressed token accounts.
     * @param toAddress                     Destination **uncompressed** token
     *                                      account address. (ATA)
     * @param amount                        Amount of tokens to decompress.
     * @param recentValidityProof           Recent validity proof.
     * @param recentInputStateRootIndices   Recent state root indices.
     * @param tokenPoolInfos                Token pool info.
     *
     * @returns The decompress instruction
     */
    static decompress({ payer, inputCompressedTokenAccounts, toAddress, amount, recentValidityProof, recentInputStateRootIndices, tokenPoolInfos, }: DecompressParams): Promise<TransactionInstruction>;
    /**
     * Create `mergeTokenAccounts` instruction
     *
     * @param payer                         Fee payer.
     * @param owner                         Owner of the compressed token
     *                                      accounts to be merged.
     * @param inputCompressedTokenAccounts  Source compressed token accounts.
     * @param mint                          SPL Token mint address.
     * @param recentValidityProof           Recent validity proof.
     * @param recentInputStateRootIndices   Recent state root indices.
     *
     * @returns instruction
     */
    static mergeTokenAccounts({ payer, owner, inputCompressedTokenAccounts, mint, recentValidityProof, recentInputStateRootIndices, }: MergeTokenAccountsParams): Promise<TransactionInstruction[]>;
    /**
     * Create `compressSplTokenAccount` instruction
     *
     * @param feePayer              Fee payer.
     * @param authority             SPL Token account owner.
     * @param tokenAccount          SPL Token account to compress.
     * @param mint                  SPL Token mint address.
     * @param remainingAmount       Optional: Amount to leave in token account.
     * @param outputStateTreeInfo   State tree to write to.
     * @param tokenPoolInfo         Token pool info.
     *
     * @returns instruction
     */
    static compressSplTokenAccount({ feePayer, authority, tokenAccount, mint, remainingAmount, outputStateTreeInfo, tokenPoolInfo, }: CompressSplTokenAccountParams): Promise<TransactionInstruction>;
    /**
     * Get the program ID for a mint
     *
     * @param mint                  SPL Token mint address.
     * @param connection            Connection.
     *
     * @returns program ID
     */
    static getMintProgramId(mint: PublicKey, connection: Connection): Promise<PublicKey | undefined>;
    /**
     * Create `approve` instruction to delegate compressed tokens.
     *
     * @param payer                         Fee payer.
     * @param inputCompressedTokenAccounts  Source compressed token accounts.
     * @param toAddress                     Owner to delegate to.
     * @param amount                        Amount of tokens to delegate.
     * @param recentValidityProof           Recent validity proof.
     * @param recentInputStateRootIndices   Recent state root indices.
     *
     * @returns instruction
     */
    static approve({ payer, inputCompressedTokenAccounts, toAddress, amount, recentValidityProof, recentInputStateRootIndices, }: ApproveParams): Promise<TransactionInstruction>;
    /**
     * Create `revoke` instruction to revoke delegation of compressed tokens.
     *
     * @param payer                         Fee payer.
     * @param inputCompressedTokenAccounts  Source compressed token accounts.
     * @param recentValidityProof           Recent validity proof.
     * @param recentInputStateRootIndices   Recent state root indices.
     *
     * @returns instruction
     */
    static revoke({ payer, inputCompressedTokenAccounts, recentValidityProof, recentInputStateRootIndices, }: RevokeParams): Promise<TransactionInstruction>;
}

export { ADD_TOKEN_POOL_DISCRIMINATOR, APPROVE_DISCRIMINATOR, Action, type AddTokenPoolParams, type ApproveAndMintToParams, type ApproveParams, BATCH_COMPRESS_DISCRIMINATOR, type BatchCompressInstructionData, COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR, CPI_AUTHORITY_SEED, CREATE_TOKEN_POOL_DISCRIMINATOR, type CompressParams, type CompressSplTokenAccountInstructionData, type CompressSplTokenAccountParams, type CompressedTokenInstructionDataApprove, CompressedTokenInstructionDataApproveLayout, type CompressedTokenInstructionDataRevoke, CompressedTokenInstructionDataRevokeLayout, type CompressedTokenInstructionDataTransfer, CompressedTokenInstructionDataTransferLayout, CompressedTokenProgram, CpiContextLayout, type CreateMintParams, type CreateTokenPoolParams, type CreateTokenProgramLookupTableParams, type DecompressParams, type DelegatedTransfer, DelegatedTransferLayout, ERROR_NO_ACCOUNTS_FOUND, IDL, type InputTokenDataWithContext, type LightCompressedToken, MINT_TO_DISCRIMINATOR, type MergeTokenAccountsParams, type MintToInstructionData, type MintToParams, POOL_SEED, type PackCompressedTokenAccountsParams, type PackedTokenTransferOutputData, REVOKE_DISCRIMINATOR, type RevokeParams, SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE, TRANSFER_DISCRIMINATOR, type TokenData, type TokenPoolActivity, type TokenPoolInfo, type TokenTransferOutputData, type TransferParams, addTokenPoolAccountsLayout, type addTokenPoolAccountsLayoutParams, addTokenPools, approve, approveAccountsLayout, type approveAccountsLayoutParams, approveAndMintTo, batchCompressLayout, checkMint, checkTokenPoolInfo, compress, compressSplTokenAccount, compressSplTokenAccountInstructionDataLayout, createDecompressOutputState, createMint, createTokenPool, createTokenPoolAccountsLayout, type createTokenPoolAccountsLayoutParams, createTokenProgramLookupTable, createTransferOutputState, decodeApproveInstructionData, decodeBatchCompressInstructionData, decodeCompressSplTokenAccountInstructionData, decodeMintToInstructionData, decodeRevokeInstructionData, decodeTransferInstructionData, decompress, decompressDelegated, encodeApproveInstructionData, encodeBatchCompressInstructionData, encodeCompressSplTokenAccountInstructionData, encodeMintToInstructionData, encodeRevokeInstructionData, encodeTransferInstructionData, freezeAccountsLayout, type freezeAccountsLayoutParams, getTokenPoolInfos, isSingleTokenPoolInfo, mergeTokenAccounts, mintTo, mintToAccountsLayout, type mintToAccountsLayoutParams, mintToLayout, packCompressedTokenAccounts, parseMaybeDelegatedTransfer, parseTokenData, revoke, revokeAccountsLayout, type revokeAccountsLayoutParams, selectMinCompressedTokenAccountsForDecompression, selectMinCompressedTokenAccountsForTransfer, selectMinCompressedTokenAccountsForTransferOrPartial, selectSmartCompressedTokenAccountsForTransfer, selectSmartCompressedTokenAccountsForTransferOrPartial, selectTokenAccountsForApprove, selectTokenPoolInfo, selectTokenPoolInfosForDecompression, sumUpTokenAmount, thawAccountsLayout, type thawAccountsLayoutParams, transfer, transferAccountsLayout, type transferAccountsLayoutParams, transferDelegated, validateSameTokenOwner };
