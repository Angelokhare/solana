"use strict";var e=require("@solana/web3.js"),t=require("@lightprotocol/stateless.js"),n=require("@solana/spl-token"),o=require("@coral-xyz/borsh"),r="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},i=[],s=[],a="undefined"!=typeof Uint8Array?Uint8Array:Array,u=0;function c(){u=1;for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=0;t<64;++t)i[t]=e[t],s[e.charCodeAt(t)]=t;s["-".charCodeAt(0)]=62,s["_".charCodeAt(0)]=63}function p(e,t,n){for(var o,r,s=[],a=t;a<n;a+=3)o=(e[a]<<16)+(e[a+1]<<8)+e[a+2],s.push(i[(r=o)>>18&63]+i[r>>12&63]+i[r>>6&63]+i[63&r]);return s.join("")}function m(e){var t;u||c();for(var n=e.length,o=n%3,r="",s=[],a=16383,m=0,d=n-o;m<d;m+=a)s.push(p(e,m,m+a>d?d:m+a));return 1===o?(t=e[n-1],r+=i[t>>2],r+=i[t<<4&63],r+="=="):2===o&&(t=(e[n-2]<<8)+e[n-1],r+=i[t>>10],r+=i[t>>4&63],r+=i[t<<2&63],r+="="),s.push(r),s.join("")}function d(e,t,n,o,r){var i,s,a=8*r-o-1,u=(1<<a)-1,c=u>>1,p=-7,m=n?r-1:0,d=n?-1:1,l=e[t+m];for(m+=d,i=l&(1<<-p)-1,l>>=-p,p+=a;p>0;i=256*i+e[t+m],m+=d,p-=8);for(s=i&(1<<-p)-1,i>>=-p,p+=o;p>0;s=256*s+e[t+m],m+=d,p-=8);if(0===i)i=1-c;else{if(i===u)return s?NaN:Infinity*(l?-1:1);s+=Math.pow(2,o),i-=c}return(l?-1:1)*s*Math.pow(2,i-o)}function l(e,t,n,o,r,i){var s,a,u,c=8*i-r-1,p=(1<<c)-1,m=p>>1,d=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,l=o?0:i-1,g=o?1:-1,h=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||Infinity===t?(a=isNaN(t)?1:0,s=p):(s=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-s))<1&&(s--,u*=2),(t+=s+m>=1?d/u:d*Math.pow(2,1-m))*u>=2&&(s++,u/=2),s+m>=p?(a=0,s=p):s+m>=1?(a=(t*u-1)*Math.pow(2,r),s+=m):(a=t*Math.pow(2,m-1)*Math.pow(2,r),s=0));r>=8;e[n+l]=255&a,l+=g,a/=256,r-=8);for(s=s<<r|a,c+=r;c>0;e[n+l]=255&s,l+=g,s/=256,c-=8);e[n+l-g]|=128*h}var g={}.toString,h=Array.isArray||function(e){return"[object Array]"==g.call(e)};function f(){return P.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function y(e,t){if(f()<t)throw new RangeError("Invalid typed array length");return P.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=P.prototype:(null===e&&(e=new P(t)),e.length=t),e}function P(e,t,n){if(!(P.TYPED_ARRAY_SUPPORT||this instanceof P))return new P(e,t,n);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return A(this,e)}return k(this,e,t,n)}function k(e,t,n,o){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,n,o){if(t.byteLength,n<0||t.byteLength<n)throw new RangeError("'offset' is out of bounds");if(t.byteLength<n+(o||0))throw new RangeError("'length' is out of bounds");return t=void 0===n&&void 0===o?new Uint8Array(t):void 0===o?new Uint8Array(t,n):new Uint8Array(t,n,o),P.TYPED_ARRAY_SUPPORT?(e=t).__proto__=P.prototype:e=S(e,t),e}(e,t,n,o):"string"==typeof t?function(e,t,n){if("string"==typeof n&&""!==n||(n="utf8"),!P.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var o=0|w(t,n),r=(e=y(e,o)).write(t,n);return r!==o&&(e=e.slice(0,r)),e}(e,t,n):function(e,t){if(I(t)){var n=0|T(t.length);return 0===(e=y(e,n)).length||t.copy(e,0,0,n),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(o=t.length)!=o?y(e,0):S(e,t);if("Buffer"===t.type&&h(t.data))return S(e,t.data)}var o;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function b(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function A(e,t){if(b(t),e=y(e,t<0?0:0|T(t)),!P.TYPED_ARRAY_SUPPORT)for(var n=0;n<t;++n)e[n]=0;return e}function S(e,t){var n=t.length<0?0:0|T(t.length);e=y(e,n);for(var o=0;o<n;o+=1)e[o]=255&t[o];return e}function T(e){if(e>=f())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+f().toString(16)+" bytes");return 0|e}function I(e){return!(null==e||!e._isBuffer)}function w(e,t){if(I(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var n=e.length;if(0===n)return 0;for(var o=0;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return Q(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return X(e).length;default:if(o)return Q(e).length;t=(""+t).toLowerCase(),o=1}}function C(e,t,n){var o=0;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return F(this,t,n);case"utf8":case"utf-8":return L(this,t,n);case"ascii":return K(this,t,n);case"latin1":case"binary":return N(this,t,n);case"base64":return B(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return q(this,t,n);default:if(o)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),o=1}}function x(e,t,n){var o=e[t];e[t]=e[n],e[n]=o}function v(e,t,n,o,r){if(0===e.length)return-1;if("string"==typeof n?(o=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=r?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(r)return-1;n=e.length-1}else if(n<0){if(!r)return-1;n=0}if("string"==typeof t&&(t=P.from(t,o)),I(t))return 0===t.length?-1:M(e,t,n,o,r);if("number"==typeof t)return t&=255,P.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?r?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):M(e,[t],n,o,r);throw new TypeError("val must be string, number or Buffer")}function M(e,t,n,o,r){var i,s=1,a=e.length,u=t.length;if(void 0!==o&&("ucs2"===(o=String(o).toLowerCase())||"ucs-2"===o||"utf16le"===o||"utf-16le"===o)){if(e.length<2||t.length<2)return-1;s=2,a/=2,u/=2,n/=2}function c(e,t){return 1===s?e[t]:e.readUInt16BE(t*s)}if(r){var p=-1;for(i=n;i<a;i++)if(c(e,i)===c(t,-1===p?0:i-p)){if(-1===p&&(p=i),i-p+1===u)return p*s}else-1!==p&&(i-=i-p),p=-1}else for(n+u>a&&(n=a-u),i=n;i>=0;i--){for(var m=1,d=0;d<u;d++)if(c(e,i+d)!==c(t,d)){m=0;break}if(m)return i}return-1}function E(e,t,n,o){n=Number(n)||0;var r=e.length-n;o?(o=Number(o))>r&&(o=r):o=r;var i=t.length;if(i%2!=0)throw new TypeError("Invalid hex string");o>i/2&&(o=i/2);for(var s=0;s<o;++s){var a=parseInt(t.substr(2*s,2),16);if(isNaN(a))return s;e[n+s]=a}return s}function D(e,t,n,o){return J(Q(t,e.length-n),e,n,o)}function R(e,t,n,o){return J(function(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,o)}function O(e,t,n,o){return R(e,t,n,o)}function _(e,t,n,o){return J(X(t),e,n,o)}function U(e,t,n,o){return J(function(e,t){for(var n,o,r,i=[],s=0;s<e.length&&!((t-=2)<0);++s)o=(n=e.charCodeAt(s))>>8,r=n%256,i.push(r),i.push(o);return i}(t,e.length-n),e,n,o)}function B(e,t,n){return 0===t&&n===e.length?m(e):m(e.slice(t,n))}function L(e,t,n){n=Math.min(e.length,n);for(var o=[],r=t;r<n;){var i,s,a,u,c=e[r],p=null,m=c>239?4:c>223?3:c>191?2:1;if(r+m<=n)switch(m){case 1:c<128&&(p=c);break;case 2:128==(192&(i=e[r+1]))&&(u=(31&c)<<6|63&i)>127&&(p=u);break;case 3:i=e[r+1],s=e[r+2],128==(192&i)&&128==(192&s)&&(u=(15&c)<<12|(63&i)<<6|63&s)>2047&&(u<55296||u>57343)&&(p=u);break;case 4:i=e[r+1],s=e[r+2],a=e[r+3],128==(192&i)&&128==(192&s)&&128==(192&a)&&(u=(15&c)<<18|(63&i)<<12|(63&s)<<6|63&a)>65535&&u<1114112&&(p=u)}null===p?(p=65533,m=1):p>65535&&(p-=65536,o.push(p>>>10&1023|55296),p=56320|1023&p),o.push(p),r+=m}return function(e){var t=e.length;if(t<=W)return String.fromCharCode.apply(String,e);for(var n="",o=0;o<t;)n+=String.fromCharCode.apply(String,e.slice(o,o+=W));return n}(o)}P.TYPED_ARRAY_SUPPORT=void 0!==r.TYPED_ARRAY_SUPPORT?r.TYPED_ARRAY_SUPPORT:1,f(),P.poolSize=8192,P._augment=function(e){return e.__proto__=P.prototype,e},P.from=function(e,t,n){return k(null,e,t,n)},P.TYPED_ARRAY_SUPPORT&&(P.prototype.__proto__=Uint8Array.prototype,P.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&P[Symbol.species]),P.alloc=function(e,t,n){return function(e,t,n,o){return b(t),t<=0?y(e,t):void 0!==n?"string"==typeof o?y(e,t).fill(n,o):y(e,t).fill(n):y(e,t)}(null,e,t,n)},P.allocUnsafe=function(e){return A(null,e)},P.allocUnsafeSlow=function(e){return A(null,e)},P.isBuffer=function(e){return null!=e&&(!!e._isBuffer||ee(e)||function(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&ee(e.slice(0,0))}(e))},P.compare=function(e,t){if(!I(e)||!I(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var n=e.length,o=t.length,r=0,i=Math.min(n,o);r<i;++r)if(e[r]!==t[r]){n=e[r],o=t[r];break}return n<o?-1:o<n?1:0},P.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 1;default:return 0}},P.concat=function(e,t){if(!h(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return P.alloc(0);var n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;var o=P.allocUnsafe(t),r=0;for(n=0;n<e.length;++n){var i=e[n];if(!I(i))throw new TypeError('"list" argument must be an Array of Buffers');i.copy(o,r),r+=i.length}return o},P.byteLength=w,P.prototype._isBuffer=1,P.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)x(this,t,t+1);return this},P.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)x(this,t,t+3),x(this,t+1,t+2);return this},P.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)x(this,t,t+7),x(this,t+1,t+6),x(this,t+2,t+5),x(this,t+3,t+4);return this},P.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?L(this,0,e):C.apply(this,arguments)},P.prototype.equals=function(e){if(!I(e))throw new TypeError("Argument must be a Buffer");return this===e?1:0===P.compare(this,e)},P.prototype.inspect=function(){var e="";return this.length>0&&(e=this.toString("hex",0,50).match(/.{2}/g).join(" "),this.length>50&&(e+=" ... ")),"<Buffer "+e+">"},P.prototype.compare=function(e,t,n,o,r){if(!I(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===o&&(o=0),void 0===r&&(r=this.length),t<0||n>e.length||o<0||r>this.length)throw new RangeError("out of range index");if(o>=r&&t>=n)return 0;if(o>=r)return-1;if(t>=n)return 1;if(this===e)return 0;for(var i=(r>>>=0)-(o>>>=0),s=(n>>>=0)-(t>>>=0),a=Math.min(i,s),u=this.slice(o,r),c=e.slice(t,n),p=0;p<a;++p)if(u[p]!==c[p]){i=u[p],s=c[p];break}return i<s?-1:s<i?1:0},P.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},P.prototype.indexOf=function(e,t,n){return v(this,e,t,n,1)},P.prototype.lastIndexOf=function(e,t,n){return v(this,e,t,n,0)},P.prototype.write=function(e,t,n,o){if(void 0===t)o="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)o=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===o&&(o="utf8")):(o=n,n=void 0)}var r=this.length-t;if((void 0===n||n>r)&&(n=r),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");o||(o="utf8");for(var i=0;;)switch(o){case"hex":return E(this,e,t,n);case"utf8":case"utf-8":return D(this,e,t,n);case"ascii":return R(this,e,t,n);case"latin1":case"binary":return O(this,e,t,n);case"base64":return _(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return U(this,e,t,n);default:if(i)throw new TypeError("Unknown encoding: "+o);o=(""+o).toLowerCase(),i=1}},P.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var W=4096;function K(e,t,n){var o="";n=Math.min(e.length,n);for(var r=t;r<n;++r)o+=String.fromCharCode(127&e[r]);return o}function N(e,t,n){var o="";n=Math.min(e.length,n);for(var r=t;r<n;++r)o+=String.fromCharCode(e[r]);return o}function F(e,t,n){var o,r=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>r)&&(n=r);for(var i="",s=t;s<n;++s)i+=(o=e[s])<16?"0"+o.toString(16):o.toString(16);return i}function q(e,t,n){for(var o=e.slice(t,n),r="",i=0;i<o.length;i+=2)r+=String.fromCharCode(o[i]+256*o[i+1]);return r}function Y(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function V(e,t,n,o,r,i){if(!I(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>r||t<i)throw new RangeError('"value" argument is out of bounds');if(n+o>e.length)throw new RangeError("Index out of range")}function z(e,t,n,o){t<0&&(t=65535+t+1);for(var r=0,i=Math.min(e.length-n,2);r<i;++r)e[n+r]=(t&255<<8*(o?r:1-r))>>>8*(o?r:1-r)}function H(e,t,n,o){t<0&&(t=4294967295+t+1);for(var r=0,i=Math.min(e.length-n,4);r<i;++r)e[n+r]=t>>>8*(o?r:3-r)&255}function j(e,t,n,o){if(n+o>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function $(e,t,n,o,r){return r||j(e,0,n,4),l(e,t,n,o,23,4),n+4}function Z(e,t,n,o,r){return r||j(e,0,n,8),l(e,t,n,o,52,8),n+8}P.prototype.slice=function(e,t){var n,o=this.length;if((e=~~e)<0?(e+=o)<0&&(e=0):e>o&&(e=o),(t=void 0===t?o:~~t)<0?(t+=o)<0&&(t=0):t>o&&(t=o),t<e&&(t=e),P.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,t)).__proto__=P.prototype;else{var r=t-e;n=new P(r,void 0);for(var i=0;i<r;++i)n[i]=this[i+e]}return n},P.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||Y(e,t,this.length);for(var o=this[e],r=1,i=0;++i<t&&(r*=256);)o+=this[e+i]*r;return o},P.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||Y(e,t,this.length);for(var o=this[e+--t],r=1;t>0&&(r*=256);)o+=this[e+--t]*r;return o},P.prototype.readUInt8=function(e,t){return t||Y(e,1,this.length),this[e]},P.prototype.readUInt16LE=function(e,t){return t||Y(e,2,this.length),this[e]|this[e+1]<<8},P.prototype.readUInt16BE=function(e,t){return t||Y(e,2,this.length),this[e]<<8|this[e+1]},P.prototype.readUInt32LE=function(e,t){return t||Y(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},P.prototype.readUInt32BE=function(e,t){return t||Y(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},P.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||Y(e,t,this.length);for(var o=this[e],r=1,i=0;++i<t&&(r*=256);)o+=this[e+i]*r;return o>=(r*=128)&&(o-=Math.pow(2,8*t)),o},P.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||Y(e,t,this.length);for(var o=t,r=1,i=this[e+--o];o>0&&(r*=256);)i+=this[e+--o]*r;return i>=(r*=128)&&(i-=Math.pow(2,8*t)),i},P.prototype.readInt8=function(e,t){return t||Y(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},P.prototype.readInt16LE=function(e,t){t||Y(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},P.prototype.readInt16BE=function(e,t){t||Y(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},P.prototype.readInt32LE=function(e,t){return t||Y(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},P.prototype.readInt32BE=function(e,t){return t||Y(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},P.prototype.readFloatLE=function(e,t){return t||Y(e,4,this.length),d(this,e,1,23,4)},P.prototype.readFloatBE=function(e,t){return t||Y(e,4,this.length),d(this,e,0,23,4)},P.prototype.readDoubleLE=function(e,t){return t||Y(e,8,this.length),d(this,e,1,52,8)},P.prototype.readDoubleBE=function(e,t){return t||Y(e,8,this.length),d(this,e,0,52,8)},P.prototype.writeUIntLE=function(e,t,n,o){e=+e,t|=0,n|=0,o||V(this,e,t,n,Math.pow(2,8*n)-1,0);var r=1,i=0;for(this[t]=255&e;++i<n&&(r*=256);)this[t+i]=e/r&255;return t+n},P.prototype.writeUIntBE=function(e,t,n,o){e=+e,t|=0,n|=0,o||V(this,e,t,n,Math.pow(2,8*n)-1,0);var r=n-1,i=1;for(this[t+r]=255&e;--r>=0&&(i*=256);)this[t+r]=e/i&255;return t+n},P.prototype.writeUInt8=function(e,t,n){return e=+e,t|=0,n||V(this,e,t,1,255,0),P.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},P.prototype.writeUInt16LE=function(e,t,n){return e=+e,t|=0,n||V(this,e,t,2,65535,0),P.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):z(this,e,t,1),t+2},P.prototype.writeUInt16BE=function(e,t,n){return e=+e,t|=0,n||V(this,e,t,2,65535,0),P.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):z(this,e,t,0),t+2},P.prototype.writeUInt32LE=function(e,t,n){return e=+e,t|=0,n||V(this,e,t,4,4294967295,0),P.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):H(this,e,t,1),t+4},P.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||V(this,e,t,4,4294967295,0),P.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):H(this,e,t,0),t+4},P.prototype.writeIntLE=function(e,t,n,o){if(e=+e,t|=0,!o){var r=Math.pow(2,8*n-1);V(this,e,t,n,r-1,-r)}var i=0,s=1,a=0;for(this[t]=255&e;++i<n&&(s*=256);)e<0&&0===a&&0!==this[t+i-1]&&(a=1),this[t+i]=(e/s>>0)-a&255;return t+n},P.prototype.writeIntBE=function(e,t,n,o){if(e=+e,t|=0,!o){var r=Math.pow(2,8*n-1);V(this,e,t,n,r-1,-r)}var i=n-1,s=1,a=0;for(this[t+i]=255&e;--i>=0&&(s*=256);)e<0&&0===a&&0!==this[t+i+1]&&(a=1),this[t+i]=(e/s>>0)-a&255;return t+n},P.prototype.writeInt8=function(e,t,n){return e=+e,t|=0,n||V(this,e,t,1,127,-128),P.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},P.prototype.writeInt16LE=function(e,t,n){return e=+e,t|=0,n||V(this,e,t,2,32767,-32768),P.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):z(this,e,t,1),t+2},P.prototype.writeInt16BE=function(e,t,n){return e=+e,t|=0,n||V(this,e,t,2,32767,-32768),P.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):z(this,e,t,0),t+2},P.prototype.writeInt32LE=function(e,t,n){return e=+e,t|=0,n||V(this,e,t,4,2147483647,-2147483648),P.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):H(this,e,t,1),t+4},P.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||V(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),P.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):H(this,e,t,0),t+4},P.prototype.writeFloatLE=function(e,t,n){return $(this,e,t,1,n)},P.prototype.writeFloatBE=function(e,t,n){return $(this,e,t,0,n)},P.prototype.writeDoubleLE=function(e,t,n){return Z(this,e,t,1,n)},P.prototype.writeDoubleBE=function(e,t,n){return Z(this,e,t,0,n)},P.prototype.copy=function(e,t,n,o){if(n||(n=0),o||0===o||(o=this.length),t>=e.length&&(t=e.length),t||(t=0),o>0&&o<n&&(o=n),o===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(o<0)throw new RangeError("sourceEnd out of bounds");o>this.length&&(o=this.length),e.length-t<o-n&&(o=e.length-t+n);var r,i=o-n;if(this===e&&n<t&&t<o)for(r=i-1;r>=0;--r)e[r+t]=this[r+n];else if(i<1e3||!P.TYPED_ARRAY_SUPPORT)for(r=0;r<i;++r)e[r+t]=this[r+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+i),t);return i},P.prototype.fill=function(e,t,n,o){if("string"==typeof e){if("string"==typeof t?(o=t,t=0,n=this.length):"string"==typeof n&&(o=n,n=this.length),1===e.length){var r=e.charCodeAt(0);r<256&&(e=r)}if(void 0!==o&&"string"!=typeof o)throw new TypeError("encoding must be a string");if("string"==typeof o&&!P.isEncoding(o))throw new TypeError("Unknown encoding: "+o)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;var i;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(i=t;i<n;++i)this[i]=e;else{var s=I(e)?e:Q(new P(e,o).toString()),a=s.length;for(i=0;i<n-t;++i)this[i+t]=s[i%a]}return this};var G=/[^+\/0-9A-Za-z-_]/g;function Q(e,t){var n;t=t||Infinity;for(var o=e.length,r=null,i=[],s=0;s<o;++s){if((n=e.charCodeAt(s))>55295&&n<57344){if(!r){if(n>56319){(t-=3)>-1&&i.push(239,191,189);continue}if(s+1===o){(t-=3)>-1&&i.push(239,191,189);continue}r=n;continue}if(n<56320){(t-=3)>-1&&i.push(239,191,189),r=n;continue}n=65536+(r-55296<<10|n-56320)}else r&&(t-=3)>-1&&i.push(239,191,189);if(r=null,n<128){if((t-=1)<0)break;i.push(n)}else if(n<2048){if((t-=2)<0)break;i.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;i.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;i.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return i}function X(e){return function(e){var t,n,o,r,i,p;u||c();var m=e.length;if(m%4>0)throw new Error("Invalid string. Length must be a multiple of 4");i="="===e[m-2]?2:"="===e[m-1]?1:0,p=new a(3*m/4-i),o=i>0?m-4:m;var d=0;for(t=0,n=0;t<o;t+=4,n+=3)r=s[e.charCodeAt(t)]<<18|s[e.charCodeAt(t+1)]<<12|s[e.charCodeAt(t+2)]<<6|s[e.charCodeAt(t+3)],p[d++]=r>>16&255,p[d++]=r>>8&255,p[d++]=255&r;return 2===i?(r=s[e.charCodeAt(t)]<<2|s[e.charCodeAt(t+1)]>>4,p[d++]=255&r):1===i&&(r=s[e.charCodeAt(t)]<<10|s[e.charCodeAt(t+1)]<<4|s[e.charCodeAt(t+2)]>>2,p[d++]=r>>8&255,p[d++]=255&r),p}(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(G,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function J(e,t,n,o){for(var r=0;r<o&&!(r+n>=t.length||r>=e.length);++r)t[r+n]=e[r];return r}function ee(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}const te=P.from("pool"),ne=P.from("cpi_authority"),oe=P.from([23,169,27,122,147,169,209,152]),re=P.from([241,34,48,186,37,179,123,192]),ie=P.from([65,206,101,37,147,42,221,144]),se=P.from([163,52,200,231,140,3,69,186]),ae=P.from([112,230,105,101,145,202,157,97]),ue=P.from([69,74,217,36,115,117,97,76]),ce=P.from([170,23,31,34,133,173,93,242]),pe=P.from([114,143,210,73,96,115,1,228]);function me(e,t){if(!e.mint.equals(t))throw new Error("TokenPool mint does not match the provided mint.");if(!e.isInitialized)throw new Error(`TokenPool is not initialized. Please create a compressed token pool for mint: ${t.toBase58()} via createTokenPool().`);return 1}async function de(e,o,r){const i=Array.from({length:5},((e,t)=>ot.deriveTokenPoolPdaWithIndex(o,t))),s=await e.getMultipleAccountsInfo(i.map((e=>e[0])),r);if(null===s[0])throw new Error(`TokenPool not found. Please create a compressed token pool for mint: ${o.toBase58()} via createTokenPool().`);const a=i.map(((e,t)=>s[t]?n.unpackAccount(e[0],s[t],s[t].owner):null)),u=s[0].owner;return a.map(((e,n)=>e?{mint:o,tokenPoolPda:e.address,tokenProgram:u,activity:void 0,balance:t.bn(e.amount.toString()),isInitialized:1,poolIndex:n,bump:i[n][1]}:{mint:o,tokenPoolPda:i[n][0],tokenProgram:u,activity:void 0,balance:t.bn(0),isInitialized:0,poolIndex:n,bump:i[n][1]}))}var le;exports.Action=void 0,(le=exports.Action||(exports.Action={}))[le.Compress=1]="Compress",le[le.Decompress=2]="Decompress",le[le.Transfer=3]="Transfer";const ge=e=>{for(let t=e.length-1;t>0;t--){const n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}return e};function he(e){const t=ge(e).filter((e=>e.isInitialized));if(0===t.length)throw new Error("Please pass at least one initialized token pool info.");return t[0]}function fe(e,n){if(0===e.length)throw new Error("Please pass at least one token pool info.");const o=(e=ge(e)).find((e=>e.balance.gte(t.bn(n).mul(t.bn(10)))));if((e=e.filter((e=>e.isInitialized)).sort(((e,t)=>e.poolIndex-t.poolIndex))).every((e=>e.balance.isZero())))throw new Error("All provided token pool balances are zero. Please pass recent token pool infos.");return o?[o]:e}const ye="Could not find accounts to select for transfer.";function Pe(e,t,n=4){const o=e.find((e=>e.parsed.amount.eq(t)));return o?[[o],o.parsed.amount,o.compressedAccount.lamports,o.parsed.amount]:ke(e,t,n)}function ke(e,n,o=4){const[r,i,s,a]=be(e,n,o);if(i.lt(t.bn(n))){const i=e.reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0));throw r.length>=o?new Error(`Account limit exceeded: max ${a.toString()} (${o} accounts) per transaction. Total balance: ${i.toString()} (${e.length} accounts). Consider multiple transfers to spend full balance.`):new Error(`Insufficient balance for transfer. Required: ${n.toString()}, available: ${i.toString()}.`)}if(0===r.length)throw new Error(ye);return[r,i,s,a]}function be(e,n,o=4){if(0===e.length)throw new Error(ye);let r=t.bn(0),i=t.bn(0),s=t.bn(0);const a=[];e.sort(((e,t)=>t.parsed.amount.cmp(e.parsed.amount)));for(const s of e){if(a.length>=o)break;if(r.gte(t.bn(n)))break;s.parsed.amount.isZero()&&s.compressedAccount.lamports.isZero()||(r=r.add(s.parsed.amount),i=i.add(s.compressedAccount.lamports),a.push(s))}if(s=e.slice(0,o).reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0)),r.lt(t.bn(n))&&console.log(`Insufficient balance for transfer. Requested: ${n.toString()}, Returns max available: ${s.toString()}.`),0===a.length)throw new Error(ye);return[a,r,i,s]}function Ae(e,n,o=4){if(0===e.length)throw new Error(ye);let r=t.bn(0),i=t.bn(0);const s=[],a=e.filter((e=>!e.parsed.amount.isZero()||!e.compressedAccount.lamports.isZero()));a.sort(((e,t)=>t.parsed.amount.cmp(e.parsed.amount)));for(const e of a){if(s.length>=o)break;if(r=r.add(e.parsed.amount),i=i.add(e.compressedAccount.lamports),s.push(e),r.gte(t.bn(n))){const e=a.slice(s.length);if(e.length>0){const t=e.reduce(((e,t)=>t.parsed.amount.lt(e.parsed.amount)?t:e));s.length<o&&(s.push(t),r=r.add(t.parsed.amount),i=i.add(t.compressedAccount.lamports))}break}}const u=a.slice(0,o).reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0));if(0===s.length)throw new Error(ye);return[s,r,i,u]}function Se(e){const{inputCompressedTokenAccounts:n,outputStateTreeInfo:o,remainingAccounts:r=[],rootIndices:i,tokenTransferOutputs:s}=e,a=r.slice();let u=null;n.length>0&&n[0].parsed.delegate&&(u=t.getIndexOrAdd(a,n[0].parsed.delegate));const c=[];if(n.forEach(((e,n)=>{const o=t.getIndexOrAdd(a,e.compressedAccount.treeInfo.tree),r=t.getIndexOrAdd(a,e.compressedAccount.treeInfo.queue);c.push({amount:e.parsed.amount,delegateIndex:u,merkleContext:{merkleTreePubkeyIndex:o,queuePubkeyIndex:r,leafIndex:e.compressedAccount.leafIndex,proveByIndex:e.compressedAccount.proveByIndex},rootIndex:i[n],lamports:e.compressedAccount.lamports.eq(t.bn(0))?null:e.compressedAccount.lamports,tlv:null})})),n.length>0&&o)throw new Error("Cannot specify both input accounts and outputStateTreeInfo");let p;if(n.length>0)p=n[0].compressedAccount.treeInfo;else{if(!o)throw new Error("Neither input accounts nor outputStateTreeInfo are available");p=o}const m=p.nextTreeInfo||p;let d=m.tree;if(m.treeType===t.TreeType.StateV2){if(!t.featureFlags.isV2())throw new Error("V2 trees are not supported yet");d=m.queue}const l=t.padOutputStateMerkleTrees(d,s.length),g=[];l.forEach(((e,n)=>{var o;const r=t.getIndexOrAdd(a,e);g.push({owner:s[n].owner,amount:s[n].amount,lamports:(null===(o=s[n].lamports)||void 0===o?void 0:o.eq(t.bn(0)))?null:s[n].lamports,merkleTreeIndex:r,tlv:null})}));const h=a.map((e=>({pubkey:e,isWritable:1,isSigner:0})));return{inputTokenDataWithContext:c,remainingAccountMetas:h,packedOutputTokenData:g}}function Te(e,t){if(!e.every((e=>e.parsed.mint.equals(t))))throw new Error("All input accounts must belong to the same mint");return 1}const Ie=o.struct([o.array(o.u8(),32,"a"),o.array(o.u8(),64,"b"),o.array(o.u8(),32,"c")]),we=o.struct([o.publicKey("owner"),o.u64("amount"),o.option(o.u64(),"lamports"),o.u8("merkleTreeIndex"),o.option(o.vecU8(),"tlv")]),Ce=o.struct([o.u64("amount"),o.option(o.u8(),"delegateIndex"),o.struct([o.u8("merkleTreePubkeyIndex"),o.u8("queuePubkeyIndex"),o.u32("leafIndex"),o.bool("proveByIndex")],"merkleContext"),o.u16("rootIndex"),o.option(o.u64(),"lamports"),o.option(o.vecU8(),"tlv")]),xe=o.struct([o.publicKey("owner"),o.option(o.u8(),"delegateChangeAccountIndex")]),ve=o.struct([o.bool("setContext"),o.bool("firstSetContext"),o.u8("cpiContextAccountIndex")]),Me=o.struct([o.option(Ie,"proof"),o.publicKey("mint"),o.option(xe,"delegatedTransfer"),o.vec(Ce,"inputTokenDataWithContext"),o.vec(we,"outputCompressedAccounts"),o.bool("isCompress"),o.option(o.u64(),"compressOrDecompressAmount"),o.option(ve,"cpiContext"),o.option(o.u8(),"lamportsChangeAccountMerkleTreeIndex")]),Ee=o.struct([o.vec(o.publicKey(),"recipients"),o.vec(o.u64(),"amounts"),o.option(o.u64(),"lamports")]),De=o.struct([o.vec(o.publicKey(),"pubkeys"),o.option(o.vec(o.u64(),"amounts"),"amounts"),o.option(o.u64(),"lamports"),o.option(o.u64(),"amount"),o.u8("index"),o.u8("bump")]),Re=o.struct([o.publicKey("owner"),o.option(o.u64(),"remainingAmount"),o.option(ve,"cpiContext")]);function Oe(e){const t=P.alloc(1e3),n=Ee.encode({recipients:e.recipients,amounts:e.amounts,lamports:e.lamports},t);return P.concat([new Uint8Array(re),new Uint8Array(t.subarray(0,n))])}function _e(e){const t=P.alloc(1e3),n=De.encode(e,t),o=P.alloc(4);o.writeUInt32LE(n,0);const r=t.subarray(0,n);return P.concat([new Uint8Array(ie),new Uint8Array(o),new Uint8Array(r)])}function Ue(e){const t=P.alloc(1e3),n=Re.encode({owner:e.owner,remainingAmount:e.remainingAmount,cpiContext:e.cpiContext},t);return P.concat([new Uint8Array(ae),new Uint8Array(t.subarray(0,n))])}function Be(e){const t=P.alloc(1e3),n=Me.encode(e,t),o=P.alloc(4);o.writeUInt32LE(n,0);const r=t.subarray(0,n);return P.concat([new Uint8Array(se),new Uint8Array(o),new Uint8Array(r)])}const Le=e=>{const{feePayer:t,tokenPoolPda:n,systemProgram:o,mint:r,tokenProgram:i,cpiAuthorityPda:s}=e;return[{pubkey:t,isSigner:1,isWritable:1},{pubkey:n,isSigner:0,isWritable:1},{pubkey:o,isSigner:0,isWritable:0},{pubkey:r,isSigner:0,isWritable:1},{pubkey:i,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:0}]},We=e=>{const{feePayer:t,tokenPoolPda:n,systemProgram:o,mint:r,tokenProgram:i,cpiAuthorityPda:s,existingTokenPoolPda:a}=e;return[{pubkey:t,isSigner:1,isWritable:1},{pubkey:n,isSigner:0,isWritable:1},{pubkey:a,isSigner:0,isWritable:0},{pubkey:o,isSigner:0,isWritable:0},{pubkey:r,isSigner:0,isWritable:1},{pubkey:i,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:0}]},Ke=e=>{const t=ot.programId,{feePayer:n,authority:o,cpiAuthorityPda:r,mint:i,tokenPoolPda:s,tokenProgram:a,lightSystemProgram:u,registeredProgramPda:c,noopProgram:p,accountCompressionAuthority:m,accountCompressionProgram:d,merkleTree:l,selfProgram:g,systemProgram:h,solPoolPda:f}=e;return[{pubkey:n,isSigner:1,isWritable:1},{pubkey:o,isSigner:1,isWritable:0},{pubkey:r,isSigner:0,isWritable:0},{pubkey:i,isSigner:0,isWritable:1},{pubkey:s,isSigner:0,isWritable:1},{pubkey:a,isSigner:0,isWritable:0},{pubkey:u,isSigner:0,isWritable:0},{pubkey:c,isSigner:0,isWritable:0},{pubkey:p,isSigner:0,isWritable:0},{pubkey:m,isSigner:0,isWritable:0},{pubkey:d,isSigner:0,isWritable:0},{pubkey:l,isSigner:0,isWritable:1},{pubkey:g,isSigner:0,isWritable:0},{pubkey:h,isSigner:0,isWritable:0},{pubkey:null!=f?f:t,isSigner:0,isWritable:1}]},Ne=e=>{const t=ot.programId,{feePayer:n,authority:o,cpiAuthorityPda:r,lightSystemProgram:i,registeredProgramPda:s,noopProgram:a,accountCompressionAuthority:u,accountCompressionProgram:c,selfProgram:p,tokenPoolPda:m,compressOrDecompressTokenAccount:d,tokenProgram:l,systemProgram:g}=e;return[{pubkey:n,isSigner:1,isWritable:1},{pubkey:o,isSigner:1,isWritable:0},{pubkey:r,isSigner:0,isWritable:0},{pubkey:i,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:0},{pubkey:a,isSigner:0,isWritable:0},{pubkey:u,isSigner:0,isWritable:0},{pubkey:c,isSigner:0,isWritable:0},{pubkey:p,isSigner:0,isWritable:0},{pubkey:null!=m?m:t,isSigner:0,isWritable:1},{pubkey:null!=d?d:t,isSigner:0,isWritable:1},{pubkey:null!=l?l:t,isSigner:0,isWritable:0},{pubkey:g,isSigner:0,isWritable:0}]},Fe=e=>{const{feePayer:t,authority:n,cpiAuthorityPda:o,lightSystemProgram:r,registeredProgramPda:i,noopProgram:s,accountCompressionAuthority:a,accountCompressionProgram:u,selfProgram:c,systemProgram:p}=e;return[{pubkey:t,isSigner:1,isWritable:1},{pubkey:n,isSigner:1,isWritable:0},{pubkey:o,isSigner:0,isWritable:0},{pubkey:r,isSigner:0,isWritable:0},{pubkey:i,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:0},{pubkey:a,isSigner:0,isWritable:0},{pubkey:u,isSigner:0,isWritable:0},{pubkey:c,isSigner:0,isWritable:0},{pubkey:p,isSigner:0,isWritable:0}]},qe=Fe,Ye=e=>{const{feePayer:t,authority:n,cpiAuthorityPda:o,lightSystemProgram:r,registeredProgramPda:i,noopProgram:s,accountCompressionAuthority:a,accountCompressionProgram:u,selfProgram:c,systemProgram:p,mint:m}=e;return[{pubkey:t,isSigner:1,isWritable:1},{pubkey:n,isSigner:1,isWritable:0},{pubkey:o,isSigner:0,isWritable:0},{pubkey:r,isSigner:0,isWritable:0},{pubkey:i,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:0},{pubkey:a,isSigner:0,isWritable:0},{pubkey:u,isSigner:0,isWritable:0},{pubkey:c,isSigner:0,isWritable:0},{pubkey:p,isSigner:0,isWritable:0},{pubkey:m,isSigner:0,isWritable:0}]},Ve=Ye,ze=o.struct([o.struct([o.array(o.u8(),32,"a"),o.array(o.u8(),64,"b"),o.array(o.u8(),32,"c")],"proof"),o.publicKey("mint"),o.vec(Ce,"inputTokenDataWithContext"),o.option(ve,"cpiContext"),o.publicKey("delegate"),o.u64("delegatedAmount"),o.u8("delegateMerkleTreeIndex"),o.u8("changeAccountMerkleTreeIndex"),o.option(o.u64(),"delegateLamports")]),He=o.struct([o.struct([o.array(o.u8(),32,"a"),o.array(o.u8(),64,"b"),o.array(o.u8(),32,"c")],"proof"),o.publicKey("mint"),o.vec(Ce,"inputTokenDataWithContext"),o.option(ve,"cpiContext"),o.u8("outputAccountMerkleTreeIndex")]),je={a:new Array(32).fill(0),b:new Array(64).fill(0),c:new Array(32).fill(0)};function $e(e){return e.a.every((e=>0===e))&&e.b.every((e=>0===e))&&e.c.every((e=>0===e))}function Ze(e){var t;const n=P.alloc(1e3),o=null!==(t=e.proof)&&void 0!==t?t:je,r=ze.encode(Object.assign(Object.assign({},e),{proof:o}),n),i=P.alloc(4);i.writeUInt32LE(r,0);const s=n.subarray(0,r);return P.concat([new Uint8Array(ue),new Uint8Array(i),new Uint8Array(s)])}function Ge(e){var t;const n=P.alloc(1e3),o=null!==(t=e.proof)&&void 0!==t?t:je,r=He.encode(Object.assign(Object.assign({},e),{proof:o}),n),i=P.alloc(4);i.writeUInt32LE(r,0);const s=n.subarray(0,r);return P.concat([new Uint8Array(ce),new Uint8Array(i),new Uint8Array(s)])}const Qe=e=>e.reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0)),Xe=e=>{const t=e[0].parsed.owner;e.forEach((e=>{if(!e.parsed.owner.equals(t))throw new Error("Token accounts must be owned by the same owner")}))},Je=e=>({mint:e[0].parsed.mint,currentOwner:e[0].parsed.owner,delegate:e[0].parsed.delegate}),et=(e,t)=>{if(e.length<1)throw new Error("Must supply at least one input token account.");const n=e[0].parsed.owner,o=e.findIndex((e=>e.parsed.delegate));if(-1===o)return{delegatedTransfer:null,authority:n};const r=e[o].parsed.delegate;return{delegatedTransfer:{owner:n,delegateChangeAccountIndex:t.length<=1?null:0},authority:r}};function tt(e,n,o){o=t.bn(o);const r=Qe(e),i=t.sumUpLamports(e.map((e=>e.compressedAccount))),s=r.sub(o);return t.validateSufficientBalance(s),s.eq(t.bn(0))&&i.eq(t.bn(0))?[{owner:n,amount:o,lamports:i,tlv:null}]:(t.validateSameOwner(e.map((e=>e.compressedAccount))),Xe(e),[{owner:e[0].parsed.owner,amount:s,lamports:i,tlv:null},{owner:n,amount:o,lamports:t.bn(0),tlv:null}])}function nt(e,n){n=t.bn(n);const o=t.sumUpLamports(e.map((e=>e.compressedAccount))),r=Qe(e).sub(n);return t.validateSufficientBalance(r),r.eq(t.bn(0))&&o.eq(t.bn(0))?[]:(t.validateSameOwner(e.map((e=>e.compressedAccount))),Xe(e),[{owner:e[0].parsed.owner,amount:r,lamports:o,tlv:null}])}class ot{constructor(){}static setProgramId(t){this.programId="string"==typeof t?new e.PublicKey(t):t}static deriveTokenPoolPda(t){const n=[te,t.toBuffer()],[o,r]=e.PublicKey.findProgramAddressSync(n,this.programId);return o}static findTokenPoolIndexAndBump(e,t){for(let n=0;n<5;n++){const o=ot.deriveTokenPoolPdaWithIndex(t,n);if(o[0].equals(e))return[n,o[1]]}throw new Error("Token pool not found")}static deriveTokenPoolPdaWithIndex(t,n){let o=[];o=0===n?[P.from("pool"),t.toBuffer(),P.from([])]:[P.from("pool"),t.toBuffer(),P.from([n])];const[r,i]=e.PublicKey.findProgramAddressSync(o,this.programId);return[r,i]}static get deriveCpiAuthorityPda(){const[t,n]=e.PublicKey.findProgramAddressSync([ne],this.programId);return t}static async createMint({feePayer:t,mint:o,authority:r,freezeAuthority:i,decimals:s,rentExemptBalance:a,tokenProgramId:u,mintSize:c}){const p=null!=u?u:n.TOKEN_PROGRAM_ID;return[e.SystemProgram.createAccount({fromPubkey:t,lamports:a,newAccountPubkey:o,programId:p,space:null!=c?c:n.MINT_SIZE}),n.createInitializeMint2Instruction(o,s,r,i,p),await this.createTokenPool({feePayer:t,mint:o,tokenProgramId:p})]}static async createTokenPool({feePayer:t,mint:o,tokenProgramId:r}){const i=null!=r?r:n.TOKEN_PROGRAM_ID,s=this.deriveTokenPoolPdaWithIndex(o,0),a=Le({mint:o,feePayer:t,tokenPoolPda:s[0],tokenProgram:i,cpiAuthorityPda:this.deriveCpiAuthorityPda,systemProgram:e.SystemProgram.programId});return new e.TransactionInstruction({programId:this.programId,keys:a,data:oe})}static async addTokenPool({feePayer:t,mint:o,poolIndex:r,tokenProgramId:i}){if(r<=0)throw new Error("Pool index must be greater than 0. For 0, use CreateTokenPool instead.");if(r>3)throw new Error(`Invalid poolIndex ${r}. Max 4 pools per mint.`);const s=null!=i?i:n.TOKEN_PROGRAM_ID,a=this.deriveTokenPoolPdaWithIndex(o,r-1),u=this.deriveTokenPoolPdaWithIndex(o,r),c=We({mint:o,feePayer:t,tokenPoolPda:u[0],existingTokenPoolPda:a[0],tokenProgram:s,cpiAuthorityPda:this.deriveCpiAuthorityPda,systemProgram:e.SystemProgram.programId});return new e.TransactionInstruction({programId:this.programId,keys:c,data:P.concat([new Uint8Array(pe),new Uint8Array(P.from([r]))])})}static async mintTo({feePayer:n,mint:o,authority:r,toPubkey:i,amount:s,outputStateTreeInfo:a,tokenPoolInfo:u}){const c=t.defaultStaticAccountsStruct(),p=u.tokenProgram;me(u,o);const m=t.toArray(s).map((e=>t.bn(e))),d=t.toArray(i);if(m.length!==d.length)throw new Error("Amount and toPubkey arrays must have the same length");const l=Ke({mint:o,feePayer:n,authority:r,cpiAuthorityPda:this.deriveCpiAuthorityPda,tokenProgram:p,tokenPoolPda:u.tokenPoolPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:c.registeredProgramPda,noopProgram:c.noopProgram,accountCompressionAuthority:c.accountCompressionAuthority,accountCompressionProgram:c.accountCompressionProgram,merkleTree:a.treeType===t.TreeType.StateV2?a.queue:a.tree,selfProgram:this.programId,systemProgram:e.SystemProgram.programId,solPoolPda:null}),g=Oe({recipients:d,amounts:m,lamports:null});return new e.TransactionInstruction({programId:this.programId,keys:l,data:g})}static async approveAndMintTo({feePayer:e,mint:t,authority:o,authorityTokenAccount:r,toPubkey:i,amount:s,outputStateTreeInfo:a,tokenPoolInfo:u}){const c=BigInt(s.toString());return[n.createMintToInstruction(t,r,o,c,[],u.tokenProgram),await this.compress({payer:e,owner:o,source:r,toAddress:i,mint:t,amount:s,outputStateTreeInfo:a,tokenPoolInfo:u})]}static async transfer({payer:n,inputCompressedTokenAccounts:o,toAddress:r,amount:i,recentValidityProof:s,recentInputStateRootIndices:a}){const u=tt(o,r,i),{inputTokenDataWithContext:c,packedOutputTokenData:p,remainingAccountMetas:m}=Se({inputCompressedTokenAccounts:o,rootIndices:a,tokenTransferOutputs:u}),{mint:d}=Je(o),{delegatedTransfer:l,authority:g}=et(o,u),h=Be({proof:s,mint:d,delegatedTransfer:l,inputTokenDataWithContext:c,outputCompressedAccounts:p,compressOrDecompressAmount:null,isCompress:0,cpiContext:null,lamportsChangeAccountMerkleTreeIndex:null}),{accountCompressionAuthority:f,noopProgram:y,registeredProgramPda:P,accountCompressionProgram:k}=t.defaultStaticAccountsStruct(),b=Ne({feePayer:n,authority:g,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:P,noopProgram:y,accountCompressionAuthority:f,accountCompressionProgram:k,selfProgram:this.programId,tokenPoolPda:void 0,compressOrDecompressTokenAccount:void 0,tokenProgram:void 0,systemProgram:e.SystemProgram.programId});return b.push(...m),new e.TransactionInstruction({programId:this.programId,keys:b,data:h})}static async createTokenProgramLookupTable({payer:o,authority:r,mints:i,recentSlot:s,remainingAccounts:a}){const[u,c]=e.AddressLookupTableProgram.createLookupTable({authority:r,payer:r,recentSlot:s});let p=[];i&&(p=[...i,...i.map((e=>this.deriveTokenPoolPda(e)))]);const m=[u,e.AddressLookupTableProgram.extendLookupTable({payer:o,authority:r,lookupTable:c,addresses:[e.SystemProgram.programId,e.ComputeBudgetProgram.programId,this.deriveCpiAuthorityPda,t.LightSystemProgram.programId,ot.programId,t.defaultStaticAccountsStruct().registeredProgramPda,t.defaultStaticAccountsStruct().noopProgram,t.defaultStaticAccountsStruct().accountCompressionAuthority,t.defaultStaticAccountsStruct().accountCompressionProgram,t.defaultTestStateTreeAccounts().merkleTree,t.defaultTestStateTreeAccounts().nullifierQueue,t.defaultTestStateTreeAccounts().addressTree,t.defaultTestStateTreeAccounts().addressQueue,this.programId,n.TOKEN_PROGRAM_ID,n.TOKEN_2022_PROGRAM_ID,r,...p]})];if(a&&a.length>0)for(let t=0;t<a.length;t+=25){const n=a.slice(t,t+25),i=e.AddressLookupTableProgram.extendLookupTable({payer:o,authority:r,lookupTable:c,addresses:n});m.push(i)}return{instructions:m,address:c}}static async compress({payer:n,owner:o,source:r,toAddress:i,amount:s,mint:a,outputStateTreeInfo:u,tokenPoolInfo:c}){let p;const m=t.toArray(s),d=t.toArray(i);if(me(c,a),m.length!==d.length)throw new Error("Amount and toAddress arrays must have the same length");if(t.featureFlags.isV2()){const[i,s]=this.findTokenPoolIndexAndBump(c.tokenPoolPda,a),p=_e({pubkeys:d,amounts:m.length>1?m.map((e=>t.bn(e))):null,lamports:null,amount:1===m.length?t.bn(m[0]):null,index:i,bump:s}),l=Ke(Object.assign(Object.assign({mint:a,feePayer:n,authority:o,cpiAuthorityPda:this.deriveCpiAuthorityPda,tokenProgram:c.tokenProgram,tokenPoolPda:c.tokenPoolPda,lightSystemProgram:t.LightSystemProgram.programId},t.defaultStaticAccountsStruct()),{merkleTree:u.queue,selfProgram:this.programId,systemProgram:e.SystemProgram.programId,solPoolPda:null}));return l.push({pubkey:r,isWritable:1,isSigner:0}),new e.TransactionInstruction({programId:this.programId,keys:l,data:p})}{p=m.map(((e,n)=>{const o=t.bn(e);return{owner:d[n],amount:o,lamports:null,tlv:null}}));const{inputTokenDataWithContext:i,packedOutputTokenData:l,remainingAccountMetas:g}=Se({inputCompressedTokenAccounts:[],outputStateTreeInfo:u,rootIndices:[],tokenTransferOutputs:p}),h=Be({proof:null,mint:a,delegatedTransfer:null,inputTokenDataWithContext:i,outputCompressedAccounts:l,compressOrDecompressAmount:Array.isArray(s)?s.map((e=>t.bn(e))).reduce(((e,t)=>e.add(t)),t.bn(0)):t.bn(s),isCompress:1,cpiContext:null,lamportsChangeAccountMerkleTreeIndex:null}),f=Ne(Object.assign(Object.assign({},t.defaultStaticAccountsStruct()),{feePayer:n,authority:o,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,selfProgram:this.programId,systemProgram:e.SystemProgram.programId,tokenPoolPda:c.tokenPoolPda,compressOrDecompressTokenAccount:r,tokenProgram:c.tokenProgram}));return f.push(...g),new e.TransactionInstruction({programId:this.programId,keys:f,data:h})}}static async decompress({payer:n,inputCompressedTokenAccounts:o,toAddress:r,amount:i,recentValidityProof:s,recentInputStateRootIndices:a,tokenPoolInfos:u}){const c=t.bn(i),p=t.toArray(u),m=nt(o,c),{inputTokenDataWithContext:d,packedOutputTokenData:l,remainingAccountMetas:g}=Se({inputCompressedTokenAccounts:o,rootIndices:a,tokenTransferOutputs:m,remainingAccounts:p.slice(1).map((e=>e.tokenPoolPda))}),{mint:h}=Je(o),{delegatedTransfer:f,authority:y}=et(o,m),P=Be({proof:s,mint:h,delegatedTransfer:f,inputTokenDataWithContext:d,outputCompressedAccounts:l,compressOrDecompressAmount:c,isCompress:0,cpiContext:null,lamportsChangeAccountMerkleTreeIndex:null}),k=p[0].tokenProgram,{accountCompressionAuthority:b,noopProgram:A,registeredProgramPda:S,accountCompressionProgram:T}=t.defaultStaticAccountsStruct(),I=Ne({feePayer:n,authority:y,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:S,noopProgram:A,accountCompressionAuthority:b,accountCompressionProgram:T,selfProgram:this.programId,tokenPoolPda:p[0].tokenPoolPda,compressOrDecompressTokenAccount:r,tokenProgram:k,systemProgram:e.SystemProgram.programId});return I.push(...g),new e.TransactionInstruction({programId:this.programId,keys:I,data:P})}static async mergeTokenAccounts({payer:e,owner:n,inputCompressedTokenAccounts:o,mint:r,recentValidityProof:i,recentInputStateRootIndices:s}){if(o.length>4)throw new Error("Cannot merge more than 4 token accounts at once");return Te(o,r),[await this.transfer({payer:e,inputCompressedTokenAccounts:o,toAddress:n,amount:o.reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0)),recentInputStateRootIndices:s,recentValidityProof:i})]}static async compressSplTokenAccount({feePayer:n,authority:o,tokenAccount:r,mint:i,remainingAmount:s,outputStateTreeInfo:a,tokenPoolInfo:u}){me(u,i);const c=[{pubkey:a.treeType===t.TreeType.StateV2?a.queue:a.tree,isSigner:0,isWritable:1}],p=Ue({owner:o,remainingAmount:null!=s?s:null,cpiContext:null}),{accountCompressionAuthority:m,noopProgram:d,registeredProgramPda:l,accountCompressionProgram:g}=t.defaultStaticAccountsStruct(),h=Ne({feePayer:n,authority:o,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:l,noopProgram:d,accountCompressionAuthority:m,accountCompressionProgram:g,selfProgram:this.programId,tokenPoolPda:u.tokenPoolPda,compressOrDecompressTokenAccount:r,tokenProgram:u.tokenProgram,systemProgram:e.SystemProgram.programId});return h.push(...c),new e.TransactionInstruction({programId:this.programId,keys:h,data:p})}static async getMintProgramId(e,t){var n;return null===(n=await t.getAccountInfo(e))||void 0===n?void 0:n.owner}static async approve({payer:n,inputCompressedTokenAccounts:o,toAddress:r,amount:i,recentValidityProof:s,recentInputStateRootIndices:a}){const{inputTokenDataWithContext:u,remainingAccountMetas:c}=Se({inputCompressedTokenAccounts:o,rootIndices:a,tokenTransferOutputs:[]}),{mint:p,currentOwner:m}=Je(o),d=o[0].compressedAccount.treeInfo.treeType===t.TreeType.StateV2?1:0,l=Ze({proof:s,mint:p,inputTokenDataWithContext:u,cpiContext:null,delegate:r,delegatedAmount:t.bn(i),delegateMerkleTreeIndex:d,changeAccountMerkleTreeIndex:d,delegateLamports:null}),{accountCompressionAuthority:g,noopProgram:h,registeredProgramPda:f,accountCompressionProgram:y}=t.defaultStaticAccountsStruct(),P=Fe({feePayer:n,authority:m,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:f,noopProgram:h,accountCompressionAuthority:g,accountCompressionProgram:y,selfProgram:this.programId,systemProgram:e.SystemProgram.programId});return P.push(...c),new e.TransactionInstruction({programId:this.programId,keys:P,data:l})}static async revoke({payer:n,inputCompressedTokenAccounts:o,recentValidityProof:r,recentInputStateRootIndices:i}){Xe(o);const{inputTokenDataWithContext:s,remainingAccountMetas:a}=Se({inputCompressedTokenAccounts:o,rootIndices:i,tokenTransferOutputs:[]}),{mint:u,currentOwner:c}=Je(o),p=Ge({proof:r,mint:u,inputTokenDataWithContext:s,cpiContext:null,outputAccountMerkleTreeIndex:o[0].compressedAccount.treeInfo.treeType===t.TreeType.StateV2?2:1}),{accountCompressionAuthority:m,noopProgram:d,registeredProgramPda:l,accountCompressionProgram:g}=t.defaultStaticAccountsStruct(),h=qe({feePayer:n,authority:c,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:l,noopProgram:d,accountCompressionAuthority:m,accountCompressionProgram:g,selfProgram:this.programId,systemProgram:e.SystemProgram.programId});return h.push(...a),new e.TransactionInstruction({programId:this.programId,keys:h,data:p})}}ot.programId=new e.PublicKey("cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m"),exports.ADD_TOKEN_POOL_DISCRIMINATOR=pe,exports.APPROVE_DISCRIMINATOR=ue,exports.BATCH_COMPRESS_DISCRIMINATOR=ie,exports.COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR=ae,exports.CPI_AUTHORITY_SEED=ne,exports.CREATE_TOKEN_POOL_DISCRIMINATOR=oe,exports.CompressedTokenInstructionDataApproveLayout=ze,exports.CompressedTokenInstructionDataRevokeLayout=He,exports.CompressedTokenInstructionDataTransferLayout=Me,exports.CompressedTokenProgram=ot,exports.CpiContextLayout=ve,exports.DelegatedTransferLayout=xe,exports.ERROR_NO_ACCOUNTS_FOUND=ye,exports.IDL={version:"1.2.0",name:"light_compressed_token",instructions:[{name:"createTokenPool",docs:["This instruction creates a token pool for a given mint. Every spl mint","can have one token pool. When a token is compressed the tokens are","transferrred to the token pool, and their compressed equivalent is","minted into a Merkle tree."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"tokenPoolPda",isMut:1,isSigner:0},{name:"systemProgram",isMut:0,isSigner:0},{name:"mint",isMut:1,isSigner:0},{name:"tokenProgram",isMut:0,isSigner:0},{name:"cpiAuthorityPda",isMut:0,isSigner:0}],args:[]},{name:"addTokenPool",docs:["This instruction creates an additional token pool for a given mint.","The maximum number of token pools per mint is 5."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"tokenPoolPda",isMut:1,isSigner:0},{name:"existingTokenPoolPda",isMut:0,isSigner:0},{name:"systemProgram",isMut:0,isSigner:0},{name:"mint",isMut:1,isSigner:0},{name:"tokenProgram",isMut:0,isSigner:0},{name:"cpiAuthorityPda",isMut:0,isSigner:0}],args:[{name:"tokenPoolIndex",type:"u8"}]},{name:"mintTo",docs:["Mints tokens from an spl token mint to a list of compressed accounts.","Minted tokens are transferred to a pool account owned by the compressed","token program. The instruction creates one compressed output account for","every amount and pubkey input pair. A constant amount of lamports can be","transferred to each output account to enable. A use case to add lamports","to a compressed token account is to prevent spam. This is the only way","to add lamports to a compressed token account."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"mint",isMut:1,isSigner:0},{name:"tokenPoolPda",isMut:1,isSigner:0},{name:"tokenProgram",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0,docs:["programs"]},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"merkleTree",isMut:1,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0},{name:"systemProgram",isMut:0,isSigner:0},{name:"solPoolPda",isMut:1,isSigner:0,isOptional:1}],args:[{name:"publicKeys",type:{vec:"publicKey"}},{name:"amounts",type:{vec:"u64"}},{name:"lamports",type:{option:"u64"}}]},{name:"compressSplTokenAccount",docs:["Compresses the balance of an spl token account sub an optional remaining","amount. This instruction does not close the spl token account. To close","the account bundle a close spl account instruction in your transaction."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["this program is the signer of the cpi."]},{name:"tokenPoolPda",isMut:1,isSigner:0,isOptional:1},{name:"compressOrDecompressTokenAccount",isMut:1,isSigner:0,isOptional:1},{name:"tokenProgram",isMut:0,isSigner:0,isOptional:1},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"owner",type:"publicKey"},{name:"remainingAmount",type:{option:"u64"}},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}}]},{name:"transfer",docs:["Transfers compressed tokens from one account to another. All accounts","must be of the same mint. Additional spl tokens can be compressed or","decompressed. In one transaction only compression or decompression is","possible. Lamports can be transferred alongside tokens. If output token","accounts specify less lamports than inputs the remaining lamports are","transferred to an output compressed account. Signer must be owner or","delegate. If a delegated token account is transferred the delegate is","not preserved."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["this program is the signer of the cpi."]},{name:"tokenPoolPda",isMut:1,isSigner:0,isOptional:1},{name:"compressOrDecompressTokenAccount",isMut:1,isSigner:0,isOptional:1},{name:"tokenProgram",isMut:0,isSigner:0,isOptional:1},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"approve",docs:["Delegates an amount to a delegate. A compressed token account is either","completely delegated or not. Prior delegates are not preserved. Cannot","be called by a delegate.","The instruction creates two output accounts:","1. one account with delegated amount","2. one account with remaining(change) amount"],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["this program is the signer of the cpi."]},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"revoke",docs:["Revokes a delegation. The instruction merges all inputs into one output","account. Cannot be called by a delegate. Delegates are not preserved."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["this program is the signer of the cpi."]},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"freeze",docs:["Freezes compressed token accounts. Inputs must not be frozen. Creates as","many outputs as inputs. Balances and delegates are preserved."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["that this program is the signer of the cpi."]},{name:"systemProgram",isMut:0,isSigner:0},{name:"mint",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"thaw",docs:["Thaws frozen compressed token accounts. Inputs must be frozen. Creates","as many outputs as inputs. Balances and delegates are preserved."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["that this program is the signer of the cpi."]},{name:"systemProgram",isMut:0,isSigner:0},{name:"mint",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"burn",docs:["Burns compressed tokens and spl tokens from the pool account. Delegates","can burn tokens. The output compressed token account remains delegated.","Creates one output compressed token account."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"mint",isMut:1,isSigner:0},{name:"tokenPoolPda",isMut:1,isSigner:0},{name:"tokenProgram",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"stubIdlBuild",docs:["This function is a stub to allow Anchor to include the input types in","the IDL. It should not be included in production builds nor be called in","practice."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["this program is the signer of the cpi."]},{name:"tokenPoolPda",isMut:1,isSigner:0,isOptional:1},{name:"compressOrDecompressTokenAccount",isMut:1,isSigner:0,isOptional:1},{name:"tokenProgram",isMut:0,isSigner:0,isOptional:1},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs1",type:{defined:"CompressedTokenInstructionDataTransfer"}},{name:"inputs2",type:{defined:"TokenData"}}]}],types:[{name:"AccountState",type:{kind:"enum",variants:[{name:"Initialized"},{name:"Frozen"}]}},{name:"CompressedAccount",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"lamports",type:"u64"},{name:"address",type:{option:{array:["u8",32]}}},{name:"data",type:{option:{defined:"CompressedAccountData"}}}]}},{name:"CompressedAccountData",type:{kind:"struct",fields:[{name:"discriminator",type:{array:["u8",8]}},{name:"data",type:"bytes"},{name:"dataHash",type:{array:["u8",32]}}]}},{name:"CompressedCpiContext",type:{kind:"struct",fields:[{name:"setContext",docs:["Is set by the program that is invoking the CPI to signal that is should","set the cpi context."],type:"bool"},{name:"firstSetContext",docs:["Is set to wipe the cpi context since someone could have set it before","with unrelated data."],type:"bool"},{name:"cpiContextAccountIndex",docs:["Index of cpi context account in remaining accounts."],type:"u8"}]}},{name:"CompressedProof",type:{kind:"struct",fields:[{name:"a",type:{array:["u8",32]}},{name:"b",type:{array:["u8",64]}},{name:"c",type:{array:["u8",32]}}]}},{name:"CompressedTokenInstructionDataTransfer",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"mint",type:"publicKey"},{name:"delegatedTransfer",docs:["Is required if the signer is delegate,","-> delegate is authority account,","owner = Some(owner) is the owner of the token account."],type:{option:{defined:"DelegatedTransfer"}}},{name:"inputTokenDataWithContext",type:{vec:{defined:"InputTokenDataWithContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"PackedTokenTransferOutputData"}}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressAmount",type:{option:"u64"}},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}},{name:"lamportsChangeAccountMerkleTreeIndex",type:{option:"u8"}}]}},{name:"CompressedTokenInstructionDataRevoke",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"mint",type:"publicKey"},{name:"inputTokenDataWithContext",type:{vec:{defined:"InputTokenDataWithContext"}}},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}},{name:"outputAccountMerkleTreeIndex",type:"u8"}]}},{name:"CompressedTokenInstructionDataApprove",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"mint",type:"publicKey"},{name:"inputTokenDataWithContext",type:{vec:{defined:"InputTokenDataWithContext"}}},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}},{name:"delegate",type:"publicKey"},{name:"delegatedAmount",type:"u64"},{name:"delegateMerkleTreeIndex",type:"u8"},{name:"changeAccountMerkleTreeIndex",type:"u8"},{name:"delegateLamports",type:{option:"u64"}}]}},{name:"DelegatedTransfer",docs:["Struct to provide the owner when the delegate is signer of the transaction."],type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"delegateChangeAccountIndex",docs:["Index of change compressed account in output compressed accounts. In","case that the delegate didn't spend the complete delegated compressed","account balance the change compressed account will be delegated to her","as well."],type:{option:"u8"}}]}},{name:"InputTokenDataWithContext",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"delegateIndex",type:{option:"u8"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",type:"u16"},{name:"lamports",type:{option:"u64"}},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}},{name:"InstructionDataInvoke",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"}]}},{name:"InstructionDataInvokeCpi",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}}]}},{name:"MerkleTreeSequenceNumber",type:{kind:"struct",fields:[{name:"pubkey",type:"publicKey"},{name:"seq",type:"u64"}]}},{name:"NewAddressParamsPacked",type:{kind:"struct",fields:[{name:"seed",type:{array:["u8",32]}},{name:"addressQueueAccountIndex",type:"u8"},{name:"addressMerkleTreeAccountIndex",type:"u8"},{name:"addressMerkleTreeRootIndex",type:"u16"}]}},{name:"OutputCompressedAccountWithPackedContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleTreeIndex",type:"u8"}]}},{name:"PackedCompressedAccountWithMerkleContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",docs:["Index of root used in inclusion validity proof."],type:"u16"},{name:"readOnly",docs:["Placeholder to mark accounts read-only unimplemented set to false."],type:"bool"}]}},{name:"PackedMerkleContext",type:{kind:"struct",fields:[{name:"merkleTreePubkeyIndex",type:"u8"},{name:"queuePubkeyIndex",type:"u8"},{name:"leafIndex",type:"u32"},{name:"proveByIndex",type:"bool"}]}},{name:"PackedTokenTransferOutputData",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"amount",type:"u64"},{name:"lamports",type:{option:"u64"}},{name:"merkleTreeIndex",type:"u8"},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}},{name:"PublicTransactionEvent",type:{kind:"struct",fields:[{name:"inputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"outputLeafIndices",type:{vec:"u32"}},{name:"sequenceNumbers",type:{vec:{defined:"MerkleTreeSequenceNumber"}}},{name:"relayFee",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"pubkeyArray",type:{vec:"publicKey"}},{name:"message",type:{option:"bytes"}}]}},{name:"QueueIndex",type:{kind:"struct",fields:[{name:"queueId",docs:["Id of queue in queue account."],type:"u8"},{name:"index",docs:["Index of compressed account hash in queue."],type:"u16"}]}},{name:"TokenData",type:{kind:"struct",fields:[{name:"mint",docs:["The mint associated with this account"],type:"publicKey"},{name:"owner",docs:["The owner of this account."],type:"publicKey"},{name:"amount",docs:["The amount of tokens this account holds."],type:"u64"},{name:"delegate",docs:["If `delegate` is `Some` then `delegated_amount` represents","the amount authorized by the delegate"],type:{option:"publicKey"}},{name:"state",docs:["The account's state"],type:{defined:"AccountState"}},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}}],errors:[{code:6e3,name:"PublicKeyAmountMissmatch",msg:"public keys and amounts must be of same length"},{code:6001,name:"ComputeInputSumFailed",msg:"ComputeInputSumFailed"},{code:6002,name:"ComputeOutputSumFailed",msg:"ComputeOutputSumFailed"},{code:6003,name:"ComputeCompressSumFailed",msg:"ComputeCompressSumFailed"},{code:6004,name:"ComputeDecompressSumFailed",msg:"ComputeDecompressSumFailed"},{code:6005,name:"SumCheckFailed",msg:"SumCheckFailed"},{code:6006,name:"DecompressRecipientUndefinedForDecompress",msg:"DecompressRecipientUndefinedForDecompress"},{code:6007,name:"CompressedPdaUndefinedForDecompress",msg:"CompressedPdaUndefinedForDecompress"},{code:6008,name:"DeCompressAmountUndefinedForDecompress",msg:"DeCompressAmountUndefinedForDecompress"},{code:6009,name:"CompressedPdaUndefinedForCompress",msg:"CompressedPdaUndefinedForCompress"},{code:6010,name:"DeCompressAmountUndefinedForCompress",msg:"DeCompressAmountUndefinedForCompress"},{code:6011,name:"DelegateSignerCheckFailed",msg:"DelegateSignerCheckFailed"},{code:6012,name:"MintTooLarge",msg:"Minted amount greater than u64::MAX"},{code:6013,name:"SplTokenSupplyMismatch",msg:"SplTokenSupplyMismatch"},{code:6014,name:"HeapMemoryCheckFailed",msg:"HeapMemoryCheckFailed"},{code:6015,name:"InstructionNotCallable",msg:"The instruction is not callable"},{code:6016,name:"ArithmeticUnderflow",msg:"ArithmeticUnderflow"},{code:6017,name:"HashToFieldError",msg:"HashToFieldError"},{code:6018,name:"InvalidAuthorityMint",msg:"Expected the authority to be also a mint authority"},{code:6019,name:"InvalidFreezeAuthority",msg:"Provided authority is not the freeze authority"},{code:6020,name:"InvalidDelegateIndex"},{code:6021,name:"TokenPoolPdaUndefined"},{code:6022,name:"IsTokenPoolPda",msg:"Compress or decompress recipient is the same account as the token pool pda."},{code:6023,name:"InvalidTokenPoolPda"},{code:6024,name:"NoInputTokenAccountsProvided"},{code:6025,name:"NoInputsProvided"},{code:6026,name:"MintHasNoFreezeAuthority"},{code:6027,name:"MintWithInvalidExtension"},{code:6028,name:"InsufficientTokenAccountBalance",msg:"The token account balance is less than the remaining amount."},{code:6029,name:"InvalidTokenPoolBump",msg:"Max number of token pools reached."},{code:6030,name:"FailedToDecompress"},{code:6031,name:"FailedToBurnSplTokensFromTokenPool"},{code:6032,name:"NoMatchingBumpFound"}]},exports.MINT_TO_DISCRIMINATOR=re,exports.POOL_SEED=te,exports.REVOKE_DISCRIMINATOR=ce,exports.SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE=1461600,exports.TRANSFER_DISCRIMINATOR=se,exports.addTokenPoolAccountsLayout=We,exports.addTokenPools=async function(e,n,o,r,i,s){s=s||await ot.getMintProgramId(o,e);const a=[],u=(await de(e,o)).slice(0,4),c=[];for(let e=0;e<u.length;e++)u[e].isInitialized||c.push(e);for(let e=0;e<r&&!(e>=c.length);e++)a.push(await ot.addTokenPool({mint:o,feePayer:n.publicKey,tokenProgramId:s,poolIndex:c[e]}));const{blockhash:p}=await e.getLatestBlockhash(),m=t.buildAndSignTx(a,n,p);return await t.sendAndConfirmTx(e,m,i)},exports.approve=async function(n,o,r,i,s,a,u){i=t.bn(i);const c=await n.getCompressedTokenAccountsByOwner(s.publicKey,{mint:r}),[p]=Pe(c.items,i),m=await n.getValidityProofV0(p.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue})))),d=await ot.approve({payer:o.publicKey,inputCompressedTokenAccounts:p,toAddress:a,amount:i,recentInputStateRootIndices:m.rootIndices,recentValidityProof:m.compressedProof}),{blockhash:l}=await n.getLatestBlockhash(),g=t.dedupeSigner(o,[s]),h=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:35e4}),d],o,l,g);return t.sendAndConfirmTx(n,h,u)},exports.approveAccountsLayout=Fe,exports.approveAndMintTo=async function(o,r,i,s,a,u,c,p,m){c=null!=c?c:t.selectStateTreeInfo(await o.getStateTreeInfos()),p=null!=p?p:he(await de(o,i));const d=await n.getOrCreateAssociatedTokenAccount(o,r,i,a.publicKey,void 0,void 0,m,p.tokenProgram),l=await ot.approveAndMintTo({feePayer:r.publicKey,mint:i,authority:a.publicKey,authorityTokenAccount:d.address,amount:u,toPubkey:s,outputStateTreeInfo:c,tokenPoolInfo:p}),{blockhash:g}=await o.getLatestBlockhash(),h=t.dedupeSigner(r,[a]),f=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:15e4+2e4*t.toArray(u).length}),...l],r,g,h);return await t.sendAndConfirmTx(o,f,m)},exports.batchCompressLayout=De,exports.checkMint=Te,exports.checkTokenPoolInfo=me,exports.compress=async function(n,o,r,i,s,a,u,c,p,m){c=null!=c?c:t.selectStateTreeInfo(await n.getStateTreeInfos()),p=null!=p?p:he(await de(n,r));const d=await ot.compress({payer:o.publicKey,owner:s.publicKey,source:a,toAddress:u,amount:i,mint:r,outputStateTreeInfo:c,tokenPoolInfo:p}),l=await n.getLatestBlockhash(),g=t.dedupeSigner(o,[s]),h=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:13e4+2e4*t.toArray(i).length}),d],o,l.blockhash,g);return await t.sendAndConfirmTx(n,h,m,l)},exports.compressSplTokenAccount=async function(n,o,r,i,s,a,u,c,p){u=null!=u?u:t.selectStateTreeInfo(await n.getStateTreeInfos()),c=null!=c?c:he(await de(n,r));const m=await ot.compressSplTokenAccount({feePayer:o.publicKey,authority:i.publicKey,tokenAccount:s,mint:r,remainingAmount:a,outputStateTreeInfo:u,tokenPoolInfo:c}),d=await n.getLatestBlockhash(),l=t.dedupeSigner(o,[i]),g=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:15e4}),m],o,d.blockhash,l);return await t.sendAndConfirmTx(n,g,p,d)},exports.compressSplTokenAccountInstructionDataLayout=Re,exports.createDecompressOutputState=nt,exports.createMint=async function(o,r,i,s,a=e.Keypair.generate(),u,c,p){const m=await o.getMinimumBalanceForRentExemption(n.MINT_SIZE),d=1==c?n.TOKEN_2022_PROGRAM_ID:c||n.TOKEN_PROGRAM_ID,l=await ot.createMint({feePayer:r.publicKey,mint:a.publicKey,decimals:s,authority:"secretKey"in i?i.publicKey:i,freezeAuthority:p&&"secretKey"in p?p.publicKey:null!=p?p:null,rentExemptBalance:m,tokenProgramId:d}),{blockhash:g}=await o.getLatestBlockhash(),h=t.dedupeSigner(r,[i,p].filter((e=>null!=e&&"secretKey"in e))),f=t.buildAndSignTx(l,r,g,[...h,a]),y=await t.sendAndConfirmTx(o,f,u);return{mint:a.publicKey,transactionSignature:y}},exports.createTokenPool=async function(e,n,o,r,i){i=i||await ot.getMintProgramId(o,e);const s=await ot.createTokenPool({feePayer:n.publicKey,mint:o,tokenProgramId:i}),{blockhash:a}=await e.getLatestBlockhash(),u=t.buildAndSignTx([s],n,a);return await t.sendAndConfirmTx(e,u,r)},exports.createTokenPoolAccountsLayout=Le,exports.createTokenProgramLookupTable=async function(e,n,o,r,i){const s=await e.getSlot("finalized"),{instructions:a,address:u}=await ot.createTokenProgramLookupTable({payer:n.publicKey,authority:o.publicKey,mints:r,remainingAccounts:i,recentSlot:s}),c=t.dedupeSigner(n,[o]),p=[];for(const o of a){const r=await e.getLatestBlockhash(),i=t.buildAndSignTx([o],n,r.blockhash,c),s=await t.sendAndConfirmTx(e,i,{commitment:"finalized"},r);p.push(s)}return{txIds:p,address:u}},exports.createTransferOutputState=tt,exports.decodeApproveInstructionData=function(e){const t=ze.decode(e.subarray(ue.length));return Object.assign(Object.assign({},t),{proof:$e(t.proof)?null:t.proof})},exports.decodeBatchCompressInstructionData=function(e){return De.decode(e.subarray(ie.length+4))},exports.decodeCompressSplTokenAccountInstructionData=function(e){const t=Re.decode(e.subarray(ae.length));return{owner:t.owner,remainingAmount:t.remainingAmount,cpiContext:t.cpiContext}},exports.decodeMintToInstructionData=function(e){return Ee.decode(e.subarray(re.length))},exports.decodeRevokeInstructionData=function(e){const t=He.decode(e.subarray(ce.length));return Object.assign(Object.assign({},t),{proof:$e(t.proof)?null:t.proof})},exports.decodeTransferInstructionData=function(e){return Me.decode(e.slice(se.length+4))},exports.decompress=async function(n,o,r,i,s,a,u,c){i=t.bn(i);const p=await n.getCompressedTokenAccountsByOwner(s.publicKey,{mint:r}),[m]=ke(p.items,i),d=await n.getValidityProofV0(m.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue})))),l=fe(u=null!=u?u:await de(n,r),i),g=await ot.decompress({payer:o.publicKey,inputCompressedTokenAccounts:m,toAddress:a,amount:i,tokenPoolInfos:l,recentInputStateRootIndices:d.rootIndices,recentValidityProof:d.compressedProof}),{blockhash:h}=await n.getLatestBlockhash(),f=t.dedupeSigner(o,[s]),y=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:35e4}),g],o,h,f);return await t.sendAndConfirmTx(n,y,c)},exports.decompressDelegated=async function(n,o,r,i,s,a,u,c){i=t.bn(i);const p=await n.getCompressedTokenAccountsByDelegate(s.publicKey,{mint:r}),[m]=ke(p.items,i),d=await n.getValidityProofV0(m.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue})))),l=null!=u?u:fe(await de(n,r),i),g=await ot.decompress({payer:o.publicKey,inputCompressedTokenAccounts:m,toAddress:a,amount:i,recentInputStateRootIndices:d.rootIndices,recentValidityProof:d.compressedProof,tokenPoolInfos:l}),{blockhash:h}=await n.getLatestBlockhash(),f=t.dedupeSigner(o,[s]),y=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:35e4}),g],o,h,f);return t.sendAndConfirmTx(n,y,c)},exports.encodeApproveInstructionData=Ze,exports.encodeBatchCompressInstructionData=_e,exports.encodeCompressSplTokenAccountInstructionData=Ue,exports.encodeMintToInstructionData=Oe,exports.encodeRevokeInstructionData=Ge,exports.encodeTransferInstructionData=Be,exports.freezeAccountsLayout=Ye,exports.getTokenPoolInfos=de,exports.isSingleTokenPoolInfo=function(e){return!Array.isArray(e)},exports.mergeTokenAccounts=async function(n,o,r,i,s){const a=await n.getCompressedTokenAccountsByOwner(i.publicKey,{mint:r});if(0===a.items.length)throw new Error(`No compressed token accounts found for mint ${r.toBase58()}`);const u=[e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6})];for(let e=0;e<a.items.slice(0,8).length;e+=4){const s=a.items.slice(e,e+4),c=await n.getValidityProof(s.map((e=>t.bn(e.compressedAccount.hash)))),p=await ot.mergeTokenAccounts({payer:o.publicKey,owner:i.publicKey,inputCompressedTokenAccounts:s,mint:r,recentValidityProof:c.compressedProof,recentInputStateRootIndices:c.rootIndices});u.push(...p)}const{blockhash:c}=await n.getLatestBlockhash(),p=t.dedupeSigner(o,[i]),m=t.buildAndSignTx(u,o,c,p);return t.sendAndConfirmTx(n,m,s)},exports.mintTo=async function(n,o,r,i,s,a,u,c,p){u=null!=u?u:t.selectStateTreeInfo(await n.getStateTreeInfos()),c=null!=c?c:he(await de(n,r));const m=await ot.mintTo({feePayer:o.publicKey,mint:r,authority:s.publicKey,amount:a,toPubkey:i,outputStateTreeInfo:u,tokenPoolInfo:c}),{blockhash:d}=await n.getLatestBlockhash(),l=t.dedupeSigner(o,[s]),g=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),m],o,d,l);return t.sendAndConfirmTx(n,g,p)},exports.mintToAccountsLayout=Ke,exports.mintToLayout=Ee,exports.packCompressedTokenAccounts=Se,exports.parseMaybeDelegatedTransfer=et,exports.parseTokenData=Je,exports.revoke=async function(n,o,r,i,s){const a=await n.getValidityProofV0(r.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue}))));!function(e,t){if(!e.publicKey.equals(t[0].parsed.owner))throw new Error(`Owner ${e.publicKey.toBase58()} does not match account ${t[0].parsed.owner.toBase58()}`)}(i,r),function(e){if(e.some((e=>null===e.parsed.delegate)))throw new Error("Account is not delegated")}(r);const u=await ot.revoke({payer:o.publicKey,inputCompressedTokenAccounts:r,recentInputStateRootIndices:a.rootIndices,recentValidityProof:a.compressedProof}),{blockhash:c}=await n.getLatestBlockhash(),p=t.dedupeSigner(o,[i]),m=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:5e5}),u],o,c,p);return t.sendAndConfirmTx(n,m,s)},exports.revokeAccountsLayout=qe,exports.selectMinCompressedTokenAccountsForDecompression=function(e,t,n=4){const[o,r,i,s]=ke(e,t,n);return{selectedAccounts:o,total:r,totalLamports:i,maxPossibleAmount:s}},exports.selectMinCompressedTokenAccountsForTransfer=ke,exports.selectMinCompressedTokenAccountsForTransferOrPartial=be,exports.selectSmartCompressedTokenAccountsForTransfer=function(e,n,o=4){const[r,i,s,a]=Ae(e,n,o);if(i.lt(t.bn(n))){const i=e.reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0));throw r.length>=o?new Error(`Account limit exceeded: max ${a.toString()} (${o} accounts) per transaction. Total balance: ${i.toString()} (${e.length} accounts). Consider multiple transfers to spend full balance.`):new Error(`Insufficient balance. Required: ${n.toString()}, available: ${i.toString()}.`)}if(0===r.length)throw new Error(ye);return[r,i,s,a]},exports.selectSmartCompressedTokenAccountsForTransferOrPartial=Ae,exports.selectTokenAccountsForApprove=Pe,exports.selectTokenPoolInfo=he,exports.selectTokenPoolInfosForDecompression=fe,exports.sumUpTokenAmount=Qe,exports.thawAccountsLayout=Ve,exports.transfer=async function(n,o,r,i,s,a,u){i=t.bn(i);const c=await n.getCompressedTokenAccountsByOwner(s.publicKey,{mint:r}),[p]=ke(c.items,i),m=await n.getValidityProofV0(p.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue})))),d=await ot.transfer({payer:o.publicKey,inputCompressedTokenAccounts:p,toAddress:a,amount:i,recentInputStateRootIndices:m.rootIndices,recentValidityProof:m.compressedProof}),{blockhash:l}=await n.getLatestBlockhash(),g=t.dedupeSigner(o,[s]),h=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:5e5}),d],o,l,g);return t.sendAndConfirmTx(n,h,u)},exports.transferAccountsLayout=Ne,exports.transferDelegated=async function(n,o,r,i,s,a,u){i=t.bn(i);const c=await n.getCompressedTokenAccountsByDelegate(s.publicKey,{mint:r}),[p]=ke(c.items,i),m=await n.getValidityProofV0(p.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue})))),d=await ot.transfer({payer:o.publicKey,inputCompressedTokenAccounts:p,toAddress:a,amount:i,recentInputStateRootIndices:m.rootIndices,recentValidityProof:m.compressedProof}),{blockhash:l}=await n.getLatestBlockhash(),g=t.dedupeSigner(o,[s]),h=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:5e5}),d],o,l,g);return t.sendAndConfirmTx(n,h,u)},exports.validateSameTokenOwner=Xe;
//# sourceMappingURL=index.cjs.map
