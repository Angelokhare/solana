{"version":3,"file":"index.cjs","sources":["../../../../../src/constants.ts","../../../../../src/utils/get-token-pool-infos.ts","../../../../../src/utils/select-input-accounts.ts","../../../../../src/utils/pack-compressed-token-accounts.ts","../../../../../src/utils/validation.ts","../../../../../src/layout.ts","../../../../../src/program.ts","../../../../../src/idl.ts","../../../../../src/actions/create-token-pool.ts","../../../../../src/actions/approve.ts","../../../../../src/actions/approve-and-mint-to.ts","../../../../../src/actions/compress.ts","../../../../../src/actions/compress-spl-token-account.ts","../../../../../src/actions/create-mint.ts","../../../../../src/actions/create-token-program-lookup-table.ts","../../../../../src/actions/decompress.ts","../../../../../src/actions/decompress-delegated.ts","../../../../../src/types.ts","../../../../../src/actions/merge-token-accounts.ts","../../../../../src/actions/mint-to.ts","../../../../../src/actions/revoke.ts","../../../../../src/actions/transfer.ts","../../../../../src/actions/transfer-delegated.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nexport const POOL_SEED = Buffer.from('pool');\n\nexport const CPI_AUTHORITY_SEED = Buffer.from('cpi_authority');\n\nexport const SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE = 1461600;\n\nexport const CREATE_TOKEN_POOL_DISCRIMINATOR = Buffer.from([\n    23, 169, 27, 122, 147, 169, 209, 152,\n]);\nexport const MINT_TO_DISCRIMINATOR = Buffer.from([\n    241, 34, 48, 186, 37, 179, 123, 192,\n]);\nexport const BATCH_COMPRESS_DISCRIMINATOR = Buffer.from([\n    65, 206, 101, 37, 147, 42, 221, 144,\n]);\nexport const TRANSFER_DISCRIMINATOR = Buffer.from([\n    163, 52, 200, 231, 140, 3, 69, 186,\n]);\nexport const COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR = Buffer.from([\n    112, 230, 105, 101, 145, 202, 157, 97,\n]);\n\nexport const APPROVE_DISCRIMINATOR = Buffer.from([\n    69, 74, 217, 36, 115, 117, 97, 76,\n]);\nexport const REVOKE_DISCRIMINATOR = Buffer.from([\n    170, 23, 31, 34, 133, 173, 93, 242,\n]);\nexport const ADD_TOKEN_POOL_DISCRIMINATOR = Buffer.from([\n    114, 143, 210, 73, 96, 115, 1, 228,\n]);\n","import { Commitment, PublicKey } from '@solana/web3.js';\nimport { unpackAccount } from '@solana/spl-token';\nimport { CompressedTokenProgram } from '../program';\nimport { bn, Rpc } from '@lightprotocol/stateless.js';\nimport BN from 'bn.js';\n\n/**\n * Check if the token pool info is initialized and has a balance.\n * @param mint The mint of the token pool\n * @param tokenPoolInfo The token pool info\n * @returns True if the token pool info is initialized and has a balance\n */\nexport function checkTokenPoolInfo(\n    tokenPoolInfo: TokenPoolInfo,\n    mint: PublicKey,\n): boolean {\n    if (!tokenPoolInfo.mint.equals(mint)) {\n        throw new Error(`TokenPool mint does not match the provided mint.`);\n    }\n\n    if (!tokenPoolInfo.isInitialized) {\n        throw new Error(\n            `TokenPool is not initialized. Please create a compressed token pool for mint: ${mint.toBase58()} via createTokenPool().`,\n        );\n    }\n    return true;\n}\n\n/**\n * Get the token pool infos for a given mint.\n * @param rpc         The RPC client\n * @param mint        The mint of the token pool\n * @param commitment  The commitment to use\n *\n * @returns The token pool infos\n */\nexport async function getTokenPoolInfos(\n    rpc: Rpc,\n    mint: PublicKey,\n    commitment?: Commitment,\n): Promise<TokenPoolInfo[]> {\n    const addressesAndBumps = Array.from({ length: 5 }, (_, i) =>\n        CompressedTokenProgram.deriveTokenPoolPdaWithIndex(mint, i),\n    );\n\n    const accountInfos = await rpc.getMultipleAccountsInfo(\n        addressesAndBumps.map(addressAndBump => addressAndBump[0]),\n        commitment,\n    );\n\n    if (accountInfos[0] === null) {\n        throw new Error(\n            `TokenPool not found. Please create a compressed token pool for mint: ${mint.toBase58()} via createTokenPool().`,\n        );\n    }\n\n    const parsedInfos = addressesAndBumps.map((addressAndBump, i) =>\n        accountInfos[i]\n            ? unpackAccount(\n                  addressAndBump[0],\n                  accountInfos[i],\n                  accountInfos[i].owner,\n              )\n            : null,\n    );\n\n    const tokenProgram = accountInfos[0].owner;\n    return parsedInfos.map((parsedInfo, i) => {\n        if (!parsedInfo) {\n            return {\n                mint,\n                tokenPoolPda: addressesAndBumps[i][0],\n                tokenProgram,\n                activity: undefined,\n                balance: bn(0),\n                isInitialized: false,\n                poolIndex: i,\n                bump: addressesAndBumps[i][1],\n            };\n        }\n\n        return {\n            mint,\n            tokenPoolPda: parsedInfo.address,\n            tokenProgram,\n            activity: undefined,\n            balance: bn(parsedInfo.amount.toString()),\n            isInitialized: true,\n            poolIndex: i,\n            bump: addressesAndBumps[i][1],\n        };\n    });\n}\n\nexport type TokenPoolActivity = {\n    signature: string;\n    amount: BN;\n    action: Action;\n};\n\n/**\n * Token pool pda info.\n */\nexport type TokenPoolInfo = {\n    /**\n     * The mint of the token pool\n     */\n    mint: PublicKey;\n    /**\n     * The token pool address\n     */\n    tokenPoolPda: PublicKey;\n    /**\n     * The token program of the token pool\n     */\n    tokenProgram: PublicKey;\n    /**\n     * count of txs and volume in the past 60 seconds.\n     */\n    activity?: {\n        txs: number;\n        amountAdded: BN;\n        amountRemoved: BN;\n    };\n    /**\n     * Whether the token pool is initialized\n     */\n    isInitialized: boolean;\n    /**\n     * The balance of the token pool\n     */\n    balance: BN;\n    /**\n     * The index of the token pool\n     */\n    poolIndex: number;\n    /**\n     * The bump used to derive the token pool pda\n     */\n    bump: number;\n};\n\n/**\n * @internal\n */\nexport enum Action {\n    Compress = 1,\n    Decompress = 2,\n    Transfer = 3,\n}\n\n/**\n * @internal\n */\nconst shuffleArray = <T>(array: T[]): T[] => {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n};\n\n/**\n * For `compress` and `mintTo` instructions only.\n * Select a random token pool info from the token pool infos.\n *\n * For `decompress`, use {@link selectTokenPoolInfosForDecompression} instead.\n *\n * @param infos The token pool infos\n *\n * @returns A random token pool info\n */\nexport function selectTokenPoolInfo(infos: TokenPoolInfo[]): TokenPoolInfo {\n    const shuffledInfos = shuffleArray(infos);\n\n    // filter only infos that are initialized\n    const filteredInfos = shuffledInfos.filter(info => info.isInitialized);\n\n    if (filteredInfos.length === 0) {\n        throw new Error(\n            'Please pass at least one initialized token pool info.',\n        );\n    }\n\n    // Return a single random token pool info\n    return filteredInfos[0];\n}\n\n/**\n * Select one or multiple token pool infos from the token pool infos.\n *\n * Use this function for `decompress`.\n *\n * For `compress`, `mintTo` use {@link selectTokenPoolInfo} instead.\n *\n * @param infos             The token pool infos\n * @param decompressAmount  The amount of tokens to withdraw\n *\n * @returns Array with one or more token pool infos.\n */\nexport function selectTokenPoolInfosForDecompression(\n    infos: TokenPoolInfo[],\n    decompressAmount: number | BN,\n): TokenPoolInfo[] {\n    if (infos.length === 0) {\n        throw new Error('Please pass at least one token pool info.');\n    }\n\n    infos = shuffleArray(infos);\n    // Find the first info where balance is 10x the requested amount\n    const sufficientBalanceInfo = infos.find(info =>\n        info.balance.gte(bn(decompressAmount).mul(bn(10))),\n    );\n\n    // filter only infos that are initialized\n    infos = infos\n        .filter(info => info.isInitialized)\n        .sort((a, b) => a.poolIndex - b.poolIndex);\n\n    const allBalancesZero = infos.every(info => info.balance.isZero());\n    if (allBalancesZero) {\n        throw new Error(\n            'All provided token pool balances are zero. Please pass recent token pool infos.',\n        );\n    }\n\n    // If none found, return all infos\n    return sufficientBalanceInfo ? [sufficientBalanceInfo] : infos;\n}\n","import { bn, ParsedTokenAccount } from '@lightprotocol/stateless.js';\n\nimport BN from 'bn.js';\n\nexport const ERROR_NO_ACCOUNTS_FOUND =\n    'Could not find accounts to select for transfer.';\n\n/**\n * Selects token accounts for approval, first trying to find an exact match, then falling back to minimum selection.\n *\n * @param {ParsedTokenAccount[]} accounts - Token accounts to choose from.\n * @param {BN} approveAmount - Amount to approve.\n * @param {number} [maxInputs=4] - Max accounts to select when falling back to minimum selection.\n * @returns {[\n *   selectedAccounts: ParsedTokenAccount[],\n *   total: BN,\n *   totalLamports: BN | null,\n *   maxPossibleAmount: BN\n * ]} - Returns:\n *   - selectedAccounts: Accounts chosen for approval.\n *   - total: Total amount from selected accounts.\n *   - totalLamports: Total lamports from selected accounts.\n *   - maxPossibleAmount: Max approvable amount given maxInputs.\n */\nexport function selectTokenAccountsForApprove(\n    accounts: ParsedTokenAccount[],\n    approveAmount: BN,\n    maxInputs: number = 4,\n): [\n    selectedAccounts: ParsedTokenAccount[],\n    total: BN,\n    totalLamports: BN | null,\n    maxPossibleAmount: BN,\n] {\n    // First try to find an exact match\n    const exactMatch = accounts.find(account =>\n        account.parsed.amount.eq(approveAmount),\n    );\n    if (exactMatch) {\n        return [\n            [exactMatch],\n            exactMatch.parsed.amount,\n            exactMatch.compressedAccount.lamports,\n            exactMatch.parsed.amount,\n        ];\n    }\n\n    // If no exact match, fall back to minimum selection\n    return selectMinCompressedTokenAccountsForTransfer(\n        accounts,\n        approveAmount,\n        maxInputs,\n    );\n}\n\n/**\n * Selects the minimum number of compressed token accounts required for a\n * decompress instruction, up to a specified maximum.\n *\n * @param {ParsedTokenAccount[]} accounts   Token accounts to choose from.\n * @param {BN} amount                       Amount to decompress.\n * @param {number} [maxInputs=4]            Max accounts to select. Default\n *                                          is 4.\n *\n * @returns Returns selected accounts and their totals.\n */\nexport function selectMinCompressedTokenAccountsForDecompression(\n    accounts: ParsedTokenAccount[],\n    amount: BN,\n    maxInputs: number = 4,\n): {\n    selectedAccounts: ParsedTokenAccount[];\n    total: BN;\n    totalLamports: BN | null;\n    maxPossibleAmount: BN;\n} {\n    const [selectedAccounts, total, totalLamports, maxPossibleAmount] =\n        selectMinCompressedTokenAccountsForTransfer(\n            accounts,\n            amount,\n            maxInputs,\n        );\n    return { selectedAccounts, total, totalLamports, maxPossibleAmount };\n}\n\n/**\n * Selects the minimum number of compressed token accounts required for a\n * transfer or decompression instruction, up to a specified maximum.\n *\n * @param {ParsedTokenAccount[]} accounts   Token accounts to choose from.\n * @param {BN} transferAmount               Amount to transfer or decompress.\n * @param {number} [maxInputs=4]            Max accounts to select. Default\n *                                          is 4.\n *\n * @returns Returns selected accounts and their totals. [\n *   selectedAccounts: ParsedTokenAccount[],\n *   total: BN,\n *   totalLamports: BN | null,\n *   maxPossibleAmount: BN\n * ]\n */\nexport function selectMinCompressedTokenAccountsForTransfer(\n    accounts: ParsedTokenAccount[],\n    transferAmount: BN,\n    maxInputs: number = 4,\n): [\n    selectedAccounts: ParsedTokenAccount[],\n    total: BN,\n    totalLamports: BN | null,\n    maxPossibleAmount: BN,\n] {\n    const [\n        selectedAccounts,\n        accumulatedAmount,\n        accumulatedLamports,\n        maxPossibleAmount,\n    ] = selectMinCompressedTokenAccountsForTransferOrPartial(\n        accounts,\n        transferAmount,\n        maxInputs,\n    );\n\n    if (accumulatedAmount.lt(bn(transferAmount))) {\n        const totalBalance = accounts.reduce(\n            (acc, account) => acc.add(account.parsed.amount),\n            bn(0),\n        );\n        if (selectedAccounts.length >= maxInputs) {\n            throw new Error(\n                `Account limit exceeded: max ${maxPossibleAmount.toString()} (${maxInputs} accounts) per transaction. Total balance: ${totalBalance.toString()} (${accounts.length} accounts). Consider multiple transfers to spend full balance.`,\n            );\n        } else {\n            throw new Error(\n                `Insufficient balance for transfer. Required: ${transferAmount.toString()}, available: ${totalBalance.toString()}.`,\n            );\n        }\n    }\n\n    if (selectedAccounts.length === 0) {\n        throw new Error(ERROR_NO_ACCOUNTS_FOUND);\n    }\n\n    return [\n        selectedAccounts,\n        accumulatedAmount,\n        accumulatedLamports,\n        maxPossibleAmount,\n    ];\n}\n\n/**\n * Executes {@link selectMinCompressedTokenAccountsForTransfer} strategy,\n * returns partial amounts if insufficient accounts are found instead of\n * throwing an error.\n */\nexport function selectMinCompressedTokenAccountsForTransferOrPartial(\n    accounts: ParsedTokenAccount[],\n    transferAmount: BN,\n    maxInputs: number = 4,\n): [\n    selectedAccounts: ParsedTokenAccount[],\n    total: BN,\n    totalLamports: BN | null,\n    maxPossibleAmount: BN,\n] {\n    if (accounts.length === 0) {\n        throw new Error(ERROR_NO_ACCOUNTS_FOUND);\n    }\n\n    let accumulatedAmount = bn(0);\n    let accumulatedLamports = bn(0);\n    let maxPossibleAmount = bn(0);\n\n    const selectedAccounts: ParsedTokenAccount[] = [];\n\n    accounts.sort((a, b) => b.parsed.amount.cmp(a.parsed.amount));\n\n    for (const account of accounts) {\n        if (selectedAccounts.length >= maxInputs) break;\n        if (accumulatedAmount.gte(bn(transferAmount))) break;\n\n        if (\n            !account.parsed.amount.isZero() ||\n            !account.compressedAccount.lamports.isZero()\n        ) {\n            accumulatedAmount = accumulatedAmount.add(account.parsed.amount);\n            accumulatedLamports = accumulatedLamports.add(\n                account.compressedAccount.lamports,\n            );\n            selectedAccounts.push(account);\n        }\n    }\n\n    // Max, considering maxInputs\n    maxPossibleAmount = accounts\n        .slice(0, maxInputs)\n        .reduce((total, account) => total.add(account.parsed.amount), bn(0));\n\n    if (accumulatedAmount.lt(bn(transferAmount))) {\n        console.log(\n            `Insufficient balance for transfer. Requested: ${transferAmount.toString()}, Returns max available: ${maxPossibleAmount.toString()}.`,\n        );\n    }\n\n    if (selectedAccounts.length === 0) {\n        throw new Error(ERROR_NO_ACCOUNTS_FOUND);\n    }\n\n    return [\n        selectedAccounts,\n        accumulatedAmount,\n        accumulatedLamports,\n        maxPossibleAmount,\n    ];\n}\n\n/**\n * Selects compressed token accounts for a transfer, ensuring one extra account\n * if possible, up to maxInputs.\n *\n * 1. Sorts accounts by amount (desc)\n * 2. Selects accounts until transfer amount is met or maxInputs is reached,\n *    attempting to add one extra account if possible.\n *\n * @param {ParsedTokenAccount[]} accounts - The list of token accounts to select from.\n * @param {BN} transferAmount - The token amount to be transferred.\n * @param {number} [maxInputs=4] - The maximum number of accounts to select. Default: 4.\n * @returns {[\n *   selectedAccounts: ParsedTokenAccount[],\n *   total: BN,\n *   totalLamports: BN | null,\n *   maxPossibleAmount: BN\n * ]} - An array containing:\n *   - selectedAccounts: The accounts selected for the transfer.\n *   - total: The total amount accumulated from the selected accounts.\n *   - totalLamports: The total lamports accumulated from the selected accounts.\n *   - maxPossibleAmount: The maximum possible amount that can be transferred considering maxInputs.\n *\n * @example\n * const accounts = [\n *   { parsed: { amount: new BN(100) }, compressedAccount: { lamports: new BN(10) } },\n *   { parsed: { amount: new BN(50) }, compressedAccount: { lamports: new BN(5) } },\n *   { parsed: { amount: new BN(25) }, compressedAccount: { lamports: new BN(2) } },\n * ];\n * const transferAmount = new BN(75);\n * const maxInputs = 2;\n *\n * const [selectedAccounts, total, totalLamports, maxPossibleAmount] =\n *   selectSmartCompressedTokenAccountsForTransfer(accounts, transferAmount, maxInputs);\n *\n * console.log(selectedAccounts.length); // 2\n * console.log(total.toString()); // '150'\n * console.log(totalLamports!.toString()); // '15'\n * console.log(maxPossibleAmount.toString()); // '150'\n */\nexport function selectSmartCompressedTokenAccountsForTransfer(\n    accounts: ParsedTokenAccount[],\n    transferAmount: BN,\n    maxInputs: number = 4,\n): [\n    selectedAccounts: ParsedTokenAccount[],\n    total: BN,\n    totalLamports: BN | null,\n    maxPossibleAmount: BN,\n] {\n    const [\n        selectedAccounts,\n        accumulatedAmount,\n        accumulatedLamports,\n        maxPossibleAmount,\n    ] = selectSmartCompressedTokenAccountsForTransferOrPartial(\n        accounts,\n        transferAmount,\n        maxInputs,\n    );\n\n    if (accumulatedAmount.lt(bn(transferAmount))) {\n        const totalBalance = accounts.reduce(\n            (acc, account) => acc.add(account.parsed.amount),\n            bn(0),\n        );\n        if (selectedAccounts.length >= maxInputs) {\n            throw new Error(\n                `Account limit exceeded: max ${maxPossibleAmount.toString()} (${maxInputs} accounts) per transaction. Total balance: ${totalBalance.toString()} (${accounts.length} accounts). Consider multiple transfers to spend full balance.`,\n            );\n        } else {\n            throw new Error(\n                `Insufficient balance. Required: ${transferAmount.toString()}, available: ${totalBalance.toString()}.`,\n            );\n        }\n    }\n\n    if (selectedAccounts.length === 0) {\n        throw new Error(ERROR_NO_ACCOUNTS_FOUND);\n    }\n\n    return [\n        selectedAccounts,\n        accumulatedAmount,\n        accumulatedLamports,\n        maxPossibleAmount,\n    ];\n}\n\n/**\n * Executes {@link selectMinCompressedTokenAccountsForTransfer} strategy,\n * returns partial amounts if insufficient accounts are found instead of\n * throwing an error.\n */\nexport function selectSmartCompressedTokenAccountsForTransferOrPartial(\n    accounts: ParsedTokenAccount[],\n    transferAmount: BN,\n    maxInputs: number = 4,\n): [\n    selectedAccounts: ParsedTokenAccount[],\n    total: BN,\n    totalLamports: BN | null,\n    maxPossibleAmount: BN,\n] {\n    if (accounts.length === 0) {\n        throw new Error(ERROR_NO_ACCOUNTS_FOUND);\n    }\n\n    let accumulatedAmount = bn(0);\n    let accumulatedLamports = bn(0);\n\n    const selectedAccounts: ParsedTokenAccount[] = [];\n\n    // we can ignore zero value accounts.\n    const nonZeroAccounts = accounts.filter(\n        account =>\n            !account.parsed.amount.isZero() ||\n            !account.compressedAccount.lamports.isZero(),\n    );\n\n    nonZeroAccounts.sort((a, b) => b.parsed.amount.cmp(a.parsed.amount));\n\n    for (const account of nonZeroAccounts) {\n        if (selectedAccounts.length >= maxInputs) break;\n        accumulatedAmount = accumulatedAmount.add(account.parsed.amount);\n        accumulatedLamports = accumulatedLamports.add(\n            account.compressedAccount.lamports,\n        );\n        selectedAccounts.push(account);\n\n        if (accumulatedAmount.gte(bn(transferAmount))) {\n            // Select smallest additional account if maxInputs not reached\n            const remainingAccounts = nonZeroAccounts.slice(\n                selectedAccounts.length,\n            );\n            if (remainingAccounts.length > 0) {\n                const smallestAccount = remainingAccounts.reduce((min, acc) =>\n                    acc.parsed.amount.lt(min.parsed.amount) ? acc : min,\n                );\n                if (selectedAccounts.length < maxInputs) {\n                    selectedAccounts.push(smallestAccount);\n                    accumulatedAmount = accumulatedAmount.add(\n                        smallestAccount.parsed.amount,\n                    );\n                    accumulatedLamports = accumulatedLamports.add(\n                        smallestAccount.compressedAccount.lamports,\n                    );\n                }\n            }\n            break;\n        }\n    }\n\n    const maxPossibleAmount = nonZeroAccounts\n        .slice(0, maxInputs)\n        .reduce((max, account) => max.add(account.parsed.amount), bn(0));\n\n    if (selectedAccounts.length === 0) {\n        throw new Error(ERROR_NO_ACCOUNTS_FOUND);\n    }\n\n    return [\n        selectedAccounts,\n        accumulatedAmount,\n        accumulatedLamports,\n        maxPossibleAmount,\n    ];\n}\n","import {\n    ParsedTokenAccount,\n    InputTokenDataWithContext,\n    getIndexOrAdd,\n    bn,\n    padOutputStateMerkleTrees,\n    TreeType,\n    featureFlags,\n    TreeInfo,\n} from '@lightprotocol/stateless.js';\nimport { PublicKey, AccountMeta } from '@solana/web3.js';\nimport {\n    PackedTokenTransferOutputData,\n    TokenTransferOutputData,\n} from '../types';\n\nexport type PackCompressedTokenAccountsParams = {\n    /** Input state to be consumed */\n    inputCompressedTokenAccounts: ParsedTokenAccount[];\n    /**\n     * State trees that the output should be inserted into. Defaults to the 0th\n     * state tree of the input state. Gets padded to the length of\n     * outputCompressedAccounts.\n     */\n    outputStateTreeInfo?: TreeInfo;\n    /** Optional remaining accounts to append to */\n    remainingAccounts?: PublicKey[];\n    /**\n     *  Root indices that are used on-chain to fetch the correct root\n     *  from the state Merkle tree account for validity proof verification.\n     */\n    rootIndices: number[];\n    tokenTransferOutputs: TokenTransferOutputData[];\n};\n\n/**\n * Packs Compressed Token Accounts.\n */\nexport function packCompressedTokenAccounts(\n    params: PackCompressedTokenAccountsParams,\n): {\n    inputTokenDataWithContext: InputTokenDataWithContext[];\n    remainingAccountMetas: AccountMeta[];\n    packedOutputTokenData: PackedTokenTransferOutputData[];\n} {\n    const {\n        inputCompressedTokenAccounts,\n        outputStateTreeInfo,\n        remainingAccounts = [],\n        rootIndices,\n        tokenTransferOutputs,\n    } = params;\n\n    const _remainingAccounts = remainingAccounts.slice();\n    let delegateIndex: number | null = null;\n\n    if (\n        inputCompressedTokenAccounts.length > 0 &&\n        inputCompressedTokenAccounts[0].parsed.delegate\n    ) {\n        delegateIndex = getIndexOrAdd(\n            _remainingAccounts,\n            inputCompressedTokenAccounts[0].parsed.delegate,\n        );\n    }\n\n    const packedInputTokenData: InputTokenDataWithContext[] = [];\n    /// pack inputs\n    inputCompressedTokenAccounts.forEach(\n        (account: ParsedTokenAccount, index) => {\n            const merkleTreePubkeyIndex = getIndexOrAdd(\n                _remainingAccounts,\n                account.compressedAccount.treeInfo.tree,\n            );\n\n            const queuePubkeyIndex = getIndexOrAdd(\n                _remainingAccounts,\n                account.compressedAccount.treeInfo.queue,\n            );\n\n            packedInputTokenData.push({\n                amount: account.parsed.amount,\n                delegateIndex,\n                merkleContext: {\n                    merkleTreePubkeyIndex,\n                    queuePubkeyIndex,\n                    leafIndex: account.compressedAccount.leafIndex,\n                    proveByIndex: account.compressedAccount.proveByIndex,\n                },\n                rootIndex: rootIndices[index],\n                lamports: account.compressedAccount.lamports.eq(bn(0))\n                    ? null\n                    : account.compressedAccount.lamports,\n                tlv: null,\n            });\n        },\n    );\n\n    if (inputCompressedTokenAccounts.length > 0 && outputStateTreeInfo) {\n        throw new Error(\n            'Cannot specify both input accounts and outputStateTreeInfo',\n        );\n    }\n\n    let treeInfo: TreeInfo;\n    if (inputCompressedTokenAccounts.length > 0) {\n        treeInfo = inputCompressedTokenAccounts[0].compressedAccount.treeInfo;\n    } else if (outputStateTreeInfo) {\n        treeInfo = outputStateTreeInfo;\n    } else {\n        throw new Error(\n            'Neither input accounts nor outputStateTreeInfo are available',\n        );\n    }\n\n    // Use next tree if available, otherwise fall back to current tree.\n    // `nextTreeInfo` always takes precedence.\n    const activeTreeInfo = treeInfo.nextTreeInfo || treeInfo;\n    let activeTreeOrQueue = activeTreeInfo.tree;\n\n    if (activeTreeInfo.treeType === TreeType.StateV2) {\n        if (featureFlags.isV2()) {\n            activeTreeOrQueue = activeTreeInfo.queue;\n        } else throw new Error('V2 trees are not supported yet');\n    }\n\n    // Pack output state trees\n    const paddedOutputStateMerkleTrees = padOutputStateMerkleTrees(\n        activeTreeOrQueue,\n        tokenTransferOutputs.length,\n    );\n    const packedOutputTokenData: PackedTokenTransferOutputData[] = [];\n    paddedOutputStateMerkleTrees.forEach((account, index) => {\n        const merkleTreeIndex = getIndexOrAdd(_remainingAccounts, account);\n        packedOutputTokenData.push({\n            owner: tokenTransferOutputs[index].owner,\n            amount: tokenTransferOutputs[index].amount,\n            lamports: tokenTransferOutputs[index].lamports?.eq(bn(0))\n                ? null\n                : tokenTransferOutputs[index].lamports,\n            merkleTreeIndex,\n            tlv: null,\n        });\n    });\n    // to meta\n    const remainingAccountMetas = _remainingAccounts.map(\n        (account): AccountMeta => ({\n            pubkey: account,\n            isWritable: true,\n            isSigner: false,\n        }),\n    );\n\n    return {\n        inputTokenDataWithContext: packedInputTokenData,\n        remainingAccountMetas,\n        packedOutputTokenData,\n    };\n}\n","import { ParsedTokenAccount } from '@lightprotocol/stateless.js';\nimport { PublicKey } from '@solana/web3.js';\n\n/**\n * Check if all input accounts belong to the same mint.\n *\n * @param compressedTokenAccounts   The compressed token accounts\n * @param mint                      The mint of the token pool\n * @returns True if all input accounts belong to the same mint\n */\nexport function checkMint(\n    compressedTokenAccounts: ParsedTokenAccount[],\n    mint: PublicKey,\n): boolean {\n    if (\n        !compressedTokenAccounts.every(account =>\n            account.parsed.mint.equals(mint),\n        )\n    ) {\n        throw new Error(`All input accounts must belong to the same mint`);\n    }\n\n    return true;\n}\n","import {\n    struct,\n    option,\n    vec,\n    bool,\n    u64,\n    u8,\n    publicKey,\n    array,\n    u32,\n    u16,\n    vecU8,\n} from '@coral-xyz/borsh';\nimport { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { CompressedTokenProgram } from './program';\nimport {\n    BatchCompressInstructionData,\n    CompressedTokenInstructionDataApprove,\n    CompressedTokenInstructionDataRevoke,\n    CompressedTokenInstructionDataTransfer,\n    CompressSplTokenAccountInstructionData,\n    MintToInstructionData,\n} from './types';\nimport {\n    APPROVE_DISCRIMINATOR,\n    BATCH_COMPRESS_DISCRIMINATOR,\n    COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR,\n    MINT_TO_DISCRIMINATOR,\n    REVOKE_DISCRIMINATOR,\n    TRANSFER_DISCRIMINATOR,\n} from './constants';\nimport { Buffer } from 'buffer';\nimport { ValidityProof } from '@lightprotocol/stateless.js';\n\nconst CompressedProofLayout = struct([\n    array(u8(), 32, 'a'),\n    array(u8(), 64, 'b'),\n    array(u8(), 32, 'c'),\n]);\n\nconst PackedTokenTransferOutputDataLayout = struct([\n    publicKey('owner'),\n    u64('amount'),\n    option(u64(), 'lamports'),\n    u8('merkleTreeIndex'),\n    option(vecU8(), 'tlv'),\n]);\n\nconst InputTokenDataWithContextLayout = struct([\n    u64('amount'),\n    option(u8(), 'delegateIndex'),\n    struct(\n        [\n            u8('merkleTreePubkeyIndex'),\n            u8('queuePubkeyIndex'),\n            u32('leafIndex'),\n            bool('proveByIndex'),\n        ],\n        'merkleContext',\n    ),\n    u16('rootIndex'),\n    option(u64(), 'lamports'),\n    option(vecU8(), 'tlv'),\n]);\n\nexport const DelegatedTransferLayout = struct([\n    publicKey('owner'),\n    option(u8(), 'delegateChangeAccountIndex'),\n]);\n\nexport const CpiContextLayout = struct([\n    bool('setContext'),\n    bool('firstSetContext'),\n    u8('cpiContextAccountIndex'),\n]);\n\nexport const CompressedTokenInstructionDataTransferLayout = struct([\n    option(CompressedProofLayout, 'proof'),\n    publicKey('mint'),\n    option(DelegatedTransferLayout, 'delegatedTransfer'),\n    vec(InputTokenDataWithContextLayout, 'inputTokenDataWithContext'),\n    vec(PackedTokenTransferOutputDataLayout, 'outputCompressedAccounts'),\n    bool('isCompress'),\n    option(u64(), 'compressOrDecompressAmount'),\n    option(CpiContextLayout, 'cpiContext'),\n    option(u8(), 'lamportsChangeAccountMerkleTreeIndex'),\n]);\n\nexport const mintToLayout = struct([\n    vec(publicKey(), 'recipients'),\n    vec(u64(), 'amounts'),\n    option(u64(), 'lamports'),\n]);\n\nexport const batchCompressLayout = struct([\n    vec(publicKey(), 'pubkeys'),\n    option(vec(u64(), 'amounts'), 'amounts'),\n    option(u64(), 'lamports'),\n    option(u64(), 'amount'),\n    u8('index'),\n    u8('bump'),\n]);\n\nexport const compressSplTokenAccountInstructionDataLayout = struct([\n    publicKey('owner'),\n    option(u64(), 'remainingAmount'),\n    option(CpiContextLayout, 'cpiContext'),\n]);\n\nexport function encodeMintToInstructionData(\n    data: MintToInstructionData,\n): Buffer {\n    const buffer = Buffer.alloc(1000);\n    const len = mintToLayout.encode(\n        {\n            recipients: data.recipients,\n            amounts: data.amounts,\n            lamports: data.lamports,\n        },\n        buffer,\n    );\n\n    return Buffer.concat([\n        new Uint8Array(MINT_TO_DISCRIMINATOR),\n        new Uint8Array(buffer.subarray(0, len)),\n    ]);\n}\n\nexport function decodeMintToInstructionData(\n    buffer: Buffer,\n): MintToInstructionData {\n    return mintToLayout.decode(\n        buffer.subarray(MINT_TO_DISCRIMINATOR.length),\n    ) as MintToInstructionData;\n}\n\nexport function encodeBatchCompressInstructionData(\n    data: BatchCompressInstructionData,\n): Buffer {\n    const buffer = Buffer.alloc(1000);\n    const len = batchCompressLayout.encode(data, buffer);\n\n    const lengthBuffer = Buffer.alloc(4);\n    lengthBuffer.writeUInt32LE(len, 0);\n\n    const dataBuffer = buffer.subarray(0, len);\n    return Buffer.concat([\n        new Uint8Array(BATCH_COMPRESS_DISCRIMINATOR),\n        new Uint8Array(lengthBuffer),\n        new Uint8Array(dataBuffer),\n    ]);\n}\n\nexport function decodeBatchCompressInstructionData(\n    buffer: Buffer,\n): BatchCompressInstructionData {\n    return batchCompressLayout.decode(\n        buffer.subarray(BATCH_COMPRESS_DISCRIMINATOR.length + 4),\n    ) as BatchCompressInstructionData;\n}\n\nexport function encodeCompressSplTokenAccountInstructionData(\n    data: CompressSplTokenAccountInstructionData,\n): Buffer {\n    const buffer = Buffer.alloc(1000);\n    const len = compressSplTokenAccountInstructionDataLayout.encode(\n        {\n            owner: data.owner,\n            remainingAmount: data.remainingAmount,\n            cpiContext: data.cpiContext,\n        },\n        buffer,\n    );\n\n    return Buffer.concat([\n        new Uint8Array(COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR),\n        new Uint8Array(buffer.subarray(0, len)),\n    ]);\n}\n\nexport function decodeCompressSplTokenAccountInstructionData(\n    buffer: Buffer,\n): CompressSplTokenAccountInstructionData {\n    const data = compressSplTokenAccountInstructionDataLayout.decode(\n        buffer.subarray(COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR.length),\n    ) as CompressSplTokenAccountInstructionData;\n    return {\n        owner: data.owner,\n        remainingAmount: data.remainingAmount,\n        cpiContext: data.cpiContext,\n    };\n}\nexport function encodeTransferInstructionData(\n    data: CompressedTokenInstructionDataTransfer,\n): Buffer {\n    const buffer = Buffer.alloc(1000);\n\n    const len = CompressedTokenInstructionDataTransferLayout.encode(\n        data,\n        buffer,\n    );\n\n    const lengthBuffer = Buffer.alloc(4);\n    lengthBuffer.writeUInt32LE(len, 0);\n\n    const dataBuffer = buffer.subarray(0, len);\n\n    return Buffer.concat([\n        new Uint8Array(TRANSFER_DISCRIMINATOR),\n        new Uint8Array(lengthBuffer),\n        new Uint8Array(dataBuffer),\n    ]);\n}\n\nexport function decodeTransferInstructionData(\n    buffer: Buffer,\n): CompressedTokenInstructionDataTransfer {\n    return CompressedTokenInstructionDataTransferLayout.decode(\n        buffer.slice(TRANSFER_DISCRIMINATOR.length + 4),\n    ) as CompressedTokenInstructionDataTransfer;\n}\n\ninterface BaseAccountsLayoutParams {\n    feePayer: PublicKey;\n    authority: PublicKey;\n    cpiAuthorityPda: PublicKey;\n    lightSystemProgram: PublicKey;\n    registeredProgramPda: PublicKey;\n    noopProgram: PublicKey;\n    accountCompressionAuthority: PublicKey;\n    accountCompressionProgram: PublicKey;\n    selfProgram: PublicKey;\n    systemProgram: PublicKey;\n}\nexport type createTokenPoolAccountsLayoutParams = {\n    feePayer: PublicKey;\n    tokenPoolPda: PublicKey;\n    systemProgram: PublicKey;\n    mint: PublicKey;\n    tokenProgram: PublicKey;\n    cpiAuthorityPda: PublicKey;\n};\n\nexport type addTokenPoolAccountsLayoutParams =\n    createTokenPoolAccountsLayoutParams & {\n        existingTokenPoolPda: PublicKey;\n    };\n\nexport type mintToAccountsLayoutParams = BaseAccountsLayoutParams & {\n    mint: PublicKey;\n    tokenPoolPda: PublicKey;\n    tokenProgram: PublicKey;\n    merkleTree: PublicKey;\n    solPoolPda: PublicKey | null;\n};\nexport type transferAccountsLayoutParams = BaseAccountsLayoutParams & {\n    tokenPoolPda?: PublicKey;\n    compressOrDecompressTokenAccount?: PublicKey;\n    tokenProgram?: PublicKey;\n};\nexport type approveAccountsLayoutParams = BaseAccountsLayoutParams;\nexport type revokeAccountsLayoutParams = approveAccountsLayoutParams;\nexport type freezeAccountsLayoutParams = BaseAccountsLayoutParams & {\n    mint: PublicKey;\n};\nexport type thawAccountsLayoutParams = freezeAccountsLayoutParams;\n\nexport const createTokenPoolAccountsLayout = (\n    accounts: createTokenPoolAccountsLayoutParams,\n): AccountMeta[] => {\n    const {\n        feePayer,\n        tokenPoolPda,\n        systemProgram,\n        mint,\n        tokenProgram,\n        cpiAuthorityPda,\n    } = accounts;\n    return [\n        { pubkey: feePayer, isSigner: true, isWritable: true },\n        { pubkey: tokenPoolPda, isSigner: false, isWritable: true },\n        { pubkey: systemProgram, isSigner: false, isWritable: false },\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: tokenProgram, isSigner: false, isWritable: false },\n        { pubkey: cpiAuthorityPda, isSigner: false, isWritable: false },\n    ];\n};\n\nexport const addTokenPoolAccountsLayout = (\n    accounts: addTokenPoolAccountsLayoutParams,\n): AccountMeta[] => {\n    const {\n        feePayer,\n        tokenPoolPda,\n        systemProgram,\n        mint,\n        tokenProgram,\n        cpiAuthorityPda,\n        existingTokenPoolPda,\n    } = accounts;\n    return [\n        { pubkey: feePayer, isSigner: true, isWritable: true },\n        { pubkey: tokenPoolPda, isSigner: false, isWritable: true },\n        { pubkey: existingTokenPoolPda, isSigner: false, isWritable: false },\n        { pubkey: systemProgram, isSigner: false, isWritable: false },\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: tokenProgram, isSigner: false, isWritable: false },\n        { pubkey: cpiAuthorityPda, isSigner: false, isWritable: false },\n    ];\n};\n\nexport const mintToAccountsLayout = (\n    accounts: mintToAccountsLayoutParams,\n): AccountMeta[] => {\n    const defaultPubkey = CompressedTokenProgram.programId;\n    const {\n        feePayer,\n        authority,\n        cpiAuthorityPda,\n        mint,\n        tokenPoolPda,\n        tokenProgram,\n        lightSystemProgram,\n        registeredProgramPda,\n        noopProgram,\n        accountCompressionAuthority,\n        accountCompressionProgram,\n        merkleTree,\n        selfProgram,\n        systemProgram,\n        solPoolPda,\n    } = accounts;\n\n    const accountsList: AccountMeta[] = [\n        { pubkey: feePayer, isSigner: true, isWritable: true },\n        { pubkey: authority, isSigner: true, isWritable: false },\n        { pubkey: cpiAuthorityPda, isSigner: false, isWritable: false },\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: tokenPoolPda, isSigner: false, isWritable: true },\n        { pubkey: tokenProgram, isSigner: false, isWritable: false },\n        { pubkey: lightSystemProgram, isSigner: false, isWritable: false },\n        { pubkey: registeredProgramPda, isSigner: false, isWritable: false },\n        { pubkey: noopProgram, isSigner: false, isWritable: false },\n        {\n            pubkey: accountCompressionAuthority,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: accountCompressionProgram,\n            isSigner: false,\n            isWritable: false,\n        },\n        { pubkey: merkleTree, isSigner: false, isWritable: true },\n        { pubkey: selfProgram, isSigner: false, isWritable: false },\n        { pubkey: systemProgram, isSigner: false, isWritable: false },\n        {\n            pubkey: solPoolPda ?? defaultPubkey,\n            isSigner: false,\n            isWritable: true,\n        },\n    ];\n\n    return accountsList;\n};\n\nexport const transferAccountsLayout = (\n    accounts: transferAccountsLayoutParams,\n): AccountMeta[] => {\n    const defaultPubkey = CompressedTokenProgram.programId;\n    const {\n        feePayer,\n        authority,\n        cpiAuthorityPda,\n        lightSystemProgram,\n        registeredProgramPda,\n        noopProgram,\n        accountCompressionAuthority,\n        accountCompressionProgram,\n        selfProgram,\n        tokenPoolPda,\n        compressOrDecompressTokenAccount,\n        tokenProgram,\n        systemProgram,\n    } = accounts;\n\n    const accountsList: AccountMeta[] = [\n        { pubkey: feePayer, isSigner: true, isWritable: true },\n        { pubkey: authority, isSigner: true, isWritable: false },\n        { pubkey: cpiAuthorityPda, isSigner: false, isWritable: false },\n        { pubkey: lightSystemProgram, isSigner: false, isWritable: false },\n        { pubkey: registeredProgramPda, isSigner: false, isWritable: false },\n        { pubkey: noopProgram, isSigner: false, isWritable: false },\n        {\n            pubkey: accountCompressionAuthority,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: accountCompressionProgram,\n            isSigner: false,\n            isWritable: false,\n        },\n        { pubkey: selfProgram, isSigner: false, isWritable: false },\n        {\n            pubkey: tokenPoolPda ?? defaultPubkey,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: compressOrDecompressTokenAccount ?? defaultPubkey,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: tokenProgram ?? defaultPubkey,\n            isSigner: false,\n            isWritable: false,\n        },\n        { pubkey: systemProgram, isSigner: false, isWritable: false },\n    ];\n\n    return accountsList;\n};\n\nexport const approveAccountsLayout = (\n    accounts: approveAccountsLayoutParams,\n): AccountMeta[] => {\n    const {\n        feePayer,\n        authority,\n        cpiAuthorityPda,\n        lightSystemProgram,\n        registeredProgramPda,\n        noopProgram,\n        accountCompressionAuthority,\n        accountCompressionProgram,\n        selfProgram,\n        systemProgram,\n    } = accounts;\n\n    return [\n        { pubkey: feePayer, isSigner: true, isWritable: true },\n        { pubkey: authority, isSigner: true, isWritable: false },\n        { pubkey: cpiAuthorityPda, isSigner: false, isWritable: false },\n        { pubkey: lightSystemProgram, isSigner: false, isWritable: false },\n        { pubkey: registeredProgramPda, isSigner: false, isWritable: false },\n        { pubkey: noopProgram, isSigner: false, isWritable: false },\n        {\n            pubkey: accountCompressionAuthority,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: accountCompressionProgram,\n            isSigner: false,\n            isWritable: false,\n        },\n        { pubkey: selfProgram, isSigner: false, isWritable: false },\n        { pubkey: systemProgram, isSigner: false, isWritable: false },\n    ];\n};\n\nexport const revokeAccountsLayout = approveAccountsLayout;\n\nexport const freezeAccountsLayout = (\n    accounts: freezeAccountsLayoutParams,\n): AccountMeta[] => {\n    const {\n        feePayer,\n        authority,\n        cpiAuthorityPda,\n        lightSystemProgram,\n        registeredProgramPda,\n        noopProgram,\n        accountCompressionAuthority,\n        accountCompressionProgram,\n        selfProgram,\n        systemProgram,\n        mint,\n    } = accounts;\n\n    return [\n        { pubkey: feePayer, isSigner: true, isWritable: true },\n        { pubkey: authority, isSigner: true, isWritable: false },\n        { pubkey: cpiAuthorityPda, isSigner: false, isWritable: false },\n        { pubkey: lightSystemProgram, isSigner: false, isWritable: false },\n        { pubkey: registeredProgramPda, isSigner: false, isWritable: false },\n        { pubkey: noopProgram, isSigner: false, isWritable: false },\n        {\n            pubkey: accountCompressionAuthority,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: accountCompressionProgram,\n            isSigner: false,\n            isWritable: false,\n        },\n        { pubkey: selfProgram, isSigner: false, isWritable: false },\n        { pubkey: systemProgram, isSigner: false, isWritable: false },\n        { pubkey: mint, isSigner: false, isWritable: false },\n    ];\n};\n\nexport const thawAccountsLayout = freezeAccountsLayout;\n\nexport const CompressedTokenInstructionDataApproveLayout = struct([\n    struct(\n        [array(u8(), 32, 'a'), array(u8(), 64, 'b'), array(u8(), 32, 'c')],\n        'proof',\n    ),\n    publicKey('mint'),\n    vec(InputTokenDataWithContextLayout, 'inputTokenDataWithContext'),\n    option(CpiContextLayout, 'cpiContext'),\n    publicKey('delegate'),\n    u64('delegatedAmount'),\n    u8('delegateMerkleTreeIndex'),\n    u8('changeAccountMerkleTreeIndex'),\n    option(u64(), 'delegateLamports'),\n]);\n\nexport const CompressedTokenInstructionDataRevokeLayout = struct([\n    struct(\n        [array(u8(), 32, 'a'), array(u8(), 64, 'b'), array(u8(), 32, 'c')],\n        'proof',\n    ),\n    publicKey('mint'),\n    vec(InputTokenDataWithContextLayout, 'inputTokenDataWithContext'),\n    option(CpiContextLayout, 'cpiContext'),\n    u8('outputAccountMerkleTreeIndex'),\n]);\n\n// Approve and revoke instuctions do not support optional proof yet.\nconst emptyProof: ValidityProof = {\n    a: new Array(32).fill(0),\n    b: new Array(64).fill(0),\n    c: new Array(32).fill(0),\n};\n\nfunction isEmptyProof(proof: ValidityProof): boolean {\n    return (\n        proof.a.every(a => a === 0) &&\n        proof.b.every(b => b === 0) &&\n        proof.c.every(c => c === 0)\n    );\n}\n\nexport function encodeApproveInstructionData(\n    data: CompressedTokenInstructionDataApprove,\n): Buffer {\n    const buffer = Buffer.alloc(1000);\n\n    const proofOption = data.proof ?? emptyProof;\n\n    const len = CompressedTokenInstructionDataApproveLayout.encode(\n        {\n            ...data,\n            proof: proofOption,\n        },\n        buffer,\n    );\n\n    const lengthBuffer = Buffer.alloc(4);\n    lengthBuffer.writeUInt32LE(len, 0);\n\n    const dataBuffer = buffer.subarray(0, len);\n\n    return Buffer.concat([\n        new Uint8Array(APPROVE_DISCRIMINATOR),\n        new Uint8Array(lengthBuffer),\n        new Uint8Array(dataBuffer),\n    ]);\n}\n\nexport function decodeApproveInstructionData(\n    buffer: Buffer,\n): CompressedTokenInstructionDataApprove {\n    const data = CompressedTokenInstructionDataApproveLayout.decode(\n        buffer.subarray(APPROVE_DISCRIMINATOR.length),\n    ) as CompressedTokenInstructionDataApprove;\n    return {\n        ...data,\n        proof: isEmptyProof(data.proof!) ? null : data.proof!,\n    };\n}\n\nexport function encodeRevokeInstructionData(\n    data: CompressedTokenInstructionDataRevoke,\n): Buffer {\n    const buffer = Buffer.alloc(1000);\n\n    const proofOption = data.proof ?? emptyProof;\n\n    const len = CompressedTokenInstructionDataRevokeLayout.encode(\n        {\n            ...data,\n            proof: proofOption,\n        },\n        buffer,\n    );\n\n    const lengthBuffer = Buffer.alloc(4);\n    lengthBuffer.writeUInt32LE(len, 0);\n\n    const dataBuffer = buffer.subarray(0, len);\n\n    return Buffer.concat([\n        new Uint8Array(REVOKE_DISCRIMINATOR),\n        new Uint8Array(lengthBuffer),\n        new Uint8Array(dataBuffer),\n    ]);\n}\n\nexport function decodeRevokeInstructionData(\n    buffer: Buffer,\n): CompressedTokenInstructionDataRevoke {\n    const data = CompressedTokenInstructionDataRevokeLayout.decode(\n        buffer.subarray(REVOKE_DISCRIMINATOR.length),\n    ) as CompressedTokenInstructionDataRevoke;\n    return {\n        ...data,\n        proof: isEmptyProof(data.proof!) ? null : data.proof!,\n    };\n}\n","import {\n    PublicKey,\n    TransactionInstruction,\n    SystemProgram,\n    Connection,\n    AddressLookupTableProgram,\n    AccountMeta,\n    ComputeBudgetProgram,\n} from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { Buffer } from 'buffer';\nimport {\n    ValidityProof,\n    LightSystemProgram,\n    ParsedTokenAccount,\n    bn,\n    defaultStaticAccountsStruct,\n    sumUpLamports,\n    toArray,\n    validateSameOwner,\n    validateSufficientBalance,\n    defaultTestStateTreeAccounts,\n    TreeInfo,\n    CompressedProof,\n    featureFlags,\n    TreeType,\n} from '@lightprotocol/stateless.js';\nimport {\n    MINT_SIZE,\n    TOKEN_2022_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    createInitializeMint2Instruction,\n    createMintToInstruction,\n} from '@solana/spl-token';\nimport {\n    CPI_AUTHORITY_SEED,\n    POOL_SEED,\n    CREATE_TOKEN_POOL_DISCRIMINATOR,\n    ADD_TOKEN_POOL_DISCRIMINATOR,\n} from './constants';\nimport { checkMint, packCompressedTokenAccounts } from './utils';\nimport {\n    encodeTransferInstructionData,\n    encodeCompressSplTokenAccountInstructionData,\n    encodeMintToInstructionData,\n    createTokenPoolAccountsLayout,\n    mintToAccountsLayout,\n    transferAccountsLayout,\n    approveAccountsLayout,\n    revokeAccountsLayout,\n    encodeApproveInstructionData,\n    encodeRevokeInstructionData,\n    addTokenPoolAccountsLayout,\n    encodeBatchCompressInstructionData,\n} from './layout';\nimport {\n    BatchCompressInstructionData,\n    CompressedTokenInstructionDataApprove,\n    CompressedTokenInstructionDataRevoke,\n    CompressedTokenInstructionDataTransfer,\n    DelegatedTransfer,\n    TokenTransferOutputData,\n} from './types';\nimport {\n    checkTokenPoolInfo,\n    TokenPoolInfo,\n} from './utils/get-token-pool-infos';\n\nexport type CompressParams = {\n    /**\n     * Fee payer\n     */\n    payer: PublicKey;\n    /**\n     * Owner of uncompressed token account\n     */\n    owner: PublicKey;\n    /**\n     * Source SPL Token account address\n     */\n    source: PublicKey;\n    /**\n     * Recipient address(es)\n     */\n    toAddress: PublicKey | PublicKey[];\n    /**\n     * Token amount(s) to compress\n     */\n    amount: number | BN | number[] | BN[];\n    /**\n     * SPL Token mint address\n     */\n    mint: PublicKey;\n    /**\n     * State tree to write to\n     */\n    outputStateTreeInfo: TreeInfo;\n    /**\n     * Token pool\n     */\n    tokenPoolInfo: TokenPoolInfo;\n};\n\nexport type CompressSplTokenAccountParams = {\n    /**\n     * Fee payer\n     */\n    feePayer: PublicKey;\n    /**\n     * SPL Token account owner\n     */\n    authority: PublicKey;\n    /**\n     * SPL Token account to compress\n     */\n    tokenAccount: PublicKey;\n    /**\n     * SPL Token mint address\n     */\n    mint: PublicKey;\n    /**\n     * Amount to leave in token account\n     */\n    remainingAmount?: BN;\n    /**\n     * State tree to write to\n     */\n    outputStateTreeInfo: TreeInfo;\n    /**\n     * Token pool\n     */\n    tokenPoolInfo: TokenPoolInfo;\n};\n\nexport type DecompressParams = {\n    /**\n     * Fee payer\n     */\n    payer: PublicKey;\n    /**\n     * Source compressed token accounts\n     */\n    inputCompressedTokenAccounts: ParsedTokenAccount[];\n    /**\n     * Destination uncompressed token account\n     */\n    toAddress: PublicKey;\n    /**\n     * Token amount to decompress\n     */\n    amount: number | BN;\n    /**\n     * Validity proof for input state\n     */\n    recentValidityProof: ValidityProof | CompressedProof | null;\n    /**\n     * Recent state root indices\n     */\n    recentInputStateRootIndices: number[];\n    /**\n     * Token pool(s)\n     */\n    tokenPoolInfos: TokenPoolInfo | TokenPoolInfo[];\n};\n\nexport type TransferParams = {\n    /**\n     * Fee payer\n     */\n    payer: PublicKey;\n    /**\n     * Source compressed token accounts\n     */\n    inputCompressedTokenAccounts: ParsedTokenAccount[];\n    /**\n     * Recipient address\n     */\n    toAddress: PublicKey;\n    /**\n     * Token amount to transfer\n     */\n    amount: BN | number;\n    /**\n     * Validity proof for input state\n     */\n    recentValidityProof: ValidityProof | CompressedProof | null;\n    /**\n     * Recent state root indices\n     */\n    recentInputStateRootIndices: number[];\n};\n\nexport type ApproveParams = {\n    /**\n     * Fee payer\n     */\n    payer: PublicKey;\n    /**\n     * Source compressed token accounts\n     */\n    inputCompressedTokenAccounts: ParsedTokenAccount[];\n    /**\n     * Recipient address\n     */\n    toAddress: PublicKey;\n    /**\n     * Token amount to approve\n     */\n    amount: BN | number;\n    /**\n     * Validity proof for input state\n     */\n    recentValidityProof: ValidityProof | CompressedProof | null;\n    /**\n     * Recent state root indices\n     */\n    recentInputStateRootIndices: number[];\n};\n\nexport type RevokeParams = {\n    /**\n     * Fee payer\n     */\n    payer: PublicKey;\n    /**\n     * Input compressed token accounts\n     */\n    inputCompressedTokenAccounts: ParsedTokenAccount[];\n    /**\n     * Validity proof for input state\n     */\n    recentValidityProof: ValidityProof | CompressedProof | null;\n    /**\n     * Recent state root indices\n     */\n    recentInputStateRootIndices: number[];\n};\n\n/**\n * Create Mint account for compressed Tokens\n */\nexport type CreateMintParams = {\n    /**\n     * Fee payer\n     */\n    feePayer: PublicKey;\n    /**\n     * SPL Mint address\n     */\n    mint: PublicKey;\n    /**\n     * Mint authority\n     */\n    authority: PublicKey;\n    /**\n     * Optional: freeze authority\n     */\n    freezeAuthority: PublicKey | null;\n    /**\n     * Mint decimals\n     */\n    decimals: number;\n    /**\n     * lamport amount for mint account rent exemption\n     */\n    rentExemptBalance: number;\n    /**\n     * Optional: The token program ID. Default: SPL Token Program ID\n     */\n    tokenProgramId?: PublicKey;\n    /**\n     * Optional: Mint size to use, defaults to MINT_SIZE\n     */\n    mintSize?: number;\n};\n\n/**\n * Parameters for merging compressed token accounts\n */\nexport type MergeTokenAccountsParams = {\n    /**\n     * Fee payer\n     */\n    payer: PublicKey;\n    /**\n     * Owner of the compressed token accounts to be merged\n     */\n    owner: PublicKey;\n    /**\n     * SPL Token mint address\n     */\n    mint: PublicKey;\n    /**\n     * Array of compressed token accounts to merge\n     */\n    inputCompressedTokenAccounts: ParsedTokenAccount[];\n    /**\n     * Validity proof for state inclusion\n     */\n    recentValidityProof: ValidityProof | CompressedProof | null;\n    /**\n     * State root indices of the input state\n     */\n    recentInputStateRootIndices: number[];\n};\n\n/**\n * Create compressed token accounts\n */\nexport type MintToParams = {\n    /**\n     * Fee payer\n     */\n    feePayer: PublicKey;\n    /**\n     * Token mint address\n     */\n    mint: PublicKey;\n    /**\n     * Mint authority\n     */\n    authority: PublicKey;\n    /**\n     * Recipient address(es)\n     */\n    toPubkey: PublicKey[] | PublicKey;\n    /**\n     * Token amount(s) to mint\n     */\n    amount: BN | BN[] | number | number[];\n    /**\n     * State tree for minted tokens\n     */\n    outputStateTreeInfo: TreeInfo;\n    /**\n     * Token pool\n     */\n    tokenPoolInfo: TokenPoolInfo;\n};\n\n/**\n * Register an existing SPL mint account to the compressed token program\n * Creates an omnibus account for the mint\n */\nexport type CreateTokenPoolParams = {\n    /**\n     * Fee payer\n     */\n    feePayer: PublicKey;\n    /**\n     * SPL Mint address\n     */\n    mint: PublicKey;\n    /**\n     * Optional: The token program ID. Default: SPL Token Program ID\n     */\n    tokenProgramId?: PublicKey;\n};\n\nexport type AddTokenPoolParams = {\n    /**\n     * Fee payer\n     */\n    feePayer: PublicKey;\n    /**\n     * Token mint address\n     */\n    mint: PublicKey;\n    /**\n     * Token pool index\n     */\n    poolIndex: number;\n    /**\n     * Optional: Token program ID. Default: SPL Token Program ID\n     */\n    tokenProgramId?: PublicKey;\n};\n\n/**\n * Mint from existing SPL mint to compressed token accounts\n */\nexport type ApproveAndMintToParams = {\n    /**\n     * Fee payer\n     */\n    feePayer: PublicKey;\n    /**\n     * SPL Mint address\n     */\n    mint: PublicKey;\n    /**\n     * Mint authority\n     */\n    authority: PublicKey;\n    /**\n     * Mint authority (associated) token account\n     */\n    authorityTokenAccount: PublicKey;\n    /**\n     * Recipient address\n     */\n    toPubkey: PublicKey;\n    /**\n     * Token amount to mint\n     */\n    amount: BN | number;\n    /**\n     * State tree to write to\n     */\n    outputStateTreeInfo: TreeInfo;\n    /**\n     * Token pool\n     */\n    tokenPoolInfo: TokenPoolInfo;\n};\n\nexport type CreateTokenProgramLookupTableParams = {\n    /**\n     * Fee payer\n     */\n    payer: PublicKey;\n    /**\n     * Authority of the transaction\n     */\n    authority: PublicKey;\n    /**\n     * Optional Mint addresses to store in the lookup table\n     */\n    mints?: PublicKey[];\n    /**\n     * Recently finalized Solana slot\n     */\n    recentSlot: number;\n    /**\n     * Optional additional addresses to store in the lookup table\n     */\n    remainingAccounts?: PublicKey[];\n};\n\n/**\n * Sum up the token amounts of the compressed token accounts\n */\nexport const sumUpTokenAmount = (accounts: ParsedTokenAccount[]): BN => {\n    return accounts.reduce(\n        (acc, account: ParsedTokenAccount) => acc.add(account.parsed.amount),\n        bn(0),\n    );\n};\n\n/**\n * Validate that all the compressed token accounts are owned by the same owner.\n */\nexport const validateSameTokenOwner = (accounts: ParsedTokenAccount[]) => {\n    const owner = accounts[0].parsed.owner;\n    accounts.forEach(acc => {\n        if (!acc.parsed.owner.equals(owner)) {\n            throw new Error('Token accounts must be owned by the same owner');\n        }\n    });\n};\n\n/**\n * Parse compressed token accounts to get the mint, current owner and delegate.\n */\nexport const parseTokenData = (\n    compressedTokenAccounts: ParsedTokenAccount[],\n) => {\n    const mint = compressedTokenAccounts[0].parsed.mint;\n    const currentOwner = compressedTokenAccounts[0].parsed.owner;\n    const delegate = compressedTokenAccounts[0].parsed.delegate;\n\n    return { mint, currentOwner, delegate };\n};\n\nexport const parseMaybeDelegatedTransfer = (\n    inputs: ParsedTokenAccount[],\n    outputs: TokenTransferOutputData[],\n): { delegatedTransfer: DelegatedTransfer | null; authority: PublicKey } => {\n    if (inputs.length < 1)\n        throw new Error('Must supply at least one input token account.');\n\n    const owner = inputs[0].parsed.owner;\n\n    const delegatedAccountsIndex = inputs.findIndex(a => a.parsed.delegate);\n\n    /// Fast path: no delegated account used\n    if (delegatedAccountsIndex === -1)\n        return { delegatedTransfer: null, authority: owner };\n\n    const delegate = inputs[delegatedAccountsIndex].parsed.delegate;\n    const delegateChangeAccountIndex = outputs.length <= 1 ? null : 0;\n\n    return {\n        delegatedTransfer: {\n            owner,\n            delegateChangeAccountIndex,\n        },\n        authority: delegate!,\n    };\n};\n\n/**\n * Create the output state for a transfer transaction.\n * @param inputCompressedTokenAccounts  Input state\n * @param toAddress                     Recipient address\n * @param amount                        Amount of tokens to transfer\n * @returns                             Output token data for the transfer\n *                                      instruction\n */\nexport function createTransferOutputState(\n    inputCompressedTokenAccounts: ParsedTokenAccount[],\n    toAddress: PublicKey,\n    amount: number | BN,\n): TokenTransferOutputData[] {\n    amount = bn(amount);\n    const inputAmount = sumUpTokenAmount(inputCompressedTokenAccounts);\n    const inputLamports = sumUpLamports(\n        inputCompressedTokenAccounts.map(acc => acc.compressedAccount),\n    );\n\n    const changeAmount = inputAmount.sub(amount);\n\n    validateSufficientBalance(changeAmount);\n\n    if (changeAmount.eq(bn(0)) && inputLamports.eq(bn(0))) {\n        return [\n            {\n                owner: toAddress,\n                amount,\n                lamports: inputLamports,\n                tlv: null,\n            },\n        ];\n    }\n\n    /// validates token program\n    validateSameOwner(\n        inputCompressedTokenAccounts.map(acc => acc.compressedAccount),\n    );\n    validateSameTokenOwner(inputCompressedTokenAccounts);\n\n    const outputCompressedAccounts: TokenTransferOutputData[] = [\n        {\n            owner: inputCompressedTokenAccounts[0].parsed.owner,\n            amount: changeAmount,\n            lamports: inputLamports,\n            tlv: null,\n        },\n        {\n            owner: toAddress,\n            amount,\n            lamports: bn(0),\n            tlv: null,\n        },\n    ];\n    return outputCompressedAccounts;\n}\n\n/**\n * Create the output state for a compress transaction.\n * @param inputCompressedTokenAccounts  Input state\n * @param amount                        Amount of tokens to compress\n * @returns                             Output token data for the compress\n *                                      instruction\n */\nexport function createDecompressOutputState(\n    inputCompressedTokenAccounts: ParsedTokenAccount[],\n    amount: number | BN,\n): TokenTransferOutputData[] {\n    amount = bn(amount);\n    const inputLamports = sumUpLamports(\n        inputCompressedTokenAccounts.map(acc => acc.compressedAccount),\n    );\n    const inputAmount = sumUpTokenAmount(inputCompressedTokenAccounts);\n    const changeAmount = inputAmount.sub(amount);\n\n    validateSufficientBalance(changeAmount);\n\n    /// lamports gets decompressed\n    if (changeAmount.eq(bn(0)) && inputLamports.eq(bn(0))) {\n        return [];\n    }\n\n    validateSameOwner(\n        inputCompressedTokenAccounts.map(acc => acc.compressedAccount),\n    );\n    validateSameTokenOwner(inputCompressedTokenAccounts);\n\n    const tokenTransferOutputs: TokenTransferOutputData[] = [\n        {\n            owner: inputCompressedTokenAccounts[0].parsed.owner,\n            amount: changeAmount,\n            lamports: inputLamports,\n            tlv: null,\n        },\n    ];\n    return tokenTransferOutputs;\n}\n\nexport class CompressedTokenProgram {\n    /**\n     * @internal\n     */\n    constructor() {}\n\n    /**\n     * Public key that identifies the CompressedPda program\n     */\n    static programId: PublicKey = new PublicKey(\n        'cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m',\n    );\n\n    /**\n     * Set a custom programId via PublicKey or base58 encoded string.\n     * This method is not required for regular usage.\n     *\n     * Use this only if you know what you are doing.\n     */\n    static setProgramId(programId: PublicKey | string) {\n        this.programId =\n            typeof programId === 'string'\n                ? new PublicKey(programId)\n                : programId;\n    }\n\n    /**\n     * Derive the token pool pda.\n     * To derive the token pool pda with bump, use {@link deriveTokenPoolPdaWithIndex}.\n     *\n     * @param mint The mint of the token pool\n     *\n     * @returns The token pool pda\n     */\n    static deriveTokenPoolPda(mint: PublicKey): PublicKey {\n        const seeds = [POOL_SEED, mint.toBuffer()];\n        const [address, _] = PublicKey.findProgramAddressSync(\n            seeds,\n            this.programId,\n        );\n        return address;\n    }\n\n    /**\n     * Find the index and bump for a given token pool pda and mint.\n     *\n     * @param poolPda The token pool pda to find the index and bump for\n     * @param mint The mint of the token pool\n     *\n     * @returns The index and bump number.\n     */\n    static findTokenPoolIndexAndBump(\n        poolPda: PublicKey,\n        mint: PublicKey,\n    ): [number, number] {\n        for (let index = 0; index < 5; index++) {\n            const derivedPda =\n                CompressedTokenProgram.deriveTokenPoolPdaWithIndex(mint, index);\n            if (derivedPda[0].equals(poolPda)) {\n                return [index, derivedPda[1]];\n            }\n        }\n        throw new Error('Token pool not found');\n    }\n\n    /**\n     * Derive the token pool pda with index.\n     *\n     * @param mint The mint of the token pool\n     * @param index Index. starts at 0. The Protocol supports 4 indexes aka token pools\n     * per mint.\n     *\n     * @returns The token pool pda and bump.\n     */\n    static deriveTokenPoolPdaWithIndex(\n        mint: PublicKey,\n        index: number,\n    ): [PublicKey, number] {\n        let seeds: Buffer[] = [];\n        if (index === 0) {\n            seeds = [Buffer.from('pool'), mint.toBuffer(), Buffer.from([])]; // legacy, 1st\n        } else {\n            seeds = [\n                Buffer.from('pool'),\n                mint.toBuffer(),\n                Buffer.from([index]),\n            ];\n        }\n        const [address, bump] = PublicKey.findProgramAddressSync(\n            seeds,\n            this.programId,\n        );\n        return [address, bump];\n    }\n\n    /** @internal */\n    static get deriveCpiAuthorityPda(): PublicKey {\n        const [address, _] = PublicKey.findProgramAddressSync(\n            [CPI_AUTHORITY_SEED],\n            this.programId,\n        );\n        return address;\n    }\n\n    /**\n     * Construct createMint instruction for compressed tokens.\n     *\n     * @param feePayer              Fee payer.\n     * @param mint                  SPL Mint address.\n     * @param authority             Mint authority.\n     * @param freezeAuthority       Optional: freeze authority.\n     * @param decimals              Decimals.\n     * @param rentExemptBalance     Lamport amount for mint account rent exemption.\n     * @param tokenProgramId        Optional: Token program ID. Default: SPL Token Program ID\n     * @param mintSize              Optional: mint size. Default: MINT_SIZE\n     *\n     * @returns [createMintAccountInstruction, initializeMintInstruction,\n     * createTokenPoolInstruction]\n     *\n     * Note that `createTokenPoolInstruction` must be executed after\n     * `initializeMintInstruction`.\n     */\n    static async createMint({\n        feePayer,\n        mint,\n        authority,\n        freezeAuthority,\n        decimals,\n        rentExemptBalance,\n        tokenProgramId,\n        mintSize,\n    }: CreateMintParams): Promise<TransactionInstruction[]> {\n        const tokenProgram = tokenProgramId ?? TOKEN_PROGRAM_ID;\n\n        /// Create and initialize SPL Mint account\n        const createMintAccountInstruction = SystemProgram.createAccount({\n            fromPubkey: feePayer,\n            lamports: rentExemptBalance,\n            newAccountPubkey: mint,\n            programId: tokenProgram,\n            space: mintSize ?? MINT_SIZE,\n        });\n\n        const initializeMintInstruction = createInitializeMint2Instruction(\n            mint,\n            decimals,\n            authority,\n            freezeAuthority,\n            tokenProgram,\n        );\n\n        const createTokenPoolInstruction = await this.createTokenPool({\n            feePayer,\n            mint,\n            tokenProgramId: tokenProgram,\n        });\n\n        return [\n            createMintAccountInstruction,\n            initializeMintInstruction,\n            createTokenPoolInstruction,\n        ];\n    }\n\n    /**\n     * Enable compression for an existing SPL mint, creating an omnibus account.\n     * For new mints, use `CompressedTokenProgram.createMint`.\n     *\n     * @param feePayer              Fee payer.\n     * @param mint                  SPL Mint address.\n     * @param tokenProgramId        Optional: Token program ID. Default: SPL\n     *                              Token Program ID\n     *\n     * @returns The createTokenPool instruction\n     */\n    static async createTokenPool({\n        feePayer,\n        mint,\n        tokenProgramId,\n    }: CreateTokenPoolParams): Promise<TransactionInstruction> {\n        const tokenProgram = tokenProgramId ?? TOKEN_PROGRAM_ID;\n\n        const tokenPoolPda = this.deriveTokenPoolPdaWithIndex(mint, 0);\n\n        const keys = createTokenPoolAccountsLayout({\n            mint,\n            feePayer,\n            tokenPoolPda: tokenPoolPda[0],\n            tokenProgram,\n            cpiAuthorityPda: this.deriveCpiAuthorityPda,\n            systemProgram: SystemProgram.programId,\n        });\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data: CREATE_TOKEN_POOL_DISCRIMINATOR,\n        });\n    }\n\n    /**\n     * Add a token pool to an existing SPL mint.  For new mints, use\n     * {@link createTokenPool}.\n     *\n     * @param feePayer              Fee payer.\n     * @param mint                  SPL Mint address.\n     * @param poolIndex             Pool index.\n     * @param tokenProgramId        Optional: Token program ID. Default: SPL\n     *                              Token Program ID\n     *\n     * @returns The addTokenPool instruction\n     */\n    static async addTokenPool({\n        feePayer,\n        mint,\n        poolIndex,\n        tokenProgramId,\n    }: AddTokenPoolParams): Promise<TransactionInstruction> {\n        if (poolIndex <= 0) {\n            throw new Error(\n                'Pool index must be greater than 0. For 0, use CreateTokenPool instead.',\n            );\n        }\n        if (poolIndex > 3) {\n            throw new Error(\n                `Invalid poolIndex ${poolIndex}. Max 4 pools per mint.`,\n            );\n        }\n\n        const tokenProgram = tokenProgramId ?? TOKEN_PROGRAM_ID;\n\n        const existingTokenPoolPda = this.deriveTokenPoolPdaWithIndex(\n            mint,\n            poolIndex - 1,\n        );\n        const tokenPoolPda = this.deriveTokenPoolPdaWithIndex(mint, poolIndex);\n\n        const keys = addTokenPoolAccountsLayout({\n            mint,\n            feePayer,\n            tokenPoolPda: tokenPoolPda[0],\n            existingTokenPoolPda: existingTokenPoolPda[0],\n            tokenProgram,\n            cpiAuthorityPda: this.deriveCpiAuthorityPda,\n            systemProgram: SystemProgram.programId,\n        });\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data: Buffer.concat([\n                new Uint8Array(ADD_TOKEN_POOL_DISCRIMINATOR),\n                new Uint8Array(Buffer.from([poolIndex])),\n            ]),\n        });\n    }\n\n    /**\n     * Construct mintTo instruction for compressed tokens\n     *\n     * @param feePayer              Fee payer.\n     * @param mint                  SPL Mint address.\n     * @param authority             Mint authority.\n     * @param toPubkey              Recipient owner address.\n     * @param amount                Amount of tokens to mint.\n     * @param outputStateTreeInfo   State tree to write to.\n     * @param tokenPoolInfo         Token pool info.\n     *\n     * @returns The mintTo instruction\n     */\n    static async mintTo({\n        feePayer,\n        mint,\n        authority,\n        toPubkey,\n        amount,\n        outputStateTreeInfo,\n        tokenPoolInfo,\n    }: MintToParams): Promise<TransactionInstruction> {\n        const systemKeys = defaultStaticAccountsStruct();\n        const tokenProgram = tokenPoolInfo.tokenProgram;\n        checkTokenPoolInfo(tokenPoolInfo, mint);\n\n        const amounts = toArray<BN | number>(amount).map(amount => bn(amount));\n        const toPubkeys = toArray(toPubkey);\n\n        if (amounts.length !== toPubkeys.length) {\n            throw new Error(\n                'Amount and toPubkey arrays must have the same length',\n            );\n        }\n\n        const keys = mintToAccountsLayout({\n            mint,\n            feePayer,\n            authority,\n            cpiAuthorityPda: this.deriveCpiAuthorityPda,\n            tokenProgram,\n            tokenPoolPda: tokenPoolInfo.tokenPoolPda,\n            lightSystemProgram: LightSystemProgram.programId,\n            registeredProgramPda: systemKeys.registeredProgramPda,\n            noopProgram: systemKeys.noopProgram,\n            accountCompressionAuthority: systemKeys.accountCompressionAuthority,\n            accountCompressionProgram: systemKeys.accountCompressionProgram,\n            merkleTree:\n                outputStateTreeInfo.treeType === TreeType.StateV2\n                    ? outputStateTreeInfo.queue\n                    : outputStateTreeInfo.tree,\n            selfProgram: this.programId,\n            systemProgram: SystemProgram.programId,\n            solPoolPda: null,\n        });\n\n        const data = encodeMintToInstructionData({\n            recipients: toPubkeys,\n            amounts,\n            lamports: null,\n        });\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Mint tokens from registered SPL mint account to a compressed account\n     *\n     * @param feePayer              Fee payer.\n     * @param mint                  SPL Mint address.\n     * @param authority             Mint authority.\n     * @param authorityTokenAccount The mint authority's associated token\n     *                              account (ATA).\n     * @param toPubkey              Recipient owner address.\n     * @param amount                Amount of tokens to mint.\n     * @param outputStateTreeInfo   State tree to write to.\n     * @param tokenPoolInfo         Token pool info.\n     *\n     * @returns The mintTo instruction\n     */\n    static async approveAndMintTo({\n        feePayer,\n        mint,\n        authority,\n        authorityTokenAccount,\n        toPubkey,\n        amount,\n        outputStateTreeInfo,\n        tokenPoolInfo,\n    }: ApproveAndMintToParams) {\n        const amountBigInt: bigint = BigInt(amount.toString());\n\n        /// 1. Mint to existing ATA of mintAuthority.\n        const splMintToInstruction = createMintToInstruction(\n            mint,\n            authorityTokenAccount,\n            authority,\n            amountBigInt,\n            [],\n            tokenPoolInfo.tokenProgram,\n        );\n\n        /// 2. Compress from mint authority ATA to recipient compressed account\n        const compressInstruction = await this.compress({\n            payer: feePayer,\n            owner: authority,\n            source: authorityTokenAccount,\n            toAddress: toPubkey,\n            mint,\n            amount,\n            outputStateTreeInfo,\n            tokenPoolInfo,\n        });\n\n        return [splMintToInstruction, compressInstruction];\n    }\n\n    /**\n     * Construct transfer instruction for compressed tokens\n     *\n     * @param payer                         Fee payer.\n     * @param inputCompressedTokenAccounts  Source compressed token accounts.\n     * @param toAddress                     Recipient owner address.\n     * @param amount                        Amount of tokens to transfer.\n     * @param recentValidityProof           Recent validity proof.\n     * @param recentInputStateRootIndices   Recent state root indices.\n     *\n     * @returns The transfer instruction\n     */\n    static async transfer({\n        payer,\n        inputCompressedTokenAccounts,\n        toAddress,\n        amount,\n        recentValidityProof,\n        recentInputStateRootIndices,\n    }: TransferParams): Promise<TransactionInstruction> {\n        const tokenTransferOutputs: TokenTransferOutputData[] =\n            createTransferOutputState(\n                inputCompressedTokenAccounts,\n                toAddress,\n                amount,\n            );\n\n        const {\n            inputTokenDataWithContext,\n            packedOutputTokenData,\n            remainingAccountMetas,\n        } = packCompressedTokenAccounts({\n            inputCompressedTokenAccounts,\n            rootIndices: recentInputStateRootIndices,\n            tokenTransferOutputs,\n        });\n\n        const { mint } = parseTokenData(inputCompressedTokenAccounts);\n\n        const { delegatedTransfer, authority } = parseMaybeDelegatedTransfer(\n            inputCompressedTokenAccounts,\n            tokenTransferOutputs,\n        );\n\n        const rawData: CompressedTokenInstructionDataTransfer = {\n            proof: recentValidityProof,\n            mint,\n            delegatedTransfer,\n            inputTokenDataWithContext,\n            outputCompressedAccounts: packedOutputTokenData,\n            compressOrDecompressAmount: null,\n            isCompress: false,\n            cpiContext: null,\n            lamportsChangeAccountMerkleTreeIndex: null,\n        };\n        const data = encodeTransferInstructionData(rawData);\n\n        const {\n            accountCompressionAuthority,\n            noopProgram,\n            registeredProgramPda,\n            accountCompressionProgram,\n        } = defaultStaticAccountsStruct();\n        const keys = transferAccountsLayout({\n            feePayer: payer,\n            authority,\n            cpiAuthorityPda: this.deriveCpiAuthorityPda,\n            lightSystemProgram: LightSystemProgram.programId,\n            registeredProgramPda: registeredProgramPda,\n            noopProgram: noopProgram,\n            accountCompressionAuthority: accountCompressionAuthority,\n            accountCompressionProgram: accountCompressionProgram,\n            selfProgram: this.programId,\n            tokenPoolPda: undefined,\n            compressOrDecompressTokenAccount: undefined,\n            tokenProgram: undefined,\n            systemProgram: SystemProgram.programId,\n        });\n\n        keys.push(...remainingAccountMetas);\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Create lookup table instructions for the token program's default\n     * accounts.\n     *\n     * @param payer                     Fee payer.\n     * @param authority                 Authority.\n     * @param mints                     Mints.\n     * @param recentSlot                Recent slot.\n     * @param remainingAccounts         Remaining accounts.\n     *\n     * @returns [createInstruction, extendInstruction, option(extendInstruction2)]\n     */\n    static async createTokenProgramLookupTable({\n        payer,\n        authority,\n        mints,\n        recentSlot,\n        remainingAccounts,\n    }: CreateTokenProgramLookupTableParams) {\n        const [createInstruction, lookupTableAddress] =\n            AddressLookupTableProgram.createLookupTable({\n                authority,\n                payer: authority,\n                recentSlot,\n            });\n\n        let optionalMintKeys: PublicKey[] = [];\n        if (mints) {\n            optionalMintKeys = [\n                ...mints,\n                ...mints.map(mint => this.deriveTokenPoolPda(mint)),\n            ];\n        }\n\n        const extendInstruction = AddressLookupTableProgram.extendLookupTable({\n            payer,\n            authority,\n            lookupTable: lookupTableAddress,\n            addresses: [\n                SystemProgram.programId,\n                ComputeBudgetProgram.programId,\n                this.deriveCpiAuthorityPda,\n                LightSystemProgram.programId,\n                CompressedTokenProgram.programId,\n                defaultStaticAccountsStruct().registeredProgramPda,\n                defaultStaticAccountsStruct().noopProgram,\n                defaultStaticAccountsStruct().accountCompressionAuthority,\n                defaultStaticAccountsStruct().accountCompressionProgram,\n                defaultTestStateTreeAccounts().merkleTree,\n                defaultTestStateTreeAccounts().nullifierQueue,\n                defaultTestStateTreeAccounts().addressTree,\n                defaultTestStateTreeAccounts().addressQueue,\n                this.programId,\n                TOKEN_PROGRAM_ID,\n                TOKEN_2022_PROGRAM_ID,\n                authority,\n                ...optionalMintKeys,\n            ],\n        });\n\n        const instructions = [createInstruction, extendInstruction];\n\n        if (remainingAccounts && remainingAccounts.length > 0) {\n            for (let i = 0; i < remainingAccounts.length; i += 25) {\n                const chunk = remainingAccounts.slice(i, i + 25);\n                const extendIx = AddressLookupTableProgram.extendLookupTable({\n                    payer,\n                    authority,\n                    lookupTable: lookupTableAddress,\n                    addresses: chunk,\n                });\n                instructions.push(extendIx);\n            }\n        }\n\n        return {\n            instructions,\n            address: lookupTableAddress,\n        };\n    }\n\n    /**\n     * Create compress instruction\n     *\n     * @param payer                         Fee payer.\n     * @param owner                         Owner of uncompressed token account.\n     * @param source                        Source SPL Token account address.\n     * @param toAddress                     Recipient owner address(es).\n     * @param amount                        Amount of tokens to compress.\n     * @param mint                          SPL Token mint address.\n     * @param outputStateTreeInfo           State tree to write to.\n     * @param tokenPoolInfo                 Token pool info.\n     *\n     * @returns The compress instruction\n     */\n    static async compress({\n        payer,\n        owner,\n        source,\n        toAddress,\n        amount,\n        mint,\n        outputStateTreeInfo,\n        tokenPoolInfo,\n    }: CompressParams): Promise<TransactionInstruction> {\n        let tokenTransferOutputs: TokenTransferOutputData[];\n\n        const amountArray = toArray<BN | number>(amount);\n        const toAddressArray = toArray(toAddress);\n\n        checkTokenPoolInfo(tokenPoolInfo, mint);\n\n        if (amountArray.length !== toAddressArray.length) {\n            throw new Error(\n                'Amount and toAddress arrays must have the same length',\n            );\n        }\n        if (featureFlags.isV2()) {\n            const [index, bump] = this.findTokenPoolIndexAndBump(\n                tokenPoolInfo.tokenPoolPda,\n                mint,\n            );\n            const rawData: BatchCompressInstructionData = {\n                pubkeys: toAddressArray,\n                amounts:\n                    amountArray.length > 1\n                        ? amountArray.map(amt => bn(amt))\n                        : null,\n                lamports: null,\n                amount: amountArray.length === 1 ? bn(amountArray[0]) : null,\n                index,\n                bump,\n            };\n\n            const data = encodeBatchCompressInstructionData(rawData);\n            const keys = mintToAccountsLayout({\n                mint,\n                feePayer: payer,\n                authority: owner,\n                cpiAuthorityPda: this.deriveCpiAuthorityPda,\n                tokenProgram: tokenPoolInfo.tokenProgram,\n                tokenPoolPda: tokenPoolInfo.tokenPoolPda,\n                lightSystemProgram: LightSystemProgram.programId,\n                ...defaultStaticAccountsStruct(),\n                merkleTree: outputStateTreeInfo.queue,\n                selfProgram: this.programId,\n                systemProgram: SystemProgram.programId,\n                solPoolPda: null,\n            });\n            keys.push({\n                pubkey: source,\n                isWritable: true,\n                isSigner: false,\n            });\n\n            return new TransactionInstruction({\n                programId: this.programId,\n                keys,\n                data,\n            });\n        } else {\n            tokenTransferOutputs = amountArray.map((amt, index) => {\n                const amountBN = bn(amt);\n                return {\n                    owner: toAddressArray[index],\n                    amount: amountBN,\n                    lamports: null,\n                    tlv: null,\n                };\n            });\n\n            const {\n                inputTokenDataWithContext,\n                packedOutputTokenData,\n                remainingAccountMetas,\n            } = packCompressedTokenAccounts({\n                inputCompressedTokenAccounts: [],\n                outputStateTreeInfo,\n                rootIndices: [],\n                tokenTransferOutputs,\n            });\n\n            const rawData: CompressedTokenInstructionDataTransfer = {\n                proof: null,\n                mint,\n                delegatedTransfer: null,\n                inputTokenDataWithContext,\n                outputCompressedAccounts: packedOutputTokenData,\n                compressOrDecompressAmount: Array.isArray(amount)\n                    ? amount\n                          .map(amt => bn(amt))\n                          .reduce((sum, amt) => sum.add(amt), bn(0))\n                    : bn(amount),\n                isCompress: true,\n                cpiContext: null,\n                lamportsChangeAccountMerkleTreeIndex: null,\n            };\n            const data = encodeTransferInstructionData(rawData);\n            const keys = transferAccountsLayout({\n                ...defaultStaticAccountsStruct(),\n                feePayer: payer,\n                authority: owner,\n                cpiAuthorityPda: this.deriveCpiAuthorityPda,\n                lightSystemProgram: LightSystemProgram.programId,\n                selfProgram: this.programId,\n                systemProgram: SystemProgram.programId,\n                tokenPoolPda: tokenPoolInfo.tokenPoolPda,\n                compressOrDecompressTokenAccount: source,\n                tokenProgram: tokenPoolInfo.tokenProgram,\n            });\n            keys.push(...remainingAccountMetas);\n\n            return new TransactionInstruction({\n                programId: this.programId,\n                keys,\n                data,\n            });\n        }\n    }\n\n    /**\n     * Construct decompress instruction\n     *\n     * @param payer                         Fee payer.\n     * @param inputCompressedTokenAccounts  Source compressed token accounts.\n     * @param toAddress                     Destination **uncompressed** token\n     *                                      account address. (ATA)\n     * @param amount                        Amount of tokens to decompress.\n     * @param recentValidityProof           Recent validity proof.\n     * @param recentInputStateRootIndices   Recent state root indices.\n     * @param tokenPoolInfos                Token pool info.\n     *\n     * @returns The decompress instruction\n     */\n    static async decompress({\n        payer,\n        inputCompressedTokenAccounts,\n        toAddress,\n        amount,\n        recentValidityProof,\n        recentInputStateRootIndices,\n        tokenPoolInfos,\n    }: DecompressParams): Promise<TransactionInstruction> {\n        const amountBN = bn(amount);\n        const tokenPoolInfosArray = toArray(tokenPoolInfos);\n\n        const tokenTransferOutputs = createDecompressOutputState(\n            inputCompressedTokenAccounts,\n            amountBN,\n        );\n\n        /// Pack\n        const {\n            inputTokenDataWithContext,\n            packedOutputTokenData,\n            remainingAccountMetas,\n        } = packCompressedTokenAccounts({\n            inputCompressedTokenAccounts,\n            rootIndices: recentInputStateRootIndices,\n            tokenTransferOutputs: tokenTransferOutputs,\n            remainingAccounts: tokenPoolInfosArray\n                .slice(1)\n                .map(info => info.tokenPoolPda),\n        });\n\n        const { mint } = parseTokenData(inputCompressedTokenAccounts);\n        const { delegatedTransfer, authority } = parseMaybeDelegatedTransfer(\n            inputCompressedTokenAccounts,\n            tokenTransferOutputs,\n        );\n\n        const rawData: CompressedTokenInstructionDataTransfer = {\n            proof: recentValidityProof,\n            mint,\n            delegatedTransfer,\n            inputTokenDataWithContext,\n            outputCompressedAccounts: packedOutputTokenData,\n            compressOrDecompressAmount: amountBN,\n            isCompress: false,\n            cpiContext: null,\n            lamportsChangeAccountMerkleTreeIndex: null,\n        };\n        const data = encodeTransferInstructionData(rawData);\n        const tokenProgram = tokenPoolInfosArray[0].tokenProgram;\n\n        const {\n            accountCompressionAuthority,\n            noopProgram,\n            registeredProgramPda,\n            accountCompressionProgram,\n        } = defaultStaticAccountsStruct();\n\n        const keys = transferAccountsLayout({\n            feePayer: payer,\n            authority: authority,\n            cpiAuthorityPda: this.deriveCpiAuthorityPda,\n            lightSystemProgram: LightSystemProgram.programId,\n            registeredProgramPda: registeredProgramPda,\n            noopProgram: noopProgram,\n            accountCompressionAuthority: accountCompressionAuthority,\n            accountCompressionProgram: accountCompressionProgram,\n            selfProgram: this.programId,\n            tokenPoolPda: tokenPoolInfosArray[0].tokenPoolPda,\n            compressOrDecompressTokenAccount: toAddress,\n            tokenProgram,\n            systemProgram: SystemProgram.programId,\n        });\n        keys.push(...remainingAccountMetas);\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Create `mergeTokenAccounts` instruction\n     *\n     * @param payer                         Fee payer.\n     * @param owner                         Owner of the compressed token\n     *                                      accounts to be merged.\n     * @param inputCompressedTokenAccounts  Source compressed token accounts.\n     * @param mint                          SPL Token mint address.\n     * @param recentValidityProof           Recent validity proof.\n     * @param recentInputStateRootIndices   Recent state root indices.\n     *\n     * @returns instruction\n     */\n    static async mergeTokenAccounts({\n        payer,\n        owner,\n        inputCompressedTokenAccounts,\n        mint,\n        recentValidityProof,\n        recentInputStateRootIndices,\n    }: MergeTokenAccountsParams): Promise<TransactionInstruction[]> {\n        if (inputCompressedTokenAccounts.length > 4) {\n            throw new Error('Cannot merge more than 4 token accounts at once');\n        }\n\n        checkMint(inputCompressedTokenAccounts, mint);\n\n        const ix = await this.transfer({\n            payer,\n            inputCompressedTokenAccounts,\n            toAddress: owner,\n            amount: inputCompressedTokenAccounts.reduce(\n                (sum, account) => sum.add(account.parsed.amount),\n                bn(0),\n            ),\n            recentInputStateRootIndices,\n            recentValidityProof,\n        });\n\n        return [ix];\n    }\n\n    /**\n     * Create `compressSplTokenAccount` instruction\n     *\n     * @param feePayer              Fee payer.\n     * @param authority             SPL Token account owner.\n     * @param tokenAccount          SPL Token account to compress.\n     * @param mint                  SPL Token mint address.\n     * @param remainingAmount       Optional: Amount to leave in token account.\n     * @param outputStateTreeInfo   State tree to write to.\n     * @param tokenPoolInfo         Token pool info.\n     *\n     * @returns instruction\n     */\n    static async compressSplTokenAccount({\n        feePayer,\n        authority,\n        tokenAccount,\n        mint,\n        remainingAmount,\n        outputStateTreeInfo,\n        tokenPoolInfo,\n    }: CompressSplTokenAccountParams): Promise<TransactionInstruction> {\n        checkTokenPoolInfo(tokenPoolInfo, mint);\n        const remainingAccountMetas: AccountMeta[] = [\n            {\n                pubkey:\n                    outputStateTreeInfo.treeType === TreeType.StateV2\n                        ? outputStateTreeInfo.queue\n                        : outputStateTreeInfo.tree,\n                isSigner: false,\n                isWritable: true,\n            },\n        ];\n\n        const data = encodeCompressSplTokenAccountInstructionData({\n            owner: authority,\n            remainingAmount: remainingAmount ?? null,\n            cpiContext: null,\n        });\n        const {\n            accountCompressionAuthority,\n            noopProgram,\n            registeredProgramPda,\n            accountCompressionProgram,\n        } = defaultStaticAccountsStruct();\n\n        const keys = transferAccountsLayout({\n            feePayer,\n            authority,\n            cpiAuthorityPda: this.deriveCpiAuthorityPda,\n            lightSystemProgram: LightSystemProgram.programId,\n            registeredProgramPda: registeredProgramPda,\n            noopProgram: noopProgram,\n            accountCompressionAuthority: accountCompressionAuthority,\n            accountCompressionProgram: accountCompressionProgram,\n            selfProgram: this.programId,\n            tokenPoolPda: tokenPoolInfo.tokenPoolPda,\n            compressOrDecompressTokenAccount: tokenAccount,\n            tokenProgram: tokenPoolInfo.tokenProgram,\n            systemProgram: SystemProgram.programId,\n        });\n\n        keys.push(...remainingAccountMetas);\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Get the program ID for a mint\n     *\n     * @param mint                  SPL Token mint address.\n     * @param connection            Connection.\n     *\n     * @returns program ID\n     */\n    static async getMintProgramId(\n        mint: PublicKey,\n        connection: Connection,\n    ): Promise<PublicKey | undefined> {\n        return (await connection.getAccountInfo(mint))?.owner;\n    }\n\n    /**\n     * Create `approve` instruction to delegate compressed tokens.\n     *\n     * @param payer                         Fee payer.\n     * @param inputCompressedTokenAccounts  Source compressed token accounts.\n     * @param toAddress                     Owner to delegate to.\n     * @param amount                        Amount of tokens to delegate.\n     * @param recentValidityProof           Recent validity proof.\n     * @param recentInputStateRootIndices   Recent state root indices.\n     *\n     * @returns instruction\n     */\n    static async approve({\n        payer,\n        inputCompressedTokenAccounts,\n        toAddress,\n        amount,\n        recentValidityProof,\n        recentInputStateRootIndices,\n    }: ApproveParams): Promise<TransactionInstruction> {\n        const { inputTokenDataWithContext, remainingAccountMetas } =\n            packCompressedTokenAccounts({\n                inputCompressedTokenAccounts,\n                rootIndices: recentInputStateRootIndices,\n                tokenTransferOutputs: [],\n            });\n\n        const { mint, currentOwner } = parseTokenData(\n            inputCompressedTokenAccounts,\n        );\n\n        const CHANGE_INDEX =\n            inputCompressedTokenAccounts[0].compressedAccount.treeInfo\n                .treeType === TreeType.StateV2\n                ? 1\n                : 0;\n\n        const rawData: CompressedTokenInstructionDataApprove = {\n            proof: recentValidityProof,\n            mint,\n            inputTokenDataWithContext,\n            cpiContext: null,\n            delegate: toAddress,\n            delegatedAmount: bn(amount),\n            delegateMerkleTreeIndex: CHANGE_INDEX,\n            changeAccountMerkleTreeIndex: CHANGE_INDEX,\n            delegateLamports: null,\n        };\n\n        const data = encodeApproveInstructionData(rawData);\n\n        const {\n            accountCompressionAuthority,\n            noopProgram,\n            registeredProgramPda,\n            accountCompressionProgram,\n        } = defaultStaticAccountsStruct();\n\n        const keys = approveAccountsLayout({\n            feePayer: payer,\n            authority: currentOwner,\n            cpiAuthorityPda: this.deriveCpiAuthorityPda,\n            lightSystemProgram: LightSystemProgram.programId,\n            registeredProgramPda: registeredProgramPda,\n            noopProgram: noopProgram,\n            accountCompressionAuthority: accountCompressionAuthority,\n            accountCompressionProgram: accountCompressionProgram,\n            selfProgram: this.programId,\n            systemProgram: SystemProgram.programId,\n        });\n\n        keys.push(...remainingAccountMetas);\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Create `revoke` instruction to revoke delegation of compressed tokens.\n     *\n     * @param payer                         Fee payer.\n     * @param inputCompressedTokenAccounts  Source compressed token accounts.\n     * @param recentValidityProof           Recent validity proof.\n     * @param recentInputStateRootIndices   Recent state root indices.\n     *\n     * @returns instruction\n     */\n    static async revoke({\n        payer,\n        inputCompressedTokenAccounts,\n        recentValidityProof,\n        recentInputStateRootIndices,\n    }: RevokeParams): Promise<TransactionInstruction> {\n        validateSameTokenOwner(inputCompressedTokenAccounts);\n\n        const { inputTokenDataWithContext, remainingAccountMetas } =\n            packCompressedTokenAccounts({\n                inputCompressedTokenAccounts,\n                rootIndices: recentInputStateRootIndices,\n                tokenTransferOutputs: [],\n            });\n\n        const { mint, currentOwner } = parseTokenData(\n            inputCompressedTokenAccounts,\n        );\n\n        const rawData: CompressedTokenInstructionDataRevoke = {\n            proof: recentValidityProof,\n            mint,\n            inputTokenDataWithContext,\n            cpiContext: null,\n            outputAccountMerkleTreeIndex:\n                inputCompressedTokenAccounts[0].compressedAccount.treeInfo\n                    .treeType === TreeType.StateV2\n                    ? 2\n                    : 1,\n        };\n        const data = encodeRevokeInstructionData(rawData);\n\n        const {\n            accountCompressionAuthority,\n            noopProgram,\n            registeredProgramPda,\n            accountCompressionProgram,\n        } = defaultStaticAccountsStruct();\n        const keys = revokeAccountsLayout({\n            feePayer: payer,\n            authority: currentOwner,\n            cpiAuthorityPda: this.deriveCpiAuthorityPda,\n            lightSystemProgram: LightSystemProgram.programId,\n            registeredProgramPda: registeredProgramPda,\n            noopProgram: noopProgram,\n            accountCompressionAuthority: accountCompressionAuthority,\n            accountCompressionProgram: accountCompressionProgram,\n            selfProgram: this.programId,\n            systemProgram: SystemProgram.programId,\n        });\n\n        keys.push(...remainingAccountMetas);\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n}\n","export type LightCompressedToken = {\n    version: '1.2.0';\n    name: 'light_compressed_token';\n    instructions: [\n        {\n            name: 'createTokenPool';\n            docs: [\n                'This instruction creates a token pool for a given mint. Every spl mint',\n                'can have one token pool. When a token is compressed the tokens are',\n                'transferrred to the token pool, and their compressed equivalent is',\n                'minted into a Merkle tree.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'tokenPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'mint';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'tokenProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [];\n        },\n        {\n            name: 'addTokenPool';\n            docs: [\n                'This instruction creates an additional token pool for a given mint.',\n                'The maximum number of token pools per mint is 5.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'tokenPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'existingTokenPoolPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'mint';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'tokenProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'tokenPoolIndex';\n                    type: 'u8';\n                },\n            ];\n        },\n        {\n            name: 'mintTo';\n            docs: [\n                'Mints tokens from an spl token mint to a list of compressed accounts.',\n                'Minted tokens are transferred to a pool account owned by the compressed',\n                'token program. The instruction creates one compressed output account for',\n                'every amount and pubkey input pair. A constant amount of lamports can be',\n                'transferred to each output account to enable. A use case to add lamports',\n                'to a compressed token account is to prevent spam. This is the only way',\n                'to add lamports to a compressed token account.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'mint';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'tokenPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'tokenProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'lightSystemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['programs'];\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'merkleTree';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'selfProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'solPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n            ];\n            args: [\n                {\n                    name: 'publicKeys';\n                    type: {\n                        vec: 'publicKey';\n                    };\n                },\n                {\n                    name: 'amounts';\n                    type: {\n                        vec: 'u64';\n                    };\n                },\n                {\n                    name: 'lamports';\n                    type: {\n                        option: 'u64';\n                    };\n                },\n            ];\n        },\n        {\n            name: 'compressSplTokenAccount';\n            docs: [\n                'Compresses the balance of an spl token account sub an optional remaining',\n                'amount. This instruction does not close the spl token account. To close',\n                'the account bundle a close spl account instruction in your transaction.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ];\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'lightSystemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'selfProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['this program is the signer of the cpi.'];\n                },\n                {\n                    name: 'tokenPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'compressOrDecompressTokenAccount';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'tokenProgram';\n                    isMut: false;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'owner';\n                    type: 'publicKey';\n                },\n                {\n                    name: 'remainingAmount';\n                    type: {\n                        option: 'u64';\n                    };\n                },\n                {\n                    name: 'cpiContext';\n                    type: {\n                        option: {\n                            defined: 'CompressedCpiContext';\n                        };\n                    };\n                },\n            ];\n        },\n        {\n            name: 'transfer';\n            docs: [\n                'Transfers compressed tokens from one account to another. All accounts',\n                'must be of the same mint. Additional spl tokens can be compressed or',\n                'decompressed. In one transaction only compression or decompression is',\n                'possible. Lamports can be transferred alongside tokens. If output token',\n                'accounts specify less lamports than inputs the remaining lamports are',\n                'transferred to an output compressed account. Signer must be owner or',\n                'delegate. If a delegated token account is transferred the delegate is',\n                'not preserved.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ];\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'lightSystemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'selfProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['this program is the signer of the cpi.'];\n                },\n                {\n                    name: 'tokenPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'compressOrDecompressTokenAccount';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'tokenProgram';\n                    isMut: false;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'approve';\n            docs: [\n                'Delegates an amount to a delegate. A compressed token account is either',\n                'completely delegated or not. Prior delegates are not preserved. Cannot',\n                'be called by a delegate.',\n                'The instruction creates two output accounts:',\n                '1. one account with delegated amount',\n                '2. one account with remaining(change) amount',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ];\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'lightSystemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'selfProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['this program is the signer of the cpi.'];\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'revoke';\n            docs: [\n                'Revokes a delegation. The instruction merges all inputs into one output',\n                'account. Cannot be called by a delegate. Delegates are not preserved.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ];\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'lightSystemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'selfProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['this program is the signer of the cpi.'];\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'freeze';\n            docs: [\n                'Freezes compressed token accounts. Inputs must not be frozen. Creates as',\n                'many outputs as inputs. Balances and delegates are preserved.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'lightSystemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'selfProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['that this program is the signer of the cpi.'];\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'mint';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'thaw';\n            docs: [\n                'Thaws frozen compressed token accounts. Inputs must be frozen. Creates',\n                'as many outputs as inputs. Balances and delegates are preserved.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'lightSystemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'selfProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['that this program is the signer of the cpi.'];\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'mint';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'burn';\n            docs: [\n                'Burns compressed tokens and spl tokens from the pool account. Delegates',\n                'can burn tokens. The output compressed token account remains delegated.',\n                'Creates one output compressed token account.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ];\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'mint';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'tokenPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'tokenProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'lightSystemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'selfProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'stubIdlBuild';\n            docs: [\n                'This function is a stub to allow Anchor to include the input types in',\n                'the IDL. It should not be included in production builds nor be called in',\n                'practice.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: ['UNCHECKED: only pays fees.'];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ];\n                },\n                {\n                    name: 'cpiAuthorityPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'lightSystemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'selfProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['this program is the signer of the cpi.'];\n                },\n                {\n                    name: 'tokenPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'compressOrDecompressTokenAccount';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'tokenProgram';\n                    isMut: false;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs1';\n                    type: {\n                        defined: 'CompressedTokenInstructionDataTransfer';\n                    };\n                },\n                {\n                    name: 'inputs2';\n                    type: {\n                        defined: 'TokenData';\n                    };\n                },\n            ];\n        },\n    ];\n    types: [\n        {\n            name: 'AccountState';\n            type: {\n                kind: 'enum';\n                variants: [\n                    {\n                        name: 'Initialized';\n                    },\n                    {\n                        name: 'Frozen';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedAccount';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'owner';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'lamports';\n                        type: 'u64';\n                    },\n                    {\n                        name: 'address';\n                        type: {\n                            option: {\n                                array: ['u8', 32];\n                            };\n                        };\n                    },\n                    {\n                        name: 'data';\n                        type: {\n                            option: {\n                                defined: 'CompressedAccountData';\n                            };\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedAccountData';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'discriminator';\n                        type: {\n                            array: ['u8', 8];\n                        };\n                    },\n                    {\n                        name: 'data';\n                        type: 'bytes';\n                    },\n                    {\n                        name: 'dataHash';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedCpiContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'setContext';\n                        docs: [\n                            'Is set by the program that is invoking the CPI to signal that is should',\n                            'set the cpi context.',\n                        ];\n                        type: 'bool';\n                    },\n                    {\n                        name: 'firstSetContext';\n                        docs: [\n                            'Is set to wipe the cpi context since someone could have set it before',\n                            'with unrelated data.',\n                        ];\n                        type: 'bool';\n                    },\n                    {\n                        name: 'cpiContextAccountIndex';\n                        docs: [\n                            'Index of cpi context account in remaining accounts.',\n                        ];\n                        type: 'u8';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedProof';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'a';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                    {\n                        name: 'b';\n                        type: {\n                            array: ['u8', 64];\n                        };\n                    },\n                    {\n                        name: 'c';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedTokenInstructionDataTransfer';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'proof';\n                        type: {\n                            option: {\n                                defined: 'CompressedProof';\n                            };\n                        };\n                    },\n                    {\n                        name: 'mint';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'delegatedTransfer';\n                        docs: [\n                            'Is required if the signer is delegate,',\n                            '-> delegate is authority account,',\n                            'owner = Some(owner) is the owner of the token account.',\n                        ];\n                        type: {\n                            option: {\n                                defined: 'DelegatedTransfer';\n                            };\n                        };\n                    },\n                    {\n                        name: 'inputTokenDataWithContext';\n                        type: {\n                            vec: {\n                                defined: 'InputTokenDataWithContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccounts';\n                        type: {\n                            vec: {\n                                defined: 'PackedTokenTransferOutputData';\n                            };\n                        };\n                    },\n                    {\n                        name: 'isCompress';\n                        type: 'bool';\n                    },\n                    {\n                        name: 'compressOrDecompressAmount';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'cpiContext';\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'lamportsChangeAccountMerkleTreeIndex';\n                        type: {\n                            option: 'u8';\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedTokenInstructionDataRevoke';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'proof';\n                        type: {\n                            option: {\n                                defined: 'CompressedProof';\n                            };\n                        };\n                    },\n                    {\n                        name: 'mint';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'inputTokenDataWithContext';\n                        type: {\n                            vec: {\n                                defined: 'InputTokenDataWithContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'cpiContext';\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputAccountMerkleTreeIndex';\n                        type: 'u8';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedTokenInstructionDataApprove';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'proof';\n                        type: {\n                            option: {\n                                defined: 'CompressedProof';\n                            };\n                        };\n                    },\n                    {\n                        name: 'mint';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'inputTokenDataWithContext';\n                        type: {\n                            vec: {\n                                defined: 'InputTokenDataWithContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'cpiContext';\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'delegate';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'delegatedAmount';\n                        type: 'u64';\n                    },\n                    {\n                        name: 'delegateMerkleTreeIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'changeAccountMerkleTreeIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'delegateLamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'DelegatedTransfer';\n            docs: [\n                'Struct to provide the owner when the delegate is signer of the transaction.',\n            ];\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'owner';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'delegateChangeAccountIndex';\n                        docs: [\n                            'Index of change compressed account in output compressed accounts. In',\n                            \"case that the delegate didn't spend the complete delegated compressed\",\n                            'account balance the change compressed account will be delegated to her',\n                            'as well.',\n                        ];\n                        type: {\n                            option: 'u8';\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'InputTokenDataWithContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'amount';\n                        type: 'u64';\n                    },\n                    {\n                        name: 'delegateIndex';\n                        type: {\n                            option: 'u8';\n                        };\n                    },\n                    {\n                        name: 'merkleContext';\n                        type: {\n                            defined: 'PackedMerkleContext';\n                        };\n                    },\n                    {\n                        name: 'rootIndex';\n                        type: 'u16';\n                    },\n                    {\n                        name: 'lamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'tlv';\n                        docs: [\n                            'Placeholder for TokenExtension tlv data (unimplemented)',\n                        ];\n                        type: {\n                            option: 'bytes';\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'InstructionDataInvoke';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'proof';\n                        type: {\n                            option: {\n                                defined: 'CompressedProof';\n                            };\n                        };\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext';\n                        type: {\n                            vec: {\n                                defined: 'PackedCompressedAccountWithMerkleContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccounts';\n                        type: {\n                            vec: {\n                                defined: 'OutputCompressedAccountWithPackedContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'relayFee';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'newAddressParams';\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked';\n                            };\n                        };\n                    },\n                    {\n                        name: 'compressOrDecompressLamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'isCompress';\n                        type: 'bool';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'InstructionDataInvokeCpi';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'proof';\n                        type: {\n                            option: {\n                                defined: 'CompressedProof';\n                            };\n                        };\n                    },\n                    {\n                        name: 'newAddressParams';\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked';\n                            };\n                        };\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext';\n                        type: {\n                            vec: {\n                                defined: 'PackedCompressedAccountWithMerkleContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccounts';\n                        type: {\n                            vec: {\n                                defined: 'OutputCompressedAccountWithPackedContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'relayFee';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'compressOrDecompressLamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'isCompress';\n                        type: 'bool';\n                    },\n                    {\n                        name: 'cpiContext';\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext';\n                            };\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'MerkleTreeSequenceNumber';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'pubkey';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'seq';\n                        type: 'u64';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'NewAddressParamsPacked';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'seed';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                    {\n                        name: 'addressQueueAccountIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'addressMerkleTreeAccountIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'addressMerkleTreeRootIndex';\n                        type: 'u16';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'OutputCompressedAccountWithPackedContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'compressedAccount';\n                        type: {\n                            defined: 'CompressedAccount';\n                        };\n                    },\n                    {\n                        name: 'merkleTreeIndex';\n                        type: 'u8';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'PackedCompressedAccountWithMerkleContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'compressedAccount';\n                        type: {\n                            defined: 'CompressedAccount';\n                        };\n                    },\n                    {\n                        name: 'merkleContext';\n                        type: {\n                            defined: 'PackedMerkleContext';\n                        };\n                    },\n                    {\n                        name: 'rootIndex';\n                        docs: [\n                            'Index of root used in inclusion validity proof.',\n                        ];\n                        type: 'u16';\n                    },\n                    {\n                        name: 'readOnly';\n                        docs: [\n                            'Placeholder to mark accounts read-only unimplemented set to false.',\n                        ];\n                        type: 'bool';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'PackedMerkleContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'merkleTreePubkeyIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'queuePubkeyIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'leafIndex';\n                        type: 'u32';\n                    },\n                    {\n                        name: 'proveByIndex';\n                        type: 'bool';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'PackedTokenTransferOutputData';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'owner';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'amount';\n                        type: 'u64';\n                    },\n                    {\n                        name: 'lamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'merkleTreeIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'tlv';\n                        docs: [\n                            'Placeholder for TokenExtension tlv data (unimplemented)',\n                        ];\n                        type: {\n                            option: 'bytes';\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'PublicTransactionEvent';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'inputCompressedAccountHashes';\n                        type: {\n                            vec: {\n                                array: ['u8', 32];\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccountHashes';\n                        type: {\n                            vec: {\n                                array: ['u8', 32];\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccounts';\n                        type: {\n                            vec: {\n                                defined: 'OutputCompressedAccountWithPackedContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputLeafIndices';\n                        type: {\n                            vec: 'u32';\n                        };\n                    },\n                    {\n                        name: 'sequenceNumbers';\n                        type: {\n                            vec: {\n                                defined: 'MerkleTreeSequenceNumber';\n                            };\n                        };\n                    },\n                    {\n                        name: 'relayFee';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'isCompress';\n                        type: 'bool';\n                    },\n                    {\n                        name: 'compressOrDecompressLamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'pubkeyArray';\n                        type: {\n                            vec: 'publicKey';\n                        };\n                    },\n                    {\n                        name: 'message';\n                        type: {\n                            option: 'bytes';\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'QueueIndex';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'queueId';\n                        docs: ['Id of queue in queue account.'];\n                        type: 'u8';\n                    },\n                    {\n                        name: 'index';\n                        docs: ['Index of compressed account hash in queue.'];\n                        type: 'u16';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'TokenData';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'mint';\n                        docs: ['The mint associated with this account'];\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'owner';\n                        docs: ['The owner of this account.'];\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'amount';\n                        docs: ['The amount of tokens this account holds.'];\n                        type: 'u64';\n                    },\n                    {\n                        name: 'delegate';\n                        docs: [\n                            'If `delegate` is `Some` then `delegated_amount` represents',\n                            'the amount authorized by the delegate',\n                        ];\n                        type: {\n                            option: 'publicKey';\n                        };\n                    },\n                    {\n                        name: 'state';\n                        docs: [\"The account's state\"];\n                        type: {\n                            defined: 'AccountState';\n                        };\n                    },\n                    {\n                        name: 'tlv';\n                        docs: [\n                            'Placeholder for TokenExtension tlv data (unimplemented)',\n                        ];\n                        type: {\n                            option: 'bytes';\n                        };\n                    },\n                ];\n            };\n        },\n    ];\n    errors: [\n        {\n            code: 6000;\n            name: 'PublicKeyAmountMissmatch';\n            msg: 'public keys and amounts must be of same length';\n        },\n        {\n            code: 6001;\n            name: 'ComputeInputSumFailed';\n            msg: 'ComputeInputSumFailed';\n        },\n        {\n            code: 6002;\n            name: 'ComputeOutputSumFailed';\n            msg: 'ComputeOutputSumFailed';\n        },\n        {\n            code: 6003;\n            name: 'ComputeCompressSumFailed';\n            msg: 'ComputeCompressSumFailed';\n        },\n        {\n            code: 6004;\n            name: 'ComputeDecompressSumFailed';\n            msg: 'ComputeDecompressSumFailed';\n        },\n        {\n            code: 6005;\n            name: 'SumCheckFailed';\n            msg: 'SumCheckFailed';\n        },\n        {\n            code: 6006;\n            name: 'DecompressRecipientUndefinedForDecompress';\n            msg: 'DecompressRecipientUndefinedForDecompress';\n        },\n        {\n            code: 6007;\n            name: 'CompressedPdaUndefinedForDecompress';\n            msg: 'CompressedPdaUndefinedForDecompress';\n        },\n        {\n            code: 6008;\n            name: 'DeCompressAmountUndefinedForDecompress';\n            msg: 'DeCompressAmountUndefinedForDecompress';\n        },\n        {\n            code: 6009;\n            name: 'CompressedPdaUndefinedForCompress';\n            msg: 'CompressedPdaUndefinedForCompress';\n        },\n        {\n            code: 6010;\n            name: 'DeCompressAmountUndefinedForCompress';\n            msg: 'DeCompressAmountUndefinedForCompress';\n        },\n        {\n            code: 6011;\n            name: 'DelegateSignerCheckFailed';\n            msg: 'DelegateSignerCheckFailed';\n        },\n        {\n            code: 6012;\n            name: 'MintTooLarge';\n            msg: 'Minted amount greater than u64::MAX';\n        },\n        {\n            code: 6013;\n            name: 'SplTokenSupplyMismatch';\n            msg: 'SplTokenSupplyMismatch';\n        },\n        {\n            code: 6014;\n            name: 'HeapMemoryCheckFailed';\n            msg: 'HeapMemoryCheckFailed';\n        },\n        {\n            code: 6015;\n            name: 'InstructionNotCallable';\n            msg: 'The instruction is not callable';\n        },\n        {\n            code: 6016;\n            name: 'ArithmeticUnderflow';\n            msg: 'ArithmeticUnderflow';\n        },\n        {\n            code: 6017;\n            name: 'HashToFieldError';\n            msg: 'HashToFieldError';\n        },\n        {\n            code: 6018;\n            name: 'InvalidAuthorityMint';\n            msg: 'Expected the authority to be also a mint authority';\n        },\n        {\n            code: 6019;\n            name: 'InvalidFreezeAuthority';\n            msg: 'Provided authority is not the freeze authority';\n        },\n        {\n            code: 6020;\n            name: 'InvalidDelegateIndex';\n        },\n        {\n            code: 6021;\n            name: 'TokenPoolPdaUndefined';\n        },\n        {\n            code: 6022;\n            name: 'IsTokenPoolPda';\n            msg: 'Compress or decompress recipient is the same account as the token pool pda.';\n        },\n        {\n            code: 6023;\n            name: 'InvalidTokenPoolPda';\n        },\n        {\n            code: 6024;\n            name: 'NoInputTokenAccountsProvided';\n        },\n        {\n            code: 6025;\n            name: 'NoInputsProvided';\n        },\n        {\n            code: 6026;\n            name: 'MintHasNoFreezeAuthority';\n        },\n        {\n            code: 6027;\n            name: 'MintWithInvalidExtension';\n        },\n        {\n            code: 6028;\n            name: 'InsufficientTokenAccountBalance';\n            msg: 'The token account balance is less than the remaining amount.';\n        },\n        {\n            code: 6029;\n            name: 'InvalidTokenPoolBump';\n            msg: 'Max number of token pools reached.';\n        },\n        {\n            code: 6030;\n            name: 'FailedToDecompress';\n        },\n        {\n            code: 6031;\n            name: 'FailedToBurnSplTokensFromTokenPool';\n        },\n        {\n            code: 6032;\n            name: 'NoMatchingBumpFound';\n        },\n    ];\n};\nexport const IDL: LightCompressedToken = {\n    version: '1.2.0',\n    name: 'light_compressed_token',\n    instructions: [\n        {\n            name: 'createTokenPool',\n            docs: [\n                'This instruction creates a token pool for a given mint. Every spl mint',\n                'can have one token pool. When a token is compressed the tokens are',\n                'transferrred to the token pool, and their compressed equivalent is',\n                'minted into a Merkle tree.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'tokenPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'mint',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'tokenProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [],\n        },\n        {\n            name: 'addTokenPool',\n            docs: [\n                'This instruction creates an additional token pool for a given mint.',\n                'The maximum number of token pools per mint is 5.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'tokenPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'existingTokenPoolPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'mint',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'tokenProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'tokenPoolIndex',\n                    type: 'u8',\n                },\n            ],\n        },\n        {\n            name: 'mintTo',\n            docs: [\n                'Mints tokens from an spl token mint to a list of compressed accounts.',\n                'Minted tokens are transferred to a pool account owned by the compressed',\n                'token program. The instruction creates one compressed output account for',\n                'every amount and pubkey input pair. A constant amount of lamports can be',\n                'transferred to each output account to enable. A use case to add lamports',\n                'to a compressed token account is to prevent spam. This is the only way',\n                'to add lamports to a compressed token account.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'mint',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'tokenPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'tokenProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'lightSystemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['programs'],\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'merkleTree',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'selfProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'solPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n            ],\n            args: [\n                {\n                    name: 'publicKeys',\n                    type: {\n                        vec: 'publicKey',\n                    },\n                },\n                {\n                    name: 'amounts',\n                    type: {\n                        vec: 'u64',\n                    },\n                },\n                {\n                    name: 'lamports',\n                    type: {\n                        option: 'u64',\n                    },\n                },\n            ],\n        },\n        {\n            name: 'compressSplTokenAccount',\n            docs: [\n                'Compresses the balance of an spl token account sub an optional remaining',\n                'amount. This instruction does not close the spl token account. To close',\n                'the account bundle a close spl account instruction in your transaction.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ],\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'lightSystemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'selfProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['this program is the signer of the cpi.'],\n                },\n                {\n                    name: 'tokenPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'compressOrDecompressTokenAccount',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'tokenProgram',\n                    isMut: false,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'owner',\n                    type: 'publicKey',\n                },\n                {\n                    name: 'remainingAmount',\n                    type: {\n                        option: 'u64',\n                    },\n                },\n                {\n                    name: 'cpiContext',\n                    type: {\n                        option: {\n                            defined: 'CompressedCpiContext',\n                        },\n                    },\n                },\n            ],\n        },\n        {\n            name: 'transfer',\n            docs: [\n                'Transfers compressed tokens from one account to another. All accounts',\n                'must be of the same mint. Additional spl tokens can be compressed or',\n                'decompressed. In one transaction only compression or decompression is',\n                'possible. Lamports can be transferred alongside tokens. If output token',\n                'accounts specify less lamports than inputs the remaining lamports are',\n                'transferred to an output compressed account. Signer must be owner or',\n                'delegate. If a delegated token account is transferred the delegate is',\n                'not preserved.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ],\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'lightSystemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'selfProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['this program is the signer of the cpi.'],\n                },\n                {\n                    name: 'tokenPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'compressOrDecompressTokenAccount',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'tokenProgram',\n                    isMut: false,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'approve',\n            docs: [\n                'Delegates an amount to a delegate. A compressed token account is either',\n                'completely delegated or not. Prior delegates are not preserved. Cannot',\n                'be called by a delegate.',\n                'The instruction creates two output accounts:',\n                '1. one account with delegated amount',\n                '2. one account with remaining(change) amount',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ],\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'lightSystemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'selfProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['this program is the signer of the cpi.'],\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'revoke',\n            docs: [\n                'Revokes a delegation. The instruction merges all inputs into one output',\n                'account. Cannot be called by a delegate. Delegates are not preserved.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ],\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'lightSystemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'selfProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['this program is the signer of the cpi.'],\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'freeze',\n            docs: [\n                'Freezes compressed token accounts. Inputs must not be frozen. Creates as',\n                'many outputs as inputs. Balances and delegates are preserved.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'lightSystemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'selfProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['that this program is the signer of the cpi.'],\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'mint',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'thaw',\n            docs: [\n                'Thaws frozen compressed token accounts. Inputs must be frozen. Creates',\n                'as many outputs as inputs. Balances and delegates are preserved.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'lightSystemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'selfProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['that this program is the signer of the cpi.'],\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'mint',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'burn',\n            docs: [\n                'Burns compressed tokens and spl tokens from the pool account. Delegates',\n                'can burn tokens. The output compressed token account remains delegated.',\n                'Creates one output compressed token account.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ],\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'mint',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'tokenPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'tokenProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'lightSystemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'selfProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'stubIdlBuild',\n            docs: [\n                'This function is a stub to allow Anchor to include the input types in',\n                'the IDL. It should not be included in production builds nor be called in',\n                'practice.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: ['UNCHECKED: only pays fees.'],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                    docs: [\n                        'Authority is verified through proof since both owner and delegate',\n                        'are included in the token data hash, which is a public input to the',\n                        'validity proof.',\n                    ],\n                },\n                {\n                    name: 'cpiAuthorityPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'lightSystemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'selfProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['this program is the signer of the cpi.'],\n                },\n                {\n                    name: 'tokenPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'compressOrDecompressTokenAccount',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'tokenProgram',\n                    isMut: false,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs1',\n                    type: {\n                        defined: 'CompressedTokenInstructionDataTransfer',\n                    },\n                },\n                {\n                    name: 'inputs2',\n                    type: {\n                        defined: 'TokenData',\n                    },\n                },\n            ],\n        },\n    ],\n    types: [\n        {\n            name: 'AccountState',\n            type: {\n                kind: 'enum',\n                variants: [\n                    {\n                        name: 'Initialized',\n                    },\n                    {\n                        name: 'Frozen',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedAccount',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'owner',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'lamports',\n                        type: 'u64',\n                    },\n                    {\n                        name: 'address',\n                        type: {\n                            option: {\n                                array: ['u8', 32],\n                            },\n                        },\n                    },\n                    {\n                        name: 'data',\n                        type: {\n                            option: {\n                                defined: 'CompressedAccountData',\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedAccountData',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'discriminator',\n                        type: {\n                            array: ['u8', 8],\n                        },\n                    },\n                    {\n                        name: 'data',\n                        type: 'bytes',\n                    },\n                    {\n                        name: 'dataHash',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedCpiContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'setContext',\n                        docs: [\n                            'Is set by the program that is invoking the CPI to signal that is should',\n                            'set the cpi context.',\n                        ],\n                        type: 'bool',\n                    },\n                    {\n                        name: 'firstSetContext',\n                        docs: [\n                            'Is set to wipe the cpi context since someone could have set it before',\n                            'with unrelated data.',\n                        ],\n                        type: 'bool',\n                    },\n                    {\n                        name: 'cpiContextAccountIndex',\n                        docs: [\n                            'Index of cpi context account in remaining accounts.',\n                        ],\n                        type: 'u8',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedProof',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'a',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                    {\n                        name: 'b',\n                        type: {\n                            array: ['u8', 64],\n                        },\n                    },\n                    {\n                        name: 'c',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedTokenInstructionDataTransfer',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'proof',\n                        type: {\n                            option: {\n                                defined: 'CompressedProof',\n                            },\n                        },\n                    },\n                    {\n                        name: 'mint',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'delegatedTransfer',\n                        docs: [\n                            'Is required if the signer is delegate,',\n                            '-> delegate is authority account,',\n                            'owner = Some(owner) is the owner of the token account.',\n                        ],\n                        type: {\n                            option: {\n                                defined: 'DelegatedTransfer',\n                            },\n                        },\n                    },\n                    {\n                        name: 'inputTokenDataWithContext',\n                        type: {\n                            vec: {\n                                defined: 'InputTokenDataWithContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccounts',\n                        type: {\n                            vec: {\n                                defined: 'PackedTokenTransferOutputData',\n                            },\n                        },\n                    },\n                    {\n                        name: 'isCompress',\n                        type: 'bool',\n                    },\n                    {\n                        name: 'compressOrDecompressAmount',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'cpiContext',\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'lamportsChangeAccountMerkleTreeIndex',\n                        type: {\n                            option: 'u8',\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedTokenInstructionDataRevoke',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'proof',\n                        type: {\n                            option: {\n                                defined: 'CompressedProof',\n                            },\n                        },\n                    },\n                    {\n                        name: 'mint',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'inputTokenDataWithContext',\n                        type: {\n                            vec: {\n                                defined: 'InputTokenDataWithContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'cpiContext',\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputAccountMerkleTreeIndex',\n                        type: 'u8',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedTokenInstructionDataApprove',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'proof',\n                        type: {\n                            option: {\n                                defined: 'CompressedProof',\n                            },\n                        },\n                    },\n                    {\n                        name: 'mint',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'inputTokenDataWithContext',\n                        type: {\n                            vec: {\n                                defined: 'InputTokenDataWithContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'cpiContext',\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'delegate',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'delegatedAmount',\n                        type: 'u64',\n                    },\n                    {\n                        name: 'delegateMerkleTreeIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'changeAccountMerkleTreeIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'delegateLamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'DelegatedTransfer',\n            docs: [\n                'Struct to provide the owner when the delegate is signer of the transaction.',\n            ],\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'owner',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'delegateChangeAccountIndex',\n                        docs: [\n                            'Index of change compressed account in output compressed accounts. In',\n                            \"case that the delegate didn't spend the complete delegated compressed\",\n                            'account balance the change compressed account will be delegated to her',\n                            'as well.',\n                        ],\n                        type: {\n                            option: 'u8',\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'InputTokenDataWithContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'amount',\n                        type: 'u64',\n                    },\n                    {\n                        name: 'delegateIndex',\n                        type: {\n                            option: 'u8',\n                        },\n                    },\n                    {\n                        name: 'merkleContext',\n                        type: {\n                            defined: 'PackedMerkleContext',\n                        },\n                    },\n                    {\n                        name: 'rootIndex',\n                        type: 'u16',\n                    },\n                    {\n                        name: 'lamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'tlv',\n                        docs: [\n                            'Placeholder for TokenExtension tlv data (unimplemented)',\n                        ],\n                        type: {\n                            option: 'bytes',\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'InstructionDataInvoke',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'proof',\n                        type: {\n                            option: {\n                                defined: 'CompressedProof',\n                            },\n                        },\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext',\n                        type: {\n                            vec: {\n                                defined:\n                                    'PackedCompressedAccountWithMerkleContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccounts',\n                        type: {\n                            vec: {\n                                defined:\n                                    'OutputCompressedAccountWithPackedContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'relayFee',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'newAddressParams',\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked',\n                            },\n                        },\n                    },\n                    {\n                        name: 'compressOrDecompressLamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'isCompress',\n                        type: 'bool',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'InstructionDataInvokeCpi',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'proof',\n                        type: {\n                            option: {\n                                defined: 'CompressedProof',\n                            },\n                        },\n                    },\n                    {\n                        name: 'newAddressParams',\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked',\n                            },\n                        },\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext',\n                        type: {\n                            vec: {\n                                defined:\n                                    'PackedCompressedAccountWithMerkleContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccounts',\n                        type: {\n                            vec: {\n                                defined:\n                                    'OutputCompressedAccountWithPackedContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'relayFee',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'compressOrDecompressLamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'isCompress',\n                        type: 'bool',\n                    },\n                    {\n                        name: 'cpiContext',\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext',\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'MerkleTreeSequenceNumber',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'pubkey',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'seq',\n                        type: 'u64',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'NewAddressParamsPacked',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'seed',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                    {\n                        name: 'addressQueueAccountIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'addressMerkleTreeAccountIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'addressMerkleTreeRootIndex',\n                        type: 'u16',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'OutputCompressedAccountWithPackedContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'compressedAccount',\n                        type: {\n                            defined: 'CompressedAccount',\n                        },\n                    },\n                    {\n                        name: 'merkleTreeIndex',\n                        type: 'u8',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'PackedCompressedAccountWithMerkleContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'compressedAccount',\n                        type: {\n                            defined: 'CompressedAccount',\n                        },\n                    },\n                    {\n                        name: 'merkleContext',\n                        type: {\n                            defined: 'PackedMerkleContext',\n                        },\n                    },\n                    {\n                        name: 'rootIndex',\n                        docs: [\n                            'Index of root used in inclusion validity proof.',\n                        ],\n                        type: 'u16',\n                    },\n                    {\n                        name: 'readOnly',\n                        docs: [\n                            'Placeholder to mark accounts read-only unimplemented set to false.',\n                        ],\n                        type: 'bool',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'PackedMerkleContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'merkleTreePubkeyIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'queuePubkeyIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'leafIndex',\n                        type: 'u32',\n                    },\n                    {\n                        name: 'proveByIndex',\n                        type: 'bool',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'PackedTokenTransferOutputData',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'owner',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'amount',\n                        type: 'u64',\n                    },\n                    {\n                        name: 'lamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'merkleTreeIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'tlv',\n                        docs: [\n                            'Placeholder for TokenExtension tlv data (unimplemented)',\n                        ],\n                        type: {\n                            option: 'bytes',\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'PublicTransactionEvent',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'inputCompressedAccountHashes',\n                        type: {\n                            vec: {\n                                array: ['u8', 32],\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccountHashes',\n                        type: {\n                            vec: {\n                                array: ['u8', 32],\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccounts',\n                        type: {\n                            vec: {\n                                defined:\n                                    'OutputCompressedAccountWithPackedContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputLeafIndices',\n                        type: {\n                            vec: 'u32',\n                        },\n                    },\n                    {\n                        name: 'sequenceNumbers',\n                        type: {\n                            vec: {\n                                defined: 'MerkleTreeSequenceNumber',\n                            },\n                        },\n                    },\n                    {\n                        name: 'relayFee',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'isCompress',\n                        type: 'bool',\n                    },\n                    {\n                        name: 'compressOrDecompressLamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'pubkeyArray',\n                        type: {\n                            vec: 'publicKey',\n                        },\n                    },\n                    {\n                        name: 'message',\n                        type: {\n                            option: 'bytes',\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'QueueIndex',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'queueId',\n                        docs: ['Id of queue in queue account.'],\n                        type: 'u8',\n                    },\n                    {\n                        name: 'index',\n                        docs: ['Index of compressed account hash in queue.'],\n                        type: 'u16',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'TokenData',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'mint',\n                        docs: ['The mint associated with this account'],\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'owner',\n                        docs: ['The owner of this account.'],\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'amount',\n                        docs: ['The amount of tokens this account holds.'],\n                        type: 'u64',\n                    },\n                    {\n                        name: 'delegate',\n                        docs: [\n                            'If `delegate` is `Some` then `delegated_amount` represents',\n                            'the amount authorized by the delegate',\n                        ],\n                        type: {\n                            option: 'publicKey',\n                        },\n                    },\n                    {\n                        name: 'state',\n                        docs: [\"The account's state\"],\n                        type: {\n                            defined: 'AccountState',\n                        },\n                    },\n                    {\n                        name: 'tlv',\n                        docs: [\n                            'Placeholder for TokenExtension tlv data (unimplemented)',\n                        ],\n                        type: {\n                            option: 'bytes',\n                        },\n                    },\n                ],\n            },\n        },\n    ],\n    errors: [\n        {\n            code: 6000,\n            name: 'PublicKeyAmountMissmatch',\n            msg: 'public keys and amounts must be of same length',\n        },\n        {\n            code: 6001,\n            name: 'ComputeInputSumFailed',\n            msg: 'ComputeInputSumFailed',\n        },\n        {\n            code: 6002,\n            name: 'ComputeOutputSumFailed',\n            msg: 'ComputeOutputSumFailed',\n        },\n        {\n            code: 6003,\n            name: 'ComputeCompressSumFailed',\n            msg: 'ComputeCompressSumFailed',\n        },\n        {\n            code: 6004,\n            name: 'ComputeDecompressSumFailed',\n            msg: 'ComputeDecompressSumFailed',\n        },\n        {\n            code: 6005,\n            name: 'SumCheckFailed',\n            msg: 'SumCheckFailed',\n        },\n        {\n            code: 6006,\n            name: 'DecompressRecipientUndefinedForDecompress',\n            msg: 'DecompressRecipientUndefinedForDecompress',\n        },\n        {\n            code: 6007,\n            name: 'CompressedPdaUndefinedForDecompress',\n            msg: 'CompressedPdaUndefinedForDecompress',\n        },\n        {\n            code: 6008,\n            name: 'DeCompressAmountUndefinedForDecompress',\n            msg: 'DeCompressAmountUndefinedForDecompress',\n        },\n        {\n            code: 6009,\n            name: 'CompressedPdaUndefinedForCompress',\n            msg: 'CompressedPdaUndefinedForCompress',\n        },\n        {\n            code: 6010,\n            name: 'DeCompressAmountUndefinedForCompress',\n            msg: 'DeCompressAmountUndefinedForCompress',\n        },\n        {\n            code: 6011,\n            name: 'DelegateSignerCheckFailed',\n            msg: 'DelegateSignerCheckFailed',\n        },\n        {\n            code: 6012,\n            name: 'MintTooLarge',\n            msg: 'Minted amount greater than u64::MAX',\n        },\n        {\n            code: 6013,\n            name: 'SplTokenSupplyMismatch',\n            msg: 'SplTokenSupplyMismatch',\n        },\n        {\n            code: 6014,\n            name: 'HeapMemoryCheckFailed',\n            msg: 'HeapMemoryCheckFailed',\n        },\n        {\n            code: 6015,\n            name: 'InstructionNotCallable',\n            msg: 'The instruction is not callable',\n        },\n        {\n            code: 6016,\n            name: 'ArithmeticUnderflow',\n            msg: 'ArithmeticUnderflow',\n        },\n        {\n            code: 6017,\n            name: 'HashToFieldError',\n            msg: 'HashToFieldError',\n        },\n        {\n            code: 6018,\n            name: 'InvalidAuthorityMint',\n            msg: 'Expected the authority to be also a mint authority',\n        },\n        {\n            code: 6019,\n            name: 'InvalidFreezeAuthority',\n            msg: 'Provided authority is not the freeze authority',\n        },\n        {\n            code: 6020,\n            name: 'InvalidDelegateIndex',\n        },\n        {\n            code: 6021,\n            name: 'TokenPoolPdaUndefined',\n        },\n        {\n            code: 6022,\n            name: 'IsTokenPoolPda',\n            msg: 'Compress or decompress recipient is the same account as the token pool pda.',\n        },\n        {\n            code: 6023,\n            name: 'InvalidTokenPoolPda',\n        },\n        {\n            code: 6024,\n            name: 'NoInputTokenAccountsProvided',\n        },\n        {\n            code: 6025,\n            name: 'NoInputsProvided',\n        },\n        {\n            code: 6026,\n            name: 'MintHasNoFreezeAuthority',\n        },\n        {\n            code: 6027,\n            name: 'MintWithInvalidExtension',\n        },\n        {\n            code: 6028,\n            name: 'InsufficientTokenAccountBalance',\n            msg: 'The token account balance is less than the remaining amount.',\n        },\n        {\n            code: 6029,\n            name: 'InvalidTokenPoolBump',\n            msg: 'Max number of token pools reached.',\n        },\n        {\n            code: 6030,\n            name: 'FailedToDecompress',\n        },\n        {\n            code: 6031,\n            name: 'FailedToBurnSplTokensFromTokenPool',\n        },\n        {\n            code: 6032,\n            name: 'NoMatchingBumpFound',\n        },\n    ],\n};\n","import {\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionInstruction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { CompressedTokenProgram } from '../program';\nimport {\n    Rpc,\n    buildAndSignTx,\n    sendAndConfirmTx,\n} from '@lightprotocol/stateless.js';\nimport { getTokenPoolInfos } from '../utils/get-token-pool-infos';\n\n/**\n * Register an existing mint with the CompressedToken program\n *\n * @param rpc             RPC connection to use\n * @param payer           Fee payer\n * @param mint            SPL Mint address\n * @param confirmOptions  Options for confirming the transaction\n * @param tokenProgramId  Optional: Address of the token program. Default:\n *                        TOKEN_PROGRAM_ID\n *\n * @return transaction signature\n */\nexport async function createTokenPool(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    tokenProgramId?: PublicKey,\n): Promise<TransactionSignature> {\n    tokenProgramId = tokenProgramId\n        ? tokenProgramId\n        : await CompressedTokenProgram.getMintProgramId(mint, rpc);\n\n    const ix = await CompressedTokenProgram.createTokenPool({\n        feePayer: payer.publicKey,\n        mint,\n        tokenProgramId,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n\n    const tx = buildAndSignTx([ix], payer, blockhash);\n\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return txId;\n}\n\n/**\n * Create additional token pools for an existing mint\n *\n * @param rpc                   RPC connection to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param numMaxAdditionalPools Number of additional token pools to create. Max\n *                              3.\n * @param confirmOptions        Optional: Options for confirming the transaction\n * @param tokenProgramId        Optional: Address of the token program. Default:\n *                              TOKEN_PROGRAM_ID\n *\n * @return transaction signature\n */\nexport async function addTokenPools(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    numMaxAdditionalPools: number,\n    confirmOptions?: ConfirmOptions,\n    tokenProgramId?: PublicKey,\n) {\n    tokenProgramId = tokenProgramId\n        ? tokenProgramId\n        : await CompressedTokenProgram.getMintProgramId(mint, rpc);\n    const instructions: TransactionInstruction[] = [];\n\n    const infos = (await getTokenPoolInfos(rpc, mint)).slice(0, 4);\n\n    // Get indices of uninitialized pools\n    const uninitializedIndices = [];\n    for (let i = 0; i < infos.length; i++) {\n        if (!infos[i].isInitialized) {\n            uninitializedIndices.push(i);\n        }\n    }\n\n    // Create instructions for requested number of pools\n    for (let i = 0; i < numMaxAdditionalPools; i++) {\n        if (i >= uninitializedIndices.length) {\n            break;\n        }\n\n        instructions.push(\n            await CompressedTokenProgram.addTokenPool({\n                mint,\n                feePayer: payer.publicKey,\n                tokenProgramId,\n                poolIndex: uninitializedIndices[i],\n            }),\n        );\n    }\n    const { blockhash } = await rpc.getLatestBlockhash();\n\n    const tx = buildAndSignTx(instructions, payer, blockhash);\n\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return txId;\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport {\n    bn,\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n} from '@lightprotocol/stateless.js';\nimport BN from 'bn.js';\nimport { CompressedTokenProgram } from '../program';\nimport {\n    selectMinCompressedTokenAccountsForTransfer,\n    selectTokenAccountsForApprove,\n} from '../utils';\n\n/**\n * Approve a delegate to spend tokens\n *\n * @param rpc                   Rpc to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param amount                Number of tokens to delegate\n * @param owner                 Owner of the SPL token account.\n * @param delegate              Address of the delegate\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approve(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    amount: number | BN,\n    owner: Signer,\n    delegate: PublicKey,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    amount = bn(amount);\n    const compressedTokenAccounts = await rpc.getCompressedTokenAccountsByOwner(\n        owner.publicKey,\n        {\n            mint,\n        },\n    );\n\n    const [inputAccounts] = selectTokenAccountsForApprove(\n        compressedTokenAccounts.items,\n        amount,\n    );\n\n    const proof = await rpc.getValidityProofV0(\n        inputAccounts.map(account => ({\n            hash: account.compressedAccount.hash,\n            tree: account.compressedAccount.treeInfo.tree,\n            queue: account.compressedAccount.treeInfo.queue,\n        })),\n    );\n\n    const ix = await CompressedTokenProgram.approve({\n        payer: payer.publicKey,\n        inputCompressedTokenAccounts: inputAccounts,\n        toAddress: delegate,\n        amount,\n        recentInputStateRootIndices: proof.rootIndices,\n        recentValidityProof: proof.compressedProof,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [owner]);\n    const signedTx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 350_000 }), ix],\n        payer,\n        blockhash,\n        additionalSigners,\n    );\n\n    return sendAndConfirmTx(rpc, signedTx, confirmOptions);\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport BN from 'bn.js';\nimport {\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n    selectStateTreeInfo,\n    toArray,\n    TreeInfo,\n} from '@lightprotocol/stateless.js';\nimport { CompressedTokenProgram } from '../program';\nimport { getOrCreateAssociatedTokenAccount } from '@solana/spl-token';\n\nimport {\n    getTokenPoolInfos,\n    selectTokenPoolInfo,\n    TokenPoolInfo,\n} from '../utils/get-token-pool-infos';\n\n/**\n * Mint compressed tokens to a solana address from an external mint authority\n *\n * @param rpc                   Rpc to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param toPubkey              Address of the account to mint to\n * @param authority             Minting authority\n * @param amount                Amount to mint\n * @param outputStateTreeInfo   Optional: State tree account that the compressed\n *                              tokens should be inserted into. Defaults to a\n *                              shared state tree account.\n * @param tokenPoolInfo         Optional: Token pool info.\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approveAndMintTo(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    toPubkey: PublicKey,\n    authority: Signer,\n    amount: number | BN,\n    outputStateTreeInfo?: TreeInfo,\n    tokenPoolInfo?: TokenPoolInfo,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    outputStateTreeInfo =\n        outputStateTreeInfo ??\n        selectStateTreeInfo(await rpc.getStateTreeInfos());\n    tokenPoolInfo =\n        tokenPoolInfo ??\n        selectTokenPoolInfo(await getTokenPoolInfos(rpc, mint));\n\n    const authorityTokenAccount = await getOrCreateAssociatedTokenAccount(\n        rpc,\n        payer,\n        mint,\n        authority.publicKey,\n        undefined,\n        undefined,\n        confirmOptions,\n        tokenPoolInfo.tokenProgram,\n    );\n\n    const ixs = await CompressedTokenProgram.approveAndMintTo({\n        feePayer: payer.publicKey,\n        mint,\n        authority: authority.publicKey,\n        authorityTokenAccount: authorityTokenAccount.address,\n        amount,\n        toPubkey,\n        outputStateTreeInfo,\n        tokenPoolInfo,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [authority]);\n\n    const tx = buildAndSignTx(\n        [\n            ComputeBudgetProgram.setComputeUnitLimit({\n                units: 150_000 + toArray(amount).length * 20_000,\n            }),\n            ...ixs,\n        ],\n        payer,\n        blockhash,\n        additionalSigners,\n    );\n\n    return await sendAndConfirmTx(rpc, tx, confirmOptions);\n}\n","import {\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n    ComputeBudgetProgram,\n} from '@solana/web3.js';\nimport {\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n    selectStateTreeInfo,\n    toArray,\n    TreeInfo,\n} from '@lightprotocol/stateless.js';\nimport BN from 'bn.js';\nimport { CompressedTokenProgram } from '../program';\nimport {\n    getTokenPoolInfos,\n    selectTokenPoolInfo,\n    TokenPoolInfo,\n} from '../utils/get-token-pool-infos';\n\n/**\n * Compress SPL tokens\n *\n * @param rpc                   Rpc connection to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param amount                Number of tokens to compress.\n * @param owner                 Owner of the SPL token account.\n * @param sourceTokenAccount    Source SPL token account. (ATA)\n * @param toAddress             Recipient owner address.\n * @param outputStateTreeInfo   Optional: State tree account that the compressed\n *                              tokens should be inserted into. Defaults to a\n *                              shared state tree account.\n * @param tokenPoolInfo         Optional: Token pool info.\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Signature of the confirmed transaction\n */\nexport async function compress(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    amount: number | BN | number[] | BN[],\n    owner: Signer,\n    sourceTokenAccount: PublicKey,\n    toAddress: PublicKey | Array<PublicKey>,\n    outputStateTreeInfo?: TreeInfo,\n    tokenPoolInfo?: TokenPoolInfo,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    outputStateTreeInfo =\n        outputStateTreeInfo ??\n        selectStateTreeInfo(await rpc.getStateTreeInfos());\n    tokenPoolInfo =\n        tokenPoolInfo ??\n        selectTokenPoolInfo(await getTokenPoolInfos(rpc, mint));\n\n    const compressIx = await CompressedTokenProgram.compress({\n        payer: payer.publicKey,\n        owner: owner.publicKey,\n        source: sourceTokenAccount,\n        toAddress,\n        amount,\n        mint,\n        outputStateTreeInfo,\n        tokenPoolInfo,\n    });\n\n    const blockhashCtx = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [owner]);\n    const signedTx = buildAndSignTx(\n        [\n            ComputeBudgetProgram.setComputeUnitLimit({\n                units: 130_000 + toArray(amount).length * 20_000,\n            }),\n            compressIx,\n        ],\n        payer,\n        blockhashCtx.blockhash,\n        additionalSigners,\n    );\n\n    return await sendAndConfirmTx(rpc, signedTx, confirmOptions, blockhashCtx);\n}\n","import {\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n    ComputeBudgetProgram,\n} from '@solana/web3.js';\nimport {\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n    selectStateTreeInfo,\n    TreeInfo,\n} from '@lightprotocol/stateless.js';\nimport BN from 'bn.js';\nimport {\n    getTokenPoolInfos,\n    selectTokenPoolInfo,\n    TokenPoolInfo,\n} from '../utils/get-token-pool-infos';\nimport { CompressedTokenProgram } from '../program';\n\n/**\n * Compress SPL tokens into compressed token format\n *\n * @param rpc                   Rpc connection to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param owner                 Owner of the token account\n * @param tokenAccount          Token account to compress\n * @param remainingAmount       Optional: amount to leave in token account.\n *                              Default: 0\n * @param outputStateTreeInfo   Optional: State tree account that the compressed\n *                              account into\n * @param tokenPoolInfo         Optional: Token pool info.\n * @param confirmOptions        Options for confirming the transaction\n\n *\n * @return Signature of the confirmed transaction\n */\nexport async function compressSplTokenAccount(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    owner: Signer,\n    tokenAccount: PublicKey,\n    remainingAmount?: BN,\n    outputStateTreeInfo?: TreeInfo,\n    tokenPoolInfo?: TokenPoolInfo,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    outputStateTreeInfo =\n        outputStateTreeInfo ??\n        selectStateTreeInfo(await rpc.getStateTreeInfos());\n    tokenPoolInfo =\n        tokenPoolInfo ??\n        selectTokenPoolInfo(await getTokenPoolInfos(rpc, mint));\n\n    const compressIx = await CompressedTokenProgram.compressSplTokenAccount({\n        feePayer: payer.publicKey,\n        authority: owner.publicKey,\n        tokenAccount,\n        mint,\n        remainingAmount,\n        outputStateTreeInfo,\n        tokenPoolInfo,\n    });\n\n    const blockhashCtx = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [owner]);\n\n    const signedTx = buildAndSignTx(\n        [\n            ComputeBudgetProgram.setComputeUnitLimit({\n                units: 150_000,\n            }),\n            compressIx,\n        ],\n        payer,\n        blockhashCtx.blockhash,\n        additionalSigners,\n    );\n\n    return await sendAndConfirmTx(rpc, signedTx, confirmOptions, blockhashCtx);\n}\n","import {\n    ConfirmOptions,\n    Keypair,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { CompressedTokenProgram } from '../program';\nimport {\n    MINT_SIZE,\n    TOKEN_2022_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n} from '@solana/spl-token';\nimport {\n    Rpc,\n    buildAndSignTx,\n    dedupeSigner,\n    sendAndConfirmTx,\n} from '@lightprotocol/stateless.js';\n\n/**\n * Create and initialize a new compressed token mint\n *\n * @param rpc               RPC connection to use\n * @param payer             Fee payer\n * @param mintAuthority     Account that will control minting\n * @param decimals          Location of the decimal place\n * @param keypair           Optional: Mint keypair. Defaults to a random\n *                          keypair.\n * @param confirmOptions    Options for confirming the transaction\n * @param tokenProgramId    Optional: Program ID for the token. Defaults to\n *                          TOKEN_PROGRAM_ID.\n * @param freezeAuthority   Optional: Account that will control freeze and thaw.\n *                          Defaults to none.\n *\n * @return Object with mint address and transaction signature\n */\nexport async function createMint(\n    rpc: Rpc,\n    payer: Signer,\n    mintAuthority: PublicKey | Signer,\n    decimals: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    tokenProgramId?: PublicKey | boolean,\n    freezeAuthority?: PublicKey | Signer,\n): Promise<{ mint: PublicKey; transactionSignature: TransactionSignature }> {\n    const rentExemptBalance =\n        await rpc.getMinimumBalanceForRentExemption(MINT_SIZE);\n\n    // If true, uses TOKEN_2022_PROGRAM_ID.\n    // If false or undefined, defaults to TOKEN_PROGRAM_ID.\n    // Otherwise, uses the provided tokenProgramId.\n    const resolvedTokenProgramId =\n        tokenProgramId === true\n            ? TOKEN_2022_PROGRAM_ID\n            : tokenProgramId || TOKEN_PROGRAM_ID;\n\n    const ixs = await CompressedTokenProgram.createMint({\n        feePayer: payer.publicKey,\n        mint: keypair.publicKey,\n        decimals,\n        authority:\n            'secretKey' in mintAuthority\n                ? mintAuthority.publicKey\n                : mintAuthority,\n        freezeAuthority:\n            freezeAuthority && 'secretKey' in freezeAuthority\n                ? freezeAuthority.publicKey\n                : (freezeAuthority ?? null),\n        rentExemptBalance,\n        tokenProgramId: resolvedTokenProgramId,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n\n    const additionalSigners = dedupeSigner(\n        payer,\n        [mintAuthority, freezeAuthority].filter(\n            (signer): signer is Signer =>\n                signer != undefined && 'secretKey' in signer,\n        ),\n    );\n\n    const tx = buildAndSignTx(ixs, payer, blockhash, [\n        ...additionalSigners,\n        keypair,\n    ]);\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return { mint: keypair.publicKey, transactionSignature: txId };\n}\n","import { PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport {\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n} from '@lightprotocol/stateless.js';\n\nimport { CompressedTokenProgram } from '../program';\n\n/**\n * Create a lookup table for the token program's default accounts\n *\n * @param rpc                   Rpc connection to use\n * @param payer                 Fee payer\n * @param authority             Authority of the lookup table\n * @param mints                 Optional array of mint public keys to include in\n *                              the lookup table\n * @param additionalAccounts    Optional array of additional account public keys\n *                              to include in the lookup table\n *\n * @return Object with transaction signatures and the address of the created\n *         lookup table\n */\nexport async function createTokenProgramLookupTable(\n    rpc: Rpc,\n    payer: Signer,\n    authority: Signer,\n    mints?: PublicKey[],\n    additionalAccounts?: PublicKey[],\n): Promise<{ txIds: TransactionSignature[]; address: PublicKey }> {\n    const recentSlot = await rpc.getSlot('finalized');\n    const { instructions, address } =\n        await CompressedTokenProgram.createTokenProgramLookupTable({\n            payer: payer.publicKey,\n            authority: authority.publicKey,\n            mints,\n            remainingAccounts: additionalAccounts,\n            recentSlot,\n        });\n\n    const additionalSigners = dedupeSigner(payer, [authority]);\n    const txIds = [];\n\n    for (const instruction of instructions) {\n        const blockhashCtx = await rpc.getLatestBlockhash();\n        const signedTx = buildAndSignTx(\n            [instruction],\n            payer,\n            blockhashCtx.blockhash,\n            additionalSigners,\n        );\n        const txId = await sendAndConfirmTx(\n            rpc,\n            signedTx,\n            { commitment: 'finalized' },\n            blockhashCtx,\n        );\n        txIds.push(txId);\n    }\n\n    return { txIds, address };\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport {\n    bn,\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n} from '@lightprotocol/stateless.js';\nimport BN from 'bn.js';\nimport { CompressedTokenProgram } from '../program';\nimport { selectMinCompressedTokenAccountsForTransfer } from '../utils';\nimport {\n    selectTokenPoolInfosForDecompression,\n    TokenPoolInfo,\n} from '../utils/get-token-pool-infos';\nimport { getTokenPoolInfos } from '../utils/get-token-pool-infos';\n\n/**\n * Decompress compressed tokens\n *\n * @param rpc                   Rpc connection to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param amount                Number of tokens to transfer\n * @param owner                 Owner of the compressed tokens\n * @param toAddress             Destination **uncompressed** token account\n *                              address. (ATA)\n * @param tokenPoolInfos        Optional: Token pool infos.\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return confirmed transaction signature\n */\nexport async function decompress(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    amount: number | BN,\n    owner: Signer,\n    toAddress: PublicKey,\n    tokenPoolInfos?: TokenPoolInfo[],\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    amount = bn(amount);\n\n    const compressedTokenAccounts = await rpc.getCompressedTokenAccountsByOwner(\n        owner.publicKey,\n        {\n            mint,\n        },\n    );\n\n    const [inputAccounts] = selectMinCompressedTokenAccountsForTransfer(\n        compressedTokenAccounts.items,\n        amount,\n    );\n\n    const proof = await rpc.getValidityProofV0(\n        inputAccounts.map(account => ({\n            hash: account.compressedAccount.hash,\n            tree: account.compressedAccount.treeInfo.tree,\n            queue: account.compressedAccount.treeInfo.queue,\n        })),\n    );\n\n    tokenPoolInfos = tokenPoolInfos ?? (await getTokenPoolInfos(rpc, mint));\n\n    const selectedTokenPoolInfos = selectTokenPoolInfosForDecompression(\n        tokenPoolInfos,\n        amount,\n    );\n\n    const ix = await CompressedTokenProgram.decompress({\n        payer: payer.publicKey,\n        inputCompressedTokenAccounts: inputAccounts,\n        toAddress,\n        amount,\n        tokenPoolInfos: selectedTokenPoolInfos,\n        recentInputStateRootIndices: proof.rootIndices,\n        recentValidityProof: proof.compressedProof,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [owner]);\n    const signedTx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 350_000 }), ix],\n        payer,\n        blockhash,\n        additionalSigners,\n    );\n    return await sendAndConfirmTx(rpc, signedTx, confirmOptions);\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport {\n    bn,\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n} from '@lightprotocol/stateless.js';\n\nimport BN from 'bn.js';\n\nimport { CompressedTokenProgram } from '../program';\nimport { selectMinCompressedTokenAccountsForTransfer } from '../utils';\nimport {\n    selectTokenPoolInfosForDecompression,\n    TokenPoolInfo,\n} from '../utils/get-token-pool-infos';\nimport { getTokenPoolInfos } from '../utils/get-token-pool-infos';\n\n/**\n * Decompress delegated compressed tokens. Remaining compressed tokens are\n * returned to the owner without delegation.\n *\n * @param rpc                   Rpc connection to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param amount                Number of tokens to decompress\n * @param owner                 Owner of the compressed tokens\n * @param toAddress             Destination **uncompressed** token account\n *                              address. (ATA)\n * @param tokenPoolInfos        Optional: Token pool infos.\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Signature of the confirmed transaction\n */\nexport async function decompressDelegated(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    amount: number | BN,\n    owner: Signer,\n    toAddress: PublicKey,\n    tokenPoolInfos?: TokenPoolInfo[],\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    amount = bn(amount);\n\n    const compressedTokenAccounts =\n        await rpc.getCompressedTokenAccountsByDelegate(owner.publicKey, {\n            mint,\n        });\n\n    const [inputAccounts] = selectMinCompressedTokenAccountsForTransfer(\n        compressedTokenAccounts.items,\n        amount,\n    );\n\n    const proof = await rpc.getValidityProofV0(\n        inputAccounts.map(account => ({\n            hash: account.compressedAccount.hash,\n            tree: account.compressedAccount.treeInfo.tree,\n            queue: account.compressedAccount.treeInfo.queue,\n        })),\n    );\n\n    const tokenPoolInfosToUse =\n        tokenPoolInfos ??\n        selectTokenPoolInfosForDecompression(\n            await getTokenPoolInfos(rpc, mint),\n            amount,\n        );\n\n    const ix = await CompressedTokenProgram.decompress({\n        payer: payer.publicKey,\n        inputCompressedTokenAccounts: inputAccounts,\n        toAddress,\n        amount,\n        recentInputStateRootIndices: proof.rootIndices,\n        recentValidityProof: proof.compressedProof,\n        tokenPoolInfos: tokenPoolInfosToUse,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [owner]);\n    const signedTx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 350_000 }), ix],\n        payer,\n        blockhash,\n        additionalSigners,\n    );\n\n    return sendAndConfirmTx(rpc, signedTx, confirmOptions);\n}\n","import { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { Buffer } from 'buffer';\nimport {\n    ValidityProof,\n    PackedMerkleContextLegacy,\n    CompressedCpiContext,\n} from '@lightprotocol/stateless.js';\nimport { TokenPoolInfo } from './utils/get-token-pool-infos';\n\nexport type TokenTransferOutputData = {\n    /**\n     * The owner of the output token account\n     */\n    owner: PublicKey;\n    /**\n     * The amount of tokens of the output token account\n     */\n    amount: BN;\n    /**\n     * lamports associated with the output token account\n     */\n    lamports: BN | null;\n    /**\n     * TokenExtension tlv\n     */\n    tlv: Buffer | null;\n};\n\nexport type PackedTokenTransferOutputData = {\n    /**\n     * The owner of the output token account\n     */\n    owner: PublicKey;\n    /**\n     * The amount of tokens of the output token account\n     */\n    amount: BN;\n    /**\n     * lamports associated with the output token account\n     */\n    lamports: BN | null;\n    /**\n     * Merkle tree pubkey index in remaining accounts\n     */\n    merkleTreeIndex: number;\n    /**\n     * TokenExtension tlv\n     */\n    tlv: Buffer | null;\n};\n\nexport type InputTokenDataWithContext = {\n    amount: BN;\n    delegateIndex: number | null;\n    merkleContext: PackedMerkleContextLegacy;\n    rootIndex: number;\n    lamports: BN | null;\n    tlv: Buffer | null;\n};\n\nexport type DelegatedTransfer = {\n    owner: PublicKey;\n    delegateChangeAccountIndex: number | null;\n};\n\nexport type BatchCompressInstructionData = {\n    pubkeys: PublicKey[];\n    amounts: BN[] | null;\n    lamports: BN | null;\n    amount: BN | null;\n    index: number;\n    bump: number;\n};\n\nexport type MintToInstructionData = {\n    recipients: PublicKey[];\n    amounts: BN[];\n    lamports: BN | null;\n};\nexport type CompressSplTokenAccountInstructionData = {\n    owner: PublicKey;\n    remainingAmount: BN | null;\n    cpiContext: CompressedCpiContext | null;\n};\n\nexport function isSingleTokenPoolInfo(\n    tokenPoolInfos: TokenPoolInfo | TokenPoolInfo[],\n): tokenPoolInfos is TokenPoolInfo {\n    return !Array.isArray(tokenPoolInfos);\n}\n\nexport type CompressedTokenInstructionDataTransfer = {\n    /**\n     * Validity proof\n     */\n    proof: ValidityProof | null;\n    /**\n     * The mint of the transfer\n     */\n    mint: PublicKey;\n    /**\n     * Whether the signer is a delegate\n     */\n    delegatedTransfer: DelegatedTransfer | null;\n    /**\n     * Input token data with packed merkle context\n     */\n    inputTokenDataWithContext: InputTokenDataWithContext[];\n    /**\n     * Data of the output token accounts\n     */\n    outputCompressedAccounts: PackedTokenTransferOutputData[];\n    /**\n     * Whether it's a compress or decompress action if compressOrDecompressAmount is non-null\n     */\n    isCompress: boolean;\n    /**\n     * If null, it's a transfer.\n     * If some, the amount that is being deposited into (compress) or withdrawn from (decompress) the token escrow\n     */\n    compressOrDecompressAmount: BN | null;\n    /**\n     * CPI context if\n     */\n    cpiContext: CompressedCpiContext | null;\n    /**\n     * The index of the Merkle tree for a lamport change account.\n     */\n    lamportsChangeAccountMerkleTreeIndex: number | null;\n};\n\nexport type TokenData = {\n    /**\n     * The mint associated with this account\n     */\n    mint: PublicKey;\n    /**\n     * The owner of this account\n     */\n    owner: PublicKey;\n    /**\n     * The amount of tokens this account holds\n     */\n    amount: BN;\n    /**\n     * If `delegate` is `Some` then `delegated_amount` represents the amount\n     * authorized by the delegate\n     */\n    delegate: PublicKey | null;\n    /**\n     * The account's state\n     */\n    state: number;\n    /**\n     * TokenExtension tlv\n     */\n    tlv: Buffer | null;\n};\n\nexport type CompressedTokenInstructionDataApprove = {\n    proof: ValidityProof | null;\n    mint: PublicKey;\n    inputTokenDataWithContext: InputTokenDataWithContext[];\n    cpiContext: CompressedCpiContext | null;\n    delegate: PublicKey;\n    delegatedAmount: BN;\n    delegateMerkleTreeIndex: number;\n    changeAccountMerkleTreeIndex: number;\n    delegateLamports: BN | null;\n};\n\nexport type CompressedTokenInstructionDataRevoke = {\n    proof: ValidityProof | null;\n    mint: PublicKey;\n    inputTokenDataWithContext: InputTokenDataWithContext[];\n    cpiContext: CompressedCpiContext | null;\n    outputAccountMerkleTreeIndex: number;\n};\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport {\n    Rpc,\n    dedupeSigner,\n    buildAndSignTx,\n    sendAndConfirmTx,\n    bn,\n} from '@lightprotocol/stateless.js';\nimport { CompressedTokenProgram } from '../program';\n\n/**\n * Merge multiple compressed token accounts for a given mint into a single\n * account\n *\n * @param rpc                   RPC connection to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param owner                 Owner of the token accounts to be merged\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return confirmed transaction signature\n */\nexport async function mergeTokenAccounts(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    owner: Signer,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    const compressedTokenAccounts = await rpc.getCompressedTokenAccountsByOwner(\n        owner.publicKey,\n        { mint },\n    );\n\n    if (compressedTokenAccounts.items.length === 0) {\n        throw new Error(\n            `No compressed token accounts found for mint ${mint.toBase58()}`,\n        );\n    }\n\n    const instructions = [\n        ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }),\n    ];\n\n    for (\n        let i = 0;\n        i < compressedTokenAccounts.items.slice(0, 8).length;\n        i += 4\n    ) {\n        const batch = compressedTokenAccounts.items.slice(i, i + 4);\n\n        const proof = await rpc.getValidityProof(\n            batch.map(account => bn(account.compressedAccount.hash)),\n        );\n\n        const batchInstructions =\n            await CompressedTokenProgram.mergeTokenAccounts({\n                payer: payer.publicKey,\n                owner: owner.publicKey,\n                inputCompressedTokenAccounts: batch,\n                mint,\n                recentValidityProof: proof.compressedProof,\n                recentInputStateRootIndices: proof.rootIndices,\n            });\n\n        instructions.push(...batchInstructions);\n    }\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [owner]);\n\n    const signedTx = buildAndSignTx(\n        instructions,\n        payer,\n        blockhash,\n        additionalSigners,\n    );\n\n    return sendAndConfirmTx(rpc, signedTx, confirmOptions);\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport BN from 'bn.js';\nimport {\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n    selectStateTreeInfo,\n    TreeInfo,\n} from '@lightprotocol/stateless.js';\nimport { CompressedTokenProgram } from '../program';\nimport {\n    getTokenPoolInfos,\n    selectTokenPoolInfo,\n    TokenPoolInfo,\n} from '../utils/get-token-pool-infos';\n\n/**\n * Mint compressed tokens to a solana address\n *\n * @param rpc                   Rpc connection to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param toPubkey              Address of the account to mint to. Can be an\n *                              array of addresses if the amount is an array of\n *                              amounts.\n * @param authority             Mint authority\n * @param amount                Amount to mint. Pass an array of amounts if the\n *                              toPubkey is an array of addresses.\n * @param outputStateTreeInfo   Optional: State tree account that the compressed\n *                              tokens should be part of. Defaults to the\n *                              default state tree account.\n * @param tokenPoolInfo         Optional: Token pool information\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintTo(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    toPubkey: PublicKey | PublicKey[],\n    authority: Signer,\n    amount: number | BN | number[] | BN[],\n    outputStateTreeInfo?: TreeInfo,\n    tokenPoolInfo?: TokenPoolInfo,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    outputStateTreeInfo =\n        outputStateTreeInfo ??\n        selectStateTreeInfo(await rpc.getStateTreeInfos());\n    tokenPoolInfo =\n        tokenPoolInfo ??\n        selectTokenPoolInfo(await getTokenPoolInfos(rpc, mint));\n\n    const ix = await CompressedTokenProgram.mintTo({\n        feePayer: payer.publicKey,\n        mint,\n        authority: authority.publicKey,\n        amount,\n        toPubkey,\n        outputStateTreeInfo,\n        tokenPoolInfo,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [authority]);\n\n    const tx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix],\n        payer,\n        blockhash,\n        additionalSigners,\n    );\n\n    return sendAndConfirmTx(rpc, tx, confirmOptions);\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport {\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n    ParsedTokenAccount,\n} from '@lightprotocol/stateless.js';\nimport { CompressedTokenProgram } from '../program';\n\n/**\n * Revoke one or more delegated token accounts\n *\n * @param rpc                   Rpc connection to use\n * @param payer                 Fee payer\n * @param accounts              Delegated compressed token accounts to revoke\n * @param owner                 Owner of the compressed tokens\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Signature of the confirmed transaction\n */\nexport async function revoke(\n    rpc: Rpc,\n    payer: Signer,\n    accounts: ParsedTokenAccount[],\n    owner: Signer,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    const proof = await rpc.getValidityProofV0(\n        accounts.map(account => ({\n            hash: account.compressedAccount.hash,\n            tree: account.compressedAccount.treeInfo.tree,\n            queue: account.compressedAccount.treeInfo.queue,\n        })),\n    );\n    checkOwner(owner, accounts);\n    checkIsDelegated(accounts);\n\n    const ix = await CompressedTokenProgram.revoke({\n        payer: payer.publicKey,\n        inputCompressedTokenAccounts: accounts,\n        recentInputStateRootIndices: proof.rootIndices,\n        recentValidityProof: proof.compressedProof,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [owner]);\n    const signedTx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 500_000 }), ix],\n        payer,\n        blockhash,\n        additionalSigners,\n    );\n\n    return sendAndConfirmTx(rpc, signedTx, confirmOptions);\n}\n\nfunction checkOwner(owner: Signer, accounts: ParsedTokenAccount[]) {\n    if (!owner.publicKey.equals(accounts[0].parsed.owner)) {\n        throw new Error(\n            `Owner ${owner.publicKey.toBase58()} does not match account ${accounts[0].parsed.owner.toBase58()}`,\n        );\n    }\n}\n\nfunction checkIsDelegated(accounts: ParsedTokenAccount[]) {\n    if (accounts.some(account => account.parsed.delegate === null)) {\n        throw new Error('Account is not delegated');\n    }\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport {\n    bn,\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n    StateTreeInfo,\n    selectStateTreeInfo,\n} from '@lightprotocol/stateless.js';\nimport BN from 'bn.js';\nimport { CompressedTokenProgram } from '../program';\nimport { selectMinCompressedTokenAccountsForTransfer } from '../utils';\n\n/**\n * Transfer compressed tokens from one owner to another\n *\n * @param rpc                   Rpc connection to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param amount                Number of tokens to transfer\n * @param owner                 Owner of the compressed tokens\n * @param toAddress             Destination address of the recipient\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return confirmed transaction signature\n */\nexport async function transfer(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    amount: number | BN,\n    owner: Signer,\n    toAddress: PublicKey,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    amount = bn(amount);\n    const compressedTokenAccounts = await rpc.getCompressedTokenAccountsByOwner(\n        owner.publicKey,\n        {\n            mint,\n        },\n    );\n\n    const [inputAccounts] = selectMinCompressedTokenAccountsForTransfer(\n        compressedTokenAccounts.items,\n        amount,\n    );\n\n    const proof = await rpc.getValidityProofV0(\n        inputAccounts.map(account => ({\n            hash: account.compressedAccount.hash,\n            tree: account.compressedAccount.treeInfo.tree,\n            queue: account.compressedAccount.treeInfo.queue,\n        })),\n    );\n\n    const ix = await CompressedTokenProgram.transfer({\n        payer: payer.publicKey,\n        inputCompressedTokenAccounts: inputAccounts,\n        toAddress,\n        amount,\n        recentInputStateRootIndices: proof.rootIndices,\n        recentValidityProof: proof.compressedProof,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [owner]);\n    const signedTx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 500_000 }), ix],\n        payer,\n        blockhash,\n        additionalSigners,\n    );\n\n    return sendAndConfirmTx(rpc, signedTx, confirmOptions);\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport {\n    bn,\n    sendAndConfirmTx,\n    buildAndSignTx,\n    Rpc,\n    dedupeSigner,\n} from '@lightprotocol/stateless.js';\nimport BN from 'bn.js';\nimport { CompressedTokenProgram } from '../program';\nimport { selectMinCompressedTokenAccountsForTransfer } from '../utils';\n\n/**\n * Transfer delegated compressed tokens to another owner\n *\n * @param rpc                   Rpc connection to use\n * @param payer                 Fee payer\n * @param mint                  SPL Mint address\n * @param amount                Number of tokens to transfer\n * @param owner                 Owner of the compressed tokens\n * @param toAddress             Destination address of the recipient\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return confirmed transaction signature\n */\nexport async function transferDelegated(\n    rpc: Rpc,\n    payer: Signer,\n    mint: PublicKey,\n    amount: number | BN,\n    owner: Signer,\n    toAddress: PublicKey,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    amount = bn(amount);\n    const compressedTokenAccounts =\n        await rpc.getCompressedTokenAccountsByDelegate(owner.publicKey, {\n            mint,\n        });\n\n    const [inputAccounts] = selectMinCompressedTokenAccountsForTransfer(\n        compressedTokenAccounts.items,\n        amount,\n    );\n\n    const proof = await rpc.getValidityProofV0(\n        inputAccounts.map(account => ({\n            hash: account.compressedAccount.hash,\n            tree: account.compressedAccount.treeInfo.tree,\n            queue: account.compressedAccount.treeInfo.queue,\n        })),\n    );\n\n    const ix = await CompressedTokenProgram.transfer({\n        payer: payer.publicKey,\n        inputCompressedTokenAccounts: inputAccounts,\n        toAddress,\n        amount,\n        recentInputStateRootIndices: proof.rootIndices,\n        recentValidityProof: proof.compressedProof,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const additionalSigners = dedupeSigner(payer, [owner]);\n    const signedTx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 500_000 }), ix],\n        payer,\n        blockhash,\n        additionalSigners,\n    );\n\n    return sendAndConfirmTx(rpc, signedTx, confirmOptions);\n}\n"],"names":["POOL_SEED","Buffer","from","CPI_AUTHORITY_SEED","CREATE_TOKEN_POOL_DISCRIMINATOR","MINT_TO_DISCRIMINATOR","BATCH_COMPRESS_DISCRIMINATOR","TRANSFER_DISCRIMINATOR","COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR","APPROVE_DISCRIMINATOR","REVOKE_DISCRIMINATOR","ADD_TOKEN_POOL_DISCRIMINATOR","checkTokenPoolInfo","tokenPoolInfo","mint","equals","Error","isInitialized","toBase58","async","getTokenPoolInfos","rpc","commitment","addressesAndBumps","Array","length","_","i","CompressedTokenProgram","deriveTokenPoolPdaWithIndex","accountInfos","getMultipleAccountsInfo","map","addressAndBump","parsedInfos","unpackAccount","owner","tokenProgram","parsedInfo","tokenPoolPda","address","activity","undefined","balance","bn","amount","toString","poolIndex","bump","Action","shuffleArray","array","j","Math","floor","random","selectTokenPoolInfo","infos","filteredInfos","filter","info","selectTokenPoolInfosForDecompression","decompressAmount","sufficientBalanceInfo","find","gte","mul","sort","a","b","every","isZero","ERROR_NO_ACCOUNTS_FOUND","selectTokenAccountsForApprove","accounts","approveAmount","maxInputs","exactMatch","account","parsed","eq","compressedAccount","lamports","selectMinCompressedTokenAccountsForTransfer","transferAmount","selectedAccounts","accumulatedAmount","accumulatedLamports","maxPossibleAmount","selectMinCompressedTokenAccountsForTransferOrPartial","lt","totalBalance","reduce","acc","add","cmp","push","slice","total","console","log","selectSmartCompressedTokenAccountsForTransferOrPartial","nonZeroAccounts","remainingAccounts","smallestAccount","min","max","packCompressedTokenAccounts","params","inputCompressedTokenAccounts","outputStateTreeInfo","rootIndices","tokenTransferOutputs","_remainingAccounts","delegateIndex","delegate","getIndexOrAdd","packedInputTokenData","forEach","index","merkleTreePubkeyIndex","treeInfo","tree","queuePubkeyIndex","queue","merkleContext","leafIndex","proveByIndex","rootIndex","tlv","activeTreeInfo","nextTreeInfo","activeTreeOrQueue","treeType","TreeType","StateV2","featureFlags","isV2","paddedOutputStateMerkleTrees","padOutputStateMerkleTrees","packedOutputTokenData","merkleTreeIndex","_a","remainingAccountMetas","pubkey","isWritable","isSigner","inputTokenDataWithContext","checkMint","compressedTokenAccounts","CompressedProofLayout","struct","u8","PackedTokenTransferOutputDataLayout","publicKey","u64","option","vecU8","InputTokenDataWithContextLayout","u32","bool","u16","DelegatedTransferLayout","CpiContextLayout","CompressedTokenInstructionDataTransferLayout","vec","mintToLayout","batchCompressLayout","compressSplTokenAccountInstructionDataLayout","encodeMintToInstructionData","data","buffer","alloc","len","encode","recipients","amounts","concat","Uint8Array","subarray","encodeBatchCompressInstructionData","lengthBuffer","writeUInt32LE","dataBuffer","encodeCompressSplTokenAccountInstructionData","remainingAmount","cpiContext","encodeTransferInstructionData","createTokenPoolAccountsLayout","feePayer","systemProgram","cpiAuthorityPda","addTokenPoolAccountsLayout","existingTokenPoolPda","mintToAccountsLayout","defaultPubkey","programId","authority","lightSystemProgram","registeredProgramPda","noopProgram","accountCompressionAuthority","accountCompressionProgram","merkleTree","selfProgram","solPoolPda","transferAccountsLayout","compressOrDecompressTokenAccount","approveAccountsLayout","revokeAccountsLayout","freezeAccountsLayout","thawAccountsLayout","CompressedTokenInstructionDataApproveLayout","CompressedTokenInstructionDataRevokeLayout","emptyProof","fill","c","isEmptyProof","proof","encodeApproveInstructionData","proofOption","Object","assign","encodeRevokeInstructionData","sumUpTokenAmount","validateSameTokenOwner","parseTokenData","currentOwner","parseMaybeDelegatedTransfer","inputs","outputs","delegatedAccountsIndex","findIndex","delegatedTransfer","delegateChangeAccountIndex","createTransferOutputState","toAddress","inputAmount","inputLamports","sumUpLamports","changeAmount","sub","validateSufficientBalance","validateSameOwner","createDecompressOutputState","constructor","setProgramId","this","PublicKey","deriveTokenPoolPda","seeds","toBuffer","findProgramAddressSync","findTokenPoolIndexAndBump","poolPda","derivedPda","deriveCpiAuthorityPda","createMint","freezeAuthority","decimals","rentExemptBalance","tokenProgramId","mintSize","TOKEN_PROGRAM_ID","SystemProgram","createAccount","fromPubkey","newAccountPubkey","space","MINT_SIZE","createInitializeMint2Instruction","createTokenPool","keys","TransactionInstruction","addTokenPool","mintTo","toPubkey","systemKeys","defaultStaticAccountsStruct","toArray","toPubkeys","LightSystemProgram","approveAndMintTo","authorityTokenAccount","amountBigInt","BigInt","createMintToInstruction","compress","payer","source","transfer","recentValidityProof","recentInputStateRootIndices","outputCompressedAccounts","compressOrDecompressAmount","isCompress","lamportsChangeAccountMerkleTreeIndex","createTokenProgramLookupTable","mints","recentSlot","createInstruction","lookupTableAddress","AddressLookupTableProgram","createLookupTable","optionalMintKeys","instructions","extendLookupTable","lookupTable","addresses","ComputeBudgetProgram","defaultTestStateTreeAccounts","nullifierQueue","addressTree","addressQueue","TOKEN_2022_PROGRAM_ID","chunk","extendIx","amountArray","toAddressArray","pubkeys","amt","amountBN","isArray","sum","decompress","tokenPoolInfos","tokenPoolInfosArray","mergeTokenAccounts","compressSplTokenAccount","tokenAccount","getMintProgramId","connection","getAccountInfo","approve","CHANGE_INDEX","delegatedAmount","delegateMerkleTreeIndex","changeAccountMerkleTreeIndex","delegateLamports","revoke","outputAccountMerkleTreeIndex","version","name","docs","isMut","args","type","isOptional","defined","types","kind","variants","fields","errors","code","msg","numMaxAdditionalPools","confirmOptions","uninitializedIndices","blockhash","getLatestBlockhash","tx","buildAndSignTx","sendAndConfirmTx","getCompressedTokenAccountsByOwner","inputAccounts","items","getValidityProofV0","hash","ix","compressedProof","additionalSigners","dedupeSigner","signedTx","setComputeUnitLimit","units","selectStateTreeInfo","getStateTreeInfos","getOrCreateAssociatedTokenAccount","ixs","sourceTokenAccount","compressIx","blockhashCtx","mintAuthority","keypair","Keypair","generate","getMinimumBalanceForRentExemption","resolvedTokenProgramId","signer","txId","transactionSignature","additionalAccounts","getSlot","txIds","instruction","decode","selectedTokenPoolInfos","getCompressedTokenAccountsByDelegate","tokenPoolInfosToUse","batch","getValidityProof","batchInstructions","checkOwner","some","checkIsDelegated","totalLamports"],"mappings":"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"}