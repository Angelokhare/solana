"use strict";var e=require("@solana/web3.js"),t=require("@lightprotocol/stateless.js"),o=require("buffer"),n=require("@solana/spl-token"),r=require("@coral-xyz/borsh");const s=o.Buffer.from("pool"),a=o.Buffer.from("cpi_authority"),i=o.Buffer.from([23,169,27,122,147,169,209,152]),u=o.Buffer.from([241,34,48,186,37,179,123,192]),c=o.Buffer.from([65,206,101,37,147,42,221,144]),m=o.Buffer.from([163,52,200,231,140,3,69,186]),p=o.Buffer.from([112,230,105,101,145,202,157,97]),d=o.Buffer.from([69,74,217,36,115,117,97,76]),l=o.Buffer.from([170,23,31,34,133,173,93,242]),g=o.Buffer.from([114,143,210,73,96,115,1,228]);function y(e,t){if(!e.mint.equals(t))throw new Error("TokenPool mint does not match the provided mint.");if(!e.isInitialized)throw new Error(`TokenPool is not initialized. Please create a compressed token pool for mint: ${t.toBase58()} via createTokenPool().`);return 1}async function f(e,o,r){const s=Array.from({length:5},((e,t)=>ie.deriveTokenPoolPdaWithIndex(o,t))),a=await e.getMultipleAccountsInfo(s.map((e=>e[0])),r);if(null===a[0])throw new Error(`TokenPool not found. Please create a compressed token pool for mint: ${o.toBase58()} via createTokenPool().`);const i=s.map(((e,t)=>a[t]?n.unpackAccount(e[0],a[t],a[t].owner):null)),u=a[0].owner;return i.map(((e,n)=>e?{mint:o,tokenPoolPda:e.address,tokenProgram:u,activity:void 0,balance:t.bn(e.amount.toString()),isInitialized:1,poolIndex:n,bump:s[n][1]}:{mint:o,tokenPoolPda:s[n][0],tokenProgram:u,activity:void 0,balance:t.bn(0),isInitialized:0,poolIndex:n,bump:s[n][1]}))}var h;exports.Action=void 0,(h=exports.Action||(exports.Action={}))[h.Compress=1]="Compress",h[h.Decompress=2]="Decompress",h[h.Transfer=3]="Transfer";const P=e=>{for(let t=e.length-1;t>0;t--){const o=Math.floor(Math.random()*(t+1));[e[t],e[o]]=[e[o],e[t]]}return e};function k(e){const t=P(e).filter((e=>e.isInitialized));if(0===t.length)throw new Error("Please pass at least one initialized token pool info.");return t[0]}function b(e,o){if(0===e.length)throw new Error("Please pass at least one token pool info.");const n=(e=P(e)).find((e=>e.balance.gte(t.bn(o).mul(t.bn(10)))));if((e=e.filter((e=>e.isInitialized)).sort(((e,t)=>e.poolIndex-t.poolIndex))).every((e=>e.balance.isZero())))throw new Error("All provided token pool balances are zero. Please pass recent token pool infos.");return n?[n]:e}const A="Could not find accounts to select for transfer.";function S(e,t,o=4){const n=e.find((e=>e.parsed.amount.eq(t)));return n?[[n],n.parsed.amount,n.compressedAccount.lamports,n.parsed.amount]:T(e,t,o)}function T(e,o,n=4){const[r,s,a,i]=I(e,o,n);if(s.lt(t.bn(o))){const s=e.reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0));throw r.length>=n?new Error(`Account limit exceeded: max ${i.toString()} (${n} accounts) per transaction. Total balance: ${s.toString()} (${e.length} accounts). Consider multiple transfers to spend full balance.`):new Error(`Insufficient balance for transfer. Required: ${o.toString()}, available: ${s.toString()}.`)}if(0===r.length)throw new Error(A);return[r,s,a,i]}function I(e,o,n=4){if(0===e.length)throw new Error(A);let r=t.bn(0),s=t.bn(0),a=t.bn(0);const i=[];e.sort(((e,t)=>t.parsed.amount.cmp(e.parsed.amount)));for(const a of e){if(i.length>=n)break;if(r.gte(t.bn(o)))break;a.parsed.amount.isZero()&&a.compressedAccount.lamports.isZero()||(r=r.add(a.parsed.amount),s=s.add(a.compressedAccount.lamports),i.push(a))}if(a=e.slice(0,n).reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0)),r.lt(t.bn(o))&&console.log(`Insufficient balance for transfer. Requested: ${o.toString()}, Returns max available: ${a.toString()}.`),0===i.length)throw new Error(A);return[i,r,s,a]}function C(e,o,n=4){if(0===e.length)throw new Error(A);let r=t.bn(0),s=t.bn(0);const a=[],i=e.filter((e=>!e.parsed.amount.isZero()||!e.compressedAccount.lamports.isZero()));i.sort(((e,t)=>t.parsed.amount.cmp(e.parsed.amount)));for(const e of i){if(a.length>=n)break;if(r=r.add(e.parsed.amount),s=s.add(e.compressedAccount.lamports),a.push(e),r.gte(t.bn(o))){const e=i.slice(a.length);if(e.length>0){const t=e.reduce(((e,t)=>t.parsed.amount.lt(e.parsed.amount)?t:e));a.length<n&&(a.push(t),r=r.add(t.parsed.amount),s=s.add(t.compressedAccount.lamports))}break}}const u=i.slice(0,n).reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0));if(0===a.length)throw new Error(A);return[a,r,s,u]}function x(e){const{inputCompressedTokenAccounts:o,outputStateTreeInfo:n,remainingAccounts:r=[],rootIndices:s,tokenTransferOutputs:a}=e,i=r.slice();let u=null;o.length>0&&o[0].parsed.delegate&&(u=t.getIndexOrAdd(i,o[0].parsed.delegate));const c=[];if(o.forEach(((e,o)=>{const n=t.getIndexOrAdd(i,e.compressedAccount.treeInfo.tree),r=t.getIndexOrAdd(i,e.compressedAccount.treeInfo.queue);c.push({amount:e.parsed.amount,delegateIndex:u,merkleContext:{merkleTreePubkeyIndex:n,queuePubkeyIndex:r,leafIndex:e.compressedAccount.leafIndex,proveByIndex:e.compressedAccount.proveByIndex},rootIndex:s[o],lamports:e.compressedAccount.lamports.eq(t.bn(0))?null:e.compressedAccount.lamports,tlv:null})})),o.length>0&&n)throw new Error("Cannot specify both input accounts and outputStateTreeInfo");let m;if(o.length>0)m=o[0].compressedAccount.treeInfo;else{if(!n)throw new Error("Neither input accounts nor outputStateTreeInfo are available");m=n}const p=m.nextTreeInfo||m;let d=p.tree;if(p.treeType===t.TreeType.StateV2){if(!t.featureFlags.isV2())throw new Error("V2 trees are not supported yet");d=p.queue}const l=t.padOutputStateMerkleTrees(d,a.length),g=[];l.forEach(((e,o)=>{var n;const r=t.getIndexOrAdd(i,e);g.push({owner:a[o].owner,amount:a[o].amount,lamports:(null===(n=a[o].lamports)||void 0===n?void 0:n.eq(t.bn(0)))?null:a[o].lamports,merkleTreeIndex:r,tlv:null})}));const y=i.map((e=>({pubkey:e,isWritable:1,isSigner:0})));return{inputTokenDataWithContext:c,remainingAccountMetas:y,packedOutputTokenData:g}}function w(e,t){if(!e.every((e=>e.parsed.mint.equals(t))))throw new Error("All input accounts must belong to the same mint");return 1}const M=r.struct([r.array(r.u8(),32,"a"),r.array(r.u8(),64,"b"),r.array(r.u8(),32,"c")]),v=r.struct([r.publicKey("owner"),r.u64("amount"),r.option(r.u64(),"lamports"),r.u8("merkleTreeIndex"),r.option(r.vecU8(),"tlv")]),D=r.struct([r.u64("amount"),r.option(r.u8(),"delegateIndex"),r.struct([r.u8("merkleTreePubkeyIndex"),r.u8("queuePubkeyIndex"),r.u32("leafIndex"),r.bool("proveByIndex")],"merkleContext"),r.u16("rootIndex"),r.option(r.u64(),"lamports"),r.option(r.vecU8(),"tlv")]),O=r.struct([r.publicKey("owner"),r.option(r.u8(),"delegateChangeAccountIndex")]),W=r.struct([r.bool("setContext"),r.bool("firstSetContext"),r.u8("cpiContextAccountIndex")]),E=r.struct([r.option(M,"proof"),r.publicKey("mint"),r.option(O,"delegatedTransfer"),r.vec(D,"inputTokenDataWithContext"),r.vec(v,"outputCompressedAccounts"),r.bool("isCompress"),r.option(r.u64(),"compressOrDecompressAmount"),r.option(W,"cpiContext"),r.option(r.u8(),"lamportsChangeAccountMerkleTreeIndex")]),B=r.struct([r.vec(r.publicKey(),"recipients"),r.vec(r.u64(),"amounts"),r.option(r.u64(),"lamports")]),K=r.struct([r.vec(r.publicKey(),"pubkeys"),r.option(r.vec(r.u64(),"amounts"),"amounts"),r.option(r.u64(),"lamports"),r.option(r.u64(),"amount"),r.u8("index"),r.u8("bump")]),L=r.struct([r.publicKey("owner"),r.option(r.u64(),"remainingAmount"),r.option(W,"cpiContext")]);function R(e){const t=o.Buffer.alloc(1e3),n=B.encode({recipients:e.recipients,amounts:e.amounts,lamports:e.lamports},t);return o.Buffer.concat([new Uint8Array(u),new Uint8Array(t.subarray(0,n))])}function U(e){const t=o.Buffer.alloc(1e3),n=K.encode(e,t),r=o.Buffer.alloc(4);r.writeUInt32LE(n,0);const s=t.subarray(0,n);return o.Buffer.concat([new Uint8Array(c),new Uint8Array(r),new Uint8Array(s)])}function N(e){const t=o.Buffer.alloc(1e3),n=L.encode({owner:e.owner,remainingAmount:e.remainingAmount,cpiContext:e.cpiContext},t);return o.Buffer.concat([new Uint8Array(p),new Uint8Array(t.subarray(0,n))])}function q(e){const t=o.Buffer.alloc(1e3),n=E.encode(e,t),r=o.Buffer.alloc(4);r.writeUInt32LE(n,0);const s=t.subarray(0,n);return o.Buffer.concat([new Uint8Array(m),new Uint8Array(r),new Uint8Array(s)])}const F=e=>{const{feePayer:t,tokenPoolPda:o,systemProgram:n,mint:r,tokenProgram:s,cpiAuthorityPda:a}=e;return[{pubkey:t,isSigner:1,isWritable:1},{pubkey:o,isSigner:0,isWritable:1},{pubkey:n,isSigner:0,isWritable:0},{pubkey:r,isSigner:0,isWritable:1},{pubkey:s,isSigner:0,isWritable:0},{pubkey:a,isSigner:0,isWritable:0}]},_=e=>{const{feePayer:t,tokenPoolPda:o,systemProgram:n,mint:r,tokenProgram:s,cpiAuthorityPda:a,existingTokenPoolPda:i}=e;return[{pubkey:t,isSigner:1,isWritable:1},{pubkey:o,isSigner:0,isWritable:1},{pubkey:i,isSigner:0,isWritable:0},{pubkey:n,isSigner:0,isWritable:0},{pubkey:r,isSigner:0,isWritable:1},{pubkey:s,isSigner:0,isWritable:0},{pubkey:a,isSigner:0,isWritable:0}]},V=e=>{const t=ie.programId,{feePayer:o,authority:n,cpiAuthorityPda:r,mint:s,tokenPoolPda:a,tokenProgram:i,lightSystemProgram:u,registeredProgramPda:c,noopProgram:m,accountCompressionAuthority:p,accountCompressionProgram:d,merkleTree:l,selfProgram:g,systemProgram:y,solPoolPda:f}=e;return[{pubkey:o,isSigner:1,isWritable:1},{pubkey:n,isSigner:1,isWritable:0},{pubkey:r,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:1},{pubkey:a,isSigner:0,isWritable:1},{pubkey:i,isSigner:0,isWritable:0},{pubkey:u,isSigner:0,isWritable:0},{pubkey:c,isSigner:0,isWritable:0},{pubkey:m,isSigner:0,isWritable:0},{pubkey:p,isSigner:0,isWritable:0},{pubkey:d,isSigner:0,isWritable:0},{pubkey:l,isSigner:0,isWritable:1},{pubkey:g,isSigner:0,isWritable:0},{pubkey:y,isSigner:0,isWritable:0},{pubkey:null!=f?f:t,isSigner:0,isWritable:1}]},z=e=>{const t=ie.programId,{feePayer:o,authority:n,cpiAuthorityPda:r,lightSystemProgram:s,registeredProgramPda:a,noopProgram:i,accountCompressionAuthority:u,accountCompressionProgram:c,selfProgram:m,tokenPoolPda:p,compressOrDecompressTokenAccount:d,tokenProgram:l,systemProgram:g}=e;return[{pubkey:o,isSigner:1,isWritable:1},{pubkey:n,isSigner:1,isWritable:0},{pubkey:r,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:0},{pubkey:a,isSigner:0,isWritable:0},{pubkey:i,isSigner:0,isWritable:0},{pubkey:u,isSigner:0,isWritable:0},{pubkey:c,isSigner:0,isWritable:0},{pubkey:m,isSigner:0,isWritable:0},{pubkey:null!=p?p:t,isSigner:0,isWritable:1},{pubkey:null!=d?d:t,isSigner:0,isWritable:1},{pubkey:null!=l?l:t,isSigner:0,isWritable:0},{pubkey:g,isSigner:0,isWritable:0}]},H=e=>{const{feePayer:t,authority:o,cpiAuthorityPda:n,lightSystemProgram:r,registeredProgramPda:s,noopProgram:a,accountCompressionAuthority:i,accountCompressionProgram:u,selfProgram:c,systemProgram:m}=e;return[{pubkey:t,isSigner:1,isWritable:1},{pubkey:o,isSigner:1,isWritable:0},{pubkey:n,isSigner:0,isWritable:0},{pubkey:r,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:0},{pubkey:a,isSigner:0,isWritable:0},{pubkey:i,isSigner:0,isWritable:0},{pubkey:u,isSigner:0,isWritable:0},{pubkey:c,isSigner:0,isWritable:0},{pubkey:m,isSigner:0,isWritable:0}]},$=H,j=e=>{const{feePayer:t,authority:o,cpiAuthorityPda:n,lightSystemProgram:r,registeredProgramPda:s,noopProgram:a,accountCompressionAuthority:i,accountCompressionProgram:u,selfProgram:c,systemProgram:m,mint:p}=e;return[{pubkey:t,isSigner:1,isWritable:1},{pubkey:o,isSigner:1,isWritable:0},{pubkey:n,isSigner:0,isWritable:0},{pubkey:r,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:0},{pubkey:a,isSigner:0,isWritable:0},{pubkey:i,isSigner:0,isWritable:0},{pubkey:u,isSigner:0,isWritable:0},{pubkey:c,isSigner:0,isWritable:0},{pubkey:m,isSigner:0,isWritable:0},{pubkey:p,isSigner:0,isWritable:0}]},Z=j,G=r.struct([r.struct([r.array(r.u8(),32,"a"),r.array(r.u8(),64,"b"),r.array(r.u8(),32,"c")],"proof"),r.publicKey("mint"),r.vec(D,"inputTokenDataWithContext"),r.option(W,"cpiContext"),r.publicKey("delegate"),r.u64("delegatedAmount"),r.u8("delegateMerkleTreeIndex"),r.u8("changeAccountMerkleTreeIndex"),r.option(r.u64(),"delegateLamports")]),Q=r.struct([r.struct([r.array(r.u8(),32,"a"),r.array(r.u8(),64,"b"),r.array(r.u8(),32,"c")],"proof"),r.publicKey("mint"),r.vec(D,"inputTokenDataWithContext"),r.option(W,"cpiContext"),r.u8("outputAccountMerkleTreeIndex")]),X={a:new Array(32).fill(0),b:new Array(64).fill(0),c:new Array(32).fill(0)};function Y(e){return e.a.every((e=>0===e))&&e.b.every((e=>0===e))&&e.c.every((e=>0===e))}function J(e){var t;const n=o.Buffer.alloc(1e3),r=null!==(t=e.proof)&&void 0!==t?t:X,s=G.encode(Object.assign(Object.assign({},e),{proof:r}),n),a=o.Buffer.alloc(4);a.writeUInt32LE(s,0);const i=n.subarray(0,s);return o.Buffer.concat([new Uint8Array(d),new Uint8Array(a),new Uint8Array(i)])}function ee(e){var t;const n=o.Buffer.alloc(1e3),r=null!==(t=e.proof)&&void 0!==t?t:X,s=Q.encode(Object.assign(Object.assign({},e),{proof:r}),n),a=o.Buffer.alloc(4);a.writeUInt32LE(s,0);const i=n.subarray(0,s);return o.Buffer.concat([new Uint8Array(l),new Uint8Array(a),new Uint8Array(i)])}const te=e=>e.reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0)),oe=e=>{const t=e[0].parsed.owner;e.forEach((e=>{if(!e.parsed.owner.equals(t))throw new Error("Token accounts must be owned by the same owner")}))},ne=e=>({mint:e[0].parsed.mint,currentOwner:e[0].parsed.owner,delegate:e[0].parsed.delegate}),re=(e,t)=>{if(e.length<1)throw new Error("Must supply at least one input token account.");const o=e[0].parsed.owner,n=e.findIndex((e=>e.parsed.delegate));if(-1===n)return{delegatedTransfer:null,authority:o};const r=e[n].parsed.delegate;return{delegatedTransfer:{owner:o,delegateChangeAccountIndex:t.length<=1?null:0},authority:r}};function se(e,o,n){n=t.bn(n);const r=te(e),s=t.sumUpLamports(e.map((e=>e.compressedAccount))),a=r.sub(n);return t.validateSufficientBalance(a),a.eq(t.bn(0))&&s.eq(t.bn(0))?[{owner:o,amount:n,lamports:s,tlv:null}]:(t.validateSameOwner(e.map((e=>e.compressedAccount))),oe(e),[{owner:e[0].parsed.owner,amount:a,lamports:s,tlv:null},{owner:o,amount:n,lamports:t.bn(0),tlv:null}])}function ae(e,o){o=t.bn(o);const n=t.sumUpLamports(e.map((e=>e.compressedAccount))),r=te(e).sub(o);return t.validateSufficientBalance(r),r.eq(t.bn(0))&&n.eq(t.bn(0))?[]:(t.validateSameOwner(e.map((e=>e.compressedAccount))),oe(e),[{owner:e[0].parsed.owner,amount:r,lamports:n,tlv:null}])}class ie{constructor(){}static setProgramId(t){this.programId="string"==typeof t?new e.PublicKey(t):t}static deriveTokenPoolPda(t){const o=[s,t.toBuffer()],[n,r]=e.PublicKey.findProgramAddressSync(o,this.programId);return n}static findTokenPoolIndexAndBump(e,t){for(let o=0;o<5;o++){const n=ie.deriveTokenPoolPdaWithIndex(t,o);if(n[0].equals(e))return[o,n[1]]}throw new Error("Token pool not found")}static deriveTokenPoolPdaWithIndex(t,n){let r=[];r=0===n?[o.Buffer.from("pool"),t.toBuffer(),o.Buffer.from([])]:[o.Buffer.from("pool"),t.toBuffer(),o.Buffer.from([n])];const[s,a]=e.PublicKey.findProgramAddressSync(r,this.programId);return[s,a]}static get deriveCpiAuthorityPda(){const[t,o]=e.PublicKey.findProgramAddressSync([a],this.programId);return t}static async createMint({feePayer:t,mint:o,authority:r,freezeAuthority:s,decimals:a,rentExemptBalance:i,tokenProgramId:u,mintSize:c}){const m=null!=u?u:n.TOKEN_PROGRAM_ID;return[e.SystemProgram.createAccount({fromPubkey:t,lamports:i,newAccountPubkey:o,programId:m,space:null!=c?c:n.MINT_SIZE}),n.createInitializeMint2Instruction(o,a,r,s,m),await this.createTokenPool({feePayer:t,mint:o,tokenProgramId:m})]}static async createTokenPool({feePayer:t,mint:o,tokenProgramId:r}){const s=null!=r?r:n.TOKEN_PROGRAM_ID,a=this.deriveTokenPoolPdaWithIndex(o,0),u=F({mint:o,feePayer:t,tokenPoolPda:a[0],tokenProgram:s,cpiAuthorityPda:this.deriveCpiAuthorityPda,systemProgram:e.SystemProgram.programId});return new e.TransactionInstruction({programId:this.programId,keys:u,data:i})}static async addTokenPool({feePayer:t,mint:r,poolIndex:s,tokenProgramId:a}){if(s<=0)throw new Error("Pool index must be greater than 0. For 0, use CreateTokenPool instead.");if(s>3)throw new Error(`Invalid poolIndex ${s}. Max 4 pools per mint.`);const i=null!=a?a:n.TOKEN_PROGRAM_ID,u=this.deriveTokenPoolPdaWithIndex(r,s-1),c=this.deriveTokenPoolPdaWithIndex(r,s),m=_({mint:r,feePayer:t,tokenPoolPda:c[0],existingTokenPoolPda:u[0],tokenProgram:i,cpiAuthorityPda:this.deriveCpiAuthorityPda,systemProgram:e.SystemProgram.programId});return new e.TransactionInstruction({programId:this.programId,keys:m,data:o.Buffer.concat([new Uint8Array(g),new Uint8Array(o.Buffer.from([s]))])})}static async mintTo({feePayer:o,mint:n,authority:r,toPubkey:s,amount:a,outputStateTreeInfo:i,tokenPoolInfo:u}){const c=t.defaultStaticAccountsStruct(),m=u.tokenProgram;y(u,n);const p=t.toArray(a).map((e=>t.bn(e))),d=t.toArray(s);if(p.length!==d.length)throw new Error("Amount and toPubkey arrays must have the same length");const l=V({mint:n,feePayer:o,authority:r,cpiAuthorityPda:this.deriveCpiAuthorityPda,tokenProgram:m,tokenPoolPda:u.tokenPoolPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:c.registeredProgramPda,noopProgram:c.noopProgram,accountCompressionAuthority:c.accountCompressionAuthority,accountCompressionProgram:c.accountCompressionProgram,merkleTree:i.treeType===t.TreeType.StateV2?i.queue:i.tree,selfProgram:this.programId,systemProgram:e.SystemProgram.programId,solPoolPda:null}),g=R({recipients:d,amounts:p,lamports:null});return new e.TransactionInstruction({programId:this.programId,keys:l,data:g})}static async approveAndMintTo({feePayer:e,mint:t,authority:o,authorityTokenAccount:r,toPubkey:s,amount:a,outputStateTreeInfo:i,tokenPoolInfo:u}){const c=BigInt(a.toString());return[n.createMintToInstruction(t,r,o,c,[],u.tokenProgram),await this.compress({payer:e,owner:o,source:r,toAddress:s,mint:t,amount:a,outputStateTreeInfo:i,tokenPoolInfo:u})]}static async transfer({payer:o,inputCompressedTokenAccounts:n,toAddress:r,amount:s,recentValidityProof:a,recentInputStateRootIndices:i}){const u=se(n,r,s),{inputTokenDataWithContext:c,packedOutputTokenData:m,remainingAccountMetas:p}=x({inputCompressedTokenAccounts:n,rootIndices:i,tokenTransferOutputs:u}),{mint:d}=ne(n),{delegatedTransfer:l,authority:g}=re(n,u),y=q({proof:a,mint:d,delegatedTransfer:l,inputTokenDataWithContext:c,outputCompressedAccounts:m,compressOrDecompressAmount:null,isCompress:0,cpiContext:null,lamportsChangeAccountMerkleTreeIndex:null}),{accountCompressionAuthority:f,noopProgram:h,registeredProgramPda:P,accountCompressionProgram:k}=t.defaultStaticAccountsStruct(),b=z({feePayer:o,authority:g,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:P,noopProgram:h,accountCompressionAuthority:f,accountCompressionProgram:k,selfProgram:this.programId,tokenPoolPda:void 0,compressOrDecompressTokenAccount:void 0,tokenProgram:void 0,systemProgram:e.SystemProgram.programId});return b.push(...p),new e.TransactionInstruction({programId:this.programId,keys:b,data:y})}static async createTokenProgramLookupTable({payer:o,authority:r,mints:s,recentSlot:a,remainingAccounts:i}){const[u,c]=e.AddressLookupTableProgram.createLookupTable({authority:r,payer:r,recentSlot:a});let m=[];s&&(m=[...s,...s.map((e=>this.deriveTokenPoolPda(e)))]);const p=[u,e.AddressLookupTableProgram.extendLookupTable({payer:o,authority:r,lookupTable:c,addresses:[e.SystemProgram.programId,e.ComputeBudgetProgram.programId,this.deriveCpiAuthorityPda,t.LightSystemProgram.programId,ie.programId,t.defaultStaticAccountsStruct().registeredProgramPda,t.defaultStaticAccountsStruct().noopProgram,t.defaultStaticAccountsStruct().accountCompressionAuthority,t.defaultStaticAccountsStruct().accountCompressionProgram,t.defaultTestStateTreeAccounts().merkleTree,t.defaultTestStateTreeAccounts().nullifierQueue,t.defaultTestStateTreeAccounts().addressTree,t.defaultTestStateTreeAccounts().addressQueue,this.programId,n.TOKEN_PROGRAM_ID,n.TOKEN_2022_PROGRAM_ID,r,...m]})];if(i&&i.length>0)for(let t=0;t<i.length;t+=25){const n=i.slice(t,t+25),s=e.AddressLookupTableProgram.extendLookupTable({payer:o,authority:r,lookupTable:c,addresses:n});p.push(s)}return{instructions:p,address:c}}static async compress({payer:o,owner:n,source:r,toAddress:s,amount:a,mint:i,outputStateTreeInfo:u,tokenPoolInfo:c}){let m;const p=t.toArray(a),d=t.toArray(s);if(y(c,i),p.length!==d.length)throw new Error("Amount and toAddress arrays must have the same length");if(t.featureFlags.isV2()){const[s,a]=this.findTokenPoolIndexAndBump(c.tokenPoolPda,i),m=U({pubkeys:d,amounts:p.length>1?p.map((e=>t.bn(e))):null,lamports:null,amount:1===p.length?t.bn(p[0]):null,index:s,bump:a}),l=V(Object.assign(Object.assign({mint:i,feePayer:o,authority:n,cpiAuthorityPda:this.deriveCpiAuthorityPda,tokenProgram:c.tokenProgram,tokenPoolPda:c.tokenPoolPda,lightSystemProgram:t.LightSystemProgram.programId},t.defaultStaticAccountsStruct()),{merkleTree:u.queue,selfProgram:this.programId,systemProgram:e.SystemProgram.programId,solPoolPda:null}));return l.push({pubkey:r,isWritable:1,isSigner:0}),new e.TransactionInstruction({programId:this.programId,keys:l,data:m})}{m=p.map(((e,o)=>{const n=t.bn(e);return{owner:d[o],amount:n,lamports:null,tlv:null}}));const{inputTokenDataWithContext:s,packedOutputTokenData:l,remainingAccountMetas:g}=x({inputCompressedTokenAccounts:[],outputStateTreeInfo:u,rootIndices:[],tokenTransferOutputs:m}),y=q({proof:null,mint:i,delegatedTransfer:null,inputTokenDataWithContext:s,outputCompressedAccounts:l,compressOrDecompressAmount:Array.isArray(a)?a.map((e=>t.bn(e))).reduce(((e,t)=>e.add(t)),t.bn(0)):t.bn(a),isCompress:1,cpiContext:null,lamportsChangeAccountMerkleTreeIndex:null}),f=z(Object.assign(Object.assign({},t.defaultStaticAccountsStruct()),{feePayer:o,authority:n,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,selfProgram:this.programId,systemProgram:e.SystemProgram.programId,tokenPoolPda:c.tokenPoolPda,compressOrDecompressTokenAccount:r,tokenProgram:c.tokenProgram}));return f.push(...g),new e.TransactionInstruction({programId:this.programId,keys:f,data:y})}}static async decompress({payer:o,inputCompressedTokenAccounts:n,toAddress:r,amount:s,recentValidityProof:a,recentInputStateRootIndices:i,tokenPoolInfos:u}){const c=t.bn(s),m=t.toArray(u),p=ae(n,c),{inputTokenDataWithContext:d,packedOutputTokenData:l,remainingAccountMetas:g}=x({inputCompressedTokenAccounts:n,rootIndices:i,tokenTransferOutputs:p,remainingAccounts:m.slice(1).map((e=>e.tokenPoolPda))}),{mint:y}=ne(n),{delegatedTransfer:f,authority:h}=re(n,p),P=q({proof:a,mint:y,delegatedTransfer:f,inputTokenDataWithContext:d,outputCompressedAccounts:l,compressOrDecompressAmount:c,isCompress:0,cpiContext:null,lamportsChangeAccountMerkleTreeIndex:null}),k=m[0].tokenProgram,{accountCompressionAuthority:b,noopProgram:A,registeredProgramPda:S,accountCompressionProgram:T}=t.defaultStaticAccountsStruct(),I=z({feePayer:o,authority:h,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:S,noopProgram:A,accountCompressionAuthority:b,accountCompressionProgram:T,selfProgram:this.programId,tokenPoolPda:m[0].tokenPoolPda,compressOrDecompressTokenAccount:r,tokenProgram:k,systemProgram:e.SystemProgram.programId});return I.push(...g),new e.TransactionInstruction({programId:this.programId,keys:I,data:P})}static async mergeTokenAccounts({payer:e,owner:o,inputCompressedTokenAccounts:n,mint:r,recentValidityProof:s,recentInputStateRootIndices:a}){if(n.length>4)throw new Error("Cannot merge more than 4 token accounts at once");return w(n,r),[await this.transfer({payer:e,inputCompressedTokenAccounts:n,toAddress:o,amount:n.reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0)),recentInputStateRootIndices:a,recentValidityProof:s})]}static async compressSplTokenAccount({feePayer:o,authority:n,tokenAccount:r,mint:s,remainingAmount:a,outputStateTreeInfo:i,tokenPoolInfo:u}){y(u,s);const c=[{pubkey:i.treeType===t.TreeType.StateV2?i.queue:i.tree,isSigner:0,isWritable:1}],m=N({owner:n,remainingAmount:null!=a?a:null,cpiContext:null}),{accountCompressionAuthority:p,noopProgram:d,registeredProgramPda:l,accountCompressionProgram:g}=t.defaultStaticAccountsStruct(),f=z({feePayer:o,authority:n,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:l,noopProgram:d,accountCompressionAuthority:p,accountCompressionProgram:g,selfProgram:this.programId,tokenPoolPda:u.tokenPoolPda,compressOrDecompressTokenAccount:r,tokenProgram:u.tokenProgram,systemProgram:e.SystemProgram.programId});return f.push(...c),new e.TransactionInstruction({programId:this.programId,keys:f,data:m})}static async getMintProgramId(e,t){var o;return null===(o=await t.getAccountInfo(e))||void 0===o?void 0:o.owner}static async approve({payer:o,inputCompressedTokenAccounts:n,toAddress:r,amount:s,recentValidityProof:a,recentInputStateRootIndices:i}){const{inputTokenDataWithContext:u,remainingAccountMetas:c}=x({inputCompressedTokenAccounts:n,rootIndices:i,tokenTransferOutputs:[]}),{mint:m,currentOwner:p}=ne(n),d=n[0].compressedAccount.treeInfo.treeType===t.TreeType.StateV2?1:0,l=J({proof:a,mint:m,inputTokenDataWithContext:u,cpiContext:null,delegate:r,delegatedAmount:t.bn(s),delegateMerkleTreeIndex:d,changeAccountMerkleTreeIndex:d,delegateLamports:null}),{accountCompressionAuthority:g,noopProgram:y,registeredProgramPda:f,accountCompressionProgram:h}=t.defaultStaticAccountsStruct(),P=H({feePayer:o,authority:p,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:f,noopProgram:y,accountCompressionAuthority:g,accountCompressionProgram:h,selfProgram:this.programId,systemProgram:e.SystemProgram.programId});return P.push(...c),new e.TransactionInstruction({programId:this.programId,keys:P,data:l})}static async revoke({payer:o,inputCompressedTokenAccounts:n,recentValidityProof:r,recentInputStateRootIndices:s}){oe(n);const{inputTokenDataWithContext:a,remainingAccountMetas:i}=x({inputCompressedTokenAccounts:n,rootIndices:s,tokenTransferOutputs:[]}),{mint:u,currentOwner:c}=ne(n),m=ee({proof:r,mint:u,inputTokenDataWithContext:a,cpiContext:null,outputAccountMerkleTreeIndex:n[0].compressedAccount.treeInfo.treeType===t.TreeType.StateV2?2:1}),{accountCompressionAuthority:p,noopProgram:d,registeredProgramPda:l,accountCompressionProgram:g}=t.defaultStaticAccountsStruct(),y=$({feePayer:o,authority:c,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:t.LightSystemProgram.programId,registeredProgramPda:l,noopProgram:d,accountCompressionAuthority:p,accountCompressionProgram:g,selfProgram:this.programId,systemProgram:e.SystemProgram.programId});return y.push(...i),new e.TransactionInstruction({programId:this.programId,keys:y,data:m})}}ie.programId=new e.PublicKey("cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m"),exports.ADD_TOKEN_POOL_DISCRIMINATOR=g,exports.APPROVE_DISCRIMINATOR=d,exports.BATCH_COMPRESS_DISCRIMINATOR=c,exports.COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR=p,exports.CPI_AUTHORITY_SEED=a,exports.CREATE_TOKEN_POOL_DISCRIMINATOR=i,exports.CompressedTokenInstructionDataApproveLayout=G,exports.CompressedTokenInstructionDataRevokeLayout=Q,exports.CompressedTokenInstructionDataTransferLayout=E,exports.CompressedTokenProgram=ie,exports.CpiContextLayout=W,exports.DelegatedTransferLayout=O,exports.ERROR_NO_ACCOUNTS_FOUND=A,exports.IDL={version:"1.2.0",name:"light_compressed_token",instructions:[{name:"createTokenPool",docs:["This instruction creates a token pool for a given mint. Every spl mint","can have one token pool. When a token is compressed the tokens are","transferrred to the token pool, and their compressed equivalent is","minted into a Merkle tree."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"tokenPoolPda",isMut:1,isSigner:0},{name:"systemProgram",isMut:0,isSigner:0},{name:"mint",isMut:1,isSigner:0},{name:"tokenProgram",isMut:0,isSigner:0},{name:"cpiAuthorityPda",isMut:0,isSigner:0}],args:[]},{name:"addTokenPool",docs:["This instruction creates an additional token pool for a given mint.","The maximum number of token pools per mint is 5."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"tokenPoolPda",isMut:1,isSigner:0},{name:"existingTokenPoolPda",isMut:0,isSigner:0},{name:"systemProgram",isMut:0,isSigner:0},{name:"mint",isMut:1,isSigner:0},{name:"tokenProgram",isMut:0,isSigner:0},{name:"cpiAuthorityPda",isMut:0,isSigner:0}],args:[{name:"tokenPoolIndex",type:"u8"}]},{name:"mintTo",docs:["Mints tokens from an spl token mint to a list of compressed accounts.","Minted tokens are transferred to a pool account owned by the compressed","token program. The instruction creates one compressed output account for","every amount and pubkey input pair. A constant amount of lamports can be","transferred to each output account to enable. A use case to add lamports","to a compressed token account is to prevent spam. This is the only way","to add lamports to a compressed token account."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"mint",isMut:1,isSigner:0},{name:"tokenPoolPda",isMut:1,isSigner:0},{name:"tokenProgram",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0,docs:["programs"]},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"merkleTree",isMut:1,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0},{name:"systemProgram",isMut:0,isSigner:0},{name:"solPoolPda",isMut:1,isSigner:0,isOptional:1}],args:[{name:"publicKeys",type:{vec:"publicKey"}},{name:"amounts",type:{vec:"u64"}},{name:"lamports",type:{option:"u64"}}]},{name:"compressSplTokenAccount",docs:["Compresses the balance of an spl token account sub an optional remaining","amount. This instruction does not close the spl token account. To close","the account bundle a close spl account instruction in your transaction."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["this program is the signer of the cpi."]},{name:"tokenPoolPda",isMut:1,isSigner:0,isOptional:1},{name:"compressOrDecompressTokenAccount",isMut:1,isSigner:0,isOptional:1},{name:"tokenProgram",isMut:0,isSigner:0,isOptional:1},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"owner",type:"publicKey"},{name:"remainingAmount",type:{option:"u64"}},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}}]},{name:"transfer",docs:["Transfers compressed tokens from one account to another. All accounts","must be of the same mint. Additional spl tokens can be compressed or","decompressed. In one transaction only compression or decompression is","possible. Lamports can be transferred alongside tokens. If output token","accounts specify less lamports than inputs the remaining lamports are","transferred to an output compressed account. Signer must be owner or","delegate. If a delegated token account is transferred the delegate is","not preserved."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["this program is the signer of the cpi."]},{name:"tokenPoolPda",isMut:1,isSigner:0,isOptional:1},{name:"compressOrDecompressTokenAccount",isMut:1,isSigner:0,isOptional:1},{name:"tokenProgram",isMut:0,isSigner:0,isOptional:1},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"approve",docs:["Delegates an amount to a delegate. A compressed token account is either","completely delegated or not. Prior delegates are not preserved. Cannot","be called by a delegate.","The instruction creates two output accounts:","1. one account with delegated amount","2. one account with remaining(change) amount"],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["this program is the signer of the cpi."]},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"revoke",docs:["Revokes a delegation. The instruction merges all inputs into one output","account. Cannot be called by a delegate. Delegates are not preserved."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["this program is the signer of the cpi."]},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"freeze",docs:["Freezes compressed token accounts. Inputs must not be frozen. Creates as","many outputs as inputs. Balances and delegates are preserved."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["that this program is the signer of the cpi."]},{name:"systemProgram",isMut:0,isSigner:0},{name:"mint",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"thaw",docs:["Thaws frozen compressed token accounts. Inputs must be frozen. Creates","as many outputs as inputs. Balances and delegates are preserved."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["that this program is the signer of the cpi."]},{name:"systemProgram",isMut:0,isSigner:0},{name:"mint",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"burn",docs:["Burns compressed tokens and spl tokens from the pool account. Delegates","can burn tokens. The output compressed token account remains delegated.","Creates one output compressed token account."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"mint",isMut:1,isSigner:0},{name:"tokenPoolPda",isMut:1,isSigner:0},{name:"tokenProgram",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"stubIdlBuild",docs:["This function is a stub to allow Anchor to include the input types in","the IDL. It should not be included in production builds nor be called in","practice."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:0,isSigner:1,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:0,isSigner:0},{name:"lightSystemProgram",isMut:0,isSigner:0},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"selfProgram",isMut:0,isSigner:0,docs:["this program is the signer of the cpi."]},{name:"tokenPoolPda",isMut:1,isSigner:0,isOptional:1},{name:"compressOrDecompressTokenAccount",isMut:1,isSigner:0,isOptional:1},{name:"tokenProgram",isMut:0,isSigner:0,isOptional:1},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs1",type:{defined:"CompressedTokenInstructionDataTransfer"}},{name:"inputs2",type:{defined:"TokenData"}}]}],types:[{name:"AccountState",type:{kind:"enum",variants:[{name:"Initialized"},{name:"Frozen"}]}},{name:"CompressedAccount",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"lamports",type:"u64"},{name:"address",type:{option:{array:["u8",32]}}},{name:"data",type:{option:{defined:"CompressedAccountData"}}}]}},{name:"CompressedAccountData",type:{kind:"struct",fields:[{name:"discriminator",type:{array:["u8",8]}},{name:"data",type:"bytes"},{name:"dataHash",type:{array:["u8",32]}}]}},{name:"CompressedCpiContext",type:{kind:"struct",fields:[{name:"setContext",docs:["Is set by the program that is invoking the CPI to signal that is should","set the cpi context."],type:"bool"},{name:"firstSetContext",docs:["Is set to wipe the cpi context since someone could have set it before","with unrelated data."],type:"bool"},{name:"cpiContextAccountIndex",docs:["Index of cpi context account in remaining accounts."],type:"u8"}]}},{name:"CompressedProof",type:{kind:"struct",fields:[{name:"a",type:{array:["u8",32]}},{name:"b",type:{array:["u8",64]}},{name:"c",type:{array:["u8",32]}}]}},{name:"CompressedTokenInstructionDataTransfer",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"mint",type:"publicKey"},{name:"delegatedTransfer",docs:["Is required if the signer is delegate,","-> delegate is authority account,","owner = Some(owner) is the owner of the token account."],type:{option:{defined:"DelegatedTransfer"}}},{name:"inputTokenDataWithContext",type:{vec:{defined:"InputTokenDataWithContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"PackedTokenTransferOutputData"}}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressAmount",type:{option:"u64"}},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}},{name:"lamportsChangeAccountMerkleTreeIndex",type:{option:"u8"}}]}},{name:"CompressedTokenInstructionDataRevoke",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"mint",type:"publicKey"},{name:"inputTokenDataWithContext",type:{vec:{defined:"InputTokenDataWithContext"}}},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}},{name:"outputAccountMerkleTreeIndex",type:"u8"}]}},{name:"CompressedTokenInstructionDataApprove",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"mint",type:"publicKey"},{name:"inputTokenDataWithContext",type:{vec:{defined:"InputTokenDataWithContext"}}},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}},{name:"delegate",type:"publicKey"},{name:"delegatedAmount",type:"u64"},{name:"delegateMerkleTreeIndex",type:"u8"},{name:"changeAccountMerkleTreeIndex",type:"u8"},{name:"delegateLamports",type:{option:"u64"}}]}},{name:"DelegatedTransfer",docs:["Struct to provide the owner when the delegate is signer of the transaction."],type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"delegateChangeAccountIndex",docs:["Index of change compressed account in output compressed accounts. In","case that the delegate didn't spend the complete delegated compressed","account balance the change compressed account will be delegated to her","as well."],type:{option:"u8"}}]}},{name:"InputTokenDataWithContext",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"delegateIndex",type:{option:"u8"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",type:"u16"},{name:"lamports",type:{option:"u64"}},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}},{name:"InstructionDataInvoke",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"}]}},{name:"InstructionDataInvokeCpi",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}}]}},{name:"MerkleTreeSequenceNumber",type:{kind:"struct",fields:[{name:"pubkey",type:"publicKey"},{name:"seq",type:"u64"}]}},{name:"NewAddressParamsPacked",type:{kind:"struct",fields:[{name:"seed",type:{array:["u8",32]}},{name:"addressQueueAccountIndex",type:"u8"},{name:"addressMerkleTreeAccountIndex",type:"u8"},{name:"addressMerkleTreeRootIndex",type:"u16"}]}},{name:"OutputCompressedAccountWithPackedContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleTreeIndex",type:"u8"}]}},{name:"PackedCompressedAccountWithMerkleContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",docs:["Index of root used in inclusion validity proof."],type:"u16"},{name:"readOnly",docs:["Placeholder to mark accounts read-only unimplemented set to false."],type:"bool"}]}},{name:"PackedMerkleContext",type:{kind:"struct",fields:[{name:"merkleTreePubkeyIndex",type:"u8"},{name:"queuePubkeyIndex",type:"u8"},{name:"leafIndex",type:"u32"},{name:"proveByIndex",type:"bool"}]}},{name:"PackedTokenTransferOutputData",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"amount",type:"u64"},{name:"lamports",type:{option:"u64"}},{name:"merkleTreeIndex",type:"u8"},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}},{name:"PublicTransactionEvent",type:{kind:"struct",fields:[{name:"inputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"outputLeafIndices",type:{vec:"u32"}},{name:"sequenceNumbers",type:{vec:{defined:"MerkleTreeSequenceNumber"}}},{name:"relayFee",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"pubkeyArray",type:{vec:"publicKey"}},{name:"message",type:{option:"bytes"}}]}},{name:"QueueIndex",type:{kind:"struct",fields:[{name:"queueId",docs:["Id of queue in queue account."],type:"u8"},{name:"index",docs:["Index of compressed account hash in queue."],type:"u16"}]}},{name:"TokenData",type:{kind:"struct",fields:[{name:"mint",docs:["The mint associated with this account"],type:"publicKey"},{name:"owner",docs:["The owner of this account."],type:"publicKey"},{name:"amount",docs:["The amount of tokens this account holds."],type:"u64"},{name:"delegate",docs:["If `delegate` is `Some` then `delegated_amount` represents","the amount authorized by the delegate"],type:{option:"publicKey"}},{name:"state",docs:["The account's state"],type:{defined:"AccountState"}},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}}],errors:[{code:6e3,name:"PublicKeyAmountMissmatch",msg:"public keys and amounts must be of same length"},{code:6001,name:"ComputeInputSumFailed",msg:"ComputeInputSumFailed"},{code:6002,name:"ComputeOutputSumFailed",msg:"ComputeOutputSumFailed"},{code:6003,name:"ComputeCompressSumFailed",msg:"ComputeCompressSumFailed"},{code:6004,name:"ComputeDecompressSumFailed",msg:"ComputeDecompressSumFailed"},{code:6005,name:"SumCheckFailed",msg:"SumCheckFailed"},{code:6006,name:"DecompressRecipientUndefinedForDecompress",msg:"DecompressRecipientUndefinedForDecompress"},{code:6007,name:"CompressedPdaUndefinedForDecompress",msg:"CompressedPdaUndefinedForDecompress"},{code:6008,name:"DeCompressAmountUndefinedForDecompress",msg:"DeCompressAmountUndefinedForDecompress"},{code:6009,name:"CompressedPdaUndefinedForCompress",msg:"CompressedPdaUndefinedForCompress"},{code:6010,name:"DeCompressAmountUndefinedForCompress",msg:"DeCompressAmountUndefinedForCompress"},{code:6011,name:"DelegateSignerCheckFailed",msg:"DelegateSignerCheckFailed"},{code:6012,name:"MintTooLarge",msg:"Minted amount greater than u64::MAX"},{code:6013,name:"SplTokenSupplyMismatch",msg:"SplTokenSupplyMismatch"},{code:6014,name:"HeapMemoryCheckFailed",msg:"HeapMemoryCheckFailed"},{code:6015,name:"InstructionNotCallable",msg:"The instruction is not callable"},{code:6016,name:"ArithmeticUnderflow",msg:"ArithmeticUnderflow"},{code:6017,name:"HashToFieldError",msg:"HashToFieldError"},{code:6018,name:"InvalidAuthorityMint",msg:"Expected the authority to be also a mint authority"},{code:6019,name:"InvalidFreezeAuthority",msg:"Provided authority is not the freeze authority"},{code:6020,name:"InvalidDelegateIndex"},{code:6021,name:"TokenPoolPdaUndefined"},{code:6022,name:"IsTokenPoolPda",msg:"Compress or decompress recipient is the same account as the token pool pda."},{code:6023,name:"InvalidTokenPoolPda"},{code:6024,name:"NoInputTokenAccountsProvided"},{code:6025,name:"NoInputsProvided"},{code:6026,name:"MintHasNoFreezeAuthority"},{code:6027,name:"MintWithInvalidExtension"},{code:6028,name:"InsufficientTokenAccountBalance",msg:"The token account balance is less than the remaining amount."},{code:6029,name:"InvalidTokenPoolBump",msg:"Max number of token pools reached."},{code:6030,name:"FailedToDecompress"},{code:6031,name:"FailedToBurnSplTokensFromTokenPool"},{code:6032,name:"NoMatchingBumpFound"}]},exports.MINT_TO_DISCRIMINATOR=u,exports.POOL_SEED=s,exports.REVOKE_DISCRIMINATOR=l,exports.SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE=1461600,exports.TRANSFER_DISCRIMINATOR=m,exports.addTokenPoolAccountsLayout=_,exports.addTokenPools=async function(e,o,n,r,s,a){a=a||await ie.getMintProgramId(n,e);const i=[],u=(await f(e,n)).slice(0,4),c=[];for(let e=0;e<u.length;e++)u[e].isInitialized||c.push(e);for(let e=0;e<r&&!(e>=c.length);e++)i.push(await ie.addTokenPool({mint:n,feePayer:o.publicKey,tokenProgramId:a,poolIndex:c[e]}));const{blockhash:m}=await e.getLatestBlockhash(),p=t.buildAndSignTx(i,o,m);return await t.sendAndConfirmTx(e,p,s)},exports.approve=async function(o,n,r,s,a,i,u){s=t.bn(s);const c=await o.getCompressedTokenAccountsByOwner(a.publicKey,{mint:r}),[m]=S(c.items,s),p=await o.getValidityProofV0(m.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue})))),d=await ie.approve({payer:n.publicKey,inputCompressedTokenAccounts:m,toAddress:i,amount:s,recentInputStateRootIndices:p.rootIndices,recentValidityProof:p.compressedProof}),{blockhash:l}=await o.getLatestBlockhash(),g=t.dedupeSigner(n,[a]),y=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:35e4}),d],n,l,g);return t.sendAndConfirmTx(o,y,u)},exports.approveAccountsLayout=H,exports.approveAndMintTo=async function(o,r,s,a,i,u,c,m,p){c=null!=c?c:t.selectStateTreeInfo(await o.getStateTreeInfos()),m=null!=m?m:k(await f(o,s));const d=await n.getOrCreateAssociatedTokenAccount(o,r,s,i.publicKey,void 0,void 0,p,m.tokenProgram),l=await ie.approveAndMintTo({feePayer:r.publicKey,mint:s,authority:i.publicKey,authorityTokenAccount:d.address,amount:u,toPubkey:a,outputStateTreeInfo:c,tokenPoolInfo:m}),{blockhash:g}=await o.getLatestBlockhash(),y=t.dedupeSigner(r,[i]),h=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:15e4+2e4*t.toArray(u).length}),...l],r,g,y);return await t.sendAndConfirmTx(o,h,p)},exports.batchCompressLayout=K,exports.checkMint=w,exports.checkTokenPoolInfo=y,exports.compress=async function(o,n,r,s,a,i,u,c,m,p){c=null!=c?c:t.selectStateTreeInfo(await o.getStateTreeInfos()),m=null!=m?m:k(await f(o,r));const d=await ie.compress({payer:n.publicKey,owner:a.publicKey,source:i,toAddress:u,amount:s,mint:r,outputStateTreeInfo:c,tokenPoolInfo:m}),l=await o.getLatestBlockhash(),g=t.dedupeSigner(n,[a]),y=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:13e4+2e4*t.toArray(s).length}),d],n,l.blockhash,g);return await t.sendAndConfirmTx(o,y,p,l)},exports.compressSplTokenAccount=async function(o,n,r,s,a,i,u,c,m){u=null!=u?u:t.selectStateTreeInfo(await o.getStateTreeInfos()),c=null!=c?c:k(await f(o,r));const p=await ie.compressSplTokenAccount({feePayer:n.publicKey,authority:s.publicKey,tokenAccount:a,mint:r,remainingAmount:i,outputStateTreeInfo:u,tokenPoolInfo:c}),d=await o.getLatestBlockhash(),l=t.dedupeSigner(n,[s]),g=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:15e4}),p],n,d.blockhash,l);return await t.sendAndConfirmTx(o,g,m,d)},exports.compressSplTokenAccountInstructionDataLayout=L,exports.createDecompressOutputState=ae,exports.createMint=async function(o,r,s,a,i=e.Keypair.generate(),u,c,m){const p=await o.getMinimumBalanceForRentExemption(n.MINT_SIZE),d=1==c?n.TOKEN_2022_PROGRAM_ID:c||n.TOKEN_PROGRAM_ID,l=await ie.createMint({feePayer:r.publicKey,mint:i.publicKey,decimals:a,authority:"secretKey"in s?s.publicKey:s,freezeAuthority:m&&"secretKey"in m?m.publicKey:null!=m?m:null,rentExemptBalance:p,tokenProgramId:d}),{blockhash:g}=await o.getLatestBlockhash(),y=t.dedupeSigner(r,[s,m].filter((e=>null!=e&&"secretKey"in e))),f=t.buildAndSignTx(l,r,g,[...y,i]),h=await t.sendAndConfirmTx(o,f,u);return{mint:i.publicKey,transactionSignature:h}},exports.createTokenPool=async function(e,o,n,r,s){s=s||await ie.getMintProgramId(n,e);const a=await ie.createTokenPool({feePayer:o.publicKey,mint:n,tokenProgramId:s}),{blockhash:i}=await e.getLatestBlockhash(),u=t.buildAndSignTx([a],o,i);return await t.sendAndConfirmTx(e,u,r)},exports.createTokenPoolAccountsLayout=F,exports.createTokenProgramLookupTable=async function(e,o,n,r,s){const a=await e.getSlot("finalized"),{instructions:i,address:u}=await ie.createTokenProgramLookupTable({payer:o.publicKey,authority:n.publicKey,mints:r,remainingAccounts:s,recentSlot:a}),c=t.dedupeSigner(o,[n]),m=[];for(const n of i){const r=await e.getLatestBlockhash(),s=t.buildAndSignTx([n],o,r.blockhash,c),a=await t.sendAndConfirmTx(e,s,{commitment:"finalized"},r);m.push(a)}return{txIds:m,address:u}},exports.createTransferOutputState=se,exports.decodeApproveInstructionData=function(e){const t=G.decode(e.subarray(d.length));return Object.assign(Object.assign({},t),{proof:Y(t.proof)?null:t.proof})},exports.decodeBatchCompressInstructionData=function(e){return K.decode(e.subarray(c.length+4))},exports.decodeCompressSplTokenAccountInstructionData=function(e){const t=L.decode(e.subarray(p.length));return{owner:t.owner,remainingAmount:t.remainingAmount,cpiContext:t.cpiContext}},exports.decodeMintToInstructionData=function(e){return B.decode(e.subarray(u.length))},exports.decodeRevokeInstructionData=function(e){const t=Q.decode(e.subarray(l.length));return Object.assign(Object.assign({},t),{proof:Y(t.proof)?null:t.proof})},exports.decodeTransferInstructionData=function(e){return E.decode(e.slice(m.length+4))},exports.decompress=async function(o,n,r,s,a,i,u,c){s=t.bn(s);const m=await o.getCompressedTokenAccountsByOwner(a.publicKey,{mint:r}),[p]=T(m.items,s),d=await o.getValidityProofV0(p.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue})))),l=b(u=null!=u?u:await f(o,r),s),g=await ie.decompress({payer:n.publicKey,inputCompressedTokenAccounts:p,toAddress:i,amount:s,tokenPoolInfos:l,recentInputStateRootIndices:d.rootIndices,recentValidityProof:d.compressedProof}),{blockhash:y}=await o.getLatestBlockhash(),h=t.dedupeSigner(n,[a]),P=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:35e4}),g],n,y,h);return await t.sendAndConfirmTx(o,P,c)},exports.decompressDelegated=async function(o,n,r,s,a,i,u,c){s=t.bn(s);const m=await o.getCompressedTokenAccountsByDelegate(a.publicKey,{mint:r}),[p]=T(m.items,s),d=await o.getValidityProofV0(p.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue})))),l=null!=u?u:b(await f(o,r),s),g=await ie.decompress({payer:n.publicKey,inputCompressedTokenAccounts:p,toAddress:i,amount:s,recentInputStateRootIndices:d.rootIndices,recentValidityProof:d.compressedProof,tokenPoolInfos:l}),{blockhash:y}=await o.getLatestBlockhash(),h=t.dedupeSigner(n,[a]),P=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:35e4}),g],n,y,h);return t.sendAndConfirmTx(o,P,c)},exports.encodeApproveInstructionData=J,exports.encodeBatchCompressInstructionData=U,exports.encodeCompressSplTokenAccountInstructionData=N,exports.encodeMintToInstructionData=R,exports.encodeRevokeInstructionData=ee,exports.encodeTransferInstructionData=q,exports.freezeAccountsLayout=j,exports.getTokenPoolInfos=f,exports.isSingleTokenPoolInfo=function(e){return!Array.isArray(e)},exports.mergeTokenAccounts=async function(o,n,r,s,a){const i=await o.getCompressedTokenAccountsByOwner(s.publicKey,{mint:r});if(0===i.items.length)throw new Error(`No compressed token accounts found for mint ${r.toBase58()}`);const u=[e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6})];for(let e=0;e<i.items.slice(0,8).length;e+=4){const a=i.items.slice(e,e+4),c=await o.getValidityProof(a.map((e=>t.bn(e.compressedAccount.hash)))),m=await ie.mergeTokenAccounts({payer:n.publicKey,owner:s.publicKey,inputCompressedTokenAccounts:a,mint:r,recentValidityProof:c.compressedProof,recentInputStateRootIndices:c.rootIndices});u.push(...m)}const{blockhash:c}=await o.getLatestBlockhash(),m=t.dedupeSigner(n,[s]),p=t.buildAndSignTx(u,n,c,m);return t.sendAndConfirmTx(o,p,a)},exports.mintTo=async function(o,n,r,s,a,i,u,c,m){u=null!=u?u:t.selectStateTreeInfo(await o.getStateTreeInfos()),c=null!=c?c:k(await f(o,r));const p=await ie.mintTo({feePayer:n.publicKey,mint:r,authority:a.publicKey,amount:i,toPubkey:s,outputStateTreeInfo:u,tokenPoolInfo:c}),{blockhash:d}=await o.getLatestBlockhash(),l=t.dedupeSigner(n,[a]),g=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),p],n,d,l);return t.sendAndConfirmTx(o,g,m)},exports.mintToAccountsLayout=V,exports.mintToLayout=B,exports.packCompressedTokenAccounts=x,exports.parseMaybeDelegatedTransfer=re,exports.parseTokenData=ne,exports.revoke=async function(o,n,r,s,a){const i=await o.getValidityProofV0(r.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue}))));!function(e,t){if(!e.publicKey.equals(t[0].parsed.owner))throw new Error(`Owner ${e.publicKey.toBase58()} does not match account ${t[0].parsed.owner.toBase58()}`)}(s,r),function(e){if(e.some((e=>null===e.parsed.delegate)))throw new Error("Account is not delegated")}(r);const u=await ie.revoke({payer:n.publicKey,inputCompressedTokenAccounts:r,recentInputStateRootIndices:i.rootIndices,recentValidityProof:i.compressedProof}),{blockhash:c}=await o.getLatestBlockhash(),m=t.dedupeSigner(n,[s]),p=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:5e5}),u],n,c,m);return t.sendAndConfirmTx(o,p,a)},exports.revokeAccountsLayout=$,exports.selectMinCompressedTokenAccountsForDecompression=function(e,t,o=4){const[n,r,s,a]=T(e,t,o);return{selectedAccounts:n,total:r,totalLamports:s,maxPossibleAmount:a}},exports.selectMinCompressedTokenAccountsForTransfer=T,exports.selectMinCompressedTokenAccountsForTransferOrPartial=I,exports.selectSmartCompressedTokenAccountsForTransfer=function(e,o,n=4){const[r,s,a,i]=C(e,o,n);if(s.lt(t.bn(o))){const s=e.reduce(((e,t)=>e.add(t.parsed.amount)),t.bn(0));throw r.length>=n?new Error(`Account limit exceeded: max ${i.toString()} (${n} accounts) per transaction. Total balance: ${s.toString()} (${e.length} accounts). Consider multiple transfers to spend full balance.`):new Error(`Insufficient balance. Required: ${o.toString()}, available: ${s.toString()}.`)}if(0===r.length)throw new Error(A);return[r,s,a,i]},exports.selectSmartCompressedTokenAccountsForTransferOrPartial=C,exports.selectTokenAccountsForApprove=S,exports.selectTokenPoolInfo=k,exports.selectTokenPoolInfosForDecompression=b,exports.sumUpTokenAmount=te,exports.thawAccountsLayout=Z,exports.transfer=async function(o,n,r,s,a,i,u){s=t.bn(s);const c=await o.getCompressedTokenAccountsByOwner(a.publicKey,{mint:r}),[m]=T(c.items,s),p=await o.getValidityProofV0(m.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue})))),d=await ie.transfer({payer:n.publicKey,inputCompressedTokenAccounts:m,toAddress:i,amount:s,recentInputStateRootIndices:p.rootIndices,recentValidityProof:p.compressedProof}),{blockhash:l}=await o.getLatestBlockhash(),g=t.dedupeSigner(n,[a]),y=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:5e5}),d],n,l,g);return t.sendAndConfirmTx(o,y,u)},exports.transferAccountsLayout=z,exports.transferDelegated=async function(o,n,r,s,a,i,u){s=t.bn(s);const c=await o.getCompressedTokenAccountsByDelegate(a.publicKey,{mint:r}),[m]=T(c.items,s),p=await o.getValidityProofV0(m.map((e=>({hash:e.compressedAccount.hash,tree:e.compressedAccount.treeInfo.tree,queue:e.compressedAccount.treeInfo.queue})))),d=await ie.transfer({payer:n.publicKey,inputCompressedTokenAccounts:m,toAddress:i,amount:s,recentInputStateRootIndices:p.rootIndices,recentValidityProof:p.compressedProof}),{blockhash:l}=await o.getLatestBlockhash(),g=t.dedupeSigner(n,[a]),y=t.buildAndSignTx([e.ComputeBudgetProgram.setComputeUnitLimit({units:5e5}),d],n,l,g);return t.sendAndConfirmTx(o,y,u)},exports.validateSameTokenOwner=oe;
//# sourceMappingURL=index.cjs.map
