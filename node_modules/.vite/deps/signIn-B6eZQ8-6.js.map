{"version":3,"file":"signIn-B6eZQ8-6.js","names":["EventEmitter"],"sources":["../../@solana/wallet-adapter-base/lib/esm/adapter.js","../../@solana/wallet-adapter-base/lib/esm/transaction.js","../../@solana/wallet-adapter-base/lib/esm/signer.js","../../@wallet-standard/features/lib/esm/connect.js","../../@wallet-standard/features/lib/esm/disconnect.js","../../@wallet-standard/features/lib/esm/events.js","../../@solana/wallet-standard-chains/lib/esm/index.js","../../@solana/wallet-standard-util/lib/esm/signIn.js"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { WalletNotConnectedError } from './errors.js';\nexport { EventEmitter };\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\nexport var WalletReadyState;\n(function (WalletReadyState) {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */\n    WalletReadyState[\"Installed\"] = \"Installed\";\n    WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */\n    WalletReadyState[\"Loadable\"] = \"Loadable\";\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */\n    WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\nexport class BaseWalletAdapter extends EventEmitter {\n    get connected() {\n        return !!this.publicKey;\n    }\n    async autoConnect() {\n        await this.connect();\n    }\n    async prepareTransaction(transaction, connection, options = {}) {\n        const publicKey = this.publicKey;\n        if (!publicKey)\n            throw new WalletNotConnectedError();\n        transaction.feePayer = transaction.feePayer || publicKey;\n        transaction.recentBlockhash =\n            transaction.recentBlockhash ||\n                (await connection.getLatestBlockhash({\n                    commitment: options.preflightCommitment,\n                    minContextSlot: options.minContextSlot,\n                })).blockhash;\n        return transaction;\n    }\n}\nexport function scopePollingDetectionStrategy(detect) {\n    // Early return when server-side rendering\n    if (typeof window === 'undefined' || typeof document === 'undefined')\n        return;\n    const disposers = [];\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers) {\n                dispose();\n            }\n        }\n    }\n    // Strategy #1: Try detecting every second.\n    const interval = \n    // TODO: #334 Replace with idle callback strategy.\n    setInterval(detectAndDispose, 1000);\n    disposers.push(() => clearInterval(interval));\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (\n    // Implies that `DOMContentLoaded` has not yet fired.\n    document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', detectAndDispose, { once: true });\n        disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n    }\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (\n    // If the `complete` state has been reached, we're too late.\n    document.readyState !== 'complete') {\n        window.addEventListener('load', detectAndDispose, { once: true });\n        disposers.push(() => window.removeEventListener('load', detectAndDispose));\n    }\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */\nexport function isIosAndRedirectable() {\n    // SSR: return false\n    if (!navigator)\n        return false;\n    const userAgent = navigator.userAgent.toLowerCase();\n    // if on iOS the user agent will contain either iPhone or iPad\n    // caveat: if requesting desktop site then this won't work\n    const isIos = userAgent.includes('iphone') || userAgent.includes('ipad');\n    // if in a webview then it will not include Safari\n    // note that other iOS browsers also include Safari\n    // so we will redirect only if Safari is also included\n    const isSafari = userAgent.includes('safari');\n    return isIos && isSafari;\n}\n//# sourceMappingURL=adapter.js.map","export function isVersionedTransaction(transaction) {\n    return 'version' in transaction;\n}\n//# sourceMappingURL=transaction.js.map","import { BaseWalletAdapter, } from './adapter.js';\nimport { WalletSendTransactionError, WalletSignTransactionError } from './errors.js';\nimport { isVersionedTransaction } from './transaction.js';\nexport class BaseSignerWalletAdapter extends BaseWalletAdapter {\n    async sendTransaction(transaction, connection, options = {}) {\n        let emit = true;\n        try {\n            if (isVersionedTransaction(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);\n                try {\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                }\n                catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            }\n            else {\n                try {\n                    const { signers, ...sendOptions } = options;\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                }\n                catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            }\n        }\n        catch (error) {\n            if (emit) {\n                this.emit('error', error);\n            }\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        for (const transaction of transactions) {\n            if (isVersionedTransaction(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);\n            }\n        }\n        const signedTransactions = [];\n        for (const transaction of transactions) {\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\nexport class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {\n}\nexport class BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {\n}\n//# sourceMappingURL=signer.js.map","/** Name of the feature. */\nexport const StandardConnect = 'standard:connect';\n/**\n * @deprecated Use {@link StandardConnect} instead.\n *\n * @group Deprecated\n */\nexport const Connect = StandardConnect;\n//# sourceMappingURL=connect.js.map","/** Name of the feature. */\nexport const StandardDisconnect = 'standard:disconnect';\n/**\n * @deprecated Use {@link StandardDisconnect} instead.\n *\n * @group Deprecated\n */\nexport const Disconnect = StandardDisconnect;\n//# sourceMappingURL=disconnect.js.map","/** Name of the feature. */\nexport const StandardEvents = 'standard:events';\n/**\n * @deprecated Use {@link StandardEvents} instead.\n *\n * @group Deprecated\n */\nexport const Events = StandardEvents;\n//# sourceMappingURL=events.js.map","/** Solana Mainnet (beta) cluster, e.g. https://api.mainnet-beta.solana.com */\nexport const SOLANA_MAINNET_CHAIN = 'solana:mainnet';\n/** Solana Devnet cluster, e.g. https://api.devnet.solana.com */\nexport const SOLANA_DEVNET_CHAIN = 'solana:devnet';\n/** Solana Testnet cluster, e.g. https://api.testnet.solana.com */\nexport const SOLANA_TESTNET_CHAIN = 'solana:testnet';\n/** Solana Localnet cluster, e.g. http://localhost:8899 */\nexport const SOLANA_LOCALNET_CHAIN = 'solana:localnet';\n/** Array of all Solana clusters */\nexport const SOLANA_CHAINS = [\n    SOLANA_MAINNET_CHAIN,\n    SOLANA_DEVNET_CHAIN,\n    SOLANA_TESTNET_CHAIN,\n    SOLANA_LOCALNET_CHAIN,\n];\n/**\n * Check if a chain corresponds with one of the Solana clusters.\n */\nexport function isSolanaChain(chain) {\n    return SOLANA_CHAINS.includes(chain);\n}\n//# sourceMappingURL=index.js.map","import { verifyMessageSignature } from './signMessage.js';\nimport { arraysEqual } from './util.js';\n/**\n * TODO: docs\n */\nexport function verifySignIn(input, output) {\n    const { signedMessage, signature, account: { publicKey }, } = output;\n    const message = deriveSignInMessage(input, output);\n    return (!!message && verifyMessageSignature({ message, signedMessage, signature, publicKey: publicKey }));\n}\n/**\n * TODO: docs\n */\nexport function deriveSignInMessage(input, output) {\n    const text = deriveSignInMessageText(input, output);\n    if (!text)\n        return null;\n    return new TextEncoder().encode(text);\n}\n/**\n * TODO: docs\n */\nexport function deriveSignInMessageText(input, output) {\n    const parsed = parseSignInMessage(output.signedMessage);\n    if (!parsed)\n        return null;\n    if (input.domain && input.domain !== parsed.domain)\n        return null;\n    if (input.address && input.address !== parsed.address)\n        return null;\n    if (input.statement !== parsed.statement)\n        return null;\n    if (input.uri !== parsed.uri)\n        return null;\n    if (input.version !== parsed.version)\n        return null;\n    if (input.chainId !== parsed.chainId)\n        return null;\n    if (input.nonce !== parsed.nonce)\n        return null;\n    if (input.issuedAt !== parsed.issuedAt)\n        return null;\n    if (input.expirationTime !== parsed.expirationTime)\n        return null;\n    if (input.notBefore !== parsed.notBefore)\n        return null;\n    if (input.requestId !== parsed.requestId)\n        return null;\n    if (input.resources) {\n        if (!parsed.resources)\n            return null;\n        if (!arraysEqual(input.resources, parsed.resources))\n            return null;\n    }\n    else if (parsed.resources)\n        return null;\n    return createSignInMessageText(parsed);\n}\n/**\n * TODO: docs\n */\nexport function parseSignInMessage(message) {\n    const text = new TextDecoder().decode(message);\n    return parseSignInMessageText(text);\n}\n// TODO: implement https://github.com/solana-labs/solana/blob/master/docs/src/proposals/off-chain-message-signing.md\nconst DOMAIN = '(?<domain>[^\\\\n]+?) wants you to sign in with your Solana account:\\\\n';\nconst ADDRESS = '(?<address>[^\\\\n]+)(?:\\\\n|$)';\nconst STATEMENT = '(?:\\\\n(?<statement>[\\\\S\\\\s]*?)(?:\\\\n|$))??';\nconst URI = '(?:\\\\nURI: (?<uri>[^\\\\n]+))?';\nconst VERSION = '(?:\\\\nVersion: (?<version>[^\\\\n]+))?';\nconst CHAIN_ID = '(?:\\\\nChain ID: (?<chainId>[^\\\\n]+))?';\nconst NONCE = '(?:\\\\nNonce: (?<nonce>[^\\\\n]+))?';\nconst ISSUED_AT = '(?:\\\\nIssued At: (?<issuedAt>[^\\\\n]+))?';\nconst EXPIRATION_TIME = '(?:\\\\nExpiration Time: (?<expirationTime>[^\\\\n]+))?';\nconst NOT_BEFORE = '(?:\\\\nNot Before: (?<notBefore>[^\\\\n]+))?';\nconst REQUEST_ID = '(?:\\\\nRequest ID: (?<requestId>[^\\\\n]+))?';\nconst RESOURCES = '(?:\\\\nResources:(?<resources>(?:\\\\n- [^\\\\n]+)*))?';\nconst FIELDS = `${URI}${VERSION}${CHAIN_ID}${NONCE}${ISSUED_AT}${EXPIRATION_TIME}${NOT_BEFORE}${REQUEST_ID}${RESOURCES}`;\nconst MESSAGE = new RegExp(`^${DOMAIN}${ADDRESS}${STATEMENT}${FIELDS}\\\\n*$`);\n/**\n * TODO: docs\n */\nexport function parseSignInMessageText(text) {\n    const match = MESSAGE.exec(text);\n    if (!match)\n        return null;\n    const groups = match.groups;\n    if (!groups)\n        return null;\n    return {\n        domain: groups.domain,\n        address: groups.address,\n        statement: groups.statement,\n        uri: groups.uri,\n        version: groups.version,\n        nonce: groups.nonce,\n        chainId: groups.chainId,\n        issuedAt: groups.issuedAt,\n        expirationTime: groups.expirationTime,\n        notBefore: groups.notBefore,\n        requestId: groups.requestId,\n        resources: groups.resources?.split('\\n- ').slice(1),\n    };\n}\n/**\n * TODO: docs\n */\nexport function createSignInMessage(input) {\n    const text = createSignInMessageText(input);\n    return new TextEncoder().encode(text);\n}\n/**\n * TODO: docs\n */\nexport function createSignInMessageText(input) {\n    // ${domain} wants you to sign in with your Solana account:\n    // ${address}\n    //\n    // ${statement}\n    //\n    // URI: ${uri}\n    // Version: ${version}\n    // Chain ID: ${chain}\n    // Nonce: ${nonce}\n    // Issued At: ${issued-at}\n    // Expiration Time: ${expiration-time}\n    // Not Before: ${not-before}\n    // Request ID: ${request-id}\n    // Resources:\n    // - ${resources[0]}\n    // - ${resources[1]}\n    // ...\n    // - ${resources[n]}\n    let message = `${input.domain} wants you to sign in with your Solana account:\\n`;\n    message += `${input.address}`;\n    if (input.statement) {\n        message += `\\n\\n${input.statement}`;\n    }\n    const fields = [];\n    if (input.uri) {\n        fields.push(`URI: ${input.uri}`);\n    }\n    if (input.version) {\n        fields.push(`Version: ${input.version}`);\n    }\n    if (input.chainId) {\n        fields.push(`Chain ID: ${input.chainId}`);\n    }\n    if (input.nonce) {\n        fields.push(`Nonce: ${input.nonce}`);\n    }\n    if (input.issuedAt) {\n        fields.push(`Issued At: ${input.issuedAt}`);\n    }\n    if (input.expirationTime) {\n        fields.push(`Expiration Time: ${input.expirationTime}`);\n    }\n    if (input.notBefore) {\n        fields.push(`Not Before: ${input.notBefore}`);\n    }\n    if (input.requestId) {\n        fields.push(`Request ID: ${input.requestId}`);\n    }\n    if (input.resources) {\n        fields.push(`Resources:`);\n        for (const resource of input.resources) {\n            fields.push(`- ${resource}`);\n        }\n    }\n    if (fields.length) {\n        message += `\\n\\n${fields.join('\\n')}`;\n    }\n    return message;\n}\n//# sourceMappingURL=signIn.js.map"],"mappings":"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"}