import { c as __toESM, r as __export, t as __commonJS } from "./chunk-CBgdiQcn.js";
import { t as require_buffer } from "./buffer-B-cPJC5o.js";
import { St as init_index_browser_esm, j as PublicKey } from "./index.browser.esm-CCXoTR2h.js";
import "./browser-external_buffer-X3Ug0HYL.js";
import { t as require_events } from "./events-yU-zBpk5.js";
import { t as require_elliptic } from "./elliptic-DiSash_k.js";
import { t as require_browser_external_crypto } from "./browser-external_crypto-CwrtXUOq.js";
import "./inherits_browser-COIPrfC8.js";
import { m as require_isarray, n as require_string_decoder, o as require_call_bound, r as require_call_bind, t as require_object_keys } from "./object-keys-Vf1DIUG4.js";

//#region node_modules/bignumber.js/bignumber.mjs
init_index_browser_esm();
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 0x5af3107a4000, LOG_BASE = 14, MAX_SAFE_INTEGER$1 = 9007199254740991, POWS_TEN = [
	1,
	10,
	100,
	1e3,
	1e4,
	1e5,
	1e6,
	1e7,
	1e8,
	1e9,
	1e10,
	1e11,
	0xe8d4a51000,
	0x9184e72a000
], SQRT_BASE = 1e7, MAX = 1e9;
function clone(configObject) {
	var div, convertBase, parseNumeric, P = BigNumber$1.prototype = {
		constructor: BigNumber$1,
		toString: null,
		valueOf: null
	}, ONE = new BigNumber$1(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
		prefix: "",
		groupSize: 3,
		secondaryGroupSize: 0,
		groupSeparator: ",",
		decimalSeparator: ".",
		fractionGroupSize: 0,
		fractionGroupSeparator: "\xA0",
		suffix: ""
	}, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
	function BigNumber$1(v, b) {
		var alphabet, c, caseChanged, e, i, isNum, len, str$1, x = this;
		if (!(x instanceof BigNumber$1)) return new BigNumber$1(v, b);
		if (b == null) {
			if (v && v._isBigNumber === true) {
				x.s = v.s;
				if (!v.c || v.e > MAX_EXP) x.c = x.e = null;
				else if (v.e < MIN_EXP) x.c = [x.e = 0];
				else {
					x.e = v.e;
					x.c = v.c.slice();
				}
				return;
			}
			if ((isNum = typeof v == "number") && v * 0 == 0) {
				x.s = 1 / v < 0 ? (v = -v, -1) : 1;
				if (v === ~~v) {
					for (e = 0, i = v; i >= 10; i /= 10, e++);
					if (e > MAX_EXP) x.c = x.e = null;
					else {
						x.e = e;
						x.c = [v];
					}
					return;
				}
				str$1 = String(v);
			} else {
				if (!isNumeric.test(str$1 = String(v))) return parseNumeric(x, str$1, isNum);
				x.s = str$1.charCodeAt(0) == 45 ? (str$1 = str$1.slice(1), -1) : 1;
			}
			if ((e = str$1.indexOf(".")) > -1) str$1 = str$1.replace(".", "");
			if ((i = str$1.search(/e/i)) > 0) {
				if (e < 0) e = i;
				e += +str$1.slice(i + 1);
				str$1 = str$1.substring(0, i);
			} else if (e < 0) e = str$1.length;
		} else {
			intCheck(b, 2, ALPHABET.length, "Base");
			if (b == 10 && alphabetHasNormalDecimalDigits) {
				x = new BigNumber$1(v);
				return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
			}
			str$1 = String(v);
			if (isNum = typeof v == "number") {
				if (v * 0 != 0) return parseNumeric(x, str$1, isNum, b);
				x.s = 1 / v < 0 ? (str$1 = str$1.slice(1), -1) : 1;
				if (BigNumber$1.DEBUG && str$1.replace(/^0\.0*|\./, "").length > 15) throw Error(tooManyDigits + v);
			} else x.s = str$1.charCodeAt(0) === 45 ? (str$1 = str$1.slice(1), -1) : 1;
			alphabet = ALPHABET.slice(0, b);
			e = i = 0;
			for (len = str$1.length; i < len; i++) if (alphabet.indexOf(c = str$1.charAt(i)) < 0) {
				if (c == ".") {
					if (i > e) {
						e = len;
						continue;
					}
				} else if (!caseChanged) {
					if (str$1 == str$1.toUpperCase() && (str$1 = str$1.toLowerCase()) || str$1 == str$1.toLowerCase() && (str$1 = str$1.toUpperCase())) {
						caseChanged = true;
						i = -1;
						e = 0;
						continue;
					}
				}
				return parseNumeric(x, String(v), isNum, b);
			}
			isNum = false;
			str$1 = convertBase(str$1, b, 10, x.s);
			if ((e = str$1.indexOf(".")) > -1) str$1 = str$1.replace(".", "");
			else e = str$1.length;
		}
		for (i = 0; str$1.charCodeAt(i) === 48; i++);
		for (len = str$1.length; str$1.charCodeAt(--len) === 48;);
		if (str$1 = str$1.slice(i, ++len)) {
			len -= i;
			if (isNum && BigNumber$1.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER$1 || v !== mathfloor(v))) throw Error(tooManyDigits + x.s * v);
			if ((e = e - i - 1) > MAX_EXP) x.c = x.e = null;
			else if (e < MIN_EXP) x.c = [x.e = 0];
			else {
				x.e = e;
				x.c = [];
				i = (e + 1) % LOG_BASE;
				if (e < 0) i += LOG_BASE;
				if (i < len) {
					if (i) x.c.push(+str$1.slice(0, i));
					for (len -= LOG_BASE; i < len;) x.c.push(+str$1.slice(i, i += LOG_BASE));
					i = LOG_BASE - (str$1 = str$1.slice(i)).length;
				} else i -= len;
				for (; i--; str$1 += "0");
				x.c.push(+str$1);
			}
		} else x.c = [x.e = 0];
	}
	BigNumber$1.clone = clone;
	BigNumber$1.ROUND_UP = 0;
	BigNumber$1.ROUND_DOWN = 1;
	BigNumber$1.ROUND_CEIL = 2;
	BigNumber$1.ROUND_FLOOR = 3;
	BigNumber$1.ROUND_HALF_UP = 4;
	BigNumber$1.ROUND_HALF_DOWN = 5;
	BigNumber$1.ROUND_HALF_EVEN = 6;
	BigNumber$1.ROUND_HALF_CEIL = 7;
	BigNumber$1.ROUND_HALF_FLOOR = 8;
	BigNumber$1.EUCLID = 9;
	BigNumber$1.config = BigNumber$1.set = function(obj) {
		var p, v;
		if (obj != null) if (typeof obj == "object") {
			if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
				v = obj[p];
				intCheck(v, 0, MAX, p);
				DECIMAL_PLACES = v;
			}
			if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
				v = obj[p];
				intCheck(v, 0, 8, p);
				ROUNDING_MODE = v;
			}
			if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
				v = obj[p];
				if (v && v.pop) {
					intCheck(v[0], -MAX, 0, p);
					intCheck(v[1], 0, MAX, p);
					TO_EXP_NEG = v[0];
					TO_EXP_POS = v[1];
				} else {
					intCheck(v, -MAX, MAX, p);
					TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
				}
			}
			if (obj.hasOwnProperty(p = "RANGE")) {
				v = obj[p];
				if (v && v.pop) {
					intCheck(v[0], -MAX, -1, p);
					intCheck(v[1], 1, MAX, p);
					MIN_EXP = v[0];
					MAX_EXP = v[1];
				} else {
					intCheck(v, -MAX, MAX, p);
					if (v) MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
					else throw Error(bignumberError + p + " cannot be zero: " + v);
				}
			}
			if (obj.hasOwnProperty(p = "CRYPTO")) {
				v = obj[p];
				if (v === !!v) if (v) if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) CRYPTO = v;
				else {
					CRYPTO = !v;
					throw Error(bignumberError + "crypto unavailable");
				}
				else CRYPTO = v;
				else throw Error(bignumberError + p + " not true or false: " + v);
			}
			if (obj.hasOwnProperty(p = "MODULO_MODE")) {
				v = obj[p];
				intCheck(v, 0, 9, p);
				MODULO_MODE = v;
			}
			if (obj.hasOwnProperty(p = "POW_PRECISION")) {
				v = obj[p];
				intCheck(v, 0, MAX, p);
				POW_PRECISION = v;
			}
			if (obj.hasOwnProperty(p = "FORMAT")) {
				v = obj[p];
				if (typeof v == "object") FORMAT = v;
				else throw Error(bignumberError + p + " not an object: " + v);
			}
			if (obj.hasOwnProperty(p = "ALPHABET")) {
				v = obj[p];
				if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
					alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
					ALPHABET = v;
				} else throw Error(bignumberError + p + " invalid: " + v);
			}
		} else throw Error(bignumberError + "Object expected: " + obj);
		return {
			DECIMAL_PLACES,
			ROUNDING_MODE,
			EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
			RANGE: [MIN_EXP, MAX_EXP],
			CRYPTO,
			MODULO_MODE,
			POW_PRECISION,
			FORMAT,
			ALPHABET
		};
	};
	BigNumber$1.isBigNumber = function(v) {
		if (!v || v._isBigNumber !== true) return false;
		if (!BigNumber$1.DEBUG) return true;
		var i, n, c = v.c, e = v.e, s = v.s;
		out: if ({}.toString.call(c) == "[object Array]") {
			if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
				if (c[0] === 0) {
					if (e === 0 && c.length === 1) return true;
					break out;
				}
				i = (e + 1) % LOG_BASE;
				if (i < 1) i += LOG_BASE;
				if (String(c[0]).length == i) {
					for (i = 0; i < c.length; i++) {
						n = c[i];
						if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
					}
					if (n !== 0) return true;
				}
			}
		} else if (c === null && e === null && (s === null || s === 1 || s === -1)) return true;
		throw Error(bignumberError + "Invalid BigNumber: " + v);
	};
	BigNumber$1.maximum = BigNumber$1.max = function() {
		return maxOrMin(arguments, -1);
	};
	BigNumber$1.minimum = BigNumber$1.min = function() {
		return maxOrMin(arguments, 1);
	};
	BigNumber$1.random = (function() {
		var pow2_53 = 9007199254740992;
		var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
			return mathfloor(Math.random() * pow2_53);
		} : function() {
			return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
		};
		return function(dp) {
			var a, b, e, k, v, i = 0, c = [], rand = new BigNumber$1(ONE);
			if (dp == null) dp = DECIMAL_PLACES;
			else intCheck(dp, 0, MAX);
			k = mathceil(dp / LOG_BASE);
			if (CRYPTO) if (crypto.getRandomValues) {
				a = crypto.getRandomValues(new Uint32Array(k *= 2));
				for (; i < k;) {
					v = a[i] * 131072 + (a[i + 1] >>> 11);
					if (v >= 9e15) {
						b = crypto.getRandomValues(new Uint32Array(2));
						a[i] = b[0];
						a[i + 1] = b[1];
					} else {
						c.push(v % 0x5af3107a4000);
						i += 2;
					}
				}
				i = k / 2;
			} else if (crypto.randomBytes) {
				a = crypto.randomBytes(k *= 7);
				for (; i < k;) {
					v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
					if (v >= 9e15) crypto.randomBytes(7).copy(a, i);
					else {
						c.push(v % 0x5af3107a4000);
						i += 7;
					}
				}
				i = k / 7;
			} else {
				CRYPTO = false;
				throw Error(bignumberError + "crypto unavailable");
			}
			if (!CRYPTO) for (; i < k;) {
				v = random53bitInt();
				if (v < 9e15) c[i++] = v % 0x5af3107a4000;
			}
			k = c[--i];
			dp %= LOG_BASE;
			if (k && dp) {
				v = POWS_TEN[LOG_BASE - dp];
				c[i] = mathfloor(k / v) * v;
			}
			for (; c[i] === 0; c.pop(), i--);
			if (i < 0) c = [e = 0];
			else {
				for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);
				for (i = 1, v = c[0]; v >= 10; v /= 10, i++);
				if (i < LOG_BASE) e -= LOG_BASE - i;
			}
			rand.e = e;
			rand.c = c;
			return rand;
		};
	})();
	BigNumber$1.sum = function() {
		var i = 1, args = arguments, sum = new BigNumber$1(args[0]);
		for (; i < args.length;) sum = sum.plus(args[i++]);
		return sum;
	};
	convertBase = (function() {
		var decimal = "0123456789";
		function toBaseOut(str$1, baseIn, baseOut, alphabet) {
			var j, arr$1 = [0], arrL, i = 0, len = str$1.length;
			for (; i < len;) {
				for (arrL = arr$1.length; arrL--; arr$1[arrL] *= baseIn);
				arr$1[0] += alphabet.indexOf(str$1.charAt(i++));
				for (j = 0; j < arr$1.length; j++) if (arr$1[j] > baseOut - 1) {
					if (arr$1[j + 1] == null) arr$1[j + 1] = 0;
					arr$1[j + 1] += arr$1[j] / baseOut | 0;
					arr$1[j] %= baseOut;
				}
			}
			return arr$1.reverse();
		}
		return function(str$1, baseIn, baseOut, sign$1, callerIsToString) {
			var alphabet, d, e, k, r, x, xc, y, i = str$1.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
			if (i >= 0) {
				k = POW_PRECISION;
				POW_PRECISION = 0;
				str$1 = str$1.replace(".", "");
				y = new BigNumber$1(baseIn);
				x = y.pow(str$1.length - i);
				POW_PRECISION = k;
				y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
				y.e = y.c.length;
			}
			xc = toBaseOut(str$1, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
			e = k = xc.length;
			for (; xc[--k] == 0; xc.pop());
			if (!xc[0]) return alphabet.charAt(0);
			if (i < 0) --e;
			else {
				x.c = xc;
				x.e = e;
				x.s = sign$1;
				x = div(x, y, dp, rm, baseOut);
				xc = x.c;
				r = x.r;
				e = x.e;
			}
			d = e + dp + 1;
			i = xc[d];
			k = baseOut / 2;
			r = r || d < 0 || xc[d + 1] != null;
			r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
			if (d < 1 || !xc[0]) str$1 = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
			else {
				xc.length = d;
				if (r) for (--baseOut; ++xc[--d] > baseOut;) {
					xc[d] = 0;
					if (!d) {
						++e;
						xc = [1].concat(xc);
					}
				}
				for (k = xc.length; !xc[--k];);
				for (i = 0, str$1 = ""; i <= k; str$1 += alphabet.charAt(xc[i++]));
				str$1 = toFixedPoint(str$1, e, alphabet.charAt(0));
			}
			return str$1;
		};
	})();
	div = (function() {
		function multiply(x, k, base) {
			var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
			for (x = x.slice(); i--;) {
				xlo = x[i] % SQRT_BASE;
				xhi = x[i] / SQRT_BASE | 0;
				m = khi * xlo + xhi * klo;
				temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
				carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
				x[i] = temp % base;
			}
			if (carry) x = [carry].concat(x);
			return x;
		}
		function compare$1(a, b, aL, bL) {
			var i, cmp;
			if (aL != bL) cmp = aL > bL ? 1 : -1;
			else for (i = cmp = 0; i < aL; i++) if (a[i] != b[i]) {
				cmp = a[i] > b[i] ? 1 : -1;
				break;
			}
			return cmp;
		}
		function subtract(a, b, aL, base) {
			var i = 0;
			for (; aL--;) {
				a[aL] -= i;
				i = a[aL] < b[aL] ? 1 : 0;
				a[aL] = i * base + a[aL] - b[aL];
			}
			for (; !a[0] && a.length > 1; a.splice(0, 1));
		}
		return function(x, y, dp, rm, base) {
			var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
			if (!xc || !xc[0] || !yc || !yc[0]) return new BigNumber$1(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
			q = new BigNumber$1(s);
			qc = q.c = [];
			e = x.e - y.e;
			s = dp + e + 1;
			if (!base) {
				base = BASE;
				e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
				s = s / LOG_BASE | 0;
			}
			for (i = 0; yc[i] == (xc[i] || 0); i++);
			if (yc[i] > (xc[i] || 0)) e--;
			if (s < 0) {
				qc.push(1);
				more = true;
			} else {
				xL = xc.length;
				yL = yc.length;
				i = 0;
				s += 2;
				n = mathfloor(base / (yc[0] + 1));
				if (n > 1) {
					yc = multiply(yc, n, base);
					xc = multiply(xc, n, base);
					yL = yc.length;
					xL = xc.length;
				}
				xi = yL;
				rem = xc.slice(0, yL);
				remL = rem.length;
				for (; remL < yL; rem[remL++] = 0);
				yz = yc.slice();
				yz = [0].concat(yz);
				yc0 = yc[0];
				if (yc[1] >= base / 2) yc0++;
				do {
					n = 0;
					cmp = compare$1(yc, rem, yL, remL);
					if (cmp < 0) {
						rem0 = rem[0];
						if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
						n = mathfloor(rem0 / yc0);
						if (n > 1) {
							if (n >= base) n = base - 1;
							prod = multiply(yc, n, base);
							prodL = prod.length;
							remL = rem.length;
							while (compare$1(prod, rem, prodL, remL) == 1) {
								n--;
								subtract(prod, yL < prodL ? yz : yc, prodL, base);
								prodL = prod.length;
								cmp = 1;
							}
						} else {
							if (n == 0) cmp = n = 1;
							prod = yc.slice();
							prodL = prod.length;
						}
						if (prodL < remL) prod = [0].concat(prod);
						subtract(rem, prod, remL, base);
						remL = rem.length;
						if (cmp == -1) while (compare$1(yc, rem, yL, remL) < 1) {
							n++;
							subtract(rem, yL < remL ? yz : yc, remL, base);
							remL = rem.length;
						}
					} else if (cmp === 0) {
						n++;
						rem = [0];
					}
					qc[i++] = n;
					if (rem[0]) rem[remL++] = xc[xi] || 0;
					else {
						rem = [xc[xi]];
						remL = 1;
					}
				} while ((xi++ < xL || rem[0] != null) && s--);
				more = rem[0] != null;
				if (!qc[0]) qc.splice(0, 1);
			}
			if (base == BASE) {
				for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);
				round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
			} else {
				q.e = e;
				q.r = +more;
			}
			return q;
		};
	})();
	function format$2(n, i, rm, id) {
		var c0, e, ne, len, str$1;
		if (rm == null) rm = ROUNDING_MODE;
		else intCheck(rm, 0, 8);
		if (!n.c) return n.toString();
		c0 = n.c[0];
		ne = n.e;
		if (i == null) {
			str$1 = coeffToString(n.c);
			str$1 = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str$1, ne) : toFixedPoint(str$1, ne, "0");
		} else {
			n = round(new BigNumber$1(n), i, rm);
			e = n.e;
			str$1 = coeffToString(n.c);
			len = str$1.length;
			if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
				for (; len < i; str$1 += "0", len++);
				str$1 = toExponential(str$1, e);
			} else {
				i -= ne + (id === 2 && e > ne);
				str$1 = toFixedPoint(str$1, e, "0");
				if (e + 1 > len) {
					if (--i > 0) for (str$1 += "."; i--; str$1 += "0");
				} else {
					i += e - len;
					if (i > 0) {
						if (e + 1 == len) str$1 += ".";
						for (; i--; str$1 += "0");
					}
				}
			}
		}
		return n.s < 0 && c0 ? "-" + str$1 : str$1;
	}
	function maxOrMin(args, n) {
		var k, y, i = 1, x = new BigNumber$1(args[0]);
		for (; i < args.length; i++) {
			y = new BigNumber$1(args[i]);
			if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) x = y;
		}
		return x;
	}
	function normalise(n, c, e) {
		var i = 1, j = c.length;
		for (; !c[--j]; c.pop());
		for (j = c[0]; j >= 10; j /= 10, i++);
		if ((e = i + e * LOG_BASE - 1) > MAX_EXP) n.c = n.e = null;
		else if (e < MIN_EXP) n.c = [n.e = 0];
		else {
			n.e = e;
			n.c = c;
		}
		return n;
	}
	parseNumeric = (function() {
		var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
		return function(x, str$1, isNum, b) {
			var base, s = isNum ? str$1 : str$1.replace(whitespaceOrPlus, "");
			if (isInfinityOrNaN.test(s)) x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
			else {
				if (!isNum) {
					s = s.replace(basePrefix, function(m, p1, p2) {
						base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
						return !b || b == base ? p1 : m;
					});
					if (b) {
						base = b;
						s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
					}
					if (str$1 != s) return new BigNumber$1(s, base);
				}
				if (BigNumber$1.DEBUG) throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str$1);
				x.s = null;
			}
			x.c = x.e = null;
		};
	})();
	function round(x, sd, rm, r) {
		var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
		if (xc) {
			out: {
				for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
				i = sd - d;
				if (i < 0) {
					i += LOG_BASE;
					j = sd;
					n = xc[ni = 0];
					rd = mathfloor(n / pows10[d - j - 1] % 10);
				} else {
					ni = mathceil((i + 1) / LOG_BASE);
					if (ni >= xc.length) if (r) {
						for (; xc.length <= ni; xc.push(0));
						n = rd = 0;
						d = 1;
						i %= LOG_BASE;
						j = i - LOG_BASE + 1;
					} else break out;
					else {
						n = k = xc[ni];
						for (d = 1; k >= 10; k /= 10, d++);
						i %= LOG_BASE;
						j = i - LOG_BASE + d;
						rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
					}
				}
				r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
				r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
				if (sd < 1 || !xc[0]) {
					xc.length = 0;
					if (r) {
						sd -= x.e + 1;
						xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
						x.e = -sd || 0;
					} else xc[0] = x.e = 0;
					return x;
				}
				if (i == 0) {
					xc.length = ni;
					k = 1;
					ni--;
				} else {
					xc.length = ni + 1;
					k = pows10[LOG_BASE - i];
					xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
				}
				if (r) for (;;) if (ni == 0) {
					for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
					j = xc[0] += k;
					for (k = 1; j >= 10; j /= 10, k++);
					if (i != k) {
						x.e++;
						if (xc[0] == BASE) xc[0] = 1;
					}
					break;
				} else {
					xc[ni] += k;
					if (xc[ni] != BASE) break;
					xc[ni--] = 0;
					k = 1;
				}
				for (i = xc.length; xc[--i] === 0; xc.pop());
			}
			if (x.e > MAX_EXP) x.c = x.e = null;
			else if (x.e < MIN_EXP) x.c = [x.e = 0];
		}
		return x;
	}
	function valueOf(n) {
		var str$1, e = n.e;
		if (e === null) return n.toString();
		str$1 = coeffToString(n.c);
		str$1 = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str$1, e) : toFixedPoint(str$1, e, "0");
		return n.s < 0 ? "-" + str$1 : str$1;
	}
	P.absoluteValue = P.abs = function() {
		var x = new BigNumber$1(this);
		if (x.s < 0) x.s = 1;
		return x;
	};
	P.comparedTo = function(y, b) {
		return compare(this, new BigNumber$1(y, b));
	};
	P.decimalPlaces = P.dp = function(dp, rm) {
		var c, n, v, x = this;
		if (dp != null) {
			intCheck(dp, 0, MAX);
			if (rm == null) rm = ROUNDING_MODE;
			else intCheck(rm, 0, 8);
			return round(new BigNumber$1(x), dp + x.e + 1, rm);
		}
		if (!(c = x.c)) return null;
		n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
		if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
		if (n < 0) n = 0;
		return n;
	};
	P.dividedBy = P.div = function(y, b) {
		return div(this, new BigNumber$1(y, b), DECIMAL_PLACES, ROUNDING_MODE);
	};
	P.dividedToIntegerBy = P.idiv = function(y, b) {
		return div(this, new BigNumber$1(y, b), 0, 1);
	};
	P.exponentiatedBy = P.pow = function(n, m) {
		var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
		n = new BigNumber$1(n);
		if (n.c && !n.isInteger()) throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
		if (m != null) m = new BigNumber$1(m);
		nIsBig = n.e > 14;
		if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
			y = new BigNumber$1(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
			return m ? y.mod(m) : y;
		}
		nIsNeg = n.s < 0;
		if (m) {
			if (m.c ? !m.c[0] : !m.s) return new BigNumber$1(NaN);
			isModExp = !nIsNeg && x.isInteger() && m.isInteger();
			if (isModExp) x = x.mod(m);
		} else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
			k = x.s < 0 && isOdd(n) ? -0 : 0;
			if (x.e > -1) k = 1 / k;
			return new BigNumber$1(nIsNeg ? 1 / k : k);
		} else if (POW_PRECISION) k = mathceil(POW_PRECISION / LOG_BASE + 2);
		if (nIsBig) {
			half = new BigNumber$1(.5);
			if (nIsNeg) n.s = 1;
			nIsOdd = isOdd(n);
		} else {
			i = Math.abs(+valueOf(n));
			nIsOdd = i % 2;
		}
		y = new BigNumber$1(ONE);
		for (;;) {
			if (nIsOdd) {
				y = y.times(x);
				if (!y.c) break;
				if (k) {
					if (y.c.length > k) y.c.length = k;
				} else if (isModExp) y = y.mod(m);
			}
			if (i) {
				i = mathfloor(i / 2);
				if (i === 0) break;
				nIsOdd = i % 2;
			} else {
				n = n.times(half);
				round(n, n.e + 1, 1);
				if (n.e > 14) nIsOdd = isOdd(n);
				else {
					i = +valueOf(n);
					if (i === 0) break;
					nIsOdd = i % 2;
				}
			}
			x = x.times(x);
			if (k) {
				if (x.c && x.c.length > k) x.c.length = k;
			} else if (isModExp) x = x.mod(m);
		}
		if (isModExp) return y;
		if (nIsNeg) y = ONE.div(y);
		return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
	};
	P.integerValue = function(rm) {
		var n = new BigNumber$1(this);
		if (rm == null) rm = ROUNDING_MODE;
		else intCheck(rm, 0, 8);
		return round(n, n.e + 1, rm);
	};
	P.isEqualTo = P.eq = function(y, b) {
		return compare(this, new BigNumber$1(y, b)) === 0;
	};
	P.isFinite = function() {
		return !!this.c;
	};
	P.isGreaterThan = P.gt = function(y, b) {
		return compare(this, new BigNumber$1(y, b)) > 0;
	};
	P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
		return (b = compare(this, new BigNumber$1(y, b))) === 1 || b === 0;
	};
	P.isInteger = function() {
		return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
	};
	P.isLessThan = P.lt = function(y, b) {
		return compare(this, new BigNumber$1(y, b)) < 0;
	};
	P.isLessThanOrEqualTo = P.lte = function(y, b) {
		return (b = compare(this, new BigNumber$1(y, b))) === -1 || b === 0;
	};
	P.isNaN = function() {
		return !this.s;
	};
	P.isNegative = function() {
		return this.s < 0;
	};
	P.isPositive = function() {
		return this.s > 0;
	};
	P.isZero = function() {
		return !!this.c && this.c[0] == 0;
	};
	P.minus = function(y, b) {
		var i, j, t, xLTy, x = this, a = x.s;
		y = new BigNumber$1(y, b);
		b = y.s;
		if (!a || !b) return new BigNumber$1(NaN);
		if (a != b) {
			y.s = -b;
			return x.plus(y);
		}
		var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
		if (!xe || !ye) {
			if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber$1(yc ? x : NaN);
			if (!xc[0] || !yc[0]) return yc[0] ? (y.s = -b, y) : new BigNumber$1(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
		}
		xe = bitFloor(xe);
		ye = bitFloor(ye);
		xc = xc.slice();
		if (a = xe - ye) {
			if (xLTy = a < 0) {
				a = -a;
				t = xc;
			} else {
				ye = xe;
				t = yc;
			}
			t.reverse();
			for (b = a; b--; t.push(0));
			t.reverse();
		} else {
			j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
			for (a = b = 0; b < j; b++) if (xc[b] != yc[b]) {
				xLTy = xc[b] < yc[b];
				break;
			}
		}
		if (xLTy) {
			t = xc;
			xc = yc;
			yc = t;
			y.s = -y.s;
		}
		b = (j = yc.length) - (i = xc.length);
		if (b > 0) for (; b--; xc[i++] = 0);
		b = BASE - 1;
		for (; j > a;) {
			if (xc[--j] < yc[j]) {
				for (i = j; i && !xc[--i]; xc[i] = b);
				--xc[i];
				xc[j] += BASE;
			}
			xc[j] -= yc[j];
		}
		for (; xc[0] == 0; xc.splice(0, 1), --ye);
		if (!xc[0]) {
			y.s = ROUNDING_MODE == 3 ? -1 : 1;
			y.c = [y.e = 0];
			return y;
		}
		return normalise(y, xc, ye);
	};
	P.modulo = P.mod = function(y, b) {
		var q, s, x = this;
		y = new BigNumber$1(y, b);
		if (!x.c || !y.s || y.c && !y.c[0]) return new BigNumber$1(NaN);
		else if (!y.c || x.c && !x.c[0]) return new BigNumber$1(x);
		if (MODULO_MODE == 9) {
			s = y.s;
			y.s = 1;
			q = div(x, y, 0, 3);
			y.s = s;
			q.s *= s;
		} else q = div(x, y, 0, MODULO_MODE);
		y = x.minus(q.times(y));
		if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
		return y;
	};
	P.multipliedBy = P.times = function(y, b) {
		var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber$1(y, b)).c;
		if (!xc || !yc || !xc[0] || !yc[0]) {
			if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) y.c = y.e = y.s = null;
			else {
				y.s *= x.s;
				if (!xc || !yc) y.c = y.e = null;
				else {
					y.c = [0];
					y.e = 0;
				}
			}
			return y;
		}
		e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
		y.s *= x.s;
		xcL = xc.length;
		ycL = yc.length;
		if (xcL < ycL) {
			zc = xc;
			xc = yc;
			yc = zc;
			i = xcL;
			xcL = ycL;
			ycL = i;
		}
		for (i = xcL + ycL, zc = []; i--; zc.push(0));
		base = BASE;
		sqrtBase = SQRT_BASE;
		for (i = ycL; --i >= 0;) {
			c = 0;
			ylo = yc[i] % sqrtBase;
			yhi = yc[i] / sqrtBase | 0;
			for (k = xcL, j = i + k; j > i;) {
				xlo = xc[--k] % sqrtBase;
				xhi = xc[k] / sqrtBase | 0;
				m = yhi * xlo + xhi * ylo;
				xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
				c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
				zc[j--] = xlo % base;
			}
			zc[j] = c;
		}
		if (c) ++e;
		else zc.splice(0, 1);
		return normalise(y, zc, e);
	};
	P.negated = function() {
		var x = new BigNumber$1(this);
		x.s = -x.s || null;
		return x;
	};
	P.plus = function(y, b) {
		var t, x = this, a = x.s;
		y = new BigNumber$1(y, b);
		b = y.s;
		if (!a || !b) return new BigNumber$1(NaN);
		if (a != b) {
			y.s = -b;
			return x.minus(y);
		}
		var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
		if (!xe || !ye) {
			if (!xc || !yc) return new BigNumber$1(a / 0);
			if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber$1(xc[0] ? x : a * 0);
		}
		xe = bitFloor(xe);
		ye = bitFloor(ye);
		xc = xc.slice();
		if (a = xe - ye) {
			if (a > 0) {
				ye = xe;
				t = yc;
			} else {
				a = -a;
				t = xc;
			}
			t.reverse();
			for (; a--; t.push(0));
			t.reverse();
		}
		a = xc.length;
		b = yc.length;
		if (a - b < 0) {
			t = yc;
			yc = xc;
			xc = t;
			b = a;
		}
		for (a = 0; b;) {
			a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
			xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
		}
		if (a) {
			xc = [a].concat(xc);
			++ye;
		}
		return normalise(y, xc, ye);
	};
	P.precision = P.sd = function(sd, rm) {
		var c, n, v, x = this;
		if (sd != null && sd !== !!sd) {
			intCheck(sd, 1, MAX);
			if (rm == null) rm = ROUNDING_MODE;
			else intCheck(rm, 0, 8);
			return round(new BigNumber$1(x), sd, rm);
		}
		if (!(c = x.c)) return null;
		v = c.length - 1;
		n = v * LOG_BASE + 1;
		if (v = c[v]) {
			for (; v % 10 == 0; v /= 10, n--);
			for (v = c[0]; v >= 10; v /= 10, n++);
		}
		if (sd && x.e + 1 > n) n = x.e + 1;
		return n;
	};
	P.shiftedBy = function(k) {
		intCheck(k, -MAX_SAFE_INTEGER$1, MAX_SAFE_INTEGER$1);
		return this.times("1e" + k);
	};
	P.squareRoot = P.sqrt = function() {
		var m, n, r, rep$1, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber$1("0.5");
		if (s !== 1 || !c || !c[0]) return new BigNumber$1(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : Infinity);
		s = Math.sqrt(+valueOf(x));
		if (s == 0 || s == Infinity) {
			n = coeffToString(c);
			if ((n.length + e) % 2 == 0) n += "0";
			s = Math.sqrt(+n);
			e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
			if (s == Infinity) n = "5e" + e;
			else {
				n = s.toExponential();
				n = n.slice(0, n.indexOf("e") + 1) + e;
			}
			r = new BigNumber$1(n);
		} else r = new BigNumber$1(s + "");
		if (r.c[0]) {
			e = r.e;
			s = e + dp;
			if (s < 3) s = 0;
			for (;;) {
				t = r;
				r = half.times(t.plus(div(x, t, dp, 1)));
				if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
					if (r.e < e) --s;
					n = n.slice(s - 3, s + 1);
					if (n == "9999" || !rep$1 && n == "4999") {
						if (!rep$1) {
							round(t, t.e + DECIMAL_PLACES + 2, 0);
							if (t.times(t).eq(x)) {
								r = t;
								break;
							}
						}
						dp += 4;
						s += 4;
						rep$1 = 1;
					} else {
						if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
							round(r, r.e + DECIMAL_PLACES + 2, 1);
							m = !r.times(r).eq(x);
						}
						break;
					}
				}
			}
		}
		return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
	};
	P.toExponential = function(dp, rm) {
		if (dp != null) {
			intCheck(dp, 0, MAX);
			dp++;
		}
		return format$2(this, dp, rm, 1);
	};
	P.toFixed = function(dp, rm) {
		if (dp != null) {
			intCheck(dp, 0, MAX);
			dp = dp + this.e + 1;
		}
		return format$2(this, dp, rm);
	};
	P.toFormat = function(dp, rm, format$3) {
		var str$1, x = this;
		if (format$3 == null) if (dp != null && rm && typeof rm == "object") {
			format$3 = rm;
			rm = null;
		} else if (dp && typeof dp == "object") {
			format$3 = dp;
			dp = rm = null;
		} else format$3 = FORMAT;
		else if (typeof format$3 != "object") throw Error(bignumberError + "Argument not an object: " + format$3);
		str$1 = x.toFixed(dp, rm);
		if (x.c) {
			var i, arr$1 = str$1.split("."), g1 = +format$3.groupSize, g2 = +format$3.secondaryGroupSize, groupSeparator = format$3.groupSeparator || "", intPart = arr$1[0], fractionPart = arr$1[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
			if (g2) {
				i = g1;
				g1 = g2;
				g2 = i;
				len -= i;
			}
			if (g1 > 0 && len > 0) {
				i = len % g1 || g1;
				intPart = intDigits.substr(0, i);
				for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
				if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
				if (isNeg) intPart = "-" + intPart;
			}
			str$1 = fractionPart ? intPart + (format$3.decimalSeparator || "") + ((g2 = +format$3.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format$3.fractionGroupSeparator || "")) : fractionPart) : intPart;
		}
		return (format$3.prefix || "") + str$1 + (format$3.suffix || "");
	};
	P.toFraction = function(md) {
		var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
		if (md != null) {
			n = new BigNumber$1(md);
			if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
		}
		if (!xc) return new BigNumber$1(x);
		d = new BigNumber$1(ONE);
		n1 = d0 = new BigNumber$1(ONE);
		d1 = n0 = new BigNumber$1(ONE);
		s = coeffToString(xc);
		e = d.e = s.length - x.e - 1;
		d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
		md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
		exp = MAX_EXP;
		MAX_EXP = Infinity;
		n = new BigNumber$1(s);
		n0.c[0] = 0;
		for (;;) {
			q = div(n, d, 0, 1);
			d2 = d0.plus(q.times(d1));
			if (d2.comparedTo(md) == 1) break;
			d0 = d1;
			d1 = d2;
			n1 = n0.plus(q.times(d2 = n1));
			n0 = d2;
			d = n.minus(q.times(d2 = d));
			n = d2;
		}
		d2 = div(md.minus(d0), d1, 0, 1);
		n0 = n0.plus(d2.times(n1));
		d0 = d0.plus(d2.times(d1));
		n0.s = n1.s = x.s;
		e = e * 2;
		r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
		MAX_EXP = exp;
		return r;
	};
	P.toNumber = function() {
		return +valueOf(this);
	};
	P.toPrecision = function(sd, rm) {
		if (sd != null) intCheck(sd, 1, MAX);
		return format$2(this, sd, rm, 2);
	};
	P.toString = function(b) {
		var str$1, n = this, s = n.s, e = n.e;
		if (e === null) if (s) {
			str$1 = "Infinity";
			if (s < 0) str$1 = "-" + str$1;
		} else str$1 = "NaN";
		else {
			if (b == null) str$1 = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
			else if (b === 10 && alphabetHasNormalDecimalDigits) {
				n = round(new BigNumber$1(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
				str$1 = toFixedPoint(coeffToString(n.c), n.e, "0");
			} else {
				intCheck(b, 2, ALPHABET.length, "Base");
				str$1 = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
			}
			if (s < 0 && n.c[0]) str$1 = "-" + str$1;
		}
		return str$1;
	};
	P.valueOf = P.toJSON = function() {
		return valueOf(this);
	};
	P._isBigNumber = true;
	P[Symbol.toStringTag] = "BigNumber";
	P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
	if (configObject != null) BigNumber$1.set(configObject);
	return BigNumber$1;
}
function bitFloor(n) {
	var i = n | 0;
	return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
	var s, z, i = 1, j = a.length, r = a[0] + "";
	for (; i < j;) {
		s = a[i++] + "";
		z = LOG_BASE - s.length;
		for (; z--; s = "0" + s);
		r += s;
	}
	for (j = r.length; r.charCodeAt(--j) === 48;);
	return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
	var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
	if (!i || !j) return null;
	a = xc && !xc[0];
	b = yc && !yc[0];
	if (a || b) return a ? b ? 0 : -j : i;
	if (i != j) return i;
	a = i < 0;
	b = k == l;
	if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
	if (!b) return k > l ^ a ? 1 : -1;
	j = (k = xc.length) < (l = yc.length) ? k : l;
	for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
	return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name$1) {
	if (n < min || n > max || n !== mathfloor(n)) throw Error(bignumberError + (name$1 || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
}
function isOdd(n) {
	var k = n.c.length - 1;
	return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str$1, e) {
	return (str$1.length > 1 ? str$1.charAt(0) + "." + str$1.slice(1) : str$1) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str$1, e, z) {
	var len, zs;
	if (e < 0) {
		for (zs = z + "."; ++e; zs += z);
		str$1 = zs + str$1;
	} else {
		len = str$1.length;
		if (++e > len) {
			for (zs = z, e -= len; --e; zs += z);
			str$1 += zs;
		} else if (e < len) str$1 = str$1.slice(0, e) + "." + str$1.slice(e);
	}
	return str$1;
}
var BigNumber = clone();

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
	"@babel/helpers - typeof";
	return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof(o);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
	if ("object" != _typeof(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
	var i = toPrimitive(t, "string");
	return "symbol" == _typeof(i) ? i : i + "";
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r, t) {
	return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r] = t, e;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread2(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {
			_defineProperty(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}

//#endregion
//#region node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/ours/primordials.js": ((exports, module) => {
	var AggregateError$2 = class extends Error {
		constructor(errors) {
			if (!Array.isArray(errors)) throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
			let message = "";
			for (let i = 0; i < errors.length; i++) message += `    ${errors[i].stack}\n`;
			super(message);
			this.name = "AggregateError";
			this.errors = errors;
		}
	};
	module.exports = {
		AggregateError: AggregateError$2,
		ArrayIsArray(self$1) {
			return Array.isArray(self$1);
		},
		ArrayPrototypeIncludes(self$1, el) {
			return self$1.includes(el);
		},
		ArrayPrototypeIndexOf(self$1, el) {
			return self$1.indexOf(el);
		},
		ArrayPrototypeJoin(self$1, sep) {
			return self$1.join(sep);
		},
		ArrayPrototypeMap(self$1, fn) {
			return self$1.map(fn);
		},
		ArrayPrototypePop(self$1, el) {
			return self$1.pop(el);
		},
		ArrayPrototypePush(self$1, el) {
			return self$1.push(el);
		},
		ArrayPrototypeSlice(self$1, start, end) {
			return self$1.slice(start, end);
		},
		Error,
		FunctionPrototypeCall(fn, thisArgs, ...args) {
			return fn.call(thisArgs, ...args);
		},
		FunctionPrototypeSymbolHasInstance(self$1, instance) {
			return Function.prototype[Symbol.hasInstance].call(self$1, instance);
		},
		MathFloor: Math.floor,
		Number,
		NumberIsInteger: Number.isInteger,
		NumberIsNaN: Number.isNaN,
		NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
		NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
		NumberParseInt: Number.parseInt,
		ObjectDefineProperties(self$1, props) {
			return Object.defineProperties(self$1, props);
		},
		ObjectDefineProperty(self$1, name$1, prop) {
			return Object.defineProperty(self$1, name$1, prop);
		},
		ObjectGetOwnPropertyDescriptor(self$1, name$1) {
			return Object.getOwnPropertyDescriptor(self$1, name$1);
		},
		ObjectKeys(obj) {
			return Object.keys(obj);
		},
		ObjectSetPrototypeOf(target, proto) {
			return Object.setPrototypeOf(target, proto);
		},
		Promise,
		PromisePrototypeCatch(self$1, fn) {
			return self$1.catch(fn);
		},
		PromisePrototypeThen(self$1, thenFn, catchFn) {
			return self$1.then(thenFn, catchFn);
		},
		PromiseReject(err) {
			return Promise.reject(err);
		},
		PromiseResolve(val) {
			return Promise.resolve(val);
		},
		ReflectApply: Reflect.apply,
		RegExpPrototypeTest(self$1, value$2) {
			return self$1.test(value$2);
		},
		SafeSet: Set,
		String,
		StringPrototypeSlice(self$1, start, end) {
			return self$1.slice(start, end);
		},
		StringPrototypeToLowerCase(self$1) {
			return self$1.toLowerCase();
		},
		StringPrototypeToUpperCase(self$1) {
			return self$1.toUpperCase();
		},
		StringPrototypeTrim(self$1) {
			return self$1.trim();
		},
		Symbol,
		SymbolFor: Symbol.for,
		SymbolAsyncIterator: Symbol.asyncIterator,
		SymbolHasInstance: Symbol.hasInstance,
		SymbolIterator: Symbol.iterator,
		SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
		SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
		TypedArrayPrototypeSet(self$1, buf, len) {
			return self$1.set(buf, len);
		},
		Boolean,
		Uint8Array
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/ours/util/inspect.js": ((exports, module) => {
	module.exports = {
		format(format$2, ...args) {
			return format$2.replace(/%([sdifj])/g, function(...[_unused, type$5]) {
				const replacement = args.shift();
				if (type$5 === "f") return replacement.toFixed(6);
				else if (type$5 === "j") return JSON.stringify(replacement);
				else if (type$5 === "s" && typeof replacement === "object") return `${replacement.constructor !== Object ? replacement.constructor.name : ""} {}`.trim();
				else return replacement.toString();
			});
		},
		inspect(value$2) {
			switch (typeof value$2) {
				case "string":
					if (value$2.includes("'")) {
						if (!value$2.includes("\"")) return `"${value$2}"`;
						else if (!value$2.includes("`") && !value$2.includes("${")) return `\`${value$2}\``;
					}
					return `'${value$2}'`;
				case "number":
					if (isNaN(value$2)) return "NaN";
					else if (Object.is(value$2, -0)) return String(value$2);
					return value$2;
				case "bigint": return `${String(value$2)}n`;
				case "boolean":
				case "undefined": return String(value$2);
				case "object": return "{}";
			}
		}
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/ours/errors.js
var require_errors$1 = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/ours/errors.js": ((exports, module) => {
	var { format: format$1, inspect: inspect$2 } = require_inspect();
	var { AggregateError: CustomAggregateError } = require_primordials();
	var AggregateError$1 = globalThis.AggregateError || CustomAggregateError;
	var kIsNodeError = Symbol("kIsNodeError");
	var kTypes = [
		"string",
		"function",
		"number",
		"object",
		"Function",
		"Object",
		"boolean",
		"bigint",
		"symbol"
	];
	var classRegExp = /^([A-Z][a-z0-9]*)+$/;
	var nodeInternalPrefix = "__node_internal_";
	var codes$2 = {};
	function assert$2(value$2, message) {
		if (!value$2) throw new codes$2.ERR_INTERNAL_ASSERTION(message);
	}
	function addNumericalSeparator(val) {
		let res = "";
		let i = val.length;
		const start = val[0] === "-" ? 1 : 0;
		for (; i >= start + 4; i -= 3) res = `_${val.slice(i - 3, i)}${res}`;
		return `${val.slice(0, i)}${res}`;
	}
	function getMessage(key, msg, args) {
		if (typeof msg === "function") {
			assert$2(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);
			return msg(...args);
		}
		const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
		assert$2(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);
		if (args.length === 0) return msg;
		return format$1(msg, ...args);
	}
	function E(code, message, Base) {
		if (!Base) Base = Error;
		class NodeError extends Base {
			constructor(...args) {
				super(getMessage(code, message, args));
			}
			toString() {
				return `${this.name} [${code}]: ${this.message}`;
			}
		}
		Object.defineProperties(NodeError.prototype, {
			name: {
				value: Base.name,
				writable: true,
				enumerable: false,
				configurable: true
			},
			toString: {
				value() {
					return `${this.name} [${code}]: ${this.message}`;
				},
				writable: true,
				enumerable: false,
				configurable: true
			}
		});
		NodeError.prototype.code = code;
		NodeError.prototype[kIsNodeError] = true;
		codes$2[code] = NodeError;
	}
	function hideStackFrames$1(fn) {
		const hidden = nodeInternalPrefix + fn.name;
		Object.defineProperty(fn, "name", { value: hidden });
		return fn;
	}
	function aggregateTwoErrors$3(innerError, outerError) {
		if (innerError && outerError && innerError !== outerError) {
			if (Array.isArray(outerError.errors)) {
				outerError.errors.push(innerError);
				return outerError;
			}
			const err = new AggregateError$1([outerError, innerError], outerError.message);
			err.code = outerError.code;
			return err;
		}
		return innerError || outerError;
	}
	var AbortError$8 = class extends Error {
		constructor(message = "The operation was aborted", options = void 0) {
			if (options !== void 0 && typeof options !== "object") throw new codes$2.ERR_INVALID_ARG_TYPE("options", "Object", options);
			super(message, options);
			this.code = "ABORT_ERR";
			this.name = "AbortError";
		}
	};
	E("ERR_ASSERTION", "%s", Error);
	E("ERR_INVALID_ARG_TYPE", (name$1, expected, actual) => {
		assert$2(typeof name$1 === "string", "'name' must be a string");
		if (!Array.isArray(expected)) expected = [expected];
		let msg = "The ";
		if (name$1.endsWith(" argument")) msg += `${name$1} `;
		else msg += `"${name$1}" ${name$1.includes(".") ? "property" : "argument"} `;
		msg += "must be ";
		const types = [];
		const instances = [];
		const other = [];
		for (const value$2 of expected) {
			assert$2(typeof value$2 === "string", "All expected entries have to be of type string");
			if (kTypes.includes(value$2)) types.push(value$2.toLowerCase());
			else if (classRegExp.test(value$2)) instances.push(value$2);
			else {
				assert$2(value$2 !== "object", "The value \"object\" should be written as \"Object\"");
				other.push(value$2);
			}
		}
		if (instances.length > 0) {
			const pos = types.indexOf("object");
			if (pos !== -1) {
				types.splice(types, pos, 1);
				instances.push("Object");
			}
		}
		if (types.length > 0) {
			switch (types.length) {
				case 1:
					msg += `of type ${types[0]}`;
					break;
				case 2:
					msg += `one of type ${types[0]} or ${types[1]}`;
					break;
				default: {
					const last = types.pop();
					msg += `one of type ${types.join(", ")}, or ${last}`;
				}
			}
			if (instances.length > 0 || other.length > 0) msg += " or ";
		}
		if (instances.length > 0) {
			switch (instances.length) {
				case 1:
					msg += `an instance of ${instances[0]}`;
					break;
				case 2:
					msg += `an instance of ${instances[0]} or ${instances[1]}`;
					break;
				default: {
					const last = instances.pop();
					msg += `an instance of ${instances.join(", ")}, or ${last}`;
				}
			}
			if (other.length > 0) msg += " or ";
		}
		switch (other.length) {
			case 0: break;
			case 1:
				if (other[0].toLowerCase() !== other[0]) msg += "an ";
				msg += `${other[0]}`;
				break;
			case 2:
				msg += `one of ${other[0]} or ${other[1]}`;
				break;
			default: {
				const last = other.pop();
				msg += `one of ${other.join(", ")}, or ${last}`;
			}
		}
		if (actual == null) msg += `. Received ${actual}`;
		else if (typeof actual === "function" && actual.name) msg += `. Received function ${actual.name}`;
		else if (typeof actual === "object") {
			var _actual$constructor;
			if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) msg += `. Received an instance of ${actual.constructor.name}`;
			else {
				const inspected = inspect$2(actual, { depth: -1 });
				msg += `. Received ${inspected}`;
			}
		} else {
			let inspected = inspect$2(actual, { colors: false });
			if (inspected.length > 25) inspected = `${inspected.slice(0, 25)}...`;
			msg += `. Received type ${typeof actual} (${inspected})`;
		}
		return msg;
	}, TypeError);
	E("ERR_INVALID_ARG_VALUE", (name$1, value$2, reason = "is invalid") => {
		let inspected = inspect$2(value$2);
		if (inspected.length > 128) inspected = inspected.slice(0, 128) + "...";
		return `The ${name$1.includes(".") ? "property" : "argument"} '${name$1}' ${reason}. Received ${inspected}`;
	}, TypeError);
	E("ERR_INVALID_RETURN_VALUE", (input, name$1, value$2) => {
		var _value$constructor;
		return `Expected ${input} to be returned from the "${name$1}" function but got ${value$2 !== null && value$2 !== void 0 && (_value$constructor = value$2.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value$2.constructor.name}` : `type ${typeof value$2}`}.`;
	}, TypeError);
	E("ERR_MISSING_ARGS", (...args) => {
		assert$2(args.length > 0, "At least one arg needs to be specified");
		let msg;
		const len = args.length;
		args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
		switch (len) {
			case 1:
				msg += `The ${args[0]} argument`;
				break;
			case 2:
				msg += `The ${args[0]} and ${args[1]} arguments`;
				break;
			default:
				{
					const last = args.pop();
					msg += `The ${args.join(", ")}, and ${last} arguments`;
				}
				break;
		}
		return `${msg} must be specified`;
	}, TypeError);
	E("ERR_OUT_OF_RANGE", (str$1, range, input) => {
		assert$2(range, "Missing \"range\" argument");
		let received;
		if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
		else if (typeof input === "bigint") {
			received = String(input);
			const limit = BigInt(2) ** BigInt(32);
			if (input > limit || input < -limit) received = addNumericalSeparator(received);
			received += "n";
		} else received = inspect$2(input);
		return `The value of "${str$1}" is out of range. It must be ${range}. Received ${received}`;
	}, RangeError);
	E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
	E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
	E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
	E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
	E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
	E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
	E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
	E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
	E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
	E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
	E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
	module.exports = {
		AbortError: AbortError$8,
		aggregateTwoErrors: hideStackFrames$1(aggregateTwoErrors$3),
		hideStackFrames: hideStackFrames$1,
		codes: codes$2
	};
}) });

//#endregion
//#region node_modules/abort-controller/browser.js
var require_browser$2 = /* @__PURE__ */ __commonJS({ "node_modules/abort-controller/browser.js": ((exports, module) => {
	var { AbortController: AbortController$4, AbortSignal: AbortSignal$1 } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0;
	module.exports = AbortController$4;
	module.exports.AbortSignal = AbortSignal$1;
	module.exports.default = AbortController$4;
}) });

//#endregion
//#region node_modules/readable-stream/lib/ours/util.js
var require_util = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/ours/util.js": ((exports, module) => {
	var bufferModule$1 = require_buffer();
	var { format, inspect: inspect$1 } = require_inspect();
	var { codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$9 } } = require_errors$1();
	var { kResistStopPropagation: kResistStopPropagation$1, AggregateError, SymbolDispose: SymbolDispose$3 } = require_primordials();
	var AbortSignal = globalThis.AbortSignal || require_browser$2().AbortSignal;
	var AbortController$3 = globalThis.AbortController || require_browser$2().AbortController;
	var AsyncFunction = Object.getPrototypeOf(async function() {}).constructor;
	var Blob$2 = globalThis.Blob || bufferModule$1.Blob;
	var isBlob$1 = typeof Blob$2 !== "undefined" ? function isBlob$2(b) {
		return b instanceof Blob$2;
	} : function isBlob$2(b) {
		return false;
	};
	var validateAbortSignal$5 = (signal, name$1) => {
		if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) throw new ERR_INVALID_ARG_TYPE$9(name$1, "AbortSignal", signal);
	};
	var validateFunction$3 = (value$2, name$1) => {
		if (typeof value$2 !== "function") throw new ERR_INVALID_ARG_TYPE$9(name$1, "Function", value$2);
	};
	module.exports = {
		AggregateError,
		kEmptyObject: Object.freeze({}),
		once(callback) {
			let called = false;
			return function(...args) {
				if (called) return;
				called = true;
				callback.apply(this, args);
			};
		},
		createDeferredPromise: function() {
			let resolve;
			let reject;
			return {
				promise: new Promise((res, rej) => {
					resolve = res;
					reject = rej;
				}),
				resolve,
				reject
			};
		},
		promisify(fn) {
			return new Promise((resolve, reject) => {
				fn((err, ...args) => {
					if (err) return reject(err);
					return resolve(...args);
				});
			});
		},
		debuglog() {
			return function() {};
		},
		format,
		inspect: inspect$1,
		types: {
			isAsyncFunction(fn) {
				return fn instanceof AsyncFunction;
			},
			isArrayBufferView(arr$1) {
				return ArrayBuffer.isView(arr$1);
			}
		},
		isBlob: isBlob$1,
		deprecate(fn, message) {
			return fn;
		},
		addAbortListener: require_events().addAbortListener || function addAbortListener$3(signal, listener) {
			if (signal === void 0) throw new ERR_INVALID_ARG_TYPE$9("signal", "AbortSignal", signal);
			validateAbortSignal$5(signal, "signal");
			validateFunction$3(listener, "listener");
			let removeEventListener$1;
			if (signal.aborted) queueMicrotask(() => listener());
			else {
				signal.addEventListener("abort", listener, {
					__proto__: null,
					once: true,
					[kResistStopPropagation$1]: true
				});
				removeEventListener$1 = () => {
					signal.removeEventListener("abort", listener);
				};
			}
			return {
				__proto__: null,
				[SymbolDispose$3]() {
					var _removeEventListener;
					(_removeEventListener = removeEventListener$1) === null || _removeEventListener === void 0 || _removeEventListener();
				}
			};
		},
		AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals$1) {
			if (signals$1.length === 1) return signals$1[0];
			const ac = new AbortController$3();
			const abort = () => ac.abort();
			signals$1.forEach((signal) => {
				validateAbortSignal$5(signal, "signals");
				signal.addEventListener("abort", abort, { once: true });
			});
			ac.signal.addEventListener("abort", () => {
				signals$1.forEach((signal) => signal.removeEventListener("abort", abort));
			}, { once: true });
			return ac.signal;
		}
	};
	module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/validators.js
var require_validators = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/validators.js": ((exports, module) => {
	var { ArrayIsArray: ArrayIsArray$2, ArrayPrototypeIncludes, ArrayPrototypeJoin, ArrayPrototypeMap, NumberIsInteger: NumberIsInteger$2, NumberIsNaN: NumberIsNaN$2, NumberMAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER, NumberParseInt: NumberParseInt$1, ObjectPrototypeHasOwnProperty, RegExpPrototypeExec, String: String$1, StringPrototypeToUpperCase, StringPrototypeTrim } = require_primordials();
	var { hideStackFrames, codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$8, ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE$3, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE$2, ERR_UNKNOWN_SIGNAL } } = require_errors$1();
	var { normalizeEncoding } = require_util();
	var { isAsyncFunction, isArrayBufferView } = require_util().types;
	var signals = {};
	/**
	* @param {*} value
	* @returns {boolean}
	*/
	function isInt32(value$2) {
		return value$2 === (value$2 | 0);
	}
	/**
	* @param {*} value
	* @returns {boolean}
	*/
	function isUint32(value$2) {
		return value$2 === value$2 >>> 0;
	}
	var octalReg = /^[0-7]+$/;
	var modeDesc = "must be a 32-bit unsigned integer or an octal string";
	/**
	* Parse and validate values that will be converted into mode_t (the S_*
	* constants). Only valid numbers and octal strings are allowed. They could be
	* converted to 32-bit unsigned integers or non-negative signed integers in the
	* C++ land, but any value higher than 0o777 will result in platform-specific
	* behaviors.
	* @param {*} value Values to be validated
	* @param {string} name Name of the argument
	* @param {number} [def] If specified, will be returned for invalid values
	* @returns {number}
	*/
	function parseFileMode(value$2, name$1, def) {
		if (typeof value$2 === "undefined") value$2 = def;
		if (typeof value$2 === "string") {
			if (RegExpPrototypeExec(octalReg, value$2) === null) throw new ERR_INVALID_ARG_VALUE$3(name$1, value$2, modeDesc);
			value$2 = NumberParseInt$1(value$2, 8);
		}
		validateUint32(value$2, name$1);
		return value$2;
	}
	/**
	* @callback validateInteger
	* @param {*} value
	* @param {string} name
	* @param {number} [min]
	* @param {number} [max]
	* @returns {asserts value is number}
	*/
	/** @type {validateInteger} */
	var validateInteger$2 = hideStackFrames((value$2, name$1, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
		if (typeof value$2 !== "number") throw new ERR_INVALID_ARG_TYPE$8(name$1, "number", value$2);
		if (!NumberIsInteger$2(value$2)) throw new ERR_OUT_OF_RANGE$2(name$1, "an integer", value$2);
		if (value$2 < min || value$2 > max) throw new ERR_OUT_OF_RANGE$2(name$1, `>= ${min} && <= ${max}`, value$2);
	});
	/**
	* @callback validateInt32
	* @param {*} value
	* @param {string} name
	* @param {number} [min]
	* @param {number} [max]
	* @returns {asserts value is number}
	*/
	/** @type {validateInt32} */
	var validateInt32 = hideStackFrames((value$2, name$1, min = -2147483648, max = 2147483647) => {
		if (typeof value$2 !== "number") throw new ERR_INVALID_ARG_TYPE$8(name$1, "number", value$2);
		if (!NumberIsInteger$2(value$2)) throw new ERR_OUT_OF_RANGE$2(name$1, "an integer", value$2);
		if (value$2 < min || value$2 > max) throw new ERR_OUT_OF_RANGE$2(name$1, `>= ${min} && <= ${max}`, value$2);
	});
	/**
	* @callback validateUint32
	* @param {*} value
	* @param {string} name
	* @param {number|boolean} [positive=false]
	* @returns {asserts value is number}
	*/
	/** @type {validateUint32} */
	var validateUint32 = hideStackFrames((value$2, name$1, positive = false) => {
		if (typeof value$2 !== "number") throw new ERR_INVALID_ARG_TYPE$8(name$1, "number", value$2);
		if (!NumberIsInteger$2(value$2)) throw new ERR_OUT_OF_RANGE$2(name$1, "an integer", value$2);
		const min = positive ? 1 : 0;
		const max = 4294967295;
		if (value$2 < min || value$2 > max) throw new ERR_OUT_OF_RANGE$2(name$1, `>= ${min} && <= ${max}`, value$2);
	});
	/**
	* @callback validateString
	* @param {*} value
	* @param {string} name
	* @returns {asserts value is string}
	*/
	/** @type {validateString} */
	function validateString(value$2, name$1) {
		if (typeof value$2 !== "string") throw new ERR_INVALID_ARG_TYPE$8(name$1, "string", value$2);
	}
	/**
	* @callback validateNumber
	* @param {*} value
	* @param {string} name
	* @param {number} [min]
	* @param {number} [max]
	* @returns {asserts value is number}
	*/
	/** @type {validateNumber} */
	function validateNumber(value$2, name$1, min = void 0, max) {
		if (typeof value$2 !== "number") throw new ERR_INVALID_ARG_TYPE$8(name$1, "number", value$2);
		if (min != null && value$2 < min || max != null && value$2 > max || (min != null || max != null) && NumberIsNaN$2(value$2)) throw new ERR_OUT_OF_RANGE$2(name$1, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value$2);
	}
	/**
	* @callback validateOneOf
	* @template T
	* @param {T} value
	* @param {string} name
	* @param {T[]} oneOf
	*/
	/** @type {validateOneOf} */
	var validateOneOf = hideStackFrames((value$2, name$1, oneOf) => {
		if (!ArrayPrototypeIncludes(oneOf, value$2)) throw new ERR_INVALID_ARG_VALUE$3(name$1, value$2, "must be one of: " + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String$1(v)), ", "));
	});
	/**
	* @callback validateBoolean
	* @param {*} value
	* @param {string} name
	* @returns {asserts value is boolean}
	*/
	/** @type {validateBoolean} */
	function validateBoolean$1(value$2, name$1) {
		if (typeof value$2 !== "boolean") throw new ERR_INVALID_ARG_TYPE$8(name$1, "boolean", value$2);
	}
	/**
	* @param {any} options
	* @param {string} key
	* @param {boolean} defaultValue
	* @returns {boolean}
	*/
	function getOwnPropertyValueOrDefault(options, key, defaultValue) {
		return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
	}
	/**
	* @callback validateObject
	* @param {*} value
	* @param {string} name
	* @param {{
	*   allowArray?: boolean,
	*   allowFunction?: boolean,
	*   nullable?: boolean
	* }} [options]
	*/
	/** @type {validateObject} */
	var validateObject$4 = hideStackFrames((value$2, name$1, options = null) => {
		const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
		const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
		if (!getOwnPropertyValueOrDefault(options, "nullable", false) && value$2 === null || !allowArray && ArrayIsArray$2(value$2) || typeof value$2 !== "object" && (!allowFunction || typeof value$2 !== "function")) throw new ERR_INVALID_ARG_TYPE$8(name$1, "Object", value$2);
	});
	/**
	* @callback validateDictionary - We are using the Web IDL Standard definition
	*                                of "dictionary" here, which means any value
	*                                whose Type is either Undefined, Null, or
	*                                Object (which includes functions).
	* @param {*} value
	* @param {string} name
	* @see https://webidl.spec.whatwg.org/#es-dictionary
	* @see https://tc39.es/ecma262/#table-typeof-operator-results
	*/
	/** @type {validateDictionary} */
	var validateDictionary = hideStackFrames((value$2, name$1) => {
		if (value$2 != null && typeof value$2 !== "object" && typeof value$2 !== "function") throw new ERR_INVALID_ARG_TYPE$8(name$1, "a dictionary", value$2);
	});
	/**
	* @callback validateArray
	* @param {*} value
	* @param {string} name
	* @param {number} [minLength]
	* @returns {asserts value is any[]}
	*/
	/** @type {validateArray} */
	var validateArray = hideStackFrames((value$2, name$1, minLength = 0) => {
		if (!ArrayIsArray$2(value$2)) throw new ERR_INVALID_ARG_TYPE$8(name$1, "Array", value$2);
		if (value$2.length < minLength) throw new ERR_INVALID_ARG_VALUE$3(name$1, value$2, `must be longer than ${minLength}`);
	});
	/**
	* @callback validateStringArray
	* @param {*} value
	* @param {string} name
	* @returns {asserts value is string[]}
	*/
	/** @type {validateStringArray} */
	function validateStringArray(value$2, name$1) {
		validateArray(value$2, name$1);
		for (let i = 0; i < value$2.length; i++) validateString(value$2[i], `${name$1}[${i}]`);
	}
	/**
	* @callback validateBooleanArray
	* @param {*} value
	* @param {string} name
	* @returns {asserts value is boolean[]}
	*/
	/** @type {validateBooleanArray} */
	function validateBooleanArray(value$2, name$1) {
		validateArray(value$2, name$1);
		for (let i = 0; i < value$2.length; i++) validateBoolean$1(value$2[i], `${name$1}[${i}]`);
	}
	/**
	* @callback validateAbortSignalArray
	* @param {*} value
	* @param {string} name
	* @returns {asserts value is AbortSignal[]}
	*/
	/** @type {validateAbortSignalArray} */
	function validateAbortSignalArray(value$2, name$1) {
		validateArray(value$2, name$1);
		for (let i = 0; i < value$2.length; i++) {
			const signal = value$2[i];
			const indexedName = `${name$1}[${i}]`;
			if (signal == null) throw new ERR_INVALID_ARG_TYPE$8(indexedName, "AbortSignal", signal);
			validateAbortSignal$4(signal, indexedName);
		}
	}
	/**
	* @param {*} signal
	* @param {string} [name='signal']
	* @returns {asserts signal is keyof signals}
	*/
	function validateSignalName(signal, name$1 = "signal") {
		validateString(signal, name$1);
		if (signals[signal] === void 0) {
			if (signals[StringPrototypeToUpperCase(signal)] !== void 0) throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
			throw new ERR_UNKNOWN_SIGNAL(signal);
		}
	}
	/**
	* @callback validateBuffer
	* @param {*} buffer
	* @param {string} [name='buffer']
	* @returns {asserts buffer is ArrayBufferView}
	*/
	/** @type {validateBuffer} */
	var validateBuffer = hideStackFrames((buffer, name$1 = "buffer") => {
		if (!isArrayBufferView(buffer)) throw new ERR_INVALID_ARG_TYPE$8(name$1, [
			"Buffer",
			"TypedArray",
			"DataView"
		], buffer);
	});
	/**
	* @param {string} data
	* @param {string} encoding
	*/
	function validateEncoding(data, encoding) {
		const normalizedEncoding = normalizeEncoding(encoding);
		const length = data.length;
		if (normalizedEncoding === "hex" && length % 2 !== 0) throw new ERR_INVALID_ARG_VALUE$3("encoding", encoding, `is invalid for data of length ${length}`);
	}
	/**
	* Check that the port number is not NaN when coerced to a number,
	* is an integer and that it falls within the legal range of port numbers.
	* @param {*} port
	* @param {string} [name='Port']
	* @param {boolean} [allowZero=true]
	* @returns {number}
	*/
	function validatePort(port, name$1 = "Port", allowZero = true) {
		if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) throw new ERR_SOCKET_BAD_PORT(name$1, port, allowZero);
		return port | 0;
	}
	/**
	* @callback validateAbortSignal
	* @param {*} signal
	* @param {string} name
	*/
	/** @type {validateAbortSignal} */
	var validateAbortSignal$4 = hideStackFrames((signal, name$1) => {
		if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) throw new ERR_INVALID_ARG_TYPE$8(name$1, "AbortSignal", signal);
	});
	/**
	* @callback validateFunction
	* @param {*} value
	* @param {string} name
	* @returns {asserts value is Function}
	*/
	/** @type {validateFunction} */
	var validateFunction$2 = hideStackFrames((value$2, name$1) => {
		if (typeof value$2 !== "function") throw new ERR_INVALID_ARG_TYPE$8(name$1, "Function", value$2);
	});
	/**
	* @callback validatePlainFunction
	* @param {*} value
	* @param {string} name
	* @returns {asserts value is Function}
	*/
	/** @type {validatePlainFunction} */
	var validatePlainFunction = hideStackFrames((value$2, name$1) => {
		if (typeof value$2 !== "function" || isAsyncFunction(value$2)) throw new ERR_INVALID_ARG_TYPE$8(name$1, "Function", value$2);
	});
	/**
	* @callback validateUndefined
	* @param {*} value
	* @param {string} name
	* @returns {asserts value is undefined}
	*/
	/** @type {validateUndefined} */
	var validateUndefined = hideStackFrames((value$2, name$1) => {
		if (value$2 !== void 0) throw new ERR_INVALID_ARG_TYPE$8(name$1, "undefined", value$2);
	});
	/**
	* @template T
	* @param {T} value
	* @param {string} name
	* @param {T[]} union
	*/
	function validateUnion(value$2, name$1, union) {
		if (!ArrayPrototypeIncludes(union, value$2)) throw new ERR_INVALID_ARG_TYPE$8(name$1, `('${ArrayPrototypeJoin(union, "|")}')`, value$2);
	}
	var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
	/**
	* @param {any} value
	* @param {string} name
	*/
	function validateLinkHeaderFormat(value$2, name$1) {
		if (typeof value$2 === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value$2)) throw new ERR_INVALID_ARG_VALUE$3(name$1, value$2, "must be an array or string of format \"</styles.css>; rel=preload; as=style\"");
	}
	/**
	* @param {any} hints
	* @return {string}
	*/
	function validateLinkHeaderValue(hints) {
		if (typeof hints === "string") {
			validateLinkHeaderFormat(hints, "hints");
			return hints;
		} else if (ArrayIsArray$2(hints)) {
			const hintsLength = hints.length;
			let result = "";
			if (hintsLength === 0) return result;
			for (let i = 0; i < hintsLength; i++) {
				const link$1 = hints[i];
				validateLinkHeaderFormat(link$1, "hints");
				result += link$1;
				if (i !== hintsLength - 1) result += ", ";
			}
			return result;
		}
		throw new ERR_INVALID_ARG_VALUE$3("hints", hints, "must be an array or string of format \"</styles.css>; rel=preload; as=style\"");
	}
	module.exports = {
		isInt32,
		isUint32,
		parseFileMode,
		validateArray,
		validateStringArray,
		validateBooleanArray,
		validateAbortSignalArray,
		validateBoolean: validateBoolean$1,
		validateBuffer,
		validateDictionary,
		validateEncoding,
		validateFunction: validateFunction$2,
		validateInt32,
		validateInteger: validateInteger$2,
		validateNumber,
		validateObject: validateObject$4,
		validateOneOf,
		validatePlainFunction,
		validatePort,
		validateSignalName,
		validateString,
		validateUint32,
		validateUndefined,
		validateUnion,
		validateAbortSignal: validateAbortSignal$4,
		validateLinkHeaderValue
	};
}) });

//#endregion
//#region node_modules/process/browser.js
var require_browser$1 = /* @__PURE__ */ __commonJS({ "node_modules/process/browser.js": ((exports, module) => {
	var process$8 = module.exports = {};
	var cachedSetTimeout;
	var cachedClearTimeout;
	function defaultSetTimout() {
		throw new Error("setTimeout has not been defined");
	}
	function defaultClearTimeout() {
		throw new Error("clearTimeout has not been defined");
	}
	(function() {
		try {
			if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
			else cachedSetTimeout = defaultSetTimout;
		} catch (e) {
			cachedSetTimeout = defaultSetTimout;
		}
		try {
			if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
			else cachedClearTimeout = defaultClearTimeout;
		} catch (e) {
			cachedClearTimeout = defaultClearTimeout;
		}
	})();
	function runTimeout(fun) {
		if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
		if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
			cachedSetTimeout = setTimeout;
			return setTimeout(fun, 0);
		}
		try {
			return cachedSetTimeout(fun, 0);
		} catch (e) {
			try {
				return cachedSetTimeout.call(null, fun, 0);
			} catch (e$1) {
				return cachedSetTimeout.call(this, fun, 0);
			}
		}
	}
	function runClearTimeout(marker) {
		if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
		if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
			cachedClearTimeout = clearTimeout;
			return clearTimeout(marker);
		}
		try {
			return cachedClearTimeout(marker);
		} catch (e) {
			try {
				return cachedClearTimeout.call(null, marker);
			} catch (e$1) {
				return cachedClearTimeout.call(this, marker);
			}
		}
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	function cleanUpNextTick() {
		if (!draining || !currentQueue) return;
		draining = false;
		if (currentQueue.length) queue = currentQueue.concat(queue);
		else queueIndex = -1;
		if (queue.length) drainQueue();
	}
	function drainQueue() {
		if (draining) return;
		var timeout = runTimeout(cleanUpNextTick);
		draining = true;
		var len = queue.length;
		while (len) {
			currentQueue = queue;
			queue = [];
			while (++queueIndex < len) if (currentQueue) currentQueue[queueIndex].run();
			queueIndex = -1;
			len = queue.length;
		}
		currentQueue = null;
		draining = false;
		runClearTimeout(timeout);
	}
	process$8.nextTick = function(fun) {
		var args = new Array(arguments.length - 1);
		if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
		queue.push(new Item(fun, args));
		if (queue.length === 1 && !draining) runTimeout(drainQueue);
	};
	function Item(fun, array$1) {
		this.fun = fun;
		this.array = array$1;
	}
	Item.prototype.run = function() {
		this.fun.apply(null, this.array);
	};
	process$8.title = "browser";
	process$8.browser = true;
	process$8.env = {};
	process$8.argv = [];
	process$8.version = "";
	process$8.versions = {};
	function noop$3() {}
	process$8.on = noop$3;
	process$8.addListener = noop$3;
	process$8.once = noop$3;
	process$8.off = noop$3;
	process$8.removeListener = noop$3;
	process$8.removeAllListeners = noop$3;
	process$8.emit = noop$3;
	process$8.prependListener = noop$3;
	process$8.prependOnceListener = noop$3;
	process$8.listeners = function(name$1) {
		return [];
	};
	process$8.binding = function(name$1) {
		throw new Error("process.binding is not supported");
	};
	process$8.cwd = function() {
		return "/";
	};
	process$8.chdir = function(dir) {
		throw new Error("process.chdir is not supported");
	};
	process$8.umask = function() {
		return 0;
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils$1 = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/utils.js": ((exports, module) => {
	var { SymbolAsyncIterator: SymbolAsyncIterator$3, SymbolIterator: SymbolIterator$2, SymbolFor } = require_primordials();
	var kIsDestroyed$1 = SymbolFor("nodejs.stream.destroyed");
	var kIsErrored = SymbolFor("nodejs.stream.errored");
	var kIsReadable = SymbolFor("nodejs.stream.readable");
	var kIsWritable = SymbolFor("nodejs.stream.writable");
	var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
	var kIsClosedPromise$1 = SymbolFor("nodejs.webstream.isClosedPromise");
	var kControllerErrorFunction$1 = SymbolFor("nodejs.webstream.controllerErrorFunction");
	function isReadableNodeStream$3(obj, strict = false) {
		var _obj$_readableState;
		return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
	}
	function isWritableNodeStream$2(obj) {
		var _obj$_writableState;
		return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
	}
	function isDuplexNodeStream$1(obj) {
		return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
	}
	function isNodeStream$7(obj) {
		return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
	}
	function isReadableStream$5(obj) {
		return !!(obj && !isNodeStream$7(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
	}
	function isWritableStream$4(obj) {
		return !!(obj && !isNodeStream$7(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
	}
	function isTransformStream$2(obj) {
		return !!(obj && !isNodeStream$7(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
	}
	function isWebStream$4(obj) {
		return isReadableStream$5(obj) || isWritableStream$4(obj) || isTransformStream$2(obj);
	}
	function isIterable$3(obj, isAsync) {
		if (obj == null) return false;
		if (isAsync === true) return typeof obj[SymbolAsyncIterator$3] === "function";
		if (isAsync === false) return typeof obj[SymbolIterator$2] === "function";
		return typeof obj[SymbolAsyncIterator$3] === "function" || typeof obj[SymbolIterator$2] === "function";
	}
	function isDestroyed$1(stream) {
		if (!isNodeStream$7(stream)) return null;
		const wState = stream._writableState;
		const rState = stream._readableState;
		const state = wState || rState;
		return !!(stream.destroyed || stream[kIsDestroyed$1] || state !== null && state !== void 0 && state.destroyed);
	}
	function isWritableEnded(stream) {
		if (!isWritableNodeStream$2(stream)) return null;
		if (stream.writableEnded === true) return true;
		const wState = stream._writableState;
		if (wState !== null && wState !== void 0 && wState.errored) return false;
		if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
		return wState.ended;
	}
	function isWritableFinished$1(stream, strict) {
		if (!isWritableNodeStream$2(stream)) return null;
		if (stream.writableFinished === true) return true;
		const wState = stream._writableState;
		if (wState !== null && wState !== void 0 && wState.errored) return false;
		if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
		return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
	}
	function isReadableEnded(stream) {
		if (!isReadableNodeStream$3(stream)) return null;
		if (stream.readableEnded === true) return true;
		const rState = stream._readableState;
		if (!rState || rState.errored) return false;
		if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
		return rState.ended;
	}
	function isReadableFinished$2(stream, strict) {
		if (!isReadableNodeStream$3(stream)) return null;
		const rState = stream._readableState;
		if (rState !== null && rState !== void 0 && rState.errored) return false;
		if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
		return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
	}
	function isReadable$4(stream) {
		if (stream && stream[kIsReadable] != null) return stream[kIsReadable];
		if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean") return null;
		if (isDestroyed$1(stream)) return false;
		return isReadableNodeStream$3(stream) && stream.readable && !isReadableFinished$2(stream);
	}
	function isWritable$4(stream) {
		if (stream && stream[kIsWritable] != null) return stream[kIsWritable];
		if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean") return null;
		if (isDestroyed$1(stream)) return false;
		return isWritableNodeStream$2(stream) && stream.writable && !isWritableEnded(stream);
	}
	function isFinished$1(stream, opts) {
		if (!isNodeStream$7(stream)) return null;
		if (isDestroyed$1(stream)) return true;
		if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable$4(stream)) return false;
		if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable$4(stream)) return false;
		return true;
	}
	function isWritableErrored$1(stream) {
		var _stream$_writableStat, _stream$_writableStat2;
		if (!isNodeStream$7(stream)) return null;
		if (stream.writableErrored) return stream.writableErrored;
		return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
	}
	function isReadableErrored$1(stream) {
		var _stream$_readableStat, _stream$_readableStat2;
		if (!isNodeStream$7(stream)) return null;
		if (stream.readableErrored) return stream.readableErrored;
		return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
	}
	function isClosed$1(stream) {
		if (!isNodeStream$7(stream)) return null;
		if (typeof stream.closed === "boolean") return stream.closed;
		const wState = stream._writableState;
		const rState = stream._readableState;
		if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
		if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) return stream._closed;
		return null;
	}
	function isOutgoingMessage(stream) {
		return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
	}
	function isServerResponse(stream) {
		return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
	}
	function isServerRequest$1(stream) {
		var _stream$req;
		return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
	}
	function willEmitClose(stream) {
		if (!isNodeStream$7(stream)) return null;
		const wState = stream._writableState;
		const rState = stream._readableState;
		const state = wState || rState;
		return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
	}
	function isDisturbed(stream) {
		var _stream$kIsDisturbed;
		return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
	}
	function isErrored(stream) {
		var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
		return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
	}
	module.exports = {
		isDestroyed: isDestroyed$1,
		kIsDestroyed: kIsDestroyed$1,
		isDisturbed,
		kIsDisturbed,
		isErrored,
		kIsErrored,
		isReadable: isReadable$4,
		kIsReadable,
		kIsClosedPromise: kIsClosedPromise$1,
		kControllerErrorFunction: kControllerErrorFunction$1,
		kIsWritable,
		isClosed: isClosed$1,
		isDuplexNodeStream: isDuplexNodeStream$1,
		isFinished: isFinished$1,
		isIterable: isIterable$3,
		isReadableNodeStream: isReadableNodeStream$3,
		isReadableStream: isReadableStream$5,
		isReadableEnded,
		isReadableFinished: isReadableFinished$2,
		isReadableErrored: isReadableErrored$1,
		isNodeStream: isNodeStream$7,
		isWebStream: isWebStream$4,
		isWritable: isWritable$4,
		isWritableNodeStream: isWritableNodeStream$2,
		isWritableStream: isWritableStream$4,
		isWritableEnded,
		isWritableFinished: isWritableFinished$1,
		isWritableErrored: isWritableErrored$1,
		isServerRequest: isServerRequest$1,
		isServerResponse,
		willEmitClose,
		isTransformStream: isTransformStream$2
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream$1 = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/end-of-stream.js": ((exports, module) => {
	var process$7 = require_browser$1();
	var { AbortError: AbortError$7, codes: codes$1 } = require_errors$1();
	var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$7, ERR_STREAM_PREMATURE_CLOSE: ERR_STREAM_PREMATURE_CLOSE$1 } = codes$1;
	var { kEmptyObject, once: once$5 } = require_util();
	var { validateAbortSignal: validateAbortSignal$3, validateFunction: validateFunction$1, validateObject: validateObject$3, validateBoolean } = require_validators();
	var { Promise: Promise$5, PromisePrototypeThen: PromisePrototypeThen$2, SymbolDispose: SymbolDispose$2 } = require_primordials();
	var { isClosed, isReadable: isReadable$3, isReadableNodeStream: isReadableNodeStream$2, isReadableStream: isReadableStream$4, isReadableFinished: isReadableFinished$1, isReadableErrored, isWritable: isWritable$3, isWritableNodeStream: isWritableNodeStream$1, isWritableStream: isWritableStream$3, isWritableFinished, isWritableErrored, isNodeStream: isNodeStream$6, willEmitClose: _willEmitClose, kIsClosedPromise } = require_utils$1();
	var addAbortListener$2;
	function isRequest$3(stream) {
		return stream.setHeader && typeof stream.abort === "function";
	}
	var nop$2 = () => {};
	function eos$9(stream, options, callback) {
		var _options$readable, _options$writable;
		if (arguments.length === 2) {
			callback = options;
			options = kEmptyObject;
		} else if (options == null) options = kEmptyObject;
		else validateObject$3(options, "options");
		validateFunction$1(callback, "callback");
		validateAbortSignal$3(options.signal, "options.signal");
		callback = once$5(callback);
		if (isReadableStream$4(stream) || isWritableStream$3(stream)) return eosWeb(stream, options, callback);
		if (!isNodeStream$6(stream)) throw new ERR_INVALID_ARG_TYPE$7("stream", [
			"ReadableStream",
			"WritableStream",
			"Stream"
		], stream);
		const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream$2(stream);
		const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream$1(stream);
		const wState = stream._writableState;
		const rState = stream._readableState;
		const onlegacyfinish = () => {
			if (!stream.writable) onfinish();
		};
		let willEmitClose$1 = _willEmitClose(stream) && isReadableNodeStream$2(stream) === readable && isWritableNodeStream$1(stream) === writable;
		let writableFinished = isWritableFinished(stream, false);
		const onfinish = () => {
			writableFinished = true;
			if (stream.destroyed) willEmitClose$1 = false;
			if (willEmitClose$1 && (!stream.readable || readable)) return;
			if (!readable || readableFinished) callback.call(stream);
		};
		let readableFinished = isReadableFinished$1(stream, false);
		const onend = () => {
			readableFinished = true;
			if (stream.destroyed) willEmitClose$1 = false;
			if (willEmitClose$1 && (!stream.writable || writable)) return;
			if (!writable || writableFinished) callback.call(stream);
		};
		const onerror = (err) => {
			callback.call(stream, err);
		};
		let closed = isClosed(stream);
		const onclose = () => {
			closed = true;
			const errored = isWritableErrored(stream) || isReadableErrored(stream);
			if (errored && typeof errored !== "boolean") return callback.call(stream, errored);
			if (readable && !readableFinished && isReadableNodeStream$2(stream, true)) {
				if (!isReadableFinished$1(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE$1());
			}
			if (writable && !writableFinished) {
				if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE$1());
			}
			callback.call(stream);
		};
		const onclosed = () => {
			closed = true;
			const errored = isWritableErrored(stream) || isReadableErrored(stream);
			if (errored && typeof errored !== "boolean") return callback.call(stream, errored);
			callback.call(stream);
		};
		const onrequest = () => {
			stream.req.on("finish", onfinish);
		};
		if (isRequest$3(stream)) {
			stream.on("complete", onfinish);
			if (!willEmitClose$1) stream.on("abort", onclose);
			if (stream.req) onrequest();
			else stream.on("request", onrequest);
		} else if (writable && !wState) {
			stream.on("end", onlegacyfinish);
			stream.on("close", onlegacyfinish);
		}
		if (!willEmitClose$1 && typeof stream.aborted === "boolean") stream.on("aborted", onclose);
		stream.on("end", onend);
		stream.on("finish", onfinish);
		if (options.error !== false) stream.on("error", onerror);
		stream.on("close", onclose);
		if (closed) process$7.nextTick(onclose);
		else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
			if (!willEmitClose$1) process$7.nextTick(onclosed);
		} else if (!readable && (!willEmitClose$1 || isReadable$3(stream)) && (writableFinished || isWritable$3(stream) === false)) process$7.nextTick(onclosed);
		else if (!writable && (!willEmitClose$1 || isWritable$3(stream)) && (readableFinished || isReadable$3(stream) === false)) process$7.nextTick(onclosed);
		else if (rState && stream.req && stream.aborted) process$7.nextTick(onclosed);
		const cleanup = () => {
			callback = nop$2;
			stream.removeListener("aborted", onclose);
			stream.removeListener("complete", onfinish);
			stream.removeListener("abort", onclose);
			stream.removeListener("request", onrequest);
			if (stream.req) stream.req.removeListener("finish", onfinish);
			stream.removeListener("end", onlegacyfinish);
			stream.removeListener("close", onlegacyfinish);
			stream.removeListener("finish", onfinish);
			stream.removeListener("end", onend);
			stream.removeListener("error", onerror);
			stream.removeListener("close", onclose);
		};
		if (options.signal && !closed) {
			const abort = () => {
				const endCallback = callback;
				cleanup();
				endCallback.call(stream, new AbortError$7(void 0, { cause: options.signal.reason }));
			};
			if (options.signal.aborted) process$7.nextTick(abort);
			else {
				addAbortListener$2 = addAbortListener$2 || require_util().addAbortListener;
				const disposable = addAbortListener$2(options.signal, abort);
				const originalCallback = callback;
				callback = once$5((...args) => {
					disposable[SymbolDispose$2]();
					originalCallback.apply(stream, args);
				});
			}
		}
		return cleanup;
	}
	function eosWeb(stream, options, callback) {
		let isAborted = false;
		let abort = nop$2;
		if (options.signal) {
			abort = () => {
				isAborted = true;
				callback.call(stream, new AbortError$7(void 0, { cause: options.signal.reason }));
			};
			if (options.signal.aborted) process$7.nextTick(abort);
			else {
				addAbortListener$2 = addAbortListener$2 || require_util().addAbortListener;
				const disposable = addAbortListener$2(options.signal, abort);
				const originalCallback = callback;
				callback = once$5((...args) => {
					disposable[SymbolDispose$2]();
					originalCallback.apply(stream, args);
				});
			}
		}
		const resolverFn = (...args) => {
			if (!isAborted) process$7.nextTick(() => callback.apply(stream, args));
		};
		PromisePrototypeThen$2(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
		return nop$2;
	}
	function finished$2(stream, opts) {
		var _opts;
		let autoCleanup = false;
		if (opts === null) opts = kEmptyObject;
		if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
			validateBoolean(opts.cleanup, "cleanup");
			autoCleanup = opts.cleanup;
		}
		return new Promise$5((resolve, reject) => {
			const cleanup = eos$9(stream, opts, (err) => {
				if (autoCleanup) cleanup();
				if (err) reject(err);
				else resolve();
			});
		});
	}
	module.exports = eos$9;
	module.exports.finished = finished$2;
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/destroy.js": ((exports, module) => {
	var process$6 = require_browser$1();
	var { aggregateTwoErrors: aggregateTwoErrors$2, codes: { ERR_MULTIPLE_CALLBACK: ERR_MULTIPLE_CALLBACK$1 }, AbortError: AbortError$6 } = require_errors$1();
	var { Symbol: Symbol$6 } = require_primordials();
	var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils$1();
	var kDestroy = Symbol$6("kDestroy");
	var kConstruct = Symbol$6("kConstruct");
	function checkError(err, w, r) {
		if (err) {
			err.stack;
			if (w && !w.errored) w.errored = err;
			if (r && !r.errored) r.errored = err;
		}
	}
	function destroy$1(err, cb) {
		const r = this._readableState;
		const w = this._writableState;
		const s = w || r;
		if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
			if (typeof cb === "function") cb();
			return this;
		}
		checkError(err, w, r);
		if (w) w.destroyed = true;
		if (r) r.destroyed = true;
		if (!s.constructed) this.once(kDestroy, function(er) {
			_destroy(this, aggregateTwoErrors$2(er, err), cb);
		});
		else _destroy(this, err, cb);
		return this;
	}
	function _destroy(self$1, err, cb) {
		let called = false;
		function onDestroy(err$1) {
			if (called) return;
			called = true;
			const r = self$1._readableState;
			const w = self$1._writableState;
			checkError(err$1, w, r);
			if (w) w.closed = true;
			if (r) r.closed = true;
			if (typeof cb === "function") cb(err$1);
			if (err$1) process$6.nextTick(emitErrorCloseNT, self$1, err$1);
			else process$6.nextTick(emitCloseNT, self$1);
		}
		try {
			self$1._destroy(err || null, onDestroy);
		} catch (err$1) {
			onDestroy(err$1);
		}
	}
	function emitErrorCloseNT(self$1, err) {
		emitErrorNT(self$1, err);
		emitCloseNT(self$1);
	}
	function emitCloseNT(self$1) {
		const r = self$1._readableState;
		const w = self$1._writableState;
		if (w) w.closeEmitted = true;
		if (r) r.closeEmitted = true;
		if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) self$1.emit("close");
	}
	function emitErrorNT(self$1, err) {
		const r = self$1._readableState;
		const w = self$1._writableState;
		if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) return;
		if (w) w.errorEmitted = true;
		if (r) r.errorEmitted = true;
		self$1.emit("error", err);
	}
	function undestroy() {
		const r = this._readableState;
		const w = this._writableState;
		if (r) {
			r.constructed = true;
			r.closed = false;
			r.closeEmitted = false;
			r.destroyed = false;
			r.errored = null;
			r.errorEmitted = false;
			r.reading = false;
			r.ended = r.readable === false;
			r.endEmitted = r.readable === false;
		}
		if (w) {
			w.constructed = true;
			w.destroyed = false;
			w.closed = false;
			w.closeEmitted = false;
			w.errored = null;
			w.errorEmitted = false;
			w.finalCalled = false;
			w.prefinished = false;
			w.ended = w.writable === false;
			w.ending = w.writable === false;
			w.finished = w.writable === false;
		}
	}
	function errorOrDestroy$2(stream, err, sync) {
		const r = stream._readableState;
		const w = stream._writableState;
		if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) return this;
		if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy) stream.destroy(err);
		else if (err) {
			err.stack;
			if (w && !w.errored) w.errored = err;
			if (r && !r.errored) r.errored = err;
			if (sync) process$6.nextTick(emitErrorNT, stream, err);
			else emitErrorNT(stream, err);
		}
	}
	function construct(stream, cb) {
		if (typeof stream._construct !== "function") return;
		const r = stream._readableState;
		const w = stream._writableState;
		if (r) r.constructed = false;
		if (w) w.constructed = false;
		stream.once(kConstruct, cb);
		if (stream.listenerCount(kConstruct) > 1) return;
		process$6.nextTick(constructNT, stream);
	}
	function constructNT(stream) {
		let called = false;
		function onConstruct(err) {
			if (called) {
				errorOrDestroy$2(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK$1());
				return;
			}
			called = true;
			const r = stream._readableState;
			const w = stream._writableState;
			const s = w || r;
			if (r) r.constructed = true;
			if (w) w.constructed = true;
			if (s.destroyed) stream.emit(kDestroy, err);
			else if (err) errorOrDestroy$2(stream, err, true);
			else process$6.nextTick(emitConstructNT, stream);
		}
		try {
			stream._construct((err) => {
				process$6.nextTick(onConstruct, err);
			});
		} catch (err) {
			process$6.nextTick(onConstruct, err);
		}
	}
	function emitConstructNT(stream) {
		stream.emit(kConstruct);
	}
	function isRequest$2(stream) {
		return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
	}
	function emitCloseLegacy(stream) {
		stream.emit("close");
	}
	function emitErrorCloseLegacy(stream, err) {
		stream.emit("error", err);
		process$6.nextTick(emitCloseLegacy, stream);
	}
	function destroyer$5(stream, err) {
		if (!stream || isDestroyed(stream)) return;
		if (!err && !isFinished(stream)) err = new AbortError$6();
		if (isServerRequest(stream)) {
			stream.socket = null;
			stream.destroy(err);
		} else if (isRequest$2(stream)) stream.abort();
		else if (isRequest$2(stream.req)) stream.req.abort();
		else if (typeof stream.destroy === "function") stream.destroy(err);
		else if (typeof stream.close === "function") stream.close();
		else if (err) process$6.nextTick(emitErrorCloseLegacy, stream, err);
		else process$6.nextTick(emitCloseLegacy, stream);
		if (!stream.destroyed) stream[kIsDestroyed] = true;
	}
	module.exports = {
		construct,
		destroyer: destroyer$5,
		destroy: destroy$1,
		undestroy,
		errorOrDestroy: errorOrDestroy$2
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/legacy.js": ((exports, module) => {
	var { ArrayIsArray: ArrayIsArray$1, ObjectSetPrototypeOf: ObjectSetPrototypeOf$5 } = require_primordials();
	var { EventEmitter: EE$2 } = require_events();
	function Stream$3(opts) {
		EE$2.call(this, opts);
	}
	ObjectSetPrototypeOf$5(Stream$3.prototype, EE$2.prototype);
	ObjectSetPrototypeOf$5(Stream$3, EE$2);
	Stream$3.prototype.pipe = function(dest, options) {
		const source = this;
		function ondata(chunk) {
			if (dest.writable && dest.write(chunk) === false && source.pause) source.pause();
		}
		source.on("data", ondata);
		function ondrain() {
			if (source.readable && source.resume) source.resume();
		}
		dest.on("drain", ondrain);
		if (!dest._isStdio && (!options || options.end !== false)) {
			source.on("end", onend);
			source.on("close", onclose);
		}
		let didOnEnd = false;
		function onend() {
			if (didOnEnd) return;
			didOnEnd = true;
			dest.end();
		}
		function onclose() {
			if (didOnEnd) return;
			didOnEnd = true;
			if (typeof dest.destroy === "function") dest.destroy();
		}
		function onerror(er) {
			cleanup();
			if (EE$2.listenerCount(this, "error") === 0) this.emit("error", er);
		}
		prependListener$1(source, "error", onerror);
		prependListener$1(dest, "error", onerror);
		function cleanup() {
			source.removeListener("data", ondata);
			dest.removeListener("drain", ondrain);
			source.removeListener("end", onend);
			source.removeListener("close", onclose);
			source.removeListener("error", onerror);
			dest.removeListener("error", onerror);
			source.removeListener("end", cleanup);
			source.removeListener("close", cleanup);
			dest.removeListener("close", cleanup);
		}
		source.on("end", cleanup);
		source.on("close", cleanup);
		dest.on("close", cleanup);
		dest.emit("pipe", source);
		return dest;
	};
	function prependListener$1(emitter, event, fn) {
		if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
		if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
		else if (ArrayIsArray$1(emitter._events[event])) emitter._events[event].unshift(fn);
		else emitter._events[event] = [fn, emitter._events[event]];
	}
	module.exports = {
		Stream: Stream$3,
		prependListener: prependListener$1
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/add-abort-signal.js": ((exports, module) => {
	var { SymbolDispose: SymbolDispose$1 } = require_primordials();
	var { AbortError: AbortError$5, codes } = require_errors$1();
	var { isNodeStream: isNodeStream$5, isWebStream: isWebStream$3, kControllerErrorFunction } = require_utils$1();
	var eos$8 = require_end_of_stream$1();
	var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$6 } = codes;
	var addAbortListener$1;
	var validateAbortSignal$2 = (signal, name$1) => {
		if (typeof signal !== "object" || !("aborted" in signal)) throw new ERR_INVALID_ARG_TYPE$6(name$1, "AbortSignal", signal);
	};
	module.exports.addAbortSignal = function addAbortSignal$3(signal, stream) {
		validateAbortSignal$2(signal, "signal");
		if (!isNodeStream$5(stream) && !isWebStream$3(stream)) throw new ERR_INVALID_ARG_TYPE$6("stream", [
			"ReadableStream",
			"WritableStream",
			"Stream"
		], stream);
		return module.exports.addAbortSignalNoValidate(signal, stream);
	};
	module.exports.addAbortSignalNoValidate = function(signal, stream) {
		if (typeof signal !== "object" || !("aborted" in signal)) return stream;
		const onAbort = isNodeStream$5(stream) ? () => {
			stream.destroy(new AbortError$5(void 0, { cause: signal.reason }));
		} : () => {
			stream[kControllerErrorFunction](new AbortError$5(void 0, { cause: signal.reason }));
		};
		if (signal.aborted) onAbort();
		else {
			addAbortListener$1 = addAbortListener$1 || require_util().addAbortListener;
			eos$8(stream, addAbortListener$1(signal, onAbort)[SymbolDispose$1]);
		}
		return stream;
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/buffer_list.js": ((exports, module) => {
	var { StringPrototypeSlice, SymbolIterator: SymbolIterator$1, TypedArrayPrototypeSet, Uint8Array: Uint8Array$2 } = require_primordials();
	var { Buffer: Buffer$6 } = require_buffer();
	var { inspect } = require_util();
	module.exports = class BufferList$1 {
		constructor() {
			this.head = null;
			this.tail = null;
			this.length = 0;
		}
		push(v) {
			const entry = {
				data: v,
				next: null
			};
			if (this.length > 0) this.tail.next = entry;
			else this.head = entry;
			this.tail = entry;
			++this.length;
		}
		unshift(v) {
			const entry = {
				data: v,
				next: this.head
			};
			if (this.length === 0) this.tail = entry;
			this.head = entry;
			++this.length;
		}
		shift() {
			if (this.length === 0) return;
			const ret = this.head.data;
			if (this.length === 1) this.head = this.tail = null;
			else this.head = this.head.next;
			--this.length;
			return ret;
		}
		clear() {
			this.head = this.tail = null;
			this.length = 0;
		}
		join(s) {
			if (this.length === 0) return "";
			let p = this.head;
			let ret = "" + p.data;
			while ((p = p.next) !== null) ret += s + p.data;
			return ret;
		}
		concat(n) {
			if (this.length === 0) return Buffer$6.alloc(0);
			const ret = Buffer$6.allocUnsafe(n >>> 0);
			let p = this.head;
			let i = 0;
			while (p) {
				TypedArrayPrototypeSet(ret, p.data, i);
				i += p.data.length;
				p = p.next;
			}
			return ret;
		}
		consume(n, hasStrings) {
			const data = this.head.data;
			if (n < data.length) {
				const slice$1 = data.slice(0, n);
				this.head.data = data.slice(n);
				return slice$1;
			}
			if (n === data.length) return this.shift();
			return hasStrings ? this._getString(n) : this._getBuffer(n);
		}
		first() {
			return this.head.data;
		}
		*[SymbolIterator$1]() {
			for (let p = this.head; p; p = p.next) yield p.data;
		}
		_getString(n) {
			let ret = "";
			let p = this.head;
			let c = 0;
			do {
				const str$1 = p.data;
				if (n > str$1.length) {
					ret += str$1;
					n -= str$1.length;
				} else {
					if (n === str$1.length) {
						ret += str$1;
						++c;
						if (p.next) this.head = p.next;
						else this.head = this.tail = null;
					} else {
						ret += StringPrototypeSlice(str$1, 0, n);
						this.head = p;
						p.data = StringPrototypeSlice(str$1, n);
					}
					break;
				}
				++c;
			} while ((p = p.next) !== null);
			this.length -= c;
			return ret;
		}
		_getBuffer(n) {
			const ret = Buffer$6.allocUnsafe(n);
			const retLen = n;
			let p = this.head;
			let c = 0;
			do {
				const buf = p.data;
				if (n > buf.length) {
					TypedArrayPrototypeSet(ret, buf, retLen - n);
					n -= buf.length;
				} else {
					if (n === buf.length) {
						TypedArrayPrototypeSet(ret, buf, retLen - n);
						++c;
						if (p.next) this.head = p.next;
						else this.head = this.tail = null;
					} else {
						TypedArrayPrototypeSet(ret, new Uint8Array$2(buf.buffer, buf.byteOffset, n), retLen - n);
						this.head = p;
						p.data = buf.slice(n);
					}
					break;
				}
				++c;
			} while ((p = p.next) !== null);
			this.length -= c;
			return ret;
		}
		[Symbol.for("nodejs.util.inspect.custom")](_, options) {
			return inspect(this, {
				...options,
				depth: 0,
				customInspect: false
			});
		}
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/state.js
var require_state = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/state.js": ((exports, module) => {
	var { MathFloor: MathFloor$1, NumberIsInteger: NumberIsInteger$1 } = require_primordials();
	var { validateInteger: validateInteger$1 } = require_validators();
	var { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE$2 } = require_errors$1().codes;
	var defaultHighWaterMarkBytes = 16 * 1024;
	var defaultHighWaterMarkObjectMode = 16;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
		return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}
	function getDefaultHighWaterMark$3(objectMode) {
		return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
	}
	function setDefaultHighWaterMark$1(objectMode, value$2) {
		validateInteger$1(value$2, "value", 0);
		if (objectMode) defaultHighWaterMarkObjectMode = value$2;
		else defaultHighWaterMarkBytes = value$2;
	}
	function getHighWaterMark$3(state, options, duplexKey, isDuplex) {
		const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
		if (hwm != null) {
			if (!NumberIsInteger$1(hwm) || hwm < 0) throw new ERR_INVALID_ARG_VALUE$2(isDuplex ? `options.${duplexKey}` : "options.highWaterMark", hwm);
			return MathFloor$1(hwm);
		}
		return getDefaultHighWaterMark$3(state.objectMode);
	}
	module.exports = {
		getHighWaterMark: getHighWaterMark$3,
		getDefaultHighWaterMark: getDefaultHighWaterMark$3,
		setDefaultHighWaterMark: setDefaultHighWaterMark$1
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/from.js
var require_from = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/from.js": ((exports, module) => {
	var process$5 = require_browser$1();
	var { PromisePrototypeThen: PromisePrototypeThen$1, SymbolAsyncIterator: SymbolAsyncIterator$2, SymbolIterator } = require_primordials();
	var { Buffer: Buffer$5 } = require_buffer();
	var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$5, ERR_STREAM_NULL_VALUES: ERR_STREAM_NULL_VALUES$1 } = require_errors$1().codes;
	function from$2(Readable$4, iterable, opts) {
		let iterator;
		if (typeof iterable === "string" || iterable instanceof Buffer$5) return new Readable$4({
			objectMode: true,
			...opts,
			read() {
				this.push(iterable);
				this.push(null);
			}
		});
		let isAsync;
		if (iterable && iterable[SymbolAsyncIterator$2]) {
			isAsync = true;
			iterator = iterable[SymbolAsyncIterator$2]();
		} else if (iterable && iterable[SymbolIterator]) {
			isAsync = false;
			iterator = iterable[SymbolIterator]();
		} else throw new ERR_INVALID_ARG_TYPE$5("iterable", ["Iterable"], iterable);
		const readable = new Readable$4({
			objectMode: true,
			highWaterMark: 1,
			...opts
		});
		let reading = false;
		readable._read = function() {
			if (!reading) {
				reading = true;
				next$1();
			}
		};
		readable._destroy = function(error$1, cb) {
			PromisePrototypeThen$1(close$5(error$1), () => process$5.nextTick(cb, error$1), (e) => process$5.nextTick(cb, e || error$1));
		};
		async function close$5(error$1) {
			const hadError = error$1 !== void 0 && error$1 !== null;
			const hasThrow = typeof iterator.throw === "function";
			if (hadError && hasThrow) {
				const { value: value$2, done } = await iterator.throw(error$1);
				await value$2;
				if (done) return;
			}
			if (typeof iterator.return === "function") {
				const { value: value$2 } = await iterator.return();
				await value$2;
			}
		}
		async function next$1() {
			for (;;) {
				try {
					const { value: value$2, done } = isAsync ? await iterator.next() : iterator.next();
					if (done) readable.push(null);
					else {
						const res = value$2 && typeof value$2.then === "function" ? await value$2 : value$2;
						if (res === null) {
							reading = false;
							throw new ERR_STREAM_NULL_VALUES$1();
						} else if (readable.push(res)) continue;
						else reading = false;
					}
				} catch (err) {
					readable.destroy(err);
				}
				break;
			}
		}
		return readable;
	}
	module.exports = from$2;
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/readable.js": ((exports, module) => {
	var process$4 = require_browser$1();
	var { ArrayPrototypeIndexOf, NumberIsInteger, NumberIsNaN: NumberIsNaN$1, NumberParseInt, ObjectDefineProperties: ObjectDefineProperties$2, ObjectKeys: ObjectKeys$2, ObjectSetPrototypeOf: ObjectSetPrototypeOf$4, Promise: Promise$4, SafeSet, SymbolAsyncDispose, SymbolAsyncIterator: SymbolAsyncIterator$1, Symbol: Symbol$5 } = require_primordials();
	module.exports = Readable$3;
	Readable$3.ReadableState = ReadableState;
	var { EventEmitter: EE$1 } = require_events();
	var { Stream: Stream$2, prependListener } = require_legacy();
	var { Buffer: Buffer$4 } = require_buffer();
	var { addAbortSignal: addAbortSignal$2 } = require_add_abort_signal();
	var eos$7 = require_end_of_stream$1();
	var debug = require_util().debuglog("stream", (fn) => {
		debug = fn;
	});
	var BufferList = require_buffer_list();
	var destroyImpl$2 = require_destroy();
	var { getHighWaterMark: getHighWaterMark$2, getDefaultHighWaterMark: getDefaultHighWaterMark$2 } = require_state();
	var { aggregateTwoErrors: aggregateTwoErrors$1, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$4, ERR_METHOD_NOT_IMPLEMENTED: ERR_METHOD_NOT_IMPLEMENTED$2, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE$1, ERR_STREAM_PUSH_AFTER_EOF, ERR_STREAM_UNSHIFT_AFTER_END_EVENT }, AbortError: AbortError$4 } = require_errors$1();
	var { validateObject: validateObject$2 } = require_validators();
	var kPaused = Symbol$5("kPaused");
	var { StringDecoder } = require_string_decoder();
	var from$1 = require_from();
	ObjectSetPrototypeOf$4(Readable$3.prototype, Stream$2.prototype);
	ObjectSetPrototypeOf$4(Readable$3, Stream$2);
	var nop$1 = () => {};
	var { errorOrDestroy: errorOrDestroy$1 } = destroyImpl$2;
	var kObjectMode = 1;
	var kEnded = 2;
	var kEndEmitted = 4;
	var kReading = 8;
	var kConstructed = 16;
	var kSync = 32;
	var kNeedReadable = 64;
	var kEmittedReadable = 128;
	var kReadableListening = 256;
	var kResumeScheduled = 512;
	var kErrorEmitted = 1024;
	var kEmitClose = 2048;
	var kAutoDestroy = 4096;
	var kDestroyed = 8192;
	var kClosed = 16384;
	var kCloseEmitted = 32768;
	var kMultiAwaitDrain = 65536;
	var kReadingMore = 1 << 17;
	var kDataEmitted = 1 << 18;
	function makeBitMapDescriptor(bit) {
		return {
			enumerable: false,
			get() {
				return (this.state & bit) !== 0;
			},
			set(value$2) {
				if (value$2) this.state |= bit;
				else this.state &= ~bit;
			}
		};
	}
	ObjectDefineProperties$2(ReadableState.prototype, {
		objectMode: makeBitMapDescriptor(kObjectMode),
		ended: makeBitMapDescriptor(kEnded),
		endEmitted: makeBitMapDescriptor(kEndEmitted),
		reading: makeBitMapDescriptor(kReading),
		constructed: makeBitMapDescriptor(kConstructed),
		sync: makeBitMapDescriptor(kSync),
		needReadable: makeBitMapDescriptor(kNeedReadable),
		emittedReadable: makeBitMapDescriptor(kEmittedReadable),
		readableListening: makeBitMapDescriptor(kReadableListening),
		resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
		errorEmitted: makeBitMapDescriptor(kErrorEmitted),
		emitClose: makeBitMapDescriptor(kEmitClose),
		autoDestroy: makeBitMapDescriptor(kAutoDestroy),
		destroyed: makeBitMapDescriptor(kDestroyed),
		closed: makeBitMapDescriptor(kClosed),
		closeEmitted: makeBitMapDescriptor(kCloseEmitted),
		multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
		readingMore: makeBitMapDescriptor(kReadingMore),
		dataEmitted: makeBitMapDescriptor(kDataEmitted)
	});
	function ReadableState(options, stream, isDuplex) {
		if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
		this.state = 6192;
		if (options && options.objectMode) this.state |= kObjectMode;
		if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
		this.highWaterMark = options ? getHighWaterMark$2(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark$2(false);
		this.buffer = new BufferList();
		this.length = 0;
		this.pipes = [];
		this.flowing = null;
		this[kPaused] = null;
		if (options && options.emitClose === false) this.state &= ~kEmitClose;
		if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
		this.errored = null;
		this.defaultEncoding = options && options.defaultEncoding || "utf8";
		this.awaitDrainWriters = null;
		this.decoder = null;
		this.encoding = null;
		if (options && options.encoding) {
			this.decoder = new StringDecoder(options.encoding);
			this.encoding = options.encoding;
		}
	}
	function Readable$3(options) {
		if (!(this instanceof Readable$3)) return new Readable$3(options);
		const isDuplex = this instanceof require_duplex();
		this._readableState = new ReadableState(options, this, isDuplex);
		if (options) {
			if (typeof options.read === "function") this._read = options.read;
			if (typeof options.destroy === "function") this._destroy = options.destroy;
			if (typeof options.construct === "function") this._construct = options.construct;
			if (options.signal && !isDuplex) addAbortSignal$2(options.signal, this);
		}
		Stream$2.call(this, options);
		destroyImpl$2.construct(this, () => {
			if (this._readableState.needReadable) maybeReadMore(this, this._readableState);
		});
	}
	Readable$3.prototype.destroy = destroyImpl$2.destroy;
	Readable$3.prototype._undestroy = destroyImpl$2.undestroy;
	Readable$3.prototype._destroy = function(err, cb) {
		cb(err);
	};
	Readable$3.prototype[EE$1.captureRejectionSymbol] = function(err) {
		this.destroy(err);
	};
	Readable$3.prototype[SymbolAsyncDispose] = function() {
		let error$1;
		if (!this.destroyed) {
			error$1 = this.readableEnded ? null : new AbortError$4();
			this.destroy(error$1);
		}
		return new Promise$4((resolve, reject) => eos$7(this, (err) => err && err !== error$1 ? reject(err) : resolve(null)));
	};
	Readable$3.prototype.push = function(chunk, encoding) {
		return readableAddChunk(this, chunk, encoding, false);
	};
	Readable$3.prototype.unshift = function(chunk, encoding) {
		return readableAddChunk(this, chunk, encoding, true);
	};
	function readableAddChunk(stream, chunk, encoding, addToFront) {
		debug("readableAddChunk", chunk);
		const state = stream._readableState;
		let err;
		if ((state.state & kObjectMode) === 0) {
			if (typeof chunk === "string") {
				encoding = encoding || state.defaultEncoding;
				if (state.encoding !== encoding) if (addToFront && state.encoding) chunk = Buffer$4.from(chunk, encoding).toString(state.encoding);
				else {
					chunk = Buffer$4.from(chunk, encoding);
					encoding = "";
				}
			} else if (chunk instanceof Buffer$4) encoding = "";
			else if (Stream$2._isUint8Array(chunk)) {
				chunk = Stream$2._uint8ArrayToBuffer(chunk);
				encoding = "";
			} else if (chunk != null) err = new ERR_INVALID_ARG_TYPE$4("chunk", [
				"string",
				"Buffer",
				"Uint8Array"
			], chunk);
		}
		if (err) errorOrDestroy$1(stream, err);
		else if (chunk === null) {
			state.state &= ~kReading;
			onEofChunk(stream, state);
		} else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) if (addToFront) if ((state.state & kEndEmitted) !== 0) errorOrDestroy$1(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
		else if (state.destroyed || state.errored) return false;
		else addChunk(stream, state, chunk, true);
		else if (state.ended) errorOrDestroy$1(stream, new ERR_STREAM_PUSH_AFTER_EOF());
		else if (state.destroyed || state.errored) return false;
		else {
			state.state &= ~kReading;
			if (state.decoder && !encoding) {
				chunk = state.decoder.write(chunk);
				if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
				else maybeReadMore(stream, state);
			} else addChunk(stream, state, chunk, false);
		}
		else if (!addToFront) {
			state.state &= ~kReading;
			maybeReadMore(stream, state);
		}
		return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	}
	function addChunk(stream, state, chunk, addToFront) {
		if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
			if ((state.state & kMultiAwaitDrain) !== 0) state.awaitDrainWriters.clear();
			else state.awaitDrainWriters = null;
			state.dataEmitted = true;
			stream.emit("data", chunk);
		} else {
			state.length += state.objectMode ? 1 : chunk.length;
			if (addToFront) state.buffer.unshift(chunk);
			else state.buffer.push(chunk);
			if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
		}
		maybeReadMore(stream, state);
	}
	Readable$3.prototype.isPaused = function() {
		const state = this._readableState;
		return state[kPaused] === true || state.flowing === false;
	};
	Readable$3.prototype.setEncoding = function(enc) {
		const decoder = new StringDecoder(enc);
		this._readableState.decoder = decoder;
		this._readableState.encoding = this._readableState.decoder.encoding;
		const buffer = this._readableState.buffer;
		let content = "";
		for (const data of buffer) content += decoder.write(data);
		buffer.clear();
		if (content !== "") buffer.push(content);
		this._readableState.length = content.length;
		return this;
	};
	var MAX_HWM = 1073741824;
	function computeNewHighWaterMark(n) {
		if (n > MAX_HWM) throw new ERR_OUT_OF_RANGE$1("size", "<= 1GiB", n);
		else {
			n--;
			n |= n >>> 1;
			n |= n >>> 2;
			n |= n >>> 4;
			n |= n >>> 8;
			n |= n >>> 16;
			n++;
		}
		return n;
	}
	function howMuchToRead(n, state) {
		if (n <= 0 || state.length === 0 && state.ended) return 0;
		if ((state.state & kObjectMode) !== 0) return 1;
		if (NumberIsNaN$1(n)) {
			if (state.flowing && state.length) return state.buffer.first().length;
			return state.length;
		}
		if (n <= state.length) return n;
		return state.ended ? state.length : 0;
	}
	Readable$3.prototype.read = function(n) {
		debug("read", n);
		if (n === void 0) n = NaN;
		else if (!NumberIsInteger(n)) n = NumberParseInt(n, 10);
		const state = this._readableState;
		const nOrig = n;
		if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
		if (n !== 0) state.state &= ~kEmittedReadable;
		if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
			debug("read: emitReadable", state.length, state.ended);
			if (state.length === 0 && state.ended) endReadable(this);
			else emitReadable(this);
			return null;
		}
		n = howMuchToRead(n, state);
		if (n === 0 && state.ended) {
			if (state.length === 0) endReadable(this);
			return null;
		}
		let doRead = (state.state & kNeedReadable) !== 0;
		debug("need readable", doRead);
		if (state.length === 0 || state.length - n < state.highWaterMark) {
			doRead = true;
			debug("length less than watermark", doRead);
		}
		if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
			doRead = false;
			debug("reading, ended or constructing", doRead);
		} else if (doRead) {
			debug("do read");
			state.state |= kReading | kSync;
			if (state.length === 0) state.state |= kNeedReadable;
			try {
				this._read(state.highWaterMark);
			} catch (err) {
				errorOrDestroy$1(this, err);
			}
			state.state &= ~kSync;
			if (!state.reading) n = howMuchToRead(nOrig, state);
		}
		let ret;
		if (n > 0) ret = fromList(n, state);
		else ret = null;
		if (ret === null) {
			state.needReadable = state.length <= state.highWaterMark;
			n = 0;
		} else {
			state.length -= n;
			if (state.multiAwaitDrain) state.awaitDrainWriters.clear();
			else state.awaitDrainWriters = null;
		}
		if (state.length === 0) {
			if (!state.ended) state.needReadable = true;
			if (nOrig !== n && state.ended) endReadable(this);
		}
		if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
			state.dataEmitted = true;
			this.emit("data", ret);
		}
		return ret;
	};
	function onEofChunk(stream, state) {
		debug("onEofChunk");
		if (state.ended) return;
		if (state.decoder) {
			const chunk = state.decoder.end();
			if (chunk && chunk.length) {
				state.buffer.push(chunk);
				state.length += state.objectMode ? 1 : chunk.length;
			}
		}
		state.ended = true;
		if (state.sync) emitReadable(stream);
		else {
			state.needReadable = false;
			state.emittedReadable = true;
			emitReadable_(stream);
		}
	}
	function emitReadable(stream) {
		const state = stream._readableState;
		debug("emitReadable", state.needReadable, state.emittedReadable);
		state.needReadable = false;
		if (!state.emittedReadable) {
			debug("emitReadable", state.flowing);
			state.emittedReadable = true;
			process$4.nextTick(emitReadable_, stream);
		}
	}
	function emitReadable_(stream) {
		const state = stream._readableState;
		debug("emitReadable_", state.destroyed, state.length, state.ended);
		if (!state.destroyed && !state.errored && (state.length || state.ended)) {
			stream.emit("readable");
			state.emittedReadable = false;
		}
		state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
		flow(stream);
	}
	function maybeReadMore(stream, state) {
		if (!state.readingMore && state.constructed) {
			state.readingMore = true;
			process$4.nextTick(maybeReadMore_, stream, state);
		}
	}
	function maybeReadMore_(stream, state) {
		while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
			const len = state.length;
			debug("maybeReadMore read 0");
			stream.read(0);
			if (len === state.length) break;
		}
		state.readingMore = false;
	}
	Readable$3.prototype._read = function(n) {
		throw new ERR_METHOD_NOT_IMPLEMENTED$2("_read()");
	};
	Readable$3.prototype.pipe = function(dest, pipeOpts) {
		const src = this;
		const state = this._readableState;
		if (state.pipes.length === 1) {
			if (!state.multiAwaitDrain) {
				state.multiAwaitDrain = true;
				state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
			}
		}
		state.pipes.push(dest);
		debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
		const endFn = (!pipeOpts || pipeOpts.end !== false) && dest !== process$4.stdout && dest !== process$4.stderr ? onend : unpipe;
		if (state.endEmitted) process$4.nextTick(endFn);
		else src.once("end", endFn);
		dest.on("unpipe", onunpipe);
		function onunpipe(readable, unpipeInfo) {
			debug("onunpipe");
			if (readable === src) {
				if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
					unpipeInfo.hasUnpiped = true;
					cleanup();
				}
			}
		}
		function onend() {
			debug("onend");
			dest.end();
		}
		let ondrain;
		let cleanedUp = false;
		function cleanup() {
			debug("cleanup");
			dest.removeListener("close", onclose);
			dest.removeListener("finish", onfinish);
			if (ondrain) dest.removeListener("drain", ondrain);
			dest.removeListener("error", onerror);
			dest.removeListener("unpipe", onunpipe);
			src.removeListener("end", onend);
			src.removeListener("end", unpipe);
			src.removeListener("data", ondata);
			cleanedUp = true;
			if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
		}
		function pause() {
			if (!cleanedUp) {
				if (state.pipes.length === 1 && state.pipes[0] === dest) {
					debug("false write response, pause", 0);
					state.awaitDrainWriters = dest;
					state.multiAwaitDrain = false;
				} else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
					debug("false write response, pause", state.awaitDrainWriters.size);
					state.awaitDrainWriters.add(dest);
				}
				src.pause();
			}
			if (!ondrain) {
				ondrain = pipeOnDrain(src, dest);
				dest.on("drain", ondrain);
			}
		}
		src.on("data", ondata);
		function ondata(chunk) {
			debug("ondata");
			const ret = dest.write(chunk);
			debug("dest.write", ret);
			if (ret === false) pause();
		}
		function onerror(er) {
			debug("onerror", er);
			unpipe();
			dest.removeListener("error", onerror);
			if (dest.listenerCount("error") === 0) {
				const s = dest._writableState || dest._readableState;
				if (s && !s.errorEmitted) errorOrDestroy$1(dest, er);
				else dest.emit("error", er);
			}
		}
		prependListener(dest, "error", onerror);
		function onclose() {
			dest.removeListener("finish", onfinish);
			unpipe();
		}
		dest.once("close", onclose);
		function onfinish() {
			debug("onfinish");
			dest.removeListener("close", onclose);
			unpipe();
		}
		dest.once("finish", onfinish);
		function unpipe() {
			debug("unpipe");
			src.unpipe(dest);
		}
		dest.emit("pipe", src);
		if (dest.writableNeedDrain === true) pause();
		else if (!state.flowing) {
			debug("pipe resume");
			src.resume();
		}
		return dest;
	};
	function pipeOnDrain(src, dest) {
		return function pipeOnDrainFunctionResult() {
			const state = src._readableState;
			if (state.awaitDrainWriters === dest) {
				debug("pipeOnDrain", 1);
				state.awaitDrainWriters = null;
			} else if (state.multiAwaitDrain) {
				debug("pipeOnDrain", state.awaitDrainWriters.size);
				state.awaitDrainWriters.delete(dest);
			}
			if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) src.resume();
		};
	}
	Readable$3.prototype.unpipe = function(dest) {
		const state = this._readableState;
		const unpipeInfo = { hasUnpiped: false };
		if (state.pipes.length === 0) return this;
		if (!dest) {
			const dests = state.pipes;
			state.pipes = [];
			this.pause();
			for (let i = 0; i < dests.length; i++) dests[i].emit("unpipe", this, { hasUnpiped: false });
			return this;
		}
		const index = ArrayPrototypeIndexOf(state.pipes, dest);
		if (index === -1) return this;
		state.pipes.splice(index, 1);
		if (state.pipes.length === 0) this.pause();
		dest.emit("unpipe", this, unpipeInfo);
		return this;
	};
	Readable$3.prototype.on = function(ev, fn) {
		const res = Stream$2.prototype.on.call(this, ev, fn);
		const state = this._readableState;
		if (ev === "data") {
			state.readableListening = this.listenerCount("readable") > 0;
			if (state.flowing !== false) this.resume();
		} else if (ev === "readable") {
			if (!state.endEmitted && !state.readableListening) {
				state.readableListening = state.needReadable = true;
				state.flowing = false;
				state.emittedReadable = false;
				debug("on readable", state.length, state.reading);
				if (state.length) emitReadable(this);
				else if (!state.reading) process$4.nextTick(nReadingNextTick, this);
			}
		}
		return res;
	};
	Readable$3.prototype.addListener = Readable$3.prototype.on;
	Readable$3.prototype.removeListener = function(ev, fn) {
		const res = Stream$2.prototype.removeListener.call(this, ev, fn);
		if (ev === "readable") process$4.nextTick(updateReadableListening, this);
		return res;
	};
	Readable$3.prototype.off = Readable$3.prototype.removeListener;
	Readable$3.prototype.removeAllListeners = function(ev) {
		const res = Stream$2.prototype.removeAllListeners.apply(this, arguments);
		if (ev === "readable" || ev === void 0) process$4.nextTick(updateReadableListening, this);
		return res;
	};
	function updateReadableListening(self$1) {
		const state = self$1._readableState;
		state.readableListening = self$1.listenerCount("readable") > 0;
		if (state.resumeScheduled && state[kPaused] === false) state.flowing = true;
		else if (self$1.listenerCount("data") > 0) self$1.resume();
		else if (!state.readableListening) state.flowing = null;
	}
	function nReadingNextTick(self$1) {
		debug("readable nexttick read 0");
		self$1.read(0);
	}
	Readable$3.prototype.resume = function() {
		const state = this._readableState;
		if (!state.flowing) {
			debug("resume");
			state.flowing = !state.readableListening;
			resume(this, state);
		}
		state[kPaused] = false;
		return this;
	};
	function resume(stream, state) {
		if (!state.resumeScheduled) {
			state.resumeScheduled = true;
			process$4.nextTick(resume_, stream, state);
		}
	}
	function resume_(stream, state) {
		debug("resume", state.reading);
		if (!state.reading) stream.read(0);
		state.resumeScheduled = false;
		stream.emit("resume");
		flow(stream);
		if (state.flowing && !state.reading) stream.read(0);
	}
	Readable$3.prototype.pause = function() {
		debug("call pause flowing=%j", this._readableState.flowing);
		if (this._readableState.flowing !== false) {
			debug("pause");
			this._readableState.flowing = false;
			this.emit("pause");
		}
		this._readableState[kPaused] = true;
		return this;
	};
	function flow(stream) {
		const state = stream._readableState;
		debug("flow", state.flowing);
		while (state.flowing && stream.read() !== null);
	}
	Readable$3.prototype.wrap = function(stream) {
		let paused = false;
		stream.on("data", (chunk) => {
			if (!this.push(chunk) && stream.pause) {
				paused = true;
				stream.pause();
			}
		});
		stream.on("end", () => {
			this.push(null);
		});
		stream.on("error", (err) => {
			errorOrDestroy$1(this, err);
		});
		stream.on("close", () => {
			this.destroy();
		});
		stream.on("destroy", () => {
			this.destroy();
		});
		this._read = () => {
			if (paused && stream.resume) {
				paused = false;
				stream.resume();
			}
		};
		const streamKeys = ObjectKeys$2(stream);
		for (let j = 1; j < streamKeys.length; j++) {
			const i = streamKeys[j];
			if (this[i] === void 0 && typeof stream[i] === "function") this[i] = stream[i].bind(stream);
		}
		return this;
	};
	Readable$3.prototype[SymbolAsyncIterator$1] = function() {
		return streamToAsyncIterator(this);
	};
	Readable$3.prototype.iterator = function(options) {
		if (options !== void 0) validateObject$2(options, "options");
		return streamToAsyncIterator(this, options);
	};
	function streamToAsyncIterator(stream, options) {
		if (typeof stream.read !== "function") stream = Readable$3.wrap(stream, { objectMode: true });
		const iter = createAsyncIterator(stream, options);
		iter.stream = stream;
		return iter;
	}
	async function* createAsyncIterator(stream, options) {
		let callback = nop$1;
		function next$1(resolve) {
			if (this === stream) {
				callback();
				callback = nop$1;
			} else callback = resolve;
		}
		stream.on("readable", next$1);
		let error$1;
		const cleanup = eos$7(stream, { writable: false }, (err) => {
			error$1 = err ? aggregateTwoErrors$1(error$1, err) : null;
			callback();
			callback = nop$1;
		});
		try {
			while (true) {
				const chunk = stream.destroyed ? null : stream.read();
				if (chunk !== null) yield chunk;
				else if (error$1) throw error$1;
				else if (error$1 === null) return;
				else await new Promise$4(next$1);
			}
		} catch (err) {
			error$1 = aggregateTwoErrors$1(error$1, err);
			throw error$1;
		} finally {
			if ((error$1 || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error$1 === void 0 || stream._readableState.autoDestroy)) destroyImpl$2.destroyer(stream, null);
			else {
				stream.off("readable", next$1);
				cleanup();
			}
		}
	}
	ObjectDefineProperties$2(Readable$3.prototype, {
		readable: {
			__proto__: null,
			get() {
				const r = this._readableState;
				return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
			},
			set(val) {
				if (this._readableState) this._readableState.readable = !!val;
			}
		},
		readableDidRead: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return this._readableState.dataEmitted;
			}
		},
		readableAborted: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
			}
		},
		readableHighWaterMark: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return this._readableState.highWaterMark;
			}
		},
		readableBuffer: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return this._readableState && this._readableState.buffer;
			}
		},
		readableFlowing: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return this._readableState.flowing;
			},
			set: function(state) {
				if (this._readableState) this._readableState.flowing = state;
			}
		},
		readableLength: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState.length;
			}
		},
		readableObjectMode: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState ? this._readableState.objectMode : false;
			}
		},
		readableEncoding: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState ? this._readableState.encoding : null;
			}
		},
		errored: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState ? this._readableState.errored : null;
			}
		},
		closed: {
			__proto__: null,
			get() {
				return this._readableState ? this._readableState.closed : false;
			}
		},
		destroyed: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState ? this._readableState.destroyed : false;
			},
			set(value$2) {
				if (!this._readableState) return;
				this._readableState.destroyed = value$2;
			}
		},
		readableEnded: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState ? this._readableState.endEmitted : false;
			}
		}
	});
	ObjectDefineProperties$2(ReadableState.prototype, {
		pipesCount: {
			__proto__: null,
			get() {
				return this.pipes.length;
			}
		},
		paused: {
			__proto__: null,
			get() {
				return this[kPaused] !== false;
			},
			set(value$2) {
				this[kPaused] = !!value$2;
			}
		}
	});
	Readable$3._fromList = fromList;
	function fromList(n, state) {
		if (state.length === 0) return null;
		let ret;
		if (state.objectMode) ret = state.buffer.shift();
		else if (!n || n >= state.length) {
			if (state.decoder) ret = state.buffer.join("");
			else if (state.buffer.length === 1) ret = state.buffer.first();
			else ret = state.buffer.concat(state.length);
			state.buffer.clear();
		} else ret = state.buffer.consume(n, state.decoder);
		return ret;
	}
	function endReadable(stream) {
		const state = stream._readableState;
		debug("endReadable", state.endEmitted);
		if (!state.endEmitted) {
			state.ended = true;
			process$4.nextTick(endReadableNT, state, stream);
		}
	}
	function endReadableNT(state, stream) {
		debug("endReadableNT", state.endEmitted, state.length);
		if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
			state.endEmitted = true;
			stream.emit("end");
			if (stream.writable && stream.allowHalfOpen === false) process$4.nextTick(endWritableNT, stream);
			else if (state.autoDestroy) {
				const wState = stream._writableState;
				if (!wState || wState.autoDestroy && (wState.finished || wState.writable === false)) stream.destroy();
			}
		}
	}
	function endWritableNT(stream) {
		if (stream.writable && !stream.writableEnded && !stream.destroyed) stream.end();
	}
	Readable$3.from = function(iterable, opts) {
		return from$1(Readable$3, iterable, opts);
	};
	var webStreamsAdapters$2;
	function lazyWebStreams$2() {
		if (webStreamsAdapters$2 === void 0) webStreamsAdapters$2 = {};
		return webStreamsAdapters$2;
	}
	Readable$3.fromWeb = function(readableStream, options) {
		return lazyWebStreams$2().newStreamReadableFromReadableStream(readableStream, options);
	};
	Readable$3.toWeb = function(streamReadable, options) {
		return lazyWebStreams$2().newReadableStreamFromStreamReadable(streamReadable, options);
	};
	Readable$3.wrap = function(src, options) {
		var _ref, _src$readableObjectMo;
		return new Readable$3({
			objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
			...options,
			destroy(err, callback) {
				destroyImpl$2.destroyer(src, err);
				callback(err);
			}
		}).wrap(src);
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/writable.js": ((exports, module) => {
	var process$3 = require_browser$1();
	var { ArrayPrototypeSlice, Error: Error$1, FunctionPrototypeSymbolHasInstance, ObjectDefineProperty: ObjectDefineProperty$1, ObjectDefineProperties: ObjectDefineProperties$1, ObjectSetPrototypeOf: ObjectSetPrototypeOf$3, StringPrototypeToLowerCase, Symbol: Symbol$4, SymbolHasInstance } = require_primordials();
	module.exports = Writable$2;
	Writable$2.WritableState = WritableState;
	var { EventEmitter: EE } = require_events();
	var Stream$1 = require_legacy().Stream;
	var { Buffer: Buffer$3 } = require_buffer();
	var destroyImpl$1 = require_destroy();
	var { addAbortSignal: addAbortSignal$1 } = require_add_abort_signal();
	var { getHighWaterMark: getHighWaterMark$1, getDefaultHighWaterMark: getDefaultHighWaterMark$1 } = require_state();
	var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$3, ERR_METHOD_NOT_IMPLEMENTED: ERR_METHOD_NOT_IMPLEMENTED$1, ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED: ERR_STREAM_DESTROYED$1, ERR_STREAM_ALREADY_FINISHED, ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING } = require_errors$1().codes;
	var { errorOrDestroy } = destroyImpl$1;
	ObjectSetPrototypeOf$3(Writable$2.prototype, Stream$1.prototype);
	ObjectSetPrototypeOf$3(Writable$2, Stream$1);
	function nop() {}
	var kOnFinished = Symbol$4("kOnFinished");
	function WritableState(options, stream, isDuplex) {
		if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
		this.objectMode = !!(options && options.objectMode);
		if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
		this.highWaterMark = options ? getHighWaterMark$1(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark$1(false);
		this.finalCalled = false;
		this.needDrain = false;
		this.ending = false;
		this.ended = false;
		this.finished = false;
		this.destroyed = false;
		this.decodeStrings = !!!(options && options.decodeStrings === false);
		this.defaultEncoding = options && options.defaultEncoding || "utf8";
		this.length = 0;
		this.writing = false;
		this.corked = 0;
		this.sync = true;
		this.bufferProcessing = false;
		this.onwrite = onwrite.bind(void 0, stream);
		this.writecb = null;
		this.writelen = 0;
		this.afterWriteTickInfo = null;
		resetBuffer(this);
		this.pendingcb = 0;
		this.constructed = true;
		this.prefinished = false;
		this.errorEmitted = false;
		this.emitClose = !options || options.emitClose !== false;
		this.autoDestroy = !options || options.autoDestroy !== false;
		this.errored = null;
		this.closed = false;
		this.closeEmitted = false;
		this[kOnFinished] = [];
	}
	function resetBuffer(state) {
		state.buffered = [];
		state.bufferedIndex = 0;
		state.allBuffers = true;
		state.allNoop = true;
	}
	WritableState.prototype.getBuffer = function getBuffer() {
		return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
	};
	ObjectDefineProperty$1(WritableState.prototype, "bufferedRequestCount", {
		__proto__: null,
		get() {
			return this.buffered.length - this.bufferedIndex;
		}
	});
	function Writable$2(options) {
		const isDuplex = this instanceof require_duplex();
		if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable$2, this)) return new Writable$2(options);
		this._writableState = new WritableState(options, this, isDuplex);
		if (options) {
			if (typeof options.write === "function") this._write = options.write;
			if (typeof options.writev === "function") this._writev = options.writev;
			if (typeof options.destroy === "function") this._destroy = options.destroy;
			if (typeof options.final === "function") this._final = options.final;
			if (typeof options.construct === "function") this._construct = options.construct;
			if (options.signal) addAbortSignal$1(options.signal, this);
		}
		Stream$1.call(this, options);
		destroyImpl$1.construct(this, () => {
			const state = this._writableState;
			if (!state.writing) clearBuffer(this, state);
			finishMaybe(this, state);
		});
	}
	ObjectDefineProperty$1(Writable$2, SymbolHasInstance, {
		__proto__: null,
		value: function(object$1) {
			if (FunctionPrototypeSymbolHasInstance(this, object$1)) return true;
			if (this !== Writable$2) return false;
			return object$1 && object$1._writableState instanceof WritableState;
		}
	});
	Writable$2.prototype.pipe = function() {
		errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function _write(stream, chunk, encoding, cb) {
		const state = stream._writableState;
		if (typeof encoding === "function") {
			cb = encoding;
			encoding = state.defaultEncoding;
		} else {
			if (!encoding) encoding = state.defaultEncoding;
			else if (encoding !== "buffer" && !Buffer$3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
			if (typeof cb !== "function") cb = nop;
		}
		if (chunk === null) throw new ERR_STREAM_NULL_VALUES();
		else if (!state.objectMode) if (typeof chunk === "string") {
			if (state.decodeStrings !== false) {
				chunk = Buffer$3.from(chunk, encoding);
				encoding = "buffer";
			}
		} else if (chunk instanceof Buffer$3) encoding = "buffer";
		else if (Stream$1._isUint8Array(chunk)) {
			chunk = Stream$1._uint8ArrayToBuffer(chunk);
			encoding = "buffer";
		} else throw new ERR_INVALID_ARG_TYPE$3("chunk", [
			"string",
			"Buffer",
			"Uint8Array"
		], chunk);
		let err;
		if (state.ending) err = new ERR_STREAM_WRITE_AFTER_END();
		else if (state.destroyed) err = new ERR_STREAM_DESTROYED$1("write");
		if (err) {
			process$3.nextTick(cb, err);
			errorOrDestroy(stream, err, true);
			return err;
		}
		state.pendingcb++;
		return writeOrBuffer(stream, state, chunk, encoding, cb);
	}
	Writable$2.prototype.write = function(chunk, encoding, cb) {
		return _write(this, chunk, encoding, cb) === true;
	};
	Writable$2.prototype.cork = function() {
		this._writableState.corked++;
	};
	Writable$2.prototype.uncork = function() {
		const state = this._writableState;
		if (state.corked) {
			state.corked--;
			if (!state.writing) clearBuffer(this, state);
		}
	};
	Writable$2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
		if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
		if (!Buffer$3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
		this._writableState.defaultEncoding = encoding;
		return this;
	};
	function writeOrBuffer(stream, state, chunk, encoding, callback) {
		const len = state.objectMode ? 1 : chunk.length;
		state.length += len;
		const ret = state.length < state.highWaterMark;
		if (!ret) state.needDrain = true;
		if (state.writing || state.corked || state.errored || !state.constructed) {
			state.buffered.push({
				chunk,
				encoding,
				callback
			});
			if (state.allBuffers && encoding !== "buffer") state.allBuffers = false;
			if (state.allNoop && callback !== nop) state.allNoop = false;
		} else {
			state.writelen = len;
			state.writecb = callback;
			state.writing = true;
			state.sync = true;
			stream._write(chunk, encoding, state.onwrite);
			state.sync = false;
		}
		return ret && !state.errored && !state.destroyed;
	}
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
		state.writelen = len;
		state.writecb = cb;
		state.writing = true;
		state.sync = true;
		if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED$1("write"));
		else if (writev) stream._writev(chunk, state.onwrite);
		else stream._write(chunk, encoding, state.onwrite);
		state.sync = false;
	}
	function onwriteError(stream, state, er, cb) {
		--state.pendingcb;
		cb(er);
		errorBuffer(state);
		errorOrDestroy(stream, er);
	}
	function onwrite(stream, er) {
		const state = stream._writableState;
		const sync = state.sync;
		const cb = state.writecb;
		if (typeof cb !== "function") {
			errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
			return;
		}
		state.writing = false;
		state.writecb = null;
		state.length -= state.writelen;
		state.writelen = 0;
		if (er) {
			er.stack;
			if (!state.errored) state.errored = er;
			if (stream._readableState && !stream._readableState.errored) stream._readableState.errored = er;
			if (sync) process$3.nextTick(onwriteError, stream, state, er, cb);
			else onwriteError(stream, state, er, cb);
		} else {
			if (state.buffered.length > state.bufferedIndex) clearBuffer(stream, state);
			if (sync) if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) state.afterWriteTickInfo.count++;
			else {
				state.afterWriteTickInfo = {
					count: 1,
					cb,
					stream,
					state
				};
				process$3.nextTick(afterWriteTick, state.afterWriteTickInfo);
			}
			else afterWrite(stream, state, 1, cb);
		}
	}
	function afterWriteTick({ stream, state, count, cb }) {
		state.afterWriteTickInfo = null;
		return afterWrite(stream, state, count, cb);
	}
	function afterWrite(stream, state, count, cb) {
		if (!state.ending && !stream.destroyed && state.length === 0 && state.needDrain) {
			state.needDrain = false;
			stream.emit("drain");
		}
		while (count-- > 0) {
			state.pendingcb--;
			cb();
		}
		if (state.destroyed) errorBuffer(state);
		finishMaybe(stream, state);
	}
	function errorBuffer(state) {
		if (state.writing) return;
		for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
			var _state$errored;
			const { chunk, callback } = state.buffered[n];
			const len = state.objectMode ? 1 : chunk.length;
			state.length -= len;
			callback((_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED$1("write"));
		}
		const onfinishCallbacks = state[kOnFinished].splice(0);
		for (let i = 0; i < onfinishCallbacks.length; i++) {
			var _state$errored2;
			onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED$1("end"));
		}
		resetBuffer(state);
	}
	function clearBuffer(stream, state) {
		if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) return;
		const { buffered, bufferedIndex, objectMode } = state;
		const bufferedLength = buffered.length - bufferedIndex;
		if (!bufferedLength) return;
		let i = bufferedIndex;
		state.bufferProcessing = true;
		if (bufferedLength > 1 && stream._writev) {
			state.pendingcb -= bufferedLength - 1;
			const callback = state.allNoop ? nop : (err) => {
				for (let n = i; n < buffered.length; ++n) buffered[n].callback(err);
			};
			const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
			chunks.allBuffers = state.allBuffers;
			doWrite(stream, state, true, state.length, chunks, "", callback);
			resetBuffer(state);
		} else {
			do {
				const { chunk, encoding, callback } = buffered[i];
				buffered[i++] = null;
				doWrite(stream, state, false, objectMode ? 1 : chunk.length, chunk, encoding, callback);
			} while (i < buffered.length && !state.writing);
			if (i === buffered.length) resetBuffer(state);
			else if (i > 256) {
				buffered.splice(0, i);
				state.bufferedIndex = 0;
			} else state.bufferedIndex = i;
		}
		state.bufferProcessing = false;
	}
	Writable$2.prototype._write = function(chunk, encoding, cb) {
		if (this._writev) this._writev([{
			chunk,
			encoding
		}], cb);
		else throw new ERR_METHOD_NOT_IMPLEMENTED$1("_write()");
	};
	Writable$2.prototype._writev = null;
	Writable$2.prototype.end = function(chunk, encoding, cb) {
		const state = this._writableState;
		if (typeof chunk === "function") {
			cb = chunk;
			chunk = null;
			encoding = null;
		} else if (typeof encoding === "function") {
			cb = encoding;
			encoding = null;
		}
		let err;
		if (chunk !== null && chunk !== void 0) {
			const ret = _write(this, chunk, encoding);
			if (ret instanceof Error$1) err = ret;
		}
		if (state.corked) {
			state.corked = 1;
			this.uncork();
		}
		if (err) {} else if (!state.errored && !state.ending) {
			state.ending = true;
			finishMaybe(this, state, true);
			state.ended = true;
		} else if (state.finished) err = new ERR_STREAM_ALREADY_FINISHED("end");
		else if (state.destroyed) err = new ERR_STREAM_DESTROYED$1("end");
		if (typeof cb === "function") if (err || state.finished) process$3.nextTick(cb, err);
		else state[kOnFinished].push(cb);
		return this;
	};
	function needFinish(state) {
		return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
	}
	function callFinal(stream, state) {
		let called = false;
		function onFinish(err) {
			if (called) {
				errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
				return;
			}
			called = true;
			state.pendingcb--;
			if (err) {
				const onfinishCallbacks = state[kOnFinished].splice(0);
				for (let i = 0; i < onfinishCallbacks.length; i++) onfinishCallbacks[i](err);
				errorOrDestroy(stream, err, state.sync);
			} else if (needFinish(state)) {
				state.prefinished = true;
				stream.emit("prefinish");
				state.pendingcb++;
				process$3.nextTick(finish, stream, state);
			}
		}
		state.sync = true;
		state.pendingcb++;
		try {
			stream._final(onFinish);
		} catch (err) {
			onFinish(err);
		}
		state.sync = false;
	}
	function prefinish$1(stream, state) {
		if (!state.prefinished && !state.finalCalled) if (typeof stream._final === "function" && !state.destroyed) {
			state.finalCalled = true;
			callFinal(stream, state);
		} else {
			state.prefinished = true;
			stream.emit("prefinish");
		}
	}
	function finishMaybe(stream, state, sync) {
		if (needFinish(state)) {
			prefinish$1(stream, state);
			if (state.pendingcb === 0) {
				if (sync) {
					state.pendingcb++;
					process$3.nextTick((stream$1, state$1) => {
						if (needFinish(state$1)) finish(stream$1, state$1);
						else state$1.pendingcb--;
					}, stream, state);
				} else if (needFinish(state)) {
					state.pendingcb++;
					finish(stream, state);
				}
			}
		}
	}
	function finish(stream, state) {
		state.pendingcb--;
		state.finished = true;
		const onfinishCallbacks = state[kOnFinished].splice(0);
		for (let i = 0; i < onfinishCallbacks.length; i++) onfinishCallbacks[i]();
		stream.emit("finish");
		if (state.autoDestroy) {
			const rState = stream._readableState;
			if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false)) stream.destroy();
		}
	}
	ObjectDefineProperties$1(Writable$2.prototype, {
		closed: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.closed : false;
			}
		},
		destroyed: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.destroyed : false;
			},
			set(value$2) {
				if (this._writableState) this._writableState.destroyed = value$2;
			}
		},
		writable: {
			__proto__: null,
			get() {
				const w = this._writableState;
				return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
			},
			set(val) {
				if (this._writableState) this._writableState.writable = !!val;
			}
		},
		writableFinished: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.finished : false;
			}
		},
		writableObjectMode: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.objectMode : false;
			}
		},
		writableBuffer: {
			__proto__: null,
			get() {
				return this._writableState && this._writableState.getBuffer();
			}
		},
		writableEnded: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.ending : false;
			}
		},
		writableNeedDrain: {
			__proto__: null,
			get() {
				const wState = this._writableState;
				if (!wState) return false;
				return !wState.destroyed && !wState.ending && wState.needDrain;
			}
		},
		writableHighWaterMark: {
			__proto__: null,
			get() {
				return this._writableState && this._writableState.highWaterMark;
			}
		},
		writableCorked: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.corked : 0;
			}
		},
		writableLength: {
			__proto__: null,
			get() {
				return this._writableState && this._writableState.length;
			}
		},
		errored: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._writableState ? this._writableState.errored : null;
			}
		},
		writableAborted: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
			}
		}
	});
	var destroy = destroyImpl$1.destroy;
	Writable$2.prototype.destroy = function(err, cb) {
		const state = this._writableState;
		if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) process$3.nextTick(errorBuffer, state);
		destroy.call(this, err, cb);
		return this;
	};
	Writable$2.prototype._undestroy = destroyImpl$1.undestroy;
	Writable$2.prototype._destroy = function(err, cb) {
		cb(err);
	};
	Writable$2.prototype[EE.captureRejectionSymbol] = function(err) {
		this.destroy(err);
	};
	var webStreamsAdapters$1;
	function lazyWebStreams$1() {
		if (webStreamsAdapters$1 === void 0) webStreamsAdapters$1 = {};
		return webStreamsAdapters$1;
	}
	Writable$2.fromWeb = function(writableStream, options) {
		return lazyWebStreams$1().newStreamWritableFromWritableStream(writableStream, options);
	};
	Writable$2.toWeb = function(streamWritable) {
		return lazyWebStreams$1().newWritableStreamFromStreamWritable(streamWritable);
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/duplexify.js": ((exports, module) => {
	var process$2 = require_browser$1();
	var bufferModule = require_buffer();
	var { isReadable: isReadable$2, isWritable: isWritable$2, isIterable: isIterable$2, isNodeStream: isNodeStream$4, isReadableNodeStream: isReadableNodeStream$1, isWritableNodeStream, isDuplexNodeStream, isReadableStream: isReadableStream$3, isWritableStream: isWritableStream$2 } = require_utils$1();
	var eos$6 = require_end_of_stream$1();
	var { AbortError: AbortError$3, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$2, ERR_INVALID_RETURN_VALUE: ERR_INVALID_RETURN_VALUE$1 } } = require_errors$1();
	var { destroyer: destroyer$4 } = require_destroy();
	var Duplex$5 = require_duplex();
	var Readable$2 = require_readable();
	var Writable$1 = require_writable();
	var { createDeferredPromise } = require_util();
	var from = require_from();
	var Blob$1 = globalThis.Blob || bufferModule.Blob;
	var isBlob = typeof Blob$1 !== "undefined" ? function isBlob$2(b) {
		return b instanceof Blob$1;
	} : function isBlob$2(b) {
		return false;
	};
	var AbortController$2 = globalThis.AbortController || require_browser$2().AbortController;
	var { FunctionPrototypeCall } = require_primordials();
	var Duplexify = class extends Duplex$5 {
		constructor(options) {
			super(options);
			if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
				this._readableState.readable = false;
				this._readableState.ended = true;
				this._readableState.endEmitted = true;
			}
			if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
				this._writableState.writable = false;
				this._writableState.ending = true;
				this._writableState.ended = true;
				this._writableState.finished = true;
			}
		}
	};
	module.exports = function duplexify$1(body, name$1) {
		if (isDuplexNodeStream(body)) return body;
		if (isReadableNodeStream$1(body)) return _duplexify({ readable: body });
		if (isWritableNodeStream(body)) return _duplexify({ writable: body });
		if (isNodeStream$4(body)) return _duplexify({
			writable: false,
			readable: false
		});
		if (isReadableStream$3(body)) return _duplexify({ readable: Readable$2.fromWeb(body) });
		if (isWritableStream$2(body)) return _duplexify({ writable: Writable$1.fromWeb(body) });
		if (typeof body === "function") {
			const { value: value$2, write, final: final$1, destroy: destroy$2 } = fromAsyncGen(body);
			if (isIterable$2(value$2)) return from(Duplexify, value$2, {
				objectMode: true,
				write,
				final: final$1,
				destroy: destroy$2
			});
			const then$1 = value$2 === null || value$2 === void 0 ? void 0 : value$2.then;
			if (typeof then$1 === "function") {
				let d;
				const promise = FunctionPrototypeCall(then$1, value$2, (val) => {
					if (val != null) throw new ERR_INVALID_RETURN_VALUE$1("nully", "body", val);
				}, (err) => {
					destroyer$4(d, err);
				});
				return d = new Duplexify({
					objectMode: true,
					readable: false,
					write,
					final(cb) {
						final$1(async () => {
							try {
								await promise;
								process$2.nextTick(cb, null);
							} catch (err) {
								process$2.nextTick(cb, err);
							}
						});
					},
					destroy: destroy$2
				});
			}
			throw new ERR_INVALID_RETURN_VALUE$1("Iterable, AsyncIterable or AsyncFunction", name$1, value$2);
		}
		if (isBlob(body)) return duplexify$1(body.arrayBuffer());
		if (isIterable$2(body)) return from(Duplexify, body, {
			objectMode: true,
			writable: false
		});
		if (isReadableStream$3(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream$2(body === null || body === void 0 ? void 0 : body.writable)) return Duplexify.fromWeb(body);
		if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") return _duplexify({
			readable: body !== null && body !== void 0 && body.readable ? isReadableNodeStream$1(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify$1(body.readable) : void 0,
			writable: body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify$1(body.writable) : void 0
		});
		const then = body === null || body === void 0 ? void 0 : body.then;
		if (typeof then === "function") {
			let d;
			FunctionPrototypeCall(then, body, (val) => {
				if (val != null) d.push(val);
				d.push(null);
			}, (err) => {
				destroyer$4(d, err);
			});
			return d = new Duplexify({
				objectMode: true,
				writable: false,
				read() {}
			});
		}
		throw new ERR_INVALID_ARG_TYPE$2(name$1, [
			"Blob",
			"ReadableStream",
			"WritableStream",
			"Stream",
			"Iterable",
			"AsyncIterable",
			"Function",
			"{ readable, writable } pair",
			"Promise"
		], body);
	};
	function fromAsyncGen(fn) {
		let { promise, resolve } = createDeferredPromise();
		const ac = new AbortController$2();
		const signal = ac.signal;
		return {
			value: fn((async function* () {
				while (true) {
					const _promise = promise;
					promise = null;
					const { chunk, done, cb } = await _promise;
					process$2.nextTick(cb);
					if (done) return;
					if (signal.aborted) throw new AbortError$3(void 0, { cause: signal.reason });
					({promise, resolve} = createDeferredPromise());
					yield chunk;
				}
			})(), { signal }),
			write(chunk, encoding, cb) {
				const _resolve = resolve;
				resolve = null;
				_resolve({
					chunk,
					done: false,
					cb
				});
			},
			final(cb) {
				const _resolve = resolve;
				resolve = null;
				_resolve({
					done: true,
					cb
				});
			},
			destroy(err, cb) {
				ac.abort();
				cb(err);
			}
		};
	}
	function _duplexify(pair) {
		const r = pair.readable && typeof pair.readable.read !== "function" ? Readable$2.wrap(pair.readable) : pair.readable;
		const w = pair.writable;
		let readable = !!isReadable$2(r);
		let writable = !!isWritable$2(w);
		let ondrain;
		let onfinish;
		let onreadable;
		let onclose;
		let d;
		function onfinished(err) {
			const cb = onclose;
			onclose = null;
			if (cb) cb(err);
			else if (err) d.destroy(err);
		}
		d = new Duplexify({
			readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
			writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
			readable,
			writable
		});
		if (writable) {
			eos$6(w, (err) => {
				writable = false;
				if (err) destroyer$4(r, err);
				onfinished(err);
			});
			d._write = function(chunk, encoding, callback) {
				if (w.write(chunk, encoding)) callback();
				else ondrain = callback;
			};
			d._final = function(callback) {
				w.end();
				onfinish = callback;
			};
			w.on("drain", function() {
				if (ondrain) {
					const cb = ondrain;
					ondrain = null;
					cb();
				}
			});
			w.on("finish", function() {
				if (onfinish) {
					const cb = onfinish;
					onfinish = null;
					cb();
				}
			});
		}
		if (readable) {
			eos$6(r, (err) => {
				readable = false;
				if (err) destroyer$4(r, err);
				onfinished(err);
			});
			r.on("readable", function() {
				if (onreadable) {
					const cb = onreadable;
					onreadable = null;
					cb();
				}
			});
			r.on("end", function() {
				d.push(null);
			});
			d._read = function() {
				while (true) {
					const buf = r.read();
					if (buf === null) {
						onreadable = d._read;
						return;
					}
					if (!d.push(buf)) return;
				}
			};
		}
		d._destroy = function(err, callback) {
			if (!err && onclose !== null) err = new AbortError$3();
			onreadable = null;
			ondrain = null;
			onfinish = null;
			if (onclose === null) callback(err);
			else {
				onclose = callback;
				destroyer$4(w, err);
				destroyer$4(r, err);
			}
		};
		return d;
	}
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/duplex.js": ((exports, module) => {
	var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys: ObjectKeys$1, ObjectSetPrototypeOf: ObjectSetPrototypeOf$2 } = require_primordials();
	module.exports = Duplex$4;
	var Readable$1 = require_readable();
	var Writable = require_writable();
	ObjectSetPrototypeOf$2(Duplex$4.prototype, Readable$1.prototype);
	ObjectSetPrototypeOf$2(Duplex$4, Readable$1);
	{
		const keys = ObjectKeys$1(Writable.prototype);
		for (let i = 0; i < keys.length; i++) {
			const method = keys[i];
			if (!Duplex$4.prototype[method]) Duplex$4.prototype[method] = Writable.prototype[method];
		}
	}
	function Duplex$4(options) {
		if (!(this instanceof Duplex$4)) return new Duplex$4(options);
		Readable$1.call(this, options);
		Writable.call(this, options);
		if (options) {
			this.allowHalfOpen = options.allowHalfOpen !== false;
			if (options.readable === false) {
				this._readableState.readable = false;
				this._readableState.ended = true;
				this._readableState.endEmitted = true;
			}
			if (options.writable === false) {
				this._writableState.writable = false;
				this._writableState.ending = true;
				this._writableState.ended = true;
				this._writableState.finished = true;
			}
		} else this.allowHalfOpen = true;
	}
	ObjectDefineProperties(Duplex$4.prototype, {
		writable: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
		},
		writableHighWaterMark: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
		},
		writableObjectMode: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
		},
		writableBuffer: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
		},
		writableLength: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
		},
		writableFinished: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
		},
		writableCorked: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
		},
		writableEnded: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
		},
		writableNeedDrain: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
		},
		destroyed: {
			__proto__: null,
			get() {
				if (this._readableState === void 0 || this._writableState === void 0) return false;
				return this._readableState.destroyed && this._writableState.destroyed;
			},
			set(value$2) {
				if (this._readableState && this._writableState) {
					this._readableState.destroyed = value$2;
					this._writableState.destroyed = value$2;
				}
			}
		}
	});
	var webStreamsAdapters;
	function lazyWebStreams() {
		if (webStreamsAdapters === void 0) webStreamsAdapters = {};
		return webStreamsAdapters;
	}
	Duplex$4.fromWeb = function(pair, options) {
		return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
	};
	Duplex$4.toWeb = function(duplex) {
		return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
	};
	var duplexify;
	Duplex$4.from = function(body) {
		if (!duplexify) duplexify = require_duplexify();
		return duplexify(body, "body");
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/transform.js": ((exports, module) => {
	var { ObjectSetPrototypeOf: ObjectSetPrototypeOf$1, Symbol: Symbol$3 } = require_primordials();
	module.exports = Transform$1;
	var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors$1().codes;
	var Duplex$3 = require_duplex();
	var { getHighWaterMark } = require_state();
	ObjectSetPrototypeOf$1(Transform$1.prototype, Duplex$3.prototype);
	ObjectSetPrototypeOf$1(Transform$1, Duplex$3);
	var kCallback = Symbol$3("kCallback");
	function Transform$1(options) {
		if (!(this instanceof Transform$1)) return new Transform$1(options);
		const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
		if (readableHighWaterMark === 0) options = {
			...options,
			highWaterMark: null,
			readableHighWaterMark,
			writableHighWaterMark: options.writableHighWaterMark || 0
		};
		Duplex$3.call(this, options);
		this._readableState.sync = false;
		this[kCallback] = null;
		if (options) {
			if (typeof options.transform === "function") this._transform = options.transform;
			if (typeof options.flush === "function") this._flush = options.flush;
		}
		this.on("prefinish", prefinish);
	}
	function final(cb) {
		if (typeof this._flush === "function" && !this.destroyed) this._flush((er, data) => {
			if (er) {
				if (cb) cb(er);
				else this.destroy(er);
				return;
			}
			if (data != null) this.push(data);
			this.push(null);
			if (cb) cb();
		});
		else {
			this.push(null);
			if (cb) cb();
		}
	}
	function prefinish() {
		if (this._final !== final) final.call(this);
	}
	Transform$1.prototype._final = final;
	Transform$1.prototype._transform = function(chunk, encoding, callback) {
		throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
	};
	Transform$1.prototype._write = function(chunk, encoding, callback) {
		const rState = this._readableState;
		const wState = this._writableState;
		const length = rState.length;
		this._transform(chunk, encoding, (err, val) => {
			if (err) {
				callback(err);
				return;
			}
			if (val != null) this.push(val);
			if (wState.ended || length === rState.length || rState.length < rState.highWaterMark) callback();
			else this[kCallback] = callback;
		});
	};
	Transform$1.prototype._read = function() {
		if (this[kCallback]) {
			const callback = this[kCallback];
			this[kCallback] = null;
			callback();
		}
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/passthrough.js": ((exports, module) => {
	var { ObjectSetPrototypeOf } = require_primordials();
	module.exports = PassThrough$1;
	var Transform = require_transform();
	ObjectSetPrototypeOf(PassThrough$1.prototype, Transform.prototype);
	ObjectSetPrototypeOf(PassThrough$1, Transform);
	function PassThrough$1(options) {
		if (!(this instanceof PassThrough$1)) return new PassThrough$1(options);
		Transform.call(this, options);
	}
	PassThrough$1.prototype._transform = function(chunk, encoding, cb) {
		cb(null, chunk);
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/pipeline.js": ((exports, module) => {
	var process$1 = require_browser$1();
	var { ArrayIsArray, Promise: Promise$3, SymbolAsyncIterator, SymbolDispose } = require_primordials();
	var eos$5 = require_end_of_stream$1();
	var { once: once$4 } = require_util();
	var destroyImpl = require_destroy();
	var Duplex$2 = require_duplex();
	var { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$1, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS: ERR_MISSING_ARGS$2, ERR_STREAM_DESTROYED, ERR_STREAM_PREMATURE_CLOSE }, AbortError: AbortError$2 } = require_errors$1();
	var { validateFunction, validateAbortSignal: validateAbortSignal$1 } = require_validators();
	var { isIterable: isIterable$1, isReadable: isReadable$1, isReadableNodeStream, isNodeStream: isNodeStream$3, isTransformStream: isTransformStream$1, isWebStream: isWebStream$2, isReadableStream: isReadableStream$2, isReadableFinished } = require_utils$1();
	var AbortController$1 = globalThis.AbortController || require_browser$2().AbortController;
	var PassThrough;
	var Readable;
	var addAbortListener;
	function destroyer$3(stream, reading, writing) {
		let finished$3 = false;
		stream.on("close", () => {
			finished$3 = true;
		});
		return {
			destroy: (err) => {
				if (finished$3) return;
				finished$3 = true;
				destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
			},
			cleanup: eos$5(stream, {
				readable: reading,
				writable: writing
			}, (err) => {
				finished$3 = !err;
			})
		};
	}
	function popCallback(streams) {
		validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
		return streams.pop();
	}
	function makeAsyncIterable(val) {
		if (isIterable$1(val)) return val;
		else if (isReadableNodeStream(val)) return fromReadable(val);
		throw new ERR_INVALID_ARG_TYPE$1("val", [
			"Readable",
			"Iterable",
			"AsyncIterable"
		], val);
	}
	async function* fromReadable(val) {
		if (!Readable) Readable = require_readable();
		yield* Readable.prototype[SymbolAsyncIterator].call(val);
	}
	async function pumpToNode(iterable, writable, finish$1, { end }) {
		let error$1;
		let onresolve = null;
		const resume$1 = (err) => {
			if (err) error$1 = err;
			if (onresolve) {
				const callback = onresolve;
				onresolve = null;
				callback();
			}
		};
		const wait = () => new Promise$3((resolve, reject) => {
			if (error$1) reject(error$1);
			else onresolve = () => {
				if (error$1) reject(error$1);
				else resolve();
			};
		});
		writable.on("drain", resume$1);
		const cleanup = eos$5(writable, { readable: false }, resume$1);
		try {
			if (writable.writableNeedDrain) await wait();
			for await (const chunk of iterable) if (!writable.write(chunk)) await wait();
			if (end) {
				writable.end();
				await wait();
			}
			finish$1();
		} catch (err) {
			finish$1(error$1 !== err ? aggregateTwoErrors(error$1, err) : err);
		} finally {
			cleanup();
			writable.off("drain", resume$1);
		}
	}
	async function pumpToWeb(readable, writable, finish$1, { end }) {
		if (isTransformStream$1(writable)) writable = writable.writable;
		const writer = writable.getWriter();
		try {
			for await (const chunk of readable) {
				await writer.ready;
				writer.write(chunk).catch(() => {});
			}
			await writer.ready;
			if (end) await writer.close();
			finish$1();
		} catch (err) {
			try {
				await writer.abort(err);
				finish$1(err);
			} catch (err$1) {
				finish$1(err$1);
			}
		}
	}
	function pipeline$3(...streams) {
		return pipelineImpl(streams, once$4(popCallback(streams)));
	}
	function pipelineImpl(streams, callback, opts) {
		if (streams.length === 1 && ArrayIsArray(streams[0])) streams = streams[0];
		if (streams.length < 2) throw new ERR_MISSING_ARGS$2("streams");
		const ac = new AbortController$1();
		const signal = ac.signal;
		const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
		const lastStreamCleanup = [];
		validateAbortSignal$1(outerSignal, "options.signal");
		function abort() {
			finishImpl(new AbortError$2());
		}
		addAbortListener = addAbortListener || require_util().addAbortListener;
		let disposable;
		if (outerSignal) disposable = addAbortListener(outerSignal, abort);
		let error$1;
		let value$2;
		const destroys = [];
		let finishCount = 0;
		function finish$1(err) {
			finishImpl(err, --finishCount === 0);
		}
		function finishImpl(err, final$1) {
			var _disposable;
			if (err && (!error$1 || error$1.code === "ERR_STREAM_PREMATURE_CLOSE")) error$1 = err;
			if (!error$1 && !final$1) return;
			while (destroys.length) destroys.shift()(error$1);
			(_disposable = disposable) === null || _disposable === void 0 || _disposable[SymbolDispose]();
			ac.abort();
			if (final$1) {
				if (!error$1) lastStreamCleanup.forEach((fn) => fn());
				process$1.nextTick(callback, error$1, value$2);
			}
		}
		let ret;
		for (let i = 0; i < streams.length; i++) {
			const stream = streams[i];
			const reading = i < streams.length - 1;
			const writing = i > 0;
			const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
			const isLastStream = i === streams.length - 1;
			if (isNodeStream$3(stream)) {
				if (end) {
					const { destroy: destroy$2, cleanup } = destroyer$3(stream, reading, writing);
					destroys.push(destroy$2);
					if (isReadable$1(stream) && isLastStream) lastStreamCleanup.push(cleanup);
				}
				function onError(err) {
					if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") finish$1(err);
				}
				stream.on("error", onError);
				if (isReadable$1(stream) && isLastStream) lastStreamCleanup.push(() => {
					stream.removeListener("error", onError);
				});
			}
			if (i === 0) if (typeof stream === "function") {
				ret = stream({ signal });
				if (!isIterable$1(ret)) throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
			} else if (isIterable$1(stream) || isReadableNodeStream(stream) || isTransformStream$1(stream)) ret = stream;
			else ret = Duplex$2.from(stream);
			else if (typeof stream === "function") {
				if (isTransformStream$1(ret)) {
					var _ret;
					ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
				} else ret = makeAsyncIterable(ret);
				ret = stream(ret, { signal });
				if (reading) {
					if (!isIterable$1(ret, true)) throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
				} else {
					var _ret2;
					if (!PassThrough) PassThrough = require_passthrough();
					const pt = new PassThrough({ objectMode: true });
					const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
					if (typeof then === "function") {
						finishCount++;
						then.call(ret, (val) => {
							value$2 = val;
							if (val != null) pt.write(val);
							if (end) pt.end();
							process$1.nextTick(finish$1);
						}, (err) => {
							pt.destroy(err);
							process$1.nextTick(finish$1, err);
						});
					} else if (isIterable$1(ret, true)) {
						finishCount++;
						pumpToNode(ret, pt, finish$1, { end });
					} else if (isReadableStream$2(ret) || isTransformStream$1(ret)) {
						const toRead = ret.readable || ret;
						finishCount++;
						pumpToNode(toRead, pt, finish$1, { end });
					} else throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
					ret = pt;
					const { destroy: destroy$2, cleanup } = destroyer$3(ret, false, true);
					destroys.push(destroy$2);
					if (isLastStream) lastStreamCleanup.push(cleanup);
				}
			} else if (isNodeStream$3(stream)) {
				if (isReadableNodeStream(ret)) {
					finishCount += 2;
					const cleanup = pipe$1(ret, stream, finish$1, { end });
					if (isReadable$1(stream) && isLastStream) lastStreamCleanup.push(cleanup);
				} else if (isTransformStream$1(ret) || isReadableStream$2(ret)) {
					const toRead = ret.readable || ret;
					finishCount++;
					pumpToNode(toRead, stream, finish$1, { end });
				} else if (isIterable$1(ret)) {
					finishCount++;
					pumpToNode(ret, stream, finish$1, { end });
				} else throw new ERR_INVALID_ARG_TYPE$1("val", [
					"Readable",
					"Iterable",
					"AsyncIterable",
					"ReadableStream",
					"TransformStream"
				], ret);
				ret = stream;
			} else if (isWebStream$2(stream)) {
				if (isReadableNodeStream(ret)) {
					finishCount++;
					pumpToWeb(makeAsyncIterable(ret), stream, finish$1, { end });
				} else if (isReadableStream$2(ret) || isIterable$1(ret)) {
					finishCount++;
					pumpToWeb(ret, stream, finish$1, { end });
				} else if (isTransformStream$1(ret)) {
					finishCount++;
					pumpToWeb(ret.readable, stream, finish$1, { end });
				} else throw new ERR_INVALID_ARG_TYPE$1("val", [
					"Readable",
					"Iterable",
					"AsyncIterable",
					"ReadableStream",
					"TransformStream"
				], ret);
				ret = stream;
			} else ret = Duplex$2.from(stream);
		}
		if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) process$1.nextTick(abort);
		return ret;
	}
	function pipe$1(src, dst, finish$1, { end }) {
		let ended = false;
		dst.on("close", () => {
			if (!ended) finish$1(new ERR_STREAM_PREMATURE_CLOSE());
		});
		src.pipe(dst, { end: false });
		if (end) {
			function endFn() {
				ended = true;
				dst.end();
			}
			if (isReadableFinished(src)) process$1.nextTick(endFn);
			else src.once("end", endFn);
		} else finish$1();
		eos$5(src, {
			readable: true,
			writable: false
		}, (err) => {
			const rState = src._readableState;
			if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) src.once("end", finish$1).once("error", finish$1);
			else finish$1(err);
		});
		return eos$5(dst, {
			readable: false,
			writable: true
		}, finish$1);
	}
	module.exports = {
		pipelineImpl,
		pipeline: pipeline$3
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/compose.js": ((exports, module) => {
	var { pipeline: pipeline$2 } = require_pipeline();
	var Duplex$1 = require_duplex();
	var { destroyer: destroyer$2 } = require_destroy();
	var { isNodeStream: isNodeStream$2, isReadable, isWritable: isWritable$1, isWebStream: isWebStream$1, isTransformStream, isWritableStream: isWritableStream$1, isReadableStream: isReadableStream$1 } = require_utils$1();
	var { AbortError: AbortError$1, codes: { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE$1, ERR_MISSING_ARGS: ERR_MISSING_ARGS$1 } } = require_errors$1();
	var eos$4 = require_end_of_stream$1();
	module.exports = function compose$2(...streams) {
		if (streams.length === 0) throw new ERR_MISSING_ARGS$1("streams");
		if (streams.length === 1) return Duplex$1.from(streams[0]);
		const orgStreams = [...streams];
		if (typeof streams[0] === "function") streams[0] = Duplex$1.from(streams[0]);
		if (typeof streams[streams.length - 1] === "function") {
			const idx = streams.length - 1;
			streams[idx] = Duplex$1.from(streams[idx]);
		}
		for (let n = 0; n < streams.length; ++n) {
			if (!isNodeStream$2(streams[n]) && !isWebStream$1(streams[n])) continue;
			if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream$1(streams[n]) || isTransformStream(streams[n]))) throw new ERR_INVALID_ARG_VALUE$1(`streams[${n}]`, orgStreams[n], "must be readable");
			if (n > 0 && !(isWritable$1(streams[n]) || isWritableStream$1(streams[n]) || isTransformStream(streams[n]))) throw new ERR_INVALID_ARG_VALUE$1(`streams[${n}]`, orgStreams[n], "must be writable");
		}
		let ondrain;
		let onfinish;
		let onreadable;
		let onclose;
		let d;
		function onfinished(err) {
			const cb = onclose;
			onclose = null;
			if (cb) cb(err);
			else if (err) d.destroy(err);
			else if (!readable && !writable) d.destroy();
		}
		const head = streams[0];
		const tail = pipeline$2(streams, onfinished);
		const writable = !!(isWritable$1(head) || isWritableStream$1(head) || isTransformStream(head));
		const readable = !!(isReadable(tail) || isReadableStream$1(tail) || isTransformStream(tail));
		d = new Duplex$1({
			writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
			readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
			writable,
			readable
		});
		if (writable) {
			if (isNodeStream$2(head)) {
				d._write = function(chunk, encoding, callback) {
					if (head.write(chunk, encoding)) callback();
					else ondrain = callback;
				};
				d._final = function(callback) {
					head.end();
					onfinish = callback;
				};
				head.on("drain", function() {
					if (ondrain) {
						const cb = ondrain;
						ondrain = null;
						cb();
					}
				});
			} else if (isWebStream$1(head)) {
				const writer = (isTransformStream(head) ? head.writable : head).getWriter();
				d._write = async function(chunk, encoding, callback) {
					try {
						await writer.ready;
						writer.write(chunk).catch(() => {});
						callback();
					} catch (err) {
						callback(err);
					}
				};
				d._final = async function(callback) {
					try {
						await writer.ready;
						writer.close().catch(() => {});
						onfinish = callback;
					} catch (err) {
						callback(err);
					}
				};
			}
			eos$4(isTransformStream(tail) ? tail.readable : tail, () => {
				if (onfinish) {
					const cb = onfinish;
					onfinish = null;
					cb();
				}
			});
		}
		if (readable) {
			if (isNodeStream$2(tail)) {
				tail.on("readable", function() {
					if (onreadable) {
						const cb = onreadable;
						onreadable = null;
						cb();
					}
				});
				tail.on("end", function() {
					d.push(null);
				});
				d._read = function() {
					while (true) {
						const buf = tail.read();
						if (buf === null) {
							onreadable = d._read;
							return;
						}
						if (!d.push(buf)) return;
					}
				};
			} else if (isWebStream$1(tail)) {
				const reader = (isTransformStream(tail) ? tail.readable : tail).getReader();
				d._read = async function() {
					while (true) try {
						const { value: value$2, done } = await reader.read();
						if (!d.push(value$2)) return;
						if (done) {
							d.push(null);
							return;
						}
					} catch {
						return;
					}
				};
			}
		}
		d._destroy = function(err, callback) {
			if (!err && onclose !== null) err = new AbortError$1();
			onreadable = null;
			ondrain = null;
			onfinish = null;
			if (onclose === null) callback(err);
			else {
				onclose = callback;
				if (isNodeStream$2(tail)) destroyer$2(tail, err);
			}
		};
		return d;
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/internal/streams/operators.js": ((exports, module) => {
	var AbortController = globalThis.AbortController || require_browser$2().AbortController;
	var { codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE }, AbortError } = require_errors$1();
	var { validateAbortSignal, validateInteger, validateObject: validateObject$1 } = require_validators();
	var kWeakHandler = require_primordials().Symbol("kWeak");
	var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
	var { finished: finished$1 } = require_end_of_stream$1();
	var staticCompose = require_compose();
	var { addAbortSignalNoValidate } = require_add_abort_signal();
	var { isWritable, isNodeStream: isNodeStream$1 } = require_utils$1();
	var { deprecate } = require_util();
	var { ArrayPrototypePush, Boolean: Boolean$1, MathFloor, Number: Number$1, NumberIsNaN, Promise: Promise$2, PromiseReject, PromiseResolve, PromisePrototypeThen, Symbol: Symbol$2 } = require_primordials();
	var kEmpty = Symbol$2("kEmpty");
	var kEof = Symbol$2("kEof");
	function compose$1(stream, options) {
		if (options != null) validateObject$1(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		if (isNodeStream$1(stream) && !isWritable(stream)) throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
		const composedStream = staticCompose(this, stream);
		if (options !== null && options !== void 0 && options.signal) addAbortSignalNoValidate(options.signal, composedStream);
		return composedStream;
	}
	function map(fn, options) {
		if (typeof fn !== "function") throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
		if (options != null) validateObject$1(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		let concurrency = 1;
		if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) concurrency = MathFloor(options.concurrency);
		let highWaterMark = concurrency - 1;
		if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) highWaterMark = MathFloor(options.highWaterMark);
		validateInteger(concurrency, "options.concurrency", 1);
		validateInteger(highWaterMark, "options.highWaterMark", 0);
		highWaterMark += concurrency;
		return async function* map$1() {
			const signal = require_util().AbortSignalAny([options === null || options === void 0 ? void 0 : options.signal].filter(Boolean$1));
			const stream = this;
			const queue$1 = [];
			const signalOpt = { signal };
			let next$1;
			let resume$1;
			let done = false;
			let cnt = 0;
			function onCatch() {
				done = true;
				afterItemProcessed();
			}
			function afterItemProcessed() {
				cnt -= 1;
				maybeResume();
			}
			function maybeResume() {
				if (resume$1 && !done && cnt < concurrency && queue$1.length < highWaterMark) {
					resume$1();
					resume$1 = null;
				}
			}
			async function pump$3() {
				try {
					for await (let val of stream) {
						if (done) return;
						if (signal.aborted) throw new AbortError();
						try {
							val = fn(val, signalOpt);
							if (val === kEmpty) continue;
							val = PromiseResolve(val);
						} catch (err) {
							val = PromiseReject(err);
						}
						cnt += 1;
						PromisePrototypeThen(val, afterItemProcessed, onCatch);
						queue$1.push(val);
						if (next$1) {
							next$1();
							next$1 = null;
						}
						if (!done && (queue$1.length >= highWaterMark || cnt >= concurrency)) await new Promise$2((resolve) => {
							resume$1 = resolve;
						});
					}
					queue$1.push(kEof);
				} catch (err) {
					const val = PromiseReject(err);
					PromisePrototypeThen(val, afterItemProcessed, onCatch);
					queue$1.push(val);
				} finally {
					done = true;
					if (next$1) {
						next$1();
						next$1 = null;
					}
				}
			}
			pump$3();
			try {
				while (true) {
					while (queue$1.length > 0) {
						const val = await queue$1[0];
						if (val === kEof) return;
						if (signal.aborted) throw new AbortError();
						if (val !== kEmpty) yield val;
						queue$1.shift();
						maybeResume();
					}
					await new Promise$2((resolve) => {
						next$1 = resolve;
					});
				}
			} finally {
				done = true;
				if (resume$1) {
					resume$1();
					resume$1 = null;
				}
			}
		}.call(this);
	}
	function asIndexedPairs(options = void 0) {
		if (options != null) validateObject$1(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		return async function* asIndexedPairs$1() {
			let index = 0;
			for await (const val of this) {
				var _options$signal;
				if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) throw new AbortError({ cause: options.signal.reason });
				yield [index++, val];
			}
		}.call(this);
	}
	async function some(fn, options = void 0) {
		for await (const unused of filter.call(this, fn, options)) return true;
		return false;
	}
	async function every(fn, options = void 0) {
		if (typeof fn !== "function") throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
		return !await some.call(this, async (...args) => {
			return !await fn(...args);
		}, options);
	}
	async function find(fn, options) {
		for await (const result of filter.call(this, fn, options)) return result;
	}
	async function forEach(fn, options) {
		if (typeof fn !== "function") throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
		async function forEachFn(value$2, options$1) {
			await fn(value$2, options$1);
			return kEmpty;
		}
		for await (const unused of map.call(this, forEachFn, options));
	}
	function filter(fn, options) {
		if (typeof fn !== "function") throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
		async function filterFn(value$2, options$1) {
			if (await fn(value$2, options$1)) return value$2;
			return kEmpty;
		}
		return map.call(this, filterFn, options);
	}
	var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
		constructor() {
			super("reduce");
			this.message = "Reduce of an empty stream requires an initial value";
		}
	};
	async function reduce(reducer, initialValue, options) {
		var _options$signal2;
		if (typeof reducer !== "function") throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
		if (options != null) validateObject$1(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		let hasInitialValue = arguments.length > 1;
		if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
			const err = new AbortError(void 0, { cause: options.signal.reason });
			this.once("error", () => {});
			await finished$1(this.destroy(err));
			throw err;
		}
		const ac = new AbortController();
		const signal = ac.signal;
		if (options !== null && options !== void 0 && options.signal) {
			const opts = {
				once: true,
				[kWeakHandler]: this,
				[kResistStopPropagation]: true
			};
			options.signal.addEventListener("abort", () => ac.abort(), opts);
		}
		let gotAnyItemFromStream = false;
		try {
			for await (const value$2 of this) {
				var _options$signal3;
				gotAnyItemFromStream = true;
				if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) throw new AbortError();
				if (!hasInitialValue) {
					initialValue = value$2;
					hasInitialValue = true;
				} else initialValue = await reducer(initialValue, value$2, { signal });
			}
			if (!gotAnyItemFromStream && !hasInitialValue) throw new ReduceAwareErrMissingArgs();
		} finally {
			ac.abort();
		}
		return initialValue;
	}
	async function toArray$1(options) {
		if (options != null) validateObject$1(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		const result = [];
		for await (const val of this) {
			var _options$signal4;
			if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) throw new AbortError(void 0, { cause: options.signal.reason });
			ArrayPrototypePush(result, val);
		}
		return result;
	}
	function flatMap(fn, options) {
		const values = map.call(this, fn, options);
		return async function* flatMap$1() {
			for await (const val of values) yield* val;
		}.call(this);
	}
	function toIntegerOrInfinity(number$2) {
		number$2 = Number$1(number$2);
		if (NumberIsNaN(number$2)) return 0;
		if (number$2 < 0) throw new ERR_OUT_OF_RANGE("number", ">= 0", number$2);
		return number$2;
	}
	function drop(number$2, options = void 0) {
		if (options != null) validateObject$1(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		number$2 = toIntegerOrInfinity(number$2);
		return async function* drop$1() {
			var _options$signal5;
			if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) throw new AbortError();
			for await (const val of this) {
				var _options$signal6;
				if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) throw new AbortError();
				if (number$2-- <= 0) yield val;
			}
		}.call(this);
	}
	function take(number$2, options = void 0) {
		if (options != null) validateObject$1(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		number$2 = toIntegerOrInfinity(number$2);
		return async function* take$1() {
			var _options$signal7;
			if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) throw new AbortError();
			for await (const val of this) {
				var _options$signal8;
				if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) throw new AbortError();
				if (number$2-- > 0) yield val;
				if (number$2 <= 0) return;
			}
		}.call(this);
	}
	module.exports.streamReturningOperators = {
		asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
		drop,
		filter,
		flatMap,
		map,
		take,
		compose: compose$1
	};
	module.exports.promiseReturningOperators = {
		every,
		forEach,
		reduce,
		toArray: toArray$1,
		some,
		find
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/stream/promises.js
var require_promises = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/stream/promises.js": ((exports, module) => {
	var { ArrayPrototypePop, Promise: Promise$1 } = require_primordials();
	var { isIterable, isNodeStream, isWebStream } = require_utils$1();
	var { pipelineImpl: pl } = require_pipeline();
	var { finished } = require_end_of_stream$1();
	require_stream();
	function pipeline$1(...streams) {
		return new Promise$1((resolve, reject) => {
			let signal;
			let end;
			const lastArg = streams[streams.length - 1];
			if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
				const options = ArrayPrototypePop(streams);
				signal = options.signal;
				end = options.end;
			}
			pl(streams, (err, value$2) => {
				if (err) reject(err);
				else resolve(value$2);
			}, {
				signal,
				end
			});
		});
	}
	module.exports = {
		finished,
		pipeline: pipeline$1
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/stream.js
var require_stream = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/stream.js": ((exports, module) => {
	var { Buffer: Buffer$2 } = require_buffer();
	var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
	var { promisify: { custom: customPromisify } } = require_util();
	var { streamReturningOperators, promiseReturningOperators } = require_operators();
	var { codes: { ERR_ILLEGAL_CONSTRUCTOR } } = require_errors$1();
	var compose = require_compose();
	var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
	var { pipeline } = require_pipeline();
	var { destroyer: destroyer$1 } = require_destroy();
	var eos$3 = require_end_of_stream$1();
	var promises$1 = require_promises();
	var utils = require_utils$1();
	var Stream = module.exports = require_legacy().Stream;
	Stream.isDestroyed = utils.isDestroyed;
	Stream.isDisturbed = utils.isDisturbed;
	Stream.isErrored = utils.isErrored;
	Stream.isReadable = utils.isReadable;
	Stream.isWritable = utils.isWritable;
	Stream.Readable = require_readable();
	for (const key of ObjectKeys(streamReturningOperators)) {
		const op = streamReturningOperators[key];
		function fn(...args) {
			if (new.target) throw ERR_ILLEGAL_CONSTRUCTOR();
			return Stream.Readable.from(ReflectApply(op, this, args));
		}
		ObjectDefineProperty(fn, "name", {
			__proto__: null,
			value: op.name
		});
		ObjectDefineProperty(fn, "length", {
			__proto__: null,
			value: op.length
		});
		ObjectDefineProperty(Stream.Readable.prototype, key, {
			__proto__: null,
			value: fn,
			enumerable: false,
			configurable: true,
			writable: true
		});
	}
	for (const key of ObjectKeys(promiseReturningOperators)) {
		const op = promiseReturningOperators[key];
		function fn(...args) {
			if (new.target) throw ERR_ILLEGAL_CONSTRUCTOR();
			return ReflectApply(op, this, args);
		}
		ObjectDefineProperty(fn, "name", {
			__proto__: null,
			value: op.name
		});
		ObjectDefineProperty(fn, "length", {
			__proto__: null,
			value: op.length
		});
		ObjectDefineProperty(Stream.Readable.prototype, key, {
			__proto__: null,
			value: fn,
			enumerable: false,
			configurable: true,
			writable: true
		});
	}
	Stream.Writable = require_writable();
	Stream.Duplex = require_duplex();
	Stream.Transform = require_transform();
	Stream.PassThrough = require_passthrough();
	Stream.pipeline = pipeline;
	var { addAbortSignal } = require_add_abort_signal();
	Stream.addAbortSignal = addAbortSignal;
	Stream.finished = eos$3;
	Stream.destroy = destroyer$1;
	Stream.compose = compose;
	Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
	Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
	ObjectDefineProperty(Stream, "promises", {
		__proto__: null,
		configurable: true,
		enumerable: true,
		get() {
			return promises$1;
		}
	});
	ObjectDefineProperty(pipeline, customPromisify, {
		__proto__: null,
		enumerable: true,
		get() {
			return promises$1.pipeline;
		}
	});
	ObjectDefineProperty(eos$3, customPromisify, {
		__proto__: null,
		enumerable: true,
		get() {
			return promises$1.finished;
		}
	});
	Stream.Stream = Stream;
	Stream._isUint8Array = function isUint8Array(value$2) {
		return value$2 instanceof Uint8Array;
	};
	Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
		return Buffer$2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
	};
}) });

//#endregion
//#region node_modules/readable-stream/lib/ours/browser.js
var require_browser = /* @__PURE__ */ __commonJS({ "node_modules/readable-stream/lib/ours/browser.js": ((exports, module) => {
	var CustomStream = require_stream();
	var promises = require_promises();
	var originalDestroy = CustomStream.Readable.destroy;
	module.exports = CustomStream.Readable;
	module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
	module.exports._isUint8Array = CustomStream._isUint8Array;
	module.exports.isDisturbed = CustomStream.isDisturbed;
	module.exports.isErrored = CustomStream.isErrored;
	module.exports.isReadable = CustomStream.isReadable;
	module.exports.Readable = CustomStream.Readable;
	module.exports.Writable = CustomStream.Writable;
	module.exports.Duplex = CustomStream.Duplex;
	module.exports.Transform = CustomStream.Transform;
	module.exports.PassThrough = CustomStream.PassThrough;
	module.exports.addAbortSignal = CustomStream.addAbortSignal;
	module.exports.finished = CustomStream.finished;
	module.exports.destroy = CustomStream.destroy;
	module.exports.destroy = originalDestroy;
	module.exports.pipeline = CustomStream.pipeline;
	module.exports.compose = CustomStream.compose;
	Object.defineProperty(CustomStream, "promises", {
		configurable: true,
		enumerable: true,
		get() {
			return promises;
		}
	});
	module.exports.Stream = CustomStream.Stream;
	module.exports.default = module.exports;
}) });

//#endregion
//#region node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = /* @__PURE__ */ __commonJS({ "node_modules/fast-safe-stringify/index.js": ((exports, module) => {
	module.exports = stringify$1;
	stringify$1.default = stringify$1;
	stringify$1.stable = deterministicStringify;
	stringify$1.stableStringify = deterministicStringify;
	var LIMIT_REPLACE_NODE = "[...]";
	var CIRCULAR_REPLACE_NODE = "[Circular]";
	var arr = [];
	var replacerStack = [];
	function defaultOptions() {
		return {
			depthLimit: Number.MAX_SAFE_INTEGER,
			edgesLimit: Number.MAX_SAFE_INTEGER
		};
	}
	function stringify$1(obj, replacer, spacer, options) {
		if (typeof options === "undefined") options = defaultOptions();
		decirc(obj, "", 0, [], void 0, 0, options);
		var res;
		try {
			if (replacerStack.length === 0) res = JSON.stringify(obj, replacer, spacer);
			else res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
		} catch (_) {
			return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
		} finally {
			while (arr.length !== 0) {
				var part = arr.pop();
				if (part.length === 4) Object.defineProperty(part[0], part[1], part[3]);
				else part[0][part[1]] = part[2];
			}
		}
		return res;
	}
	function setReplace(replace, val, k, parent) {
		var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
		if (propertyDescriptor.get !== void 0) if (propertyDescriptor.configurable) {
			Object.defineProperty(parent, k, { value: replace });
			arr.push([
				parent,
				k,
				val,
				propertyDescriptor
			]);
		} else replacerStack.push([
			val,
			k,
			replace
		]);
		else {
			parent[k] = replace;
			arr.push([
				parent,
				k,
				val
			]);
		}
	}
	function decirc(val, k, edgeIndex, stack, parent, depth, options) {
		depth += 1;
		var i;
		if (typeof val === "object" && val !== null) {
			for (i = 0; i < stack.length; i++) if (stack[i] === val) {
				setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
				return;
			}
			if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
				setReplace(LIMIT_REPLACE_NODE, val, k, parent);
				return;
			}
			if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
				setReplace(LIMIT_REPLACE_NODE, val, k, parent);
				return;
			}
			stack.push(val);
			if (Array.isArray(val)) for (i = 0; i < val.length; i++) decirc(val[i], i, i, stack, val, depth, options);
			else {
				var keys = Object.keys(val);
				for (i = 0; i < keys.length; i++) {
					var key = keys[i];
					decirc(val[key], key, i, stack, val, depth, options);
				}
			}
			stack.pop();
		}
	}
	function compareFunction(a, b) {
		if (a < b) return -1;
		if (a > b) return 1;
		return 0;
	}
	function deterministicStringify(obj, replacer, spacer, options) {
		if (typeof options === "undefined") options = defaultOptions();
		var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
		var res;
		try {
			if (replacerStack.length === 0) res = JSON.stringify(tmp, replacer, spacer);
			else res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
		} catch (_) {
			return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
		} finally {
			while (arr.length !== 0) {
				var part = arr.pop();
				if (part.length === 4) Object.defineProperty(part[0], part[1], part[3]);
				else part[0][part[1]] = part[2];
			}
		}
		return res;
	}
	function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
		depth += 1;
		var i;
		if (typeof val === "object" && val !== null) {
			for (i = 0; i < stack.length; i++) if (stack[i] === val) {
				setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
				return;
			}
			try {
				if (typeof val.toJSON === "function") return;
			} catch (_) {
				return;
			}
			if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
				setReplace(LIMIT_REPLACE_NODE, val, k, parent);
				return;
			}
			if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
				setReplace(LIMIT_REPLACE_NODE, val, k, parent);
				return;
			}
			stack.push(val);
			if (Array.isArray(val)) for (i = 0; i < val.length; i++) deterministicDecirc(val[i], i, i, stack, val, depth, options);
			else {
				var tmp = {};
				var keys = Object.keys(val).sort(compareFunction);
				for (i = 0; i < keys.length; i++) {
					var key = keys[i];
					deterministicDecirc(val[key], key, i, stack, val, depth, options);
					tmp[key] = val[key];
				}
				if (typeof parent !== "undefined") {
					arr.push([
						parent,
						k,
						val
					]);
					parent[k] = tmp;
				} else return tmp;
			}
			stack.pop();
		}
	}
	function replaceGetterValues(replacer) {
		replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
			return v;
		};
		return function(key, val) {
			if (replacerStack.length > 0) for (var i = 0; i < replacerStack.length; i++) {
				var part = replacerStack[i];
				if (part[1] === key && part[0] === val) {
					val = part[2];
					replacerStack.splice(i, 1);
					break;
				}
			}
			return replacer.call(this, key, val);
		};
	}
}) });

//#endregion
//#region node_modules/wrappy/wrappy.js
var require_wrappy = /* @__PURE__ */ __commonJS({ "node_modules/wrappy/wrappy.js": ((exports, module) => {
	module.exports = wrappy$1;
	function wrappy$1(fn, cb) {
		if (fn && cb) return wrappy$1(fn)(cb);
		if (typeof fn !== "function") throw new TypeError("need wrapper function");
		Object.keys(fn).forEach(function(k) {
			wrapper[k] = fn[k];
		});
		return wrapper;
		function wrapper() {
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			var ret = fn.apply(this, args);
			var cb$1 = args[args.length - 1];
			if (typeof ret === "function" && ret !== cb$1) Object.keys(cb$1).forEach(function(k) {
				ret[k] = cb$1[k];
			});
			return ret;
		}
	}
}) });

//#endregion
//#region node_modules/once/once.js
var require_once = /* @__PURE__ */ __commonJS({ "node_modules/once/once.js": ((exports, module) => {
	var wrappy = require_wrappy();
	module.exports = wrappy(once$3);
	module.exports.strict = wrappy(onceStrict);
	once$3.proto = once$3(function() {
		Object.defineProperty(Function.prototype, "once", {
			value: function() {
				return once$3(this);
			},
			configurable: true
		});
		Object.defineProperty(Function.prototype, "onceStrict", {
			value: function() {
				return onceStrict(this);
			},
			configurable: true
		});
	});
	function once$3(fn) {
		var f = function() {
			if (f.called) return f.value;
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.called = false;
		return f;
	}
	function onceStrict(fn) {
		var f = function() {
			if (f.called) throw new Error(f.onceError);
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.onceError = (fn.name || "Function wrapped with `once`") + " shouldn't be called more than once";
		f.called = false;
		return f;
	}
}) });

//#endregion
//#region node_modules/end-of-stream/index.js
var require_end_of_stream = /* @__PURE__ */ __commonJS({ "node_modules/end-of-stream/index.js": ((exports, module) => {
	var once$2 = require_once();
	var noop$2 = function() {};
	var qnt = global.Bare ? queueMicrotask : process.nextTick.bind(process);
	var isRequest$1 = function(stream) {
		return stream.setHeader && typeof stream.abort === "function";
	};
	var isChildProcess = function(stream) {
		return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
	};
	var eos$2 = function(stream, opts, callback) {
		if (typeof opts === "function") return eos$2(stream, null, opts);
		if (!opts) opts = {};
		callback = once$2(callback || noop$2);
		var ws = stream._writableState;
		var rs = stream._readableState;
		var readable = opts.readable || opts.readable !== false && stream.readable;
		var writable = opts.writable || opts.writable !== false && stream.writable;
		var cancelled = false;
		var onlegacyfinish = function() {
			if (!stream.writable) onfinish();
		};
		var onfinish = function() {
			writable = false;
			if (!readable) callback.call(stream);
		};
		var onend = function() {
			readable = false;
			if (!writable) callback.call(stream);
		};
		var onexit = function(exitCode) {
			callback.call(stream, exitCode ? /* @__PURE__ */ new Error("exited with error code: " + exitCode) : null);
		};
		var onerror = function(err) {
			callback.call(stream, err);
		};
		var onclose = function() {
			qnt(onclosenexttick);
		};
		var onclosenexttick = function() {
			if (cancelled) return;
			if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, /* @__PURE__ */ new Error("premature close"));
			if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, /* @__PURE__ */ new Error("premature close"));
		};
		var onrequest = function() {
			stream.req.on("finish", onfinish);
		};
		if (isRequest$1(stream)) {
			stream.on("complete", onfinish);
			stream.on("abort", onclose);
			if (stream.req) onrequest();
			else stream.on("request", onrequest);
		} else if (writable && !ws) {
			stream.on("end", onlegacyfinish);
			stream.on("close", onlegacyfinish);
		}
		if (isChildProcess(stream)) stream.on("exit", onexit);
		stream.on("end", onend);
		stream.on("finish", onfinish);
		if (opts.error !== false) stream.on("error", onerror);
		stream.on("close", onclose);
		return function() {
			cancelled = true;
			stream.removeListener("complete", onfinish);
			stream.removeListener("abort", onclose);
			stream.removeListener("request", onrequest);
			if (stream.req) stream.req.removeListener("finish", onfinish);
			stream.removeListener("end", onlegacyfinish);
			stream.removeListener("close", onlegacyfinish);
			stream.removeListener("finish", onfinish);
			stream.removeListener("exit", onexit);
			stream.removeListener("end", onend);
			stream.removeListener("error", onerror);
			stream.removeListener("close", onclose);
		};
	};
	module.exports = eos$2;
}) });

//#endregion
//#region browser-external:fs
var require_browser_external_fs = /* @__PURE__ */ __commonJS({ "browser-external:fs": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region node_modules/pump/index.js
var require_pump = /* @__PURE__ */ __commonJS({ "node_modules/pump/index.js": ((exports, module) => {
	var once$1 = require_once();
	var eos$1 = require_end_of_stream();
	var fs;
	try {
		fs = require_browser_external_fs();
	} catch (e) {}
	var noop$1 = function() {};
	var ancient = typeof process === "undefined" ? false : /^v?\.0/.test(process.version);
	var isFn = function(fn) {
		return typeof fn === "function";
	};
	var isFS = function(stream) {
		if (!ancient) return false;
		if (!fs) return false;
		return (stream instanceof (fs.ReadStream || noop$1) || stream instanceof (fs.WriteStream || noop$1)) && isFn(stream.close);
	};
	var isRequest = function(stream) {
		return stream.setHeader && isFn(stream.abort);
	};
	var destroyer = function(stream, reading, writing, callback) {
		callback = once$1(callback);
		var closed = false;
		stream.on("close", function() {
			closed = true;
		});
		eos$1(stream, {
			readable: reading,
			writable: writing
		}, function(err) {
			if (err) return callback(err);
			closed = true;
			callback();
		});
		var destroyed = false;
		return function(err) {
			if (closed) return;
			if (destroyed) return;
			destroyed = true;
			if (isFS(stream)) return stream.close(noop$1);
			if (isRequest(stream)) return stream.abort();
			if (isFn(stream.destroy)) return stream.destroy();
			callback(err || /* @__PURE__ */ new Error("stream was destroyed"));
		};
	};
	var call = function(fn) {
		fn();
	};
	var pipe = function(from$3, to) {
		return from$3.pipe(to);
	};
	var pump$2 = function() {
		var streams = Array.prototype.slice.call(arguments);
		var callback = isFn(streams[streams.length - 1] || noop$1) && streams.pop() || noop$1;
		if (Array.isArray(streams[0])) streams = streams[0];
		if (streams.length < 2) throw new Error("pump requires two streams per minimum");
		var error$1;
		var destroys = streams.map(function(stream, i) {
			var reading = i < streams.length - 1;
			return destroyer(stream, reading, i > 0, function(err) {
				if (!error$1) error$1 = err;
				if (err) destroys.forEach(call);
				if (reading) return;
				destroys.forEach(call);
				callback(error$1);
			});
		});
		return streams.reduce(pipe);
	};
	module.exports = pump$2;
}) });

//#endregion
//#region node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js
var import_browser = require_browser();
var import_fast_safe_stringify = /* @__PURE__ */ __toESM(require_fast_safe_stringify());
var import_events$1 = require_events();
var import_end_of_stream = /* @__PURE__ */ __toESM(require_end_of_stream());
var import_once = /* @__PURE__ */ __toESM(require_once());
var import_pump$1 = /* @__PURE__ */ __toESM(require_pump());
function noop() {}
var SYN = "SYN";
var ACK = "ACK";
var BRK = "BRK";
var BasePostMessageStream = class extends import_browser.Duplex {
	constructor(_ref) {
		let { name: name$1, target, targetWindow = window, targetOrigin = "*" } = _ref;
		super({ objectMode: true });
		_defineProperty(this, "_init", void 0);
		_defineProperty(this, "_haveSyn", void 0);
		_defineProperty(this, "_name", void 0);
		_defineProperty(this, "_target", void 0);
		_defineProperty(this, "_targetWindow", void 0);
		_defineProperty(this, "_targetOrigin", void 0);
		_defineProperty(this, "_onMessage", void 0);
		_defineProperty(this, "_synIntervalId", void 0);
		if (!name$1 || !target) throw new Error("Invalid input.");
		this._init = false;
		this._haveSyn = false;
		this._name = name$1;
		this._target = target;
		this._targetWindow = targetWindow;
		this._targetOrigin = targetOrigin;
		this._onMessage = this.onMessage.bind(this);
		this._synIntervalId = null;
		window.addEventListener("message", this._onMessage, false);
		this._handShake();
	}
	_break() {
		this.cork();
		this._write(BRK, null, noop);
		this._haveSyn = false;
		this._init = false;
	}
	_handShake() {
		this._write(SYN, null, noop);
		this.cork();
	}
	_onData(data) {
		if (!this._init) {
			if (data === SYN) {
				this._haveSyn = true;
				this._write(ACK, null, noop);
			} else if (data === ACK) {
				this._init = true;
				if (!this._haveSyn) this._write(ACK, null, noop);
				this.uncork();
			}
		} else if (data === BRK) this._break();
		else try {
			this.push(data);
		} catch (err) {
			this.emit("error", err);
		}
	}
	_postMessage(data) {
		const originConstraint = this._targetOrigin;
		this._targetWindow.postMessage({
			target: this._target,
			data
		}, originConstraint);
	}
	onMessage(event) {
		const message = event.data;
		if (this._targetOrigin !== "*" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== "object" || message.target !== this._name || !message.data) return;
		this._onData(message.data);
	}
	_read() {}
	_write(data, _, cb) {
		this._postMessage(data);
		cb();
	}
	_destroy() {
		window.removeEventListener("message", this._onMessage, false);
	}
};
var errorCodes = {
	rpc: {
		invalidInput: -32e3,
		resourceNotFound: -32001,
		resourceUnavailable: -32002,
		transactionRejected: -32003,
		methodNotSupported: -32004,
		limitExceeded: -32005,
		parse: -32700,
		invalidRequest: -32600,
		methodNotFound: -32601,
		invalidParams: -32602,
		internal: -32603
	},
	provider: {
		userRejectedRequest: 4001,
		unauthorized: 4100,
		unsupportedMethod: 4200,
		disconnected: 4900,
		chainDisconnected: 4901
	}
};
var errorValues = {
	"-32700": {
		standard: "JSON RPC 2.0",
		message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
	},
	"-32600": {
		standard: "JSON RPC 2.0",
		message: "The JSON sent is not a valid Request object."
	},
	"-32601": {
		standard: "JSON RPC 2.0",
		message: "The method does not exist / is not available."
	},
	"-32602": {
		standard: "JSON RPC 2.0",
		message: "Invalid method parameter(s)."
	},
	"-32603": {
		standard: "JSON RPC 2.0",
		message: "Internal JSON-RPC error."
	},
	"-32000": {
		standard: "EIP-1474",
		message: "Invalid input."
	},
	"-32001": {
		standard: "EIP-1474",
		message: "Resource not found."
	},
	"-32002": {
		standard: "EIP-1474",
		message: "Resource unavailable."
	},
	"-32003": {
		standard: "EIP-1474",
		message: "Transaction rejected."
	},
	"-32004": {
		standard: "EIP-1474",
		message: "Method not supported."
	},
	"-32005": {
		standard: "EIP-1474",
		message: "Request limit exceeded."
	},
	"4001": {
		standard: "EIP-1193",
		message: "User rejected the request."
	},
	"4100": {
		standard: "EIP-1193",
		message: "The requested account and/or method has not been authorized by the user."
	},
	"4200": {
		standard: "EIP-1193",
		message: "The requested method is not supported by this Ethereum provider."
	},
	"4900": {
		standard: "EIP-1193",
		message: "The provider is disconnected from all chains."
	},
	"4901": {
		standard: "EIP-1193",
		message: "The provider is disconnected from the specified chain."
	}
};
var FALLBACK_ERROR_CODE$1 = errorCodes.rpc.internal;
var FALLBACK_MESSAGE$1 = "Unspecified error message. This is a bug, please report it.";
var JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
/**
* Returns whether the given code is valid.
* A code is valid if it is an integer.
*
* @param code - The error code.
* @returns Whether the given code is valid.
*/
function isValidCode$1(code) {
	return Number.isInteger(code);
}
function isValidString(value$2) {
	return typeof value$2 === "string" && value$2.length > 0;
}
/**
* A type guard for {@link RuntimeObject}.
*
* @param value - The value to check.
* @returns Whether the specified value has a runtime type of `object` and is
* neither `null` nor an `Array`.
*/
function isObject$2(value$2) {
	return Boolean(value$2) && typeof value$2 === "object" && !Array.isArray(value$2);
}
/**
* Check if the given code is a valid JSON-RPC server error code.
*
* @param code - The error code.
* @returns Whether the given code is a valid JSON-RPC server error code.
*/
function isJsonRpcServerError$1(code) {
	return code >= -32099 && code <= -32e3;
}
function isJsonRpcError(value$2) {
	const castValue = value$2;
	if (!castValue) return false;
	if (!isValidCode$1(castValue.code) || !isValidString(castValue.message)) return false;
	if (castValue.stack && !isValidString(castValue.stack)) return false;
	return true;
}
/**
* Gets the message for a given code, or a fallback message if the code has
* no corresponding message.
*
* @param code - The error code.
* @param fallbackMessage - The fallback message to use if the code has no
* corresponding message.
* @returns The message for the given code, or the fallback message if the code
* has no corresponding message.
*/
function getMessageFromCode$1(code) {
	let fallbackMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : FALLBACK_MESSAGE$1;
	if (isValidCode$1(code)) {
		const codeString = code.toString();
		if (Object.hasOwn(errorValues, codeString)) return errorValues[codeString].message;
		if (isJsonRpcServerError$1(code)) return JSON_RPC_SERVER_ERROR_MESSAGE;
	}
	return fallbackMessage;
}
var FALLBACK_ERROR$1 = {
	code: FALLBACK_ERROR_CODE$1,
	message: getMessageFromCode$1(FALLBACK_ERROR_CODE$1)
};
function isValidJson(str$1) {
	try {
		JSON.parse(JSON.stringify(str$1, (strKey, strVal) => {
			if (strKey === "__proto__" || strKey === "constructor") throw new Error("Not valid json");
			if (typeof strVal === "function" || typeof strVal === "symbol") throw new Error("Not valid json");
			return strVal;
		}), (propKey, propValue) => {
			if (propKey === "__proto__" || propKey === "constructor") return;
			return propValue;
		});
	} catch (e) {
		return false;
	}
	return true;
}
/**
* Extracts all JSON-serializable properties from an object.
*
* @param object - The object in question.
* @returns An object containing all the JSON-serializable properties.
*/
function serializeObject(object$1) {
	return Object.getOwnPropertyNames(object$1).reduce((acc, key) => {
		const value$2 = object$1[key];
		if (isValidJson(value$2)) acc[key] = value$2;
		return acc;
	}, {});
}
/**
* Serializes an unknown error to be used as the `cause` in a fallback error.
*
* @param error - The unknown error.
* @returns A JSON-serializable object containing as much information about the original error as possible.
*/
function serializeCause(error$1) {
	if (Array.isArray(error$1)) return error$1.map((entry) => {
		if (isValidJson(entry)) return entry;
		else if (isObject$2(entry)) return serializeObject(entry);
		return null;
	});
	else if (isObject$2(error$1)) return serializeObject(error$1);
	if (isValidJson(error$1)) return error$1;
	return null;
}
/**
* Construct a JSON-serializable object given an error and a JSON serializable `fallbackError`
*
* @param error - The error in question.
* @param fallbackError - A JSON serializable fallback error.
* @returns A JSON serializable error object.
*/
function buildError(error$1, fallbackError) {
	if (error$1 && typeof error$1 === "object" && "serialize" in error$1 && typeof error$1.serialize === "function") return error$1.serialize();
	if (isJsonRpcError(error$1)) return error$1;
	const cause = serializeCause(error$1);
	return _objectSpread2(_objectSpread2({}, fallbackError), {}, { data: { cause } });
}
/**
* Serializes the given error to an Ethereum JSON RPC-compatible error object.
* If the given error is not fully compatible, it will be preserved on the
* returned object's data.cause property.
*
* @param error - The error to serialize.
* @param options - Options bag.
* @param options.fallbackError - The error to return if the given error is
* not compatible. Should be a JSON serializable value.
* @param options.shouldIncludeStack - Whether to include the error's stack
* on the returned object.
* @returns The serialized error.
*/
function serializeError$1(error$1) {
	let { fallbackError = FALLBACK_ERROR$1, shouldIncludeStack = true } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	if (!isJsonRpcError(fallbackError)) throw new Error("Must provide fallback error with integer number code and string message.");
	const serialized = buildError(error$1, fallbackError);
	if (!shouldIncludeStack) delete serialized.stack;
	return serialized;
}
function safeApply(handler, context, args) {
	try {
		Reflect.apply(handler, context, args);
	} catch (err) {
		setTimeout(() => {
			throw err;
		});
	}
}
function arrayClone(arr$1) {
	const n = arr$1.length;
	const copy = new Array(n);
	for (let i = 0; i < n; i += 1) copy[i] = arr$1[i];
	return copy;
}
var SafeEventEmitter = class extends import_events$1.EventEmitter {
	emit(type$5) {
		let doError = type$5 === "error";
		const events = this._events;
		if (events !== void 0) doError = doError && events.error === void 0;
		else if (!doError) return false;
		for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
		if (doError) {
			let er;
			if (args.length > 0) [er] = args;
			if (er instanceof Error) throw er;
			const err = /* @__PURE__ */ new Error(`Unhandled error.${er ? ` (${er.message})` : ""}`);
			err.context = er;
			throw err;
		}
		const handler = events[type$5];
		if (handler === void 0) return false;
		if (typeof handler === "function") safeApply(handler, this, args);
		else {
			const len = handler.length;
			const listeners = arrayClone(handler);
			for (let i = 0; i < len; i += 1) safeApply(listeners[i], this, args);
		}
		return true;
	}
};
var SerializableError = class extends Error {
	constructor(_ref) {
		let { code, message, data } = _ref;
		if (!Number.isInteger(code)) throw new Error("code must be an integer");
		if (!message || typeof message !== "string") throw new Error("message must be string");
		super(message);
		_defineProperty(this, "code", void 0);
		_defineProperty(this, "data", void 0);
		this.code = code;
		if (data !== void 0) this.data = data;
	}
	toString() {
		return (0, import_fast_safe_stringify.default)({
			code: this.code,
			message: this.message,
			data: this.data,
			stack: this.stack
		});
	}
};
var getRpcPromiseCallback = function(resolve, reject) {
	let unwrapResult = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	return (error$1, response) => {
		if (error$1 || response.error) reject(error$1 || response.error);
		else if (!unwrapResult || Array.isArray(response)) resolve(response);
		else resolve(response.result);
	};
};
function createStreamMiddleware() {
	const idMap = {};
	function readNoop() {
		return false;
	}
	const events = new SafeEventEmitter();
	function processResponse(res) {
		const context = idMap[res.id];
		if (!context) throw new Error(`StreamMiddleware - Unknown response id "${res.id}"`);
		delete idMap[res.id];
		Object.assign(context.res, res);
		setTimeout(context.end);
	}
	function processNotification(res) {
		events.emit("notification", res);
	}
	function processMessage(res, _encoding, cb) {
		let err;
		try {
			if (!res.id) processNotification(res);
			else processResponse(res);
		} catch (_err) {
			err = _err;
		}
		cb(err);
	}
	const stream = new import_browser.Duplex({
		objectMode: true,
		read: readNoop,
		write: processMessage
	});
	const middleware = (req, res, next$1, end) => {
		stream.push(req);
		idMap[req.id] = {
			req,
			res,
			next: next$1,
			end
		};
	};
	return {
		events,
		middleware,
		stream
	};
}
function createIdRemapMiddleware() {
	return (req, res, next$1, _end) => {
		const originalId = req.id;
		const newId = Math.random().toString(36).slice(2);
		req.id = newId;
		res.id = newId;
		next$1((done) => {
			req.id = originalId;
			res.id = originalId;
			done();
		});
	};
}
/**
* A JSON-RPC request and response processor.
* Give it a stack of middleware, pass it requests, and get back responses.
*/
var JRPCEngine = class JRPCEngine extends SafeEventEmitter {
	constructor() {
		super();
		_defineProperty(this, "_middleware", void 0);
		this._middleware = [];
	}
	/**
	* Serially executes the given stack of middleware.
	*
	* @returns An array of any error encountered during middleware execution,
	* a boolean indicating whether the request was completed, and an array of
	* middleware-defined return handlers.
	*/
	static async _runAllMiddleware(req, res, middlewareStack) {
		const returnHandlers = [];
		let error$1 = null;
		let isComplete = false;
		for (const middleware of middlewareStack) {
			[error$1, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);
			if (isComplete) break;
		}
		return [
			error$1,
			isComplete,
			returnHandlers.reverse()
		];
	}
	/**
	* Runs an individual middleware.
	*
	* @returns An array of any error encountered during middleware execution,
	* and a boolean indicating whether the request should end.
	*/
	static _runMiddleware(req, res, middleware, returnHandlers) {
		return new Promise((resolve) => {
			const end = (err) => {
				const error$1 = err || res.error;
				if (error$1) {
					if (typeof error$1 === "object" && Object.keys(error$1).includes("stack") === false) error$1.stack = "Stack trace is not available.";
					res.error = serializeError$1(error$1, {
						shouldIncludeStack: true,
						fallbackError: {
							message: (error$1 === null || error$1 === void 0 ? void 0 : error$1.message) || (error$1 === null || error$1 === void 0 ? void 0 : error$1.toString()),
							code: (error$1 === null || error$1 === void 0 ? void 0 : error$1.code) || -32603,
							stack: (error$1 === null || error$1 === void 0 ? void 0 : error$1.stack) || "Stack trace is not available.",
							data: (error$1 === null || error$1 === void 0 ? void 0 : error$1.data) || (error$1 === null || error$1 === void 0 ? void 0 : error$1.message) || (error$1 === null || error$1 === void 0 ? void 0 : error$1.toString())
						}
					});
				}
				resolve([error$1, true]);
			};
			const next$1 = (returnHandler) => {
				if (res.error) end(res.error);
				else {
					if (returnHandler) {
						if (typeof returnHandler !== "function") end(new SerializableError({
							code: -32603,
							message: "JRPCEngine: 'next' return handlers must be functions"
						}));
						returnHandlers.push(returnHandler);
					}
					resolve([null, false]);
				}
			};
			try {
				middleware(req, res, next$1, end);
			} catch (error$1) {
				end(error$1);
			}
		});
	}
	/**
	* Serially executes array of return handlers. The request and response are
	* assumed to be in their scope.
	*/
	static async _runReturnHandlers(handlers) {
		for (const handler of handlers) await new Promise((resolve, reject) => {
			handler((err) => err ? reject(err) : resolve());
		});
	}
	/**
	* Throws an error if the response has neither a result nor an error, or if
	* the "isComplete" flag is falsy.
	*/
	static _checkForCompletion(_req, res, isComplete) {
		if (!("result" in res) && !("error" in res)) throw new SerializableError({
			code: -32603,
			message: "Response has no error or result for request"
		});
		if (!isComplete) throw new SerializableError({
			code: -32603,
			message: "Nothing ended request"
		});
	}
	/**
	* Add a middleware function to the engine's middleware stack.
	*
	* @param middleware - The middleware function to add.
	*/
	push(middleware) {
		this._middleware.push(middleware);
	}
	/**
	* Handle a JSON-RPC request, and return a response.
	*
	* @param request - The request to handle.
	* @param callback - An error-first callback that will receive the response.
	*/
	/**
	* Handle an array of JSON-RPC requests, and return an array of responses.
	*
	* @param request - The requests to handle.
	* @param callback - An error-first callback that will receive the array of
	* responses.
	*/
	/**
	* Handle a JSON-RPC request, and return a response.
	*
	* @param request - The request to handle.
	* @returns A promise that resolves with the response, or rejects with an
	* error.
	*/
	/**
	* Handle an array of JSON-RPC requests, and return an array of responses.
	*
	* @param request - The requests to handle.
	* @returns A promise that resolves with the array of responses, or rejects
	* with an error.
	*/
	handle(req, cb) {
		if (cb && typeof cb !== "function") throw new Error("\"callback\" must be a function if provided.");
		if (Array.isArray(req)) {
			if (cb) return this._handleBatch(req, cb);
			return this._handleBatch(req);
		}
		if (cb) return this._handle(req, cb);
		return this._promiseHandle(req);
	}
	/**
	* Returns this engine as a middleware function that can be pushed to other
	* engines.
	*
	* @returns This engine as a middleware function.
	*/
	asMiddleware() {
		return async (req, res, next$1, end) => {
			try {
				const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);
				if (isComplete) {
					await JRPCEngine._runReturnHandlers(returnHandlers);
					return end(middlewareError);
				}
				return next$1(async (handlerCallback) => {
					try {
						await JRPCEngine._runReturnHandlers(returnHandlers);
					} catch (error$1) {
						return handlerCallback(error$1);
					}
					return handlerCallback();
				});
			} catch (error$1) {
				return end(error$1);
			}
		};
	}
	/**
	* Like _handle, but for batch requests.
	*/
	/**
	* Like _handle, but for batch requests.
	*/
	async _handleBatch(reqs, cb) {
		try {
			const responses = await Promise.all(reqs.map(this._promiseHandle.bind(this)));
			if (cb) return cb(null, responses);
			return responses;
		} catch (error$1) {
			if (cb) return cb(error$1);
			throw error$1;
		}
	}
	/**
	* A promise-wrapped _handle.
	*/
	_promiseHandle(req) {
		return new Promise((resolve, reject) => {
			this._handle(req, (_err, res) => {
				if (_err && res === void 0) reject(_err);
				else resolve(res);
			}).catch(reject);
		});
	}
	/**
	* Ensures that the request object is valid, processes it, and passes any
	* error and the response object to the given callback.
	*
	* Does not reject.
	*/
	async _handle(callerReq, cb) {
		if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
			const error$2 = new SerializableError({
				code: -32603,
				message: "request must be plain object"
			});
			return cb(error$2, {
				id: void 0,
				jsonrpc: "2.0",
				error: error$2
			});
		}
		if (typeof callerReq.method !== "string") {
			const error$2 = new SerializableError({
				code: -32603,
				message: "method must be string"
			});
			return cb(error$2, {
				id: callerReq.id,
				jsonrpc: "2.0",
				error: error$2
			});
		}
		const req = _objectSpread2({}, callerReq);
		const res = {
			id: req.id,
			jsonrpc: req.jsonrpc
		};
		let error$1 = null;
		try {
			await this._processRequest(req, res);
		} catch (_error) {
			error$1 = _error;
		}
		if (error$1) {
			delete res.result;
			if (!res.error) {
				var _error2, _error3, _error4, _error5, _error6, _error7, _error8;
				if (typeof error$1 === "object" && Object.keys(error$1).includes("stack") === false) error$1.stack = "Stack trace is not available.";
				res.error = serializeError$1(error$1, {
					shouldIncludeStack: true,
					fallbackError: {
						message: ((_error2 = error$1) === null || _error2 === void 0 ? void 0 : _error2.message) || ((_error3 = error$1) === null || _error3 === void 0 ? void 0 : _error3.toString()),
						code: ((_error4 = error$1) === null || _error4 === void 0 ? void 0 : _error4.code) || -32603,
						stack: ((_error5 = error$1) === null || _error5 === void 0 ? void 0 : _error5.stack) || "Stack trace is not available.",
						data: ((_error6 = error$1) === null || _error6 === void 0 ? void 0 : _error6.data) || ((_error7 = error$1) === null || _error7 === void 0 ? void 0 : _error7.message) || ((_error8 = error$1) === null || _error8 === void 0 ? void 0 : _error8.toString())
					}
				});
			}
		}
		return cb(error$1, res);
	}
	/**
	* For the given request and response, runs all middleware and their return
	* handlers, if any, and ensures that internal request processing semantics
	* are satisfied.
	*/
	async _processRequest(req, res) {
		const [error$1, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);
		JRPCEngine._checkForCompletion(req, res, isComplete);
		await JRPCEngine._runReturnHandlers(returnHandlers);
		if (error$1) throw error$1;
	}
};
var Substream = class extends import_browser.Duplex {
	constructor(_ref) {
		let { parent, name: name$1 } = _ref;
		super({ objectMode: true });
		_defineProperty(this, "_parent", void 0);
		_defineProperty(this, "_name", void 0);
		this._parent = parent;
		this._name = name$1;
	}
	/**
	* Explicitly sets read operations to a no-op.
	*/
	_read() {}
	/**
	* Called when data should be written to this writable stream.
	*
	* @param chunk - Arbitrary object to write
	* @param encoding - Encoding to use when writing payload
	* @param callback - Called when writing is complete or an error occurs
	*/
	_write(chunk, _encoding, callback) {
		this._parent.push({
			name: this._name,
			data: chunk
		});
		callback();
	}
};
var IGNORE_SUBSTREAM = Symbol("IGNORE_SUBSTREAM");
var ObjectMultiplex = class extends import_browser.Duplex {
	constructor() {
		let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		super(_objectSpread2(_objectSpread2({}, opts), {}, { objectMode: true }));
		_defineProperty(this, "_substreams", void 0);
		_defineProperty(this, "getStream", void 0);
		this._substreams = {};
	}
	createStream(name$1) {
		if (!name$1) throw new Error("ObjectMultiplex - name must not be empty");
		if (this._substreams[name$1]) throw new Error(`ObjectMultiplex - Substream for name "${name$1}" already exists`);
		const substream = new Substream({
			parent: this,
			name: name$1
		});
		this._substreams[name$1] = substream;
		anyStreamEnd(this, (_error) => substream.destroy(_error || void 0));
		return substream;
	}
	ignoreStream(name$1) {
		if (!name$1) throw new Error("ObjectMultiplex - name must not be empty");
		if (this._substreams[name$1]) throw new Error(`ObjectMultiplex - Substream for name "${name$1}" already exists`);
		this._substreams[name$1] = IGNORE_SUBSTREAM;
	}
	_read() {}
	_write(chunk, _encoding, callback) {
		const { name: name$1, data } = chunk;
		if (!name$1) {
			window.console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`);
			return callback();
		}
		const substream = this._substreams[name$1];
		if (!substream) {
			window.console.warn(`ObjectMultiplex - orphaned data for stream "${name$1}"`);
			return callback();
		}
		if (substream !== IGNORE_SUBSTREAM) substream.push(data);
		return callback();
	}
};
function anyStreamEnd(stream, _cb) {
	const cb = (0, import_once.default)(_cb);
	(0, import_end_of_stream.default)(stream, { readable: false }, cb);
	(0, import_end_of_stream.default)(stream, { writable: false }, cb);
}

//#endregion
//#region node_modules/lodash.merge/index.js
var require_lodash = /* @__PURE__ */ __commonJS({ "node_modules/lodash.merge/index.js": ((exports, module) => {
	/**
	* Lodash (Custom Build) <https://lodash.com/>
	* Build: `lodash modularize exports="npm" -o ./`
	* Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	* Released under MIT license <https://lodash.com/license>
	* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	*/
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = "__lodash_hash_undefined__";
	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800, HOT_SPAN = 16;
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	/** `Object#toString` result references. */
	var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
	var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
	/**
	* Used to match `RegExp`
	* [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	*/
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
	/** Detect free variable `self`. */
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function("return this")();
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	/** Used to access faster Node.js helpers. */
	var nodeUtil = function() {
		try {
			var types = freeModule && freeModule.require && freeModule.require("util").types;
			if (types) return types;
			return freeProcess && freeProcess.binding && freeProcess.binding("util");
		} catch (e) {}
	}();
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	/**
	* A faster alternative to `Function#apply`, this function invokes `func`
	* with the `this` binding of `thisArg` and the arguments of `args`.
	*
	* @private
	* @param {Function} func The function to invoke.
	* @param {*} thisArg The `this` binding of `func`.
	* @param {Array} args The arguments to invoke `func` with.
	* @returns {*} Returns the result of `func`.
	*/
	function apply(func, thisArg, args) {
		switch (args.length) {
			case 0: return func.call(thisArg);
			case 1: return func.call(thisArg, args[0]);
			case 2: return func.call(thisArg, args[0], args[1]);
			case 3: return func.call(thisArg, args[0], args[1], args[2]);
		}
		return func.apply(thisArg, args);
	}
	/**
	* The base implementation of `_.times` without support for iteratee shorthands
	* or max array length checks.
	*
	* @private
	* @param {number} n The number of times to invoke `iteratee`.
	* @param {Function} iteratee The function invoked per iteration.
	* @returns {Array} Returns the array of results.
	*/
	function baseTimes(n, iteratee) {
		var index = -1, result = Array(n);
		while (++index < n) result[index] = iteratee(index);
		return result;
	}
	/**
	* The base implementation of `_.unary` without support for storing metadata.
	*
	* @private
	* @param {Function} func The function to cap arguments for.
	* @returns {Function} Returns the new capped function.
	*/
	function baseUnary(func) {
		return function(value$2) {
			return func(value$2);
		};
	}
	/**
	* Gets the value at `key` of `object`.
	*
	* @private
	* @param {Object} [object] The object to query.
	* @param {string} key The key of the property to get.
	* @returns {*} Returns the property value.
	*/
	function getValue(object$1, key) {
		return object$1 == null ? void 0 : object$1[key];
	}
	/**
	* Creates a unary function that invokes `func` with its argument transformed.
	*
	* @private
	* @param {Function} func The function to wrap.
	* @param {Function} transform The argument transform.
	* @returns {Function} Returns the new function.
	*/
	function overArg(func, transform) {
		return function(arg) {
			return func(transform(arg));
		};
	}
	/** Used for built-in method references. */
	var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root["__core-js_shared__"];
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto.hasOwnProperty;
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = function() {
		var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
		return uid ? "Symbol(src)_1." + uid : "";
	}();
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var nativeObjectToString = objectProto.toString;
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	/** Used to detect if a method is native. */
	var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$1).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
	/** Built-in value references. */
	var Buffer$1 = moduleExports ? root.Buffer : void 0, Symbol$1 = root.Symbol, Uint8Array$1 = root.Uint8Array, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
	var defineProperty = function() {
		try {
			var func = getNative(Object, "defineProperty");
			func({}, "", {});
			return func;
		} catch (e) {}
	}();
	var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
	var Map$1 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
	/**
	* The base implementation of `_.create` without support for assigning
	* properties to the created object.
	*
	* @private
	* @param {Object} proto The object to inherit from.
	* @returns {Object} Returns the new object.
	*/
	var baseCreate = function() {
		function object$1() {}
		return function(proto) {
			if (!isObject$1(proto)) return {};
			if (objectCreate) return objectCreate(proto);
			object$1.prototype = proto;
			var result = new object$1();
			object$1.prototype = void 0;
			return result;
		};
	}();
	/**
	* Creates a hash object.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function Hash$1(entries) {
		var index = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index < length) {
			var entry = entries[index];
			this.set(entry[0], entry[1]);
		}
	}
	/**
	* Removes all key-value entries from the hash.
	*
	* @private
	* @name clear
	* @memberOf Hash
	*/
	function hashClear() {
		this.__data__ = nativeCreate ? nativeCreate(null) : {};
		this.size = 0;
	}
	/**
	* Removes `key` and its value from the hash.
	*
	* @private
	* @name delete
	* @memberOf Hash
	* @param {Object} hash The hash to modify.
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function hashDelete(key) {
		var result = this.has(key) && delete this.__data__[key];
		this.size -= result ? 1 : 0;
		return result;
	}
	/**
	* Gets the hash value for `key`.
	*
	* @private
	* @name get
	* @memberOf Hash
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function hashGet(key) {
		var data = this.__data__;
		if (nativeCreate) {
			var result = data[key];
			return result === HASH_UNDEFINED ? void 0 : result;
		}
		return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
	}
	/**
	* Checks if a hash value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf Hash
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function hashHas(key) {
		var data = this.__data__;
		return nativeCreate ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
	}
	/**
	* Sets the hash `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf Hash
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the hash instance.
	*/
	function hashSet(key, value$2) {
		var data = this.__data__;
		this.size += this.has(key) ? 0 : 1;
		data[key] = nativeCreate && value$2 === void 0 ? HASH_UNDEFINED : value$2;
		return this;
	}
	Hash$1.prototype.clear = hashClear;
	Hash$1.prototype["delete"] = hashDelete;
	Hash$1.prototype.get = hashGet;
	Hash$1.prototype.has = hashHas;
	Hash$1.prototype.set = hashSet;
	/**
	* Creates an list cache object.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function ListCache(entries) {
		var index = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index < length) {
			var entry = entries[index];
			this.set(entry[0], entry[1]);
		}
	}
	/**
	* Removes all key-value entries from the list cache.
	*
	* @private
	* @name clear
	* @memberOf ListCache
	*/
	function listCacheClear() {
		this.__data__ = [];
		this.size = 0;
	}
	/**
	* Removes `key` and its value from the list cache.
	*
	* @private
	* @name delete
	* @memberOf ListCache
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function listCacheDelete(key) {
		var data = this.__data__, index = assocIndexOf(data, key);
		if (index < 0) return false;
		if (index == data.length - 1) data.pop();
		else splice.call(data, index, 1);
		--this.size;
		return true;
	}
	/**
	* Gets the list cache value for `key`.
	*
	* @private
	* @name get
	* @memberOf ListCache
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function listCacheGet(key) {
		var data = this.__data__, index = assocIndexOf(data, key);
		return index < 0 ? void 0 : data[index][1];
	}
	/**
	* Checks if a list cache value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf ListCache
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function listCacheHas(key) {
		return assocIndexOf(this.__data__, key) > -1;
	}
	/**
	* Sets the list cache `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf ListCache
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the list cache instance.
	*/
	function listCacheSet(key, value$2) {
		var data = this.__data__, index = assocIndexOf(data, key);
		if (index < 0) {
			++this.size;
			data.push([key, value$2]);
		} else data[index][1] = value$2;
		return this;
	}
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype["delete"] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	/**
	* Creates a map cache object to store key-value pairs.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function MapCache(entries) {
		var index = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index < length) {
			var entry = entries[index];
			this.set(entry[0], entry[1]);
		}
	}
	/**
	* Removes all key-value entries from the map.
	*
	* @private
	* @name clear
	* @memberOf MapCache
	*/
	function mapCacheClear() {
		this.size = 0;
		this.__data__ = {
			"hash": new Hash$1(),
			"map": new (Map$1 || ListCache)(),
			"string": new Hash$1()
		};
	}
	/**
	* Removes `key` and its value from the map.
	*
	* @private
	* @name delete
	* @memberOf MapCache
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function mapCacheDelete(key) {
		var result = getMapData(this, key)["delete"](key);
		this.size -= result ? 1 : 0;
		return result;
	}
	/**
	* Gets the map value for `key`.
	*
	* @private
	* @name get
	* @memberOf MapCache
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function mapCacheGet(key) {
		return getMapData(this, key).get(key);
	}
	/**
	* Checks if a map value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf MapCache
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function mapCacheHas(key) {
		return getMapData(this, key).has(key);
	}
	/**
	* Sets the map `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf MapCache
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the map cache instance.
	*/
	function mapCacheSet(key, value$2) {
		var data = getMapData(this, key), size = data.size;
		data.set(key, value$2);
		this.size += data.size == size ? 0 : 1;
		return this;
	}
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype["delete"] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	/**
	* Creates a stack cache object to store key-value pairs.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function Stack(entries) {
		this.size = (this.__data__ = new ListCache(entries)).size;
	}
	/**
	* Removes all key-value entries from the stack.
	*
	* @private
	* @name clear
	* @memberOf Stack
	*/
	function stackClear() {
		this.__data__ = new ListCache();
		this.size = 0;
	}
	/**
	* Removes `key` and its value from the stack.
	*
	* @private
	* @name delete
	* @memberOf Stack
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function stackDelete(key) {
		var data = this.__data__, result = data["delete"](key);
		this.size = data.size;
		return result;
	}
	/**
	* Gets the stack value for `key`.
	*
	* @private
	* @name get
	* @memberOf Stack
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function stackGet(key) {
		return this.__data__.get(key);
	}
	/**
	* Checks if a stack value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf Stack
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function stackHas(key) {
		return this.__data__.has(key);
	}
	/**
	* Sets the stack `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf Stack
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the stack cache instance.
	*/
	function stackSet(key, value$2) {
		var data = this.__data__;
		if (data instanceof ListCache) {
			var pairs = data.__data__;
			if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
				pairs.push([key, value$2]);
				this.size = ++data.size;
				return this;
			}
			data = this.__data__ = new MapCache(pairs);
		}
		data.set(key, value$2);
		this.size = data.size;
		return this;
	}
	Stack.prototype.clear = stackClear;
	Stack.prototype["delete"] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	/**
	* Creates an array of the enumerable property names of the array-like `value`.
	*
	* @private
	* @param {*} value The value to query.
	* @param {boolean} inherited Specify returning inherited property names.
	* @returns {Array} Returns the array of property names.
	*/
	function arrayLikeKeys(value$2, inherited) {
		var isArr = isArray$1(value$2), isArg = !isArr && isArguments(value$2), isBuff = !isArr && !isArg && isBuffer(value$2), isType = !isArr && !isArg && !isBuff && isTypedArray(value$2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value$2.length, String) : [], length = result.length;
		for (var key in value$2) if ((inherited || hasOwnProperty$1.call(value$2, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) result.push(key);
		return result;
	}
	/**
	* This function is like `assignValue` except that it doesn't assign
	* `undefined` values.
	*
	* @private
	* @param {Object} object The object to modify.
	* @param {string} key The key of the property to assign.
	* @param {*} value The value to assign.
	*/
	function assignMergeValue(object$1, key, value$2) {
		if (value$2 !== void 0 && !eq(object$1[key], value$2) || value$2 === void 0 && !(key in object$1)) baseAssignValue(object$1, key, value$2);
	}
	/**
	* Assigns `value` to `key` of `object` if the existing value is not equivalent
	* using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	* for equality comparisons.
	*
	* @private
	* @param {Object} object The object to modify.
	* @param {string} key The key of the property to assign.
	* @param {*} value The value to assign.
	*/
	function assignValue(object$1, key, value$2) {
		var objValue = object$1[key];
		if (!(hasOwnProperty$1.call(object$1, key) && eq(objValue, value$2)) || value$2 === void 0 && !(key in object$1)) baseAssignValue(object$1, key, value$2);
	}
	/**
	* Gets the index at which the `key` is found in `array` of key-value pairs.
	*
	* @private
	* @param {Array} array The array to inspect.
	* @param {*} key The key to search for.
	* @returns {number} Returns the index of the matched value, else `-1`.
	*/
	function assocIndexOf(array$1, key) {
		var length = array$1.length;
		while (length--) if (eq(array$1[length][0], key)) return length;
		return -1;
	}
	/**
	* The base implementation of `assignValue` and `assignMergeValue` without
	* value checks.
	*
	* @private
	* @param {Object} object The object to modify.
	* @param {string} key The key of the property to assign.
	* @param {*} value The value to assign.
	*/
	function baseAssignValue(object$1, key, value$2) {
		if (key == "__proto__" && defineProperty) defineProperty(object$1, key, {
			"configurable": true,
			"enumerable": true,
			"value": value$2,
			"writable": true
		});
		else object$1[key] = value$2;
	}
	/**
	* The base implementation of `baseForOwn` which iterates over `object`
	* properties returned by `keysFunc` and invokes `iteratee` for each property.
	* Iteratee functions may exit iteration early by explicitly returning `false`.
	*
	* @private
	* @param {Object} object The object to iterate over.
	* @param {Function} iteratee The function invoked per iteration.
	* @param {Function} keysFunc The function to get the keys of `object`.
	* @returns {Object} Returns `object`.
	*/
	var baseFor = createBaseFor();
	/**
	* The base implementation of `getTag` without fallbacks for buggy environments.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the `toStringTag`.
	*/
	function baseGetTag(value$2) {
		if (value$2 == null) return value$2 === void 0 ? undefinedTag : nullTag;
		return symToStringTag && symToStringTag in Object(value$2) ? getRawTag(value$2) : objectToString(value$2);
	}
	/**
	* The base implementation of `_.isArguments`.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an `arguments` object,
	*/
	function baseIsArguments(value$2) {
		return isObjectLike(value$2) && baseGetTag(value$2) == argsTag;
	}
	/**
	* The base implementation of `_.isNative` without bad shim checks.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a native function,
	*  else `false`.
	*/
	function baseIsNative(value$2) {
		if (!isObject$1(value$2) || isMasked(value$2)) return false;
		return (isFunction(value$2) ? reIsNative : reIsHostCtor).test(toSource(value$2));
	}
	/**
	* The base implementation of `_.isTypedArray` without Node.js optimizations.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	*/
	function baseIsTypedArray(value$2) {
		return isObjectLike(value$2) && isLength(value$2.length) && !!typedArrayTags[baseGetTag(value$2)];
	}
	/**
	* The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	*
	* @private
	* @param {Object} object The object to query.
	* @returns {Array} Returns the array of property names.
	*/
	function baseKeysIn(object$1) {
		if (!isObject$1(object$1)) return nativeKeysIn(object$1);
		var isProto = isPrototype(object$1), result = [];
		for (var key in object$1) if (!(key == "constructor" && (isProto || !hasOwnProperty$1.call(object$1, key)))) result.push(key);
		return result;
	}
	/**
	* The base implementation of `_.merge` without support for multiple sources.
	*
	* @private
	* @param {Object} object The destination object.
	* @param {Object} source The source object.
	* @param {number} srcIndex The index of `source`.
	* @param {Function} [customizer] The function to customize merged values.
	* @param {Object} [stack] Tracks traversed source values and their merged
	*  counterparts.
	*/
	function baseMerge(object$1, source, srcIndex, customizer, stack) {
		if (object$1 === source) return;
		baseFor(source, function(srcValue, key) {
			stack || (stack = new Stack());
			if (isObject$1(srcValue)) baseMergeDeep(object$1, source, key, srcIndex, baseMerge, customizer, stack);
			else {
				var newValue = customizer ? customizer(safeGet(object$1, key), srcValue, key + "", object$1, source, stack) : void 0;
				if (newValue === void 0) newValue = srcValue;
				assignMergeValue(object$1, key, newValue);
			}
		}, keysIn);
	}
	/**
	* A specialized version of `baseMerge` for arrays and objects which performs
	* deep merges and tracks traversed objects enabling objects with circular
	* references to be merged.
	*
	* @private
	* @param {Object} object The destination object.
	* @param {Object} source The source object.
	* @param {string} key The key of the value to merge.
	* @param {number} srcIndex The index of `source`.
	* @param {Function} mergeFunc The function to merge values.
	* @param {Function} [customizer] The function to customize assigned values.
	* @param {Object} [stack] Tracks traversed source values and their merged
	*  counterparts.
	*/
	function baseMergeDeep(object$1, source, key, srcIndex, mergeFunc, customizer, stack) {
		var objValue = safeGet(object$1, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
		if (stacked) {
			assignMergeValue(object$1, key, stacked);
			return;
		}
		var newValue = customizer ? customizer(objValue, srcValue, key + "", object$1, source, stack) : void 0;
		var isCommon = newValue === void 0;
		if (isCommon) {
			var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
			newValue = srcValue;
			if (isArr || isBuff || isTyped) if (isArray$1(objValue)) newValue = objValue;
			else if (isArrayLikeObject(objValue)) newValue = copyArray(objValue);
			else if (isBuff) {
				isCommon = false;
				newValue = cloneBuffer(srcValue, true);
			} else if (isTyped) {
				isCommon = false;
				newValue = cloneTypedArray(srcValue, true);
			} else newValue = [];
			else if (isPlainObject(srcValue) || isArguments(srcValue)) {
				newValue = objValue;
				if (isArguments(objValue)) newValue = toPlainObject(objValue);
				else if (!isObject$1(objValue) || isFunction(objValue)) newValue = initCloneObject(srcValue);
			} else isCommon = false;
		}
		if (isCommon) {
			stack.set(srcValue, newValue);
			mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
			stack["delete"](srcValue);
		}
		assignMergeValue(object$1, key, newValue);
	}
	/**
	* The base implementation of `_.rest` which doesn't validate or coerce arguments.
	*
	* @private
	* @param {Function} func The function to apply a rest parameter to.
	* @param {number} [start=func.length-1] The start position of the rest parameter.
	* @returns {Function} Returns the new function.
	*/
	function baseRest(func, start) {
		return setToString(overRest(func, start, identity), func + "");
	}
	/**
	* The base implementation of `setToString` without support for hot loop shorting.
	*
	* @private
	* @param {Function} func The function to modify.
	* @param {Function} string The `toString` result.
	* @returns {Function} Returns `func`.
	*/
	var baseSetToString = !defineProperty ? identity : function(func, string$1) {
		return defineProperty(func, "toString", {
			"configurable": true,
			"enumerable": false,
			"value": constant(string$1),
			"writable": true
		});
	};
	/**
	* Creates a clone of  `buffer`.
	*
	* @private
	* @param {Buffer} buffer The buffer to clone.
	* @param {boolean} [isDeep] Specify a deep clone.
	* @returns {Buffer} Returns the cloned buffer.
	*/
	function cloneBuffer(buffer, isDeep) {
		if (isDeep) return buffer.slice();
		var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
		buffer.copy(result);
		return result;
	}
	/**
	* Creates a clone of `arrayBuffer`.
	*
	* @private
	* @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	* @returns {ArrayBuffer} Returns the cloned array buffer.
	*/
	function cloneArrayBuffer(arrayBuffer) {
		var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
		new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
		return result;
	}
	/**
	* Creates a clone of `typedArray`.
	*
	* @private
	* @param {Object} typedArray The typed array to clone.
	* @param {boolean} [isDeep] Specify a deep clone.
	* @returns {Object} Returns the cloned typed array.
	*/
	function cloneTypedArray(typedArray, isDeep) {
		var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
		return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}
	/**
	* Copies the values of `source` to `array`.
	*
	* @private
	* @param {Array} source The array to copy values from.
	* @param {Array} [array=[]] The array to copy values to.
	* @returns {Array} Returns `array`.
	*/
	function copyArray(source, array$1) {
		var index = -1, length = source.length;
		array$1 || (array$1 = Array(length));
		while (++index < length) array$1[index] = source[index];
		return array$1;
	}
	/**
	* Copies properties of `source` to `object`.
	*
	* @private
	* @param {Object} source The object to copy properties from.
	* @param {Array} props The property identifiers to copy.
	* @param {Object} [object={}] The object to copy properties to.
	* @param {Function} [customizer] The function to customize copied values.
	* @returns {Object} Returns `object`.
	*/
	function copyObject(source, props, object$1, customizer) {
		var isNew = !object$1;
		object$1 || (object$1 = {});
		var index = -1, length = props.length;
		while (++index < length) {
			var key = props[index];
			var newValue = customizer ? customizer(object$1[key], source[key], key, object$1, source) : void 0;
			if (newValue === void 0) newValue = source[key];
			if (isNew) baseAssignValue(object$1, key, newValue);
			else assignValue(object$1, key, newValue);
		}
		return object$1;
	}
	/**
	* Creates a function like `_.assign`.
	*
	* @private
	* @param {Function} assigner The function to assign values.
	* @returns {Function} Returns the new assigner function.
	*/
	function createAssigner(assigner) {
		return baseRest(function(object$1, sources) {
			var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
			customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
			if (guard && isIterateeCall(sources[0], sources[1], guard)) {
				customizer = length < 3 ? void 0 : customizer;
				length = 1;
			}
			object$1 = Object(object$1);
			while (++index < length) {
				var source = sources[index];
				if (source) assigner(object$1, source, index, customizer);
			}
			return object$1;
		});
	}
	/**
	* Creates a base function for methods like `_.forIn` and `_.forOwn`.
	*
	* @private
	* @param {boolean} [fromRight] Specify iterating from right to left.
	* @returns {Function} Returns the new base function.
	*/
	function createBaseFor(fromRight) {
		return function(object$1, iteratee, keysFunc) {
			var index = -1, iterable = Object(object$1), props = keysFunc(object$1), length = props.length;
			while (length--) {
				var key = props[fromRight ? length : ++index];
				if (iteratee(iterable[key], key, iterable) === false) break;
			}
			return object$1;
		};
	}
	/**
	* Gets the data for `map`.
	*
	* @private
	* @param {Object} map The map to query.
	* @param {string} key The reference key.
	* @returns {*} Returns the map data.
	*/
	function getMapData(map$1, key) {
		var data = map$1.__data__;
		return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
	}
	/**
	* Gets the native function at `key` of `object`.
	*
	* @private
	* @param {Object} object The object to query.
	* @param {string} key The key of the method to get.
	* @returns {*} Returns the function if it's native, else `undefined`.
	*/
	function getNative(object$1, key) {
		var value$2 = getValue(object$1, key);
		return baseIsNative(value$2) ? value$2 : void 0;
	}
	/**
	* A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the raw `toStringTag`.
	*/
	function getRawTag(value$2) {
		var isOwn = hasOwnProperty$1.call(value$2, symToStringTag), tag = value$2[symToStringTag];
		try {
			value$2[symToStringTag] = void 0;
			var unmasked = true;
		} catch (e) {}
		var result = nativeObjectToString.call(value$2);
		if (unmasked) if (isOwn) value$2[symToStringTag] = tag;
		else delete value$2[symToStringTag];
		return result;
	}
	/**
	* Initializes an object clone.
	*
	* @private
	* @param {Object} object The object to clone.
	* @returns {Object} Returns the initialized clone.
	*/
	function initCloneObject(object$1) {
		return typeof object$1.constructor == "function" && !isPrototype(object$1) ? baseCreate(getPrototype(object$1)) : {};
	}
	/**
	* Checks if `value` is a valid array-like index.
	*
	* @private
	* @param {*} value The value to check.
	* @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	* @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	*/
	function isIndex(value$2, length) {
		var type$5 = typeof value$2;
		length = length == null ? MAX_SAFE_INTEGER : length;
		return !!length && (type$5 == "number" || type$5 != "symbol" && reIsUint.test(value$2)) && value$2 > -1 && value$2 % 1 == 0 && value$2 < length;
	}
	/**
	* Checks if the given arguments are from an iteratee call.
	*
	* @private
	* @param {*} value The potential iteratee value argument.
	* @param {*} index The potential iteratee index or key argument.
	* @param {*} object The potential iteratee object argument.
	* @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	*  else `false`.
	*/
	function isIterateeCall(value$2, index, object$1) {
		if (!isObject$1(object$1)) return false;
		var type$5 = typeof index;
		if (type$5 == "number" ? isArrayLike(object$1) && isIndex(index, object$1.length) : type$5 == "string" && index in object$1) return eq(object$1[index], value$2);
		return false;
	}
	/**
	* Checks if `value` is suitable for use as unique object key.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	*/
	function isKeyable(value$2) {
		var type$5 = typeof value$2;
		return type$5 == "string" || type$5 == "number" || type$5 == "symbol" || type$5 == "boolean" ? value$2 !== "__proto__" : value$2 === null;
	}
	/**
	* Checks if `func` has its source masked.
	*
	* @private
	* @param {Function} func The function to check.
	* @returns {boolean} Returns `true` if `func` is masked, else `false`.
	*/
	function isMasked(func) {
		return !!maskSrcKey && maskSrcKey in func;
	}
	/**
	* Checks if `value` is likely a prototype object.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	*/
	function isPrototype(value$2) {
		var Ctor = value$2 && value$2.constructor;
		return value$2 === (typeof Ctor == "function" && Ctor.prototype || objectProto);
	}
	/**
	* This function is like
	* [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	* except that it includes inherited enumerable properties.
	*
	* @private
	* @param {Object} object The object to query.
	* @returns {Array} Returns the array of property names.
	*/
	function nativeKeysIn(object$1) {
		var result = [];
		if (object$1 != null) for (var key in Object(object$1)) result.push(key);
		return result;
	}
	/**
	* Converts `value` to a string using `Object.prototype.toString`.
	*
	* @private
	* @param {*} value The value to convert.
	* @returns {string} Returns the converted string.
	*/
	function objectToString(value$2) {
		return nativeObjectToString.call(value$2);
	}
	/**
	* A specialized version of `baseRest` which transforms the rest array.
	*
	* @private
	* @param {Function} func The function to apply a rest parameter to.
	* @param {number} [start=func.length-1] The start position of the rest parameter.
	* @param {Function} transform The rest array transform.
	* @returns {Function} Returns the new function.
	*/
	function overRest(func, start, transform) {
		start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
		return function() {
			var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array$1 = Array(length);
			while (++index < length) array$1[index] = args[start + index];
			index = -1;
			var otherArgs = Array(start + 1);
			while (++index < start) otherArgs[index] = args[index];
			otherArgs[start] = transform(array$1);
			return apply(func, this, otherArgs);
		};
	}
	/**
	* Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	*
	* @private
	* @param {Object} object The object to query.
	* @param {string} key The key of the property to get.
	* @returns {*} Returns the property value.
	*/
	function safeGet(object$1, key) {
		if (key === "constructor" && typeof object$1[key] === "function") return;
		if (key == "__proto__") return;
		return object$1[key];
	}
	/**
	* Sets the `toString` method of `func` to return `string`.
	*
	* @private
	* @param {Function} func The function to modify.
	* @param {Function} string The `toString` result.
	* @returns {Function} Returns `func`.
	*/
	var setToString = shortOut(baseSetToString);
	/**
	* Creates a function that'll short out and invoke `identity` instead
	* of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	* milliseconds.
	*
	* @private
	* @param {Function} func The function to restrict.
	* @returns {Function} Returns the new shortable function.
	*/
	function shortOut(func) {
		var count = 0, lastCalled = 0;
		return function() {
			var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
			lastCalled = stamp;
			if (remaining > 0) {
				if (++count >= HOT_COUNT) return arguments[0];
			} else count = 0;
			return func.apply(void 0, arguments);
		};
	}
	/**
	* Converts `func` to its source code.
	*
	* @private
	* @param {Function} func The function to convert.
	* @returns {string} Returns the source code.
	*/
	function toSource(func) {
		if (func != null) {
			try {
				return funcToString.call(func);
			} catch (e) {}
			try {
				return func + "";
			} catch (e) {}
		}
		return "";
	}
	/**
	* Performs a
	* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	* comparison between two values to determine if they are equivalent.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to compare.
	* @param {*} other The other value to compare.
	* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	* @example
	*
	* var object = { 'a': 1 };
	* var other = { 'a': 1 };
	*
	* _.eq(object, object);
	* // => true
	*
	* _.eq(object, other);
	* // => false
	*
	* _.eq('a', 'a');
	* // => true
	*
	* _.eq('a', Object('a'));
	* // => false
	*
	* _.eq(NaN, NaN);
	* // => true
	*/
	function eq(value$2, other) {
		return value$2 === other || value$2 !== value$2 && other !== other;
	}
	/**
	* Checks if `value` is likely an `arguments` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an `arguments` object,
	*  else `false`.
	* @example
	*
	* _.isArguments(function() { return arguments; }());
	* // => true
	*
	* _.isArguments([1, 2, 3]);
	* // => false
	*/
	var isArguments = baseIsArguments(function() {
		return arguments;
	}()) ? baseIsArguments : function(value$2) {
		return isObjectLike(value$2) && hasOwnProperty$1.call(value$2, "callee") && !propertyIsEnumerable.call(value$2, "callee");
	};
	/**
	* Checks if `value` is classified as an `Array` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an array, else `false`.
	* @example
	*
	* _.isArray([1, 2, 3]);
	* // => true
	*
	* _.isArray(document.body.children);
	* // => false
	*
	* _.isArray('abc');
	* // => false
	*
	* _.isArray(_.noop);
	* // => false
	*/
	var isArray$1 = Array.isArray;
	/**
	* Checks if `value` is array-like. A value is considered array-like if it's
	* not a function and has a `value.length` that's an integer greater than or
	* equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	* @example
	*
	* _.isArrayLike([1, 2, 3]);
	* // => true
	*
	* _.isArrayLike(document.body.children);
	* // => true
	*
	* _.isArrayLike('abc');
	* // => true
	*
	* _.isArrayLike(_.noop);
	* // => false
	*/
	function isArrayLike(value$2) {
		return value$2 != null && isLength(value$2.length) && !isFunction(value$2);
	}
	/**
	* This method is like `_.isArrayLike` except that it also checks if `value`
	* is an object.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an array-like object,
	*  else `false`.
	* @example
	*
	* _.isArrayLikeObject([1, 2, 3]);
	* // => true
	*
	* _.isArrayLikeObject(document.body.children);
	* // => true
	*
	* _.isArrayLikeObject('abc');
	* // => false
	*
	* _.isArrayLikeObject(_.noop);
	* // => false
	*/
	function isArrayLikeObject(value$2) {
		return isObjectLike(value$2) && isArrayLike(value$2);
	}
	/**
	* Checks if `value` is a buffer.
	*
	* @static
	* @memberOf _
	* @since 4.3.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	* @example
	*
	* _.isBuffer(new Buffer(2));
	* // => true
	*
	* _.isBuffer(new Uint8Array(2));
	* // => false
	*/
	var isBuffer = nativeIsBuffer || stubFalse;
	/**
	* Checks if `value` is classified as a `Function` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a function, else `false`.
	* @example
	*
	* _.isFunction(_);
	* // => true
	*
	* _.isFunction(/abc/);
	* // => false
	*/
	function isFunction(value$2) {
		if (!isObject$1(value$2)) return false;
		var tag = baseGetTag(value$2);
		return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	/**
	* Checks if `value` is a valid array-like length.
	*
	* **Note:** This method is loosely based on
	* [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	* @example
	*
	* _.isLength(3);
	* // => true
	*
	* _.isLength(Number.MIN_VALUE);
	* // => false
	*
	* _.isLength(Infinity);
	* // => false
	*
	* _.isLength('3');
	* // => false
	*/
	function isLength(value$2) {
		return typeof value$2 == "number" && value$2 > -1 && value$2 % 1 == 0 && value$2 <= MAX_SAFE_INTEGER;
	}
	/**
	* Checks if `value` is the
	* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an object, else `false`.
	* @example
	*
	* _.isObject({});
	* // => true
	*
	* _.isObject([1, 2, 3]);
	* // => true
	*
	* _.isObject(_.noop);
	* // => true
	*
	* _.isObject(null);
	* // => false
	*/
	function isObject$1(value$2) {
		var type$5 = typeof value$2;
		return value$2 != null && (type$5 == "object" || type$5 == "function");
	}
	/**
	* Checks if `value` is object-like. A value is object-like if it's not `null`
	* and has a `typeof` result of "object".
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	* @example
	*
	* _.isObjectLike({});
	* // => true
	*
	* _.isObjectLike([1, 2, 3]);
	* // => true
	*
	* _.isObjectLike(_.noop);
	* // => false
	*
	* _.isObjectLike(null);
	* // => false
	*/
	function isObjectLike(value$2) {
		return value$2 != null && typeof value$2 == "object";
	}
	/**
	* Checks if `value` is a plain object, that is, an object created by the
	* `Object` constructor or one with a `[[Prototype]]` of `null`.
	*
	* @static
	* @memberOf _
	* @since 0.8.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	* @example
	*
	* function Foo() {
	*   this.a = 1;
	* }
	*
	* _.isPlainObject(new Foo);
	* // => false
	*
	* _.isPlainObject([1, 2, 3]);
	* // => false
	*
	* _.isPlainObject({ 'x': 0, 'y': 0 });
	* // => true
	*
	* _.isPlainObject(Object.create(null));
	* // => true
	*/
	function isPlainObject(value$2) {
		if (!isObjectLike(value$2) || baseGetTag(value$2) != objectTag) return false;
		var proto = getPrototype(value$2);
		if (proto === null) return true;
		var Ctor = hasOwnProperty$1.call(proto, "constructor") && proto.constructor;
		return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	/**
	* Checks if `value` is classified as a typed array.
	*
	* @static
	* @memberOf _
	* @since 3.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	* @example
	*
	* _.isTypedArray(new Uint8Array);
	* // => true
	*
	* _.isTypedArray([]);
	* // => false
	*/
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	/**
	* Converts `value` to a plain object flattening inherited enumerable string
	* keyed properties of `value` to own properties of the plain object.
	*
	* @static
	* @memberOf _
	* @since 3.0.0
	* @category Lang
	* @param {*} value The value to convert.
	* @returns {Object} Returns the converted plain object.
	* @example
	*
	* function Foo() {
	*   this.b = 2;
	* }
	*
	* Foo.prototype.c = 3;
	*
	* _.assign({ 'a': 1 }, new Foo);
	* // => { 'a': 1, 'b': 2 }
	*
	* _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	* // => { 'a': 1, 'b': 2, 'c': 3 }
	*/
	function toPlainObject(value$2) {
		return copyObject(value$2, keysIn(value$2));
	}
	/**
	* Creates an array of the own and inherited enumerable property names of `object`.
	*
	* **Note:** Non-object values are coerced to objects.
	*
	* @static
	* @memberOf _
	* @since 3.0.0
	* @category Object
	* @param {Object} object The object to query.
	* @returns {Array} Returns the array of property names.
	* @example
	*
	* function Foo() {
	*   this.a = 1;
	*   this.b = 2;
	* }
	*
	* Foo.prototype.c = 3;
	*
	* _.keysIn(new Foo);
	* // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	*/
	function keysIn(object$1) {
		return isArrayLike(object$1) ? arrayLikeKeys(object$1, true) : baseKeysIn(object$1);
	}
	/**
	* This method is like `_.assign` except that it recursively merges own and
	* inherited enumerable string keyed properties of source objects into the
	* destination object. Source properties that resolve to `undefined` are
	* skipped if a destination value exists. Array and plain object properties
	* are merged recursively. Other objects and value types are overridden by
	* assignment. Source objects are applied from left to right. Subsequent
	* sources overwrite property assignments of previous sources.
	*
	* **Note:** This method mutates `object`.
	*
	* @static
	* @memberOf _
	* @since 0.5.0
	* @category Object
	* @param {Object} object The destination object.
	* @param {...Object} [sources] The source objects.
	* @returns {Object} Returns `object`.
	* @example
	*
	* var object = {
	*   'a': [{ 'b': 2 }, { 'd': 4 }]
	* };
	*
	* var other = {
	*   'a': [{ 'c': 3 }, { 'e': 5 }]
	* };
	*
	* _.merge(object, other);
	* // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	*/
	var merge$1 = createAssigner(function(object$1, source, srcIndex) {
		baseMerge(object$1, source, srcIndex);
	});
	/**
	* Creates a function that returns `value`.
	*
	* @static
	* @memberOf _
	* @since 2.4.0
	* @category Util
	* @param {*} value The value to return from the new function.
	* @returns {Function} Returns the new constant function.
	* @example
	*
	* var objects = _.times(2, _.constant({ 'a': 1 }));
	*
	* console.log(objects);
	* // => [{ 'a': 1 }, { 'a': 1 }]
	*
	* console.log(objects[0] === objects[1]);
	* // => true
	*/
	function constant(value$2) {
		return function() {
			return value$2;
		};
	}
	/**
	* This method returns the first argument it receives.
	*
	* @static
	* @since 0.1.0
	* @memberOf _
	* @category Util
	* @param {*} value Any value.
	* @returns {*} Returns `value`.
	* @example
	*
	* var object = { 'a': 1 };
	*
	* console.log(_.identity(object) === object);
	* // => true
	*/
	function identity(value$2) {
		return value$2;
	}
	/**
	* This method returns `false`.
	*
	* @static
	* @memberOf _
	* @since 4.13.0
	* @category Util
	* @returns {boolean} Returns `false`.
	* @example
	*
	* _.times(2, _.stubFalse);
	* // => [false, false]
	*/
	function stubFalse() {
		return false;
	}
	module.exports = merge$1;
}) });

//#endregion
//#region node_modules/loglevel/lib/loglevel.js
var require_loglevel = /* @__PURE__ */ __commonJS({ "node_modules/loglevel/lib/loglevel.js": ((exports, module) => {
	(function(root$1, definition) {
		if (typeof define === "function" && define.amd) define(definition);
		else if (typeof module === "object" && module.exports) module.exports = definition();
		else root$1.log = definition();
	})(exports, function() {
		var noop$4 = function() {};
		var undefinedType = "undefined";
		var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
		var logMethods = [
			"trace",
			"debug",
			"info",
			"warn",
			"error"
		];
		var _loggersByName = {};
		var defaultLogger = null;
		function bindMethod(obj, methodName) {
			var method = obj[methodName];
			if (typeof method.bind === "function") return method.bind(obj);
			else try {
				return Function.prototype.bind.call(method, obj);
			} catch (e) {
				return function() {
					return Function.prototype.apply.apply(method, [obj, arguments]);
				};
			}
		}
		function traceForIE() {
			if (console.log) if (console.log.apply) console.log.apply(console, arguments);
			else Function.prototype.apply.apply(console.log, [console, arguments]);
			if (console.trace) console.trace();
		}
		function realMethod(methodName) {
			if (methodName === "debug") methodName = "log";
			if (typeof console === undefinedType) return false;
			else if (methodName === "trace" && isIE) return traceForIE;
			else if (console[methodName] !== void 0) return bindMethod(console, methodName);
			else if (console.log !== void 0) return bindMethod(console, "log");
			else return noop$4;
		}
		function replaceLoggingMethods() {
			var level = this.getLevel();
			for (var i = 0; i < logMethods.length; i++) {
				var methodName = logMethods[i];
				this[methodName] = i < level ? noop$4 : this.methodFactory(methodName, level, this.name);
			}
			this.log = this.debug;
			if (typeof console === undefinedType && level < this.levels.SILENT) return "No console available for logging";
		}
		function enableLoggingWhenConsoleArrives(methodName) {
			return function() {
				if (typeof console !== undefinedType) {
					replaceLoggingMethods.call(this);
					this[methodName].apply(this, arguments);
				}
			};
		}
		function defaultMethodFactory(methodName, _level, _loggerName) {
			return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
		}
		function Logger(name$1, factory) {
			var self$1 = this;
			/**
			* The level inherited from a parent logger (or a global default). We
			* cache this here rather than delegating to the parent so that it stays
			* in sync with the actual logging methods that we have installed (the
			* parent could change levels but we might not have rebuilt the loggers
			* in this child yet).
			* @type {number}
			*/
			var inheritedLevel;
			/**
			* The default level for this logger, if any. If set, this overrides
			* `inheritedLevel`.
			* @type {number|null}
			*/
			var defaultLevel;
			/**
			* A user-specific level for this logger. If set, this overrides
			* `defaultLevel`.
			* @type {number|null}
			*/
			var userLevel;
			var storageKey$2 = "loglevel";
			if (typeof name$1 === "string") storageKey$2 += ":" + name$1;
			else if (typeof name$1 === "symbol") storageKey$2 = void 0;
			function persistLevelIfPossible(levelNum) {
				var levelName = (logMethods[levelNum] || "silent").toUpperCase();
				if (typeof window === undefinedType || !storageKey$2) return;
				try {
					window.localStorage[storageKey$2] = levelName;
					return;
				} catch (ignore) {}
				try {
					window.document.cookie = encodeURIComponent(storageKey$2) + "=" + levelName + ";";
				} catch (ignore) {}
			}
			function getPersistedLevel() {
				var storedLevel;
				if (typeof window === undefinedType || !storageKey$2) return;
				try {
					storedLevel = window.localStorage[storageKey$2];
				} catch (ignore) {}
				if (typeof storedLevel === undefinedType) try {
					var cookie = window.document.cookie;
					var cookieName = encodeURIComponent(storageKey$2);
					var location$1 = cookie.indexOf(cookieName + "=");
					if (location$1 !== -1) storedLevel = /^([^;]+)/.exec(cookie.slice(location$1 + cookieName.length + 1))[1];
				} catch (ignore) {}
				if (self$1.levels[storedLevel] === void 0) storedLevel = void 0;
				return storedLevel;
			}
			function clearPersistedLevel() {
				if (typeof window === undefinedType || !storageKey$2) return;
				try {
					window.localStorage.removeItem(storageKey$2);
				} catch (ignore) {}
				try {
					window.document.cookie = encodeURIComponent(storageKey$2) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
				} catch (ignore) {}
			}
			function normalizeLevel(input) {
				var level = input;
				if (typeof level === "string" && self$1.levels[level.toUpperCase()] !== void 0) level = self$1.levels[level.toUpperCase()];
				if (typeof level === "number" && level >= 0 && level <= self$1.levels.SILENT) return level;
				else throw new TypeError("log.setLevel() called with invalid level: " + input);
			}
			self$1.name = name$1;
			self$1.levels = {
				"TRACE": 0,
				"DEBUG": 1,
				"INFO": 2,
				"WARN": 3,
				"ERROR": 4,
				"SILENT": 5
			};
			self$1.methodFactory = factory || defaultMethodFactory;
			self$1.getLevel = function() {
				if (userLevel != null) return userLevel;
				else if (defaultLevel != null) return defaultLevel;
				else return inheritedLevel;
			};
			self$1.setLevel = function(level, persist) {
				userLevel = normalizeLevel(level);
				if (persist !== false) persistLevelIfPossible(userLevel);
				return replaceLoggingMethods.call(self$1);
			};
			self$1.setDefaultLevel = function(level) {
				defaultLevel = normalizeLevel(level);
				if (!getPersistedLevel()) self$1.setLevel(level, false);
			};
			self$1.resetLevel = function() {
				userLevel = null;
				clearPersistedLevel();
				replaceLoggingMethods.call(self$1);
			};
			self$1.enableAll = function(persist) {
				self$1.setLevel(self$1.levels.TRACE, persist);
			};
			self$1.disableAll = function(persist) {
				self$1.setLevel(self$1.levels.SILENT, persist);
			};
			self$1.rebuild = function() {
				if (defaultLogger !== self$1) inheritedLevel = normalizeLevel(defaultLogger.getLevel());
				replaceLoggingMethods.call(self$1);
				if (defaultLogger === self$1) for (var childName in _loggersByName) _loggersByName[childName].rebuild();
			};
			inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : "WARN");
			var initialLevel = getPersistedLevel();
			if (initialLevel != null) userLevel = normalizeLevel(initialLevel);
			replaceLoggingMethods.call(self$1);
		}
		defaultLogger = new Logger();
		defaultLogger.getLogger = function getLogger(name$1) {
			if (typeof name$1 !== "symbol" && typeof name$1 !== "string" || name$1 === "") throw new TypeError("You must supply a name when creating a logger.");
			var logger = _loggersByName[name$1];
			if (!logger) logger = _loggersByName[name$1] = new Logger(name$1, defaultLogger.methodFactory);
			return logger;
		};
		var _log = typeof window !== undefinedType ? window.log : void 0;
		defaultLogger.noConflict = function() {
			if (typeof window !== undefinedType && window.log === defaultLogger) window.log = _log;
			return defaultLogger;
		};
		defaultLogger.getLoggers = function getLoggers() {
			return _loggersByName;
		};
		defaultLogger["default"] = defaultLogger;
		return defaultLogger;
	});
}) });

//#endregion
//#region node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js
var import_lodash = /* @__PURE__ */ __toESM(require_lodash());
var import_loglevel$3 = /* @__PURE__ */ __toESM(require_loglevel());
var log$3 = import_loglevel$3.default.getLogger("http-helpers");
log$3.setLevel(import_loglevel$3.levels.INFO);
var apiKey = "torus-default";
function setAPIKey(apiKey_) {
	apiKey = apiKey_;
}

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_assert.js
function number$1(n) {
	if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);
}
function bool(b) {
	if (typeof b !== "boolean") throw new Error(`boolean expected, not ${b}`);
}
function isBytes$1(a) {
	return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
	if (!isBytes$1(b)) throw new Error("Uint8Array expected");
	if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash(h) {
	if (typeof h !== "function" || typeof h.create !== "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
	number$1(h.outputLen);
	number$1(h.blockLen);
}
function exists(instance, checkFinished = true) {
	if (instance.destroyed) throw new Error("Hash instance has been destroyed");
	if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
	bytes(out);
	const min = instance.outputLen;
	if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);
}
var assert$1 = {
	number: number$1,
	bool,
	bytes,
	hash,
	exists,
	output
};
var _assert_default = assert$1;

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/crypto.js
const crypto$2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/utils.js
const u32 = (arr$1) => new Uint32Array(arr$1.buffer, arr$1.byteOffset, Math.floor(arr$1.byteLength / 4));
const createView = (arr$1) => new DataView(arr$1.buffer, arr$1.byteOffset, arr$1.byteLength);
const rotr = (word$1, shift) => word$1 << 32 - shift | word$1 >>> shift;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
const byteSwap = (word$1) => word$1 << 24 & 4278190080 | word$1 << 8 & 16711680 | word$1 >>> 8 & 65280 | word$1 >>> 24 & 255;
function byteSwap32(arr$1) {
	for (let i = 0; i < arr$1.length; i++) arr$1[i] = byteSwap(arr$1[i]);
}
/**
* @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
*/
function utf8ToBytes$1(str$1) {
	if (typeof str$1 !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str$1}`);
	return new Uint8Array(new TextEncoder().encode(str$1));
}
/**
* Normalizes (non-hex) string or Uint8Array to Uint8Array.
* Warning: when Uint8Array is passed, it would NOT get copied.
* Keep in mind for future mutable operations.
*/
function toBytes$1(data) {
	if (typeof data === "string") data = utf8ToBytes$1(data);
	bytes(data);
	return data;
}
/**
* Copies several Uint8Arrays into one.
*/
function concatBytes$1(...arrays) {
	let sum = 0;
	for (let i = 0; i < arrays.length; i++) {
		const a = arrays[i];
		bytes(a);
		sum += a.length;
	}
	const res = new Uint8Array(sum);
	for (let i = 0, pad = 0; i < arrays.length; i++) {
		const a = arrays[i];
		res.set(a, pad);
		pad += a.length;
	}
	return res;
}
var Hash = class {
	clone() {
		return this._cloneInto();
	}
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
	const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
	const tmp = hashCons();
	hashC.outputLen = tmp.outputLen;
	hashC.blockLen = tmp.blockLen;
	hashC.create = () => hashCons();
	return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
	const hashC = (msg, opts) => hashCons(opts).update(toBytes$1(msg)).digest();
	const tmp = hashCons({});
	hashC.outputLen = tmp.outputLen;
	hashC.blockLen = tmp.blockLen;
	hashC.create = (opts) => hashCons(opts);
	return hashC;
}
/**
* Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
*/
function randomBytes$1(bytesLength = 32) {
	if (crypto$2 && typeof crypto$2.getRandomValues === "function") return crypto$2.getRandomValues(new Uint8Array(bytesLength));
	throw new Error("crypto.getRandomValues must be defined");
}

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value$2, isLE$1) {
	if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value$2, isLE$1);
	const _32n$1 = BigInt(32);
	const _u32_max = BigInt(4294967295);
	const wh = Number(value$2 >> _32n$1 & _u32_max);
	const wl = Number(value$2 & _u32_max);
	const h = isLE$1 ? 4 : 0;
	const l = isLE$1 ? 0 : 4;
	view.setUint32(byteOffset + h, wh, isLE$1);
	view.setUint32(byteOffset + l, wl, isLE$1);
}
const Chi = (a, b, c) => a & b ^ ~a & c;
const Maj = (a, b, c) => a & b ^ a & c ^ b & c;
/**
* Merkle-Damgard hash construction base class.
* Could be used to create MD5, RIPEMD, SHA1, SHA2.
*/
var HashMD = class extends Hash {
	constructor(blockLen, outputLen, padOffset, isLE$1) {
		super();
		this.blockLen = blockLen;
		this.outputLen = outputLen;
		this.padOffset = padOffset;
		this.isLE = isLE$1;
		this.finished = false;
		this.length = 0;
		this.pos = 0;
		this.destroyed = false;
		this.buffer = new Uint8Array(blockLen);
		this.view = createView(this.buffer);
	}
	update(data) {
		exists(this);
		const { view, buffer, blockLen } = this;
		data = toBytes$1(data);
		const len = data.length;
		for (let pos = 0; pos < len;) {
			const take$1 = Math.min(blockLen - this.pos, len - pos);
			if (take$1 === blockLen) {
				const dataView = createView(data);
				for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
				continue;
			}
			buffer.set(data.subarray(pos, pos + take$1), this.pos);
			this.pos += take$1;
			pos += take$1;
			if (this.pos === blockLen) {
				this.process(view, 0);
				this.pos = 0;
			}
		}
		this.length += data.length;
		this.roundClean();
		return this;
	}
	digestInto(out) {
		exists(this);
		output(out, this);
		this.finished = true;
		const { buffer, view, blockLen, isLE: isLE$1 } = this;
		let { pos } = this;
		buffer[pos++] = 128;
		this.buffer.subarray(pos).fill(0);
		if (this.padOffset > blockLen - pos) {
			this.process(view, 0);
			pos = 0;
		}
		for (let i = pos; i < blockLen; i++) buffer[i] = 0;
		setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE$1);
		this.process(view, 0);
		const oview = createView(out);
		const len = this.outputLen;
		if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
		const outLen = len / 4;
		const state = this.get();
		if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
		for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE$1);
	}
	digest() {
		const { buffer, outputLen } = this;
		this.digestInto(buffer);
		const res = buffer.slice(0, outputLen);
		this.destroy();
		return res;
	}
	_cloneInto(to) {
		to || (to = new this.constructor());
		to.set(...this.get());
		const { blockLen, buffer, length, finished: finished$3, destroyed, pos } = this;
		to.length = length;
		to.pos = pos;
		to.finished = finished$3;
		to.destroyed = destroyed;
		if (length % blockLen) to.buffer.set(buffer);
		return to;
	}
};

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = /* @__PURE__ */ new Uint32Array([
	1116352408,
	1899447441,
	3049323471,
	3921009573,
	961987163,
	1508970993,
	2453635748,
	2870763221,
	3624381080,
	310598401,
	607225278,
	1426881987,
	1925078388,
	2162078206,
	2614888103,
	3248222580,
	3835390401,
	4022224774,
	264347078,
	604807628,
	770255983,
	1249150122,
	1555081692,
	1996064986,
	2554220882,
	2821834349,
	2952996808,
	3210313671,
	3336571891,
	3584528711,
	113926993,
	338241895,
	666307205,
	773529912,
	1294757372,
	1396182291,
	1695183700,
	1986661051,
	2177026350,
	2456956037,
	2730485921,
	2820302411,
	3259730800,
	3345764771,
	3516065817,
	3600352804,
	4094571909,
	275423344,
	430227734,
	506948616,
	659060556,
	883997877,
	958139571,
	1322822218,
	1537002063,
	1747873779,
	1955562222,
	2024104815,
	2227730452,
	2361852424,
	2428436474,
	2756734187,
	3204031479,
	3329325298
]);
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
	1779033703,
	3144134277,
	1013904242,
	2773480762,
	1359893119,
	2600822924,
	528734635,
	1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
	constructor() {
		super(64, 32, 8, false);
		this.A = SHA256_IV[0] | 0;
		this.B = SHA256_IV[1] | 0;
		this.C = SHA256_IV[2] | 0;
		this.D = SHA256_IV[3] | 0;
		this.E = SHA256_IV[4] | 0;
		this.F = SHA256_IV[5] | 0;
		this.G = SHA256_IV[6] | 0;
		this.H = SHA256_IV[7] | 0;
	}
	get() {
		const { A, B, C, D, E: E$1, F, G, H } = this;
		return [
			A,
			B,
			C,
			D,
			E$1,
			F,
			G,
			H
		];
	}
	set(A, B, C, D, E$1, F, G, H) {
		this.A = A | 0;
		this.B = B | 0;
		this.C = C | 0;
		this.D = D | 0;
		this.E = E$1 | 0;
		this.F = F | 0;
		this.G = G | 0;
		this.H = H | 0;
	}
	process(view, offset) {
		for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
		for (let i = 16; i < 64; i++) {
			const W15 = SHA256_W[i - 15];
			const W2 = SHA256_W[i - 2];
			const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
			SHA256_W[i] = (rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10) + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
		}
		let { A, B, C, D, E: E$1, F, G, H } = this;
		for (let i = 0; i < 64; i++) {
			const sigma1 = rotr(E$1, 6) ^ rotr(E$1, 11) ^ rotr(E$1, 25);
			const T1 = H + sigma1 + Chi(E$1, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
			const T2 = (rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22)) + Maj(A, B, C) | 0;
			H = G;
			G = F;
			F = E$1;
			E$1 = D + T1 | 0;
			D = C;
			C = B;
			B = A;
			A = T1 + T2 | 0;
		}
		A = A + this.A | 0;
		B = B + this.B | 0;
		C = C + this.C | 0;
		D = D + this.D | 0;
		E$1 = E$1 + this.E | 0;
		F = F + this.F | 0;
		G = G + this.G | 0;
		H = H + this.H | 0;
		this.set(A, B, C, D, E$1, F, G, H);
	}
	roundClean() {
		SHA256_W.fill(0);
	}
	destroy() {
		this.set(0, 0, 0, 0, 0, 0, 0, 0);
		this.buffer.fill(0);
	}
};
/**
* SHA2-256 hash function
* @param message - data that would be hashed
*/
const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
	constructor(hash$1, _key) {
		super();
		this.finished = false;
		this.destroyed = false;
		hash(hash$1);
		const key = toBytes$1(_key);
		this.iHash = hash$1.create();
		if (typeof this.iHash.update !== "function") throw new Error("Expected instance of class which extends utils.Hash");
		this.blockLen = this.iHash.blockLen;
		this.outputLen = this.iHash.outputLen;
		const blockLen = this.blockLen;
		const pad = new Uint8Array(blockLen);
		pad.set(key.length > blockLen ? hash$1.create().update(key).digest() : key);
		for (let i = 0; i < pad.length; i++) pad[i] ^= 54;
		this.iHash.update(pad);
		this.oHash = hash$1.create();
		for (let i = 0; i < pad.length; i++) pad[i] ^= 106;
		this.oHash.update(pad);
		pad.fill(0);
	}
	update(buf) {
		exists(this);
		this.iHash.update(buf);
		return this;
	}
	digestInto(out) {
		exists(this);
		bytes(out, this.outputLen);
		this.finished = true;
		this.iHash.digestInto(out);
		this.oHash.update(out);
		this.oHash.digestInto(out);
		this.destroy();
	}
	digest() {
		const out = new Uint8Array(this.oHash.outputLen);
		this.digestInto(out);
		return out;
	}
	_cloneInto(to) {
		to || (to = Object.create(Object.getPrototypeOf(this), {}));
		const { oHash, iHash, finished: finished$3, destroyed, blockLen, outputLen } = this;
		to = to;
		to.finished = finished$3;
		to.destroyed = destroyed;
		to.blockLen = blockLen;
		to.outputLen = outputLen;
		to.oHash = oHash._cloneInto(to.oHash);
		to.iHash = iHash._cloneInto(to.iHash);
		return to;
	}
	destroy() {
		this.destroyed = true;
		this.oHash.destroy();
		this.iHash.destroy();
	}
};
/**
* HMAC: RFC2104 message authentication code.
* @param hash - function that would be used e.g. sha256
* @param key - message key
* @param message - message data
*/
const hmac = (hash$1, key, message) => new HMAC(hash$1, key).update(message).digest();
hmac.create = (hash$1, key) => new HMAC(hash$1, key);

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = /* @__PURE__ */ __export({
	abytes: () => abytes,
	bitGet: () => bitGet,
	bitLen: () => bitLen,
	bitMask: () => bitMask,
	bitSet: () => bitSet,
	bytesToHex: () => bytesToHex$1,
	bytesToNumberBE: () => bytesToNumberBE,
	bytesToNumberLE: () => bytesToNumberLE,
	concatBytes: () => concatBytes$2,
	createHmacDrbg: () => createHmacDrbg,
	ensureBytes: () => ensureBytes,
	equalBytes: () => equalBytes,
	hexToBytes: () => hexToBytes$1,
	hexToNumber: () => hexToNumber,
	isBytes: () => isBytes,
	numberToBytesBE: () => numberToBytesBE,
	numberToBytesLE: () => numberToBytesLE,
	numberToHexUnpadded: () => numberToHexUnpadded,
	numberToVarBytesBE: () => numberToVarBytesBE,
	utf8ToBytes: () => utf8ToBytes,
	validateObject: () => validateObject
});
var _0n$4 = /* @__PURE__ */ BigInt(0);
var _1n$5 = /* @__PURE__ */ BigInt(1);
var _2n$4 = /* @__PURE__ */ BigInt(2);
function isBytes(a) {
	return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function abytes(item) {
	if (!isBytes(item)) throw new Error("Uint8Array expected");
}
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
/**
* @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
*/
function bytesToHex$1(bytes$1) {
	abytes(bytes$1);
	let hex = "";
	for (let i = 0; i < bytes$1.length; i++) hex += hexes[bytes$1[i]];
	return hex;
}
function numberToHexUnpadded(num) {
	const hex = num.toString(16);
	return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
	if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
	return BigInt(hex === "" ? "0" : `0x${hex}`);
}
var asciis = {
	_0: 48,
	_9: 57,
	_A: 65,
	_F: 70,
	_a: 97,
	_f: 102
};
function asciiToBase16(char) {
	if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
	if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
	if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
}
/**
* @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
*/
function hexToBytes$1(hex) {
	if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
	const hl = hex.length;
	const al = hl / 2;
	if (hl % 2) throw new Error("padded hex string expected, got unpadded hex of length " + hl);
	const array$1 = new Uint8Array(al);
	for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
		const n1 = asciiToBase16(hex.charCodeAt(hi));
		const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
		if (n1 === void 0 || n2 === void 0) {
			const char = hex[hi] + hex[hi + 1];
			throw new Error("hex string expected, got non-hex character \"" + char + "\" at index " + hi);
		}
		array$1[ai] = n1 * 16 + n2;
	}
	return array$1;
}
function bytesToNumberBE(bytes$1) {
	return hexToNumber(bytesToHex$1(bytes$1));
}
function bytesToNumberLE(bytes$1) {
	abytes(bytes$1);
	return hexToNumber(bytesToHex$1(Uint8Array.from(bytes$1).reverse()));
}
function numberToBytesBE(n, len) {
	return hexToBytes$1(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
	return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
	return hexToBytes$1(numberToHexUnpadded(n));
}
/**
* Takes hex string or Uint8Array, converts to Uint8Array.
* Validates output length.
* Will throw error for other types.
* @param title descriptive title for an error e.g. 'private key'
* @param hex hex string or Uint8Array
* @param expectedLength optional, will compare to result array's length
* @returns
*/
function ensureBytes(title, hex, expectedLength) {
	let res;
	if (typeof hex === "string") try {
		res = hexToBytes$1(hex);
	} catch (e) {
		throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
	}
	else if (isBytes(hex)) res = Uint8Array.from(hex);
	else throw new Error(`${title} must be hex string or Uint8Array`);
	const len = res.length;
	if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
	return res;
}
/**
* Copies several Uint8Arrays into one.
*/
function concatBytes$2(...arrays) {
	let sum = 0;
	for (let i = 0; i < arrays.length; i++) {
		const a = arrays[i];
		abytes(a);
		sum += a.length;
	}
	const res = new Uint8Array(sum);
	for (let i = 0, pad = 0; i < arrays.length; i++) {
		const a = arrays[i];
		res.set(a, pad);
		pad += a.length;
	}
	return res;
}
function equalBytes(a, b) {
	if (a.length !== b.length) return false;
	let diff = 0;
	for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
	return diff === 0;
}
/**
* @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
*/
function utf8ToBytes(str$1) {
	if (typeof str$1 !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str$1}`);
	return new Uint8Array(new TextEncoder().encode(str$1));
}
/**
* Calculates amount of bits in a bigint.
* Same as `n.toString(2).length`
*/
function bitLen(n) {
	let len;
	for (len = 0; n > _0n$4; n >>= _1n$5, len += 1);
	return len;
}
/**
* Gets single bit at position.
* NOTE: first bit position is 0 (same as arrays)
* Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
*/
function bitGet(n, pos) {
	return n >> BigInt(pos) & _1n$5;
}
/**
* Sets single bit at position.
*/
function bitSet(n, pos, value$2) {
	return n | (value$2 ? _1n$5 : _0n$4) << BigInt(pos);
}
/**
* Calculate mask for N bits. Not using ** operator with bigints because of old engines.
* Same as BigInt(`0b${Array(i).fill('1').join('')}`)
*/
const bitMask = (n) => (_2n$4 << BigInt(n - 1)) - _1n$5;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr$1) => Uint8Array.from(arr$1);
/**
* Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
* @returns function that will call DRBG until 2nd arg returns something meaningful
* @example
*   const drbg = createHmacDRBG<Key>(32, 32, hmac);
*   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
*/
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
	if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
	if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
	if (typeof hmacFn !== "function") throw new Error("hmacFn must be a function");
	let v = u8n(hashLen);
	let k = u8n(hashLen);
	let i = 0;
	const reset = () => {
		v.fill(1);
		k.fill(0);
		i = 0;
	};
	const h = (...b) => hmacFn(k, v, ...b);
	const reseed = (seed = u8n()) => {
		k = h(u8fr([0]), seed);
		v = h();
		if (seed.length === 0) return;
		k = h(u8fr([1]), seed);
		v = h();
	};
	const gen$1 = () => {
		if (i++ >= 1e3) throw new Error("drbg: tried 1000 values");
		let len = 0;
		const out = [];
		while (len < qByteLen) {
			v = h();
			const sl = v.slice();
			out.push(sl);
			len += v.length;
		}
		return concatBytes$2(...out);
	};
	const genUntil = (seed, pred) => {
		reset();
		reseed(seed);
		let res = void 0;
		while (!(res = pred(gen$1()))) reseed();
		reset();
		return res;
	};
	return genUntil;
}
var validatorFns = {
	bigint: (val) => typeof val === "bigint",
	function: (val) => typeof val === "function",
	boolean: (val) => typeof val === "boolean",
	string: (val) => typeof val === "string",
	stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
	isSafeInteger: (val) => Number.isSafeInteger(val),
	array: (val) => Array.isArray(val),
	field: (val, object$1) => object$1.Fp.isValid(val),
	hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object$1, validators, optValidators = {}) {
	const checkField = (fieldName, type$5, isOptional) => {
		const checkVal = validatorFns[type$5];
		if (typeof checkVal !== "function") throw new Error(`Invalid validator "${type$5}", expected function`);
		const val = object$1[fieldName];
		if (isOptional && val === void 0) return;
		if (!checkVal(val, object$1)) throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type$5}`);
	};
	for (const [fieldName, type$5] of Object.entries(validators)) checkField(fieldName, type$5, false);
	for (const [fieldName, type$5] of Object.entries(optValidators)) checkField(fieldName, type$5, true);
	return object$1;
}

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/modular.js
var _0n$3 = BigInt(0), _1n$4 = BigInt(1), _2n$3 = BigInt(2), _3n$1 = BigInt(3);
var _4n$1 = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
var _9n = BigInt(9), _16n = BigInt(16);
function mod(a, b) {
	const result = a % b;
	return result >= _0n$3 ? result : b + result;
}
/**
* Efficiently raise num to power and do modular division.
* Unsafe in some contexts: uses ladder, so can expose bigint bits.
* @example
* pow(2n, 6n, 11n) // 64n % 11n == 9n
*/
function pow(num, power, modulo) {
	if (modulo <= _0n$3 || power < _0n$3) throw new Error("Expected power/modulo > 0");
	if (modulo === _1n$4) return _0n$3;
	let res = _1n$4;
	while (power > _0n$3) {
		if (power & _1n$4) res = res * num % modulo;
		num = num * num % modulo;
		power >>= _1n$4;
	}
	return res;
}
function pow2(x, power, modulo) {
	let res = x;
	while (power-- > _0n$3) {
		res *= res;
		res %= modulo;
	}
	return res;
}
function invert(number$2, modulo) {
	if (number$2 === _0n$3 || modulo <= _0n$3) throw new Error(`invert: expected positive integers, got n=${number$2} mod=${modulo}`);
	let a = mod(number$2, modulo);
	let b = modulo;
	let x = _0n$3, y = _1n$4, u = _1n$4, v = _0n$3;
	while (a !== _0n$3) {
		const q = b / a;
		const r = b % a;
		const m = x - u * q;
		const n = y - v * q;
		b = a, a = r, x = u, y = v, u = m, v = n;
	}
	if (b !== _1n$4) throw new Error("invert: does not exist");
	return mod(x, modulo);
}
/**
* Tonelli-Shanks square root search algorithm.
* 1. https://eprint.iacr.org/2012/685.pdf (page 12)
* 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
* Will start an infinite loop if field order P is not prime.
* @param P field order
* @returns function that takes field Fp (created from P) and number n
*/
function tonelliShanks(P) {
	const legendreC = (P - _1n$4) / _2n$3;
	let Q, S, Z;
	for (Q = P - _1n$4, S = 0; Q % _2n$3 === _0n$3; Q /= _2n$3, S++);
	for (Z = _2n$3; Z < P && pow(Z, legendreC, P) !== P - _1n$4; Z++);
	if (S === 1) {
		const p1div4 = (P + _1n$4) / _4n$1;
		return function tonelliFast(Fp$1, n) {
			const root$1 = Fp$1.pow(n, p1div4);
			if (!Fp$1.eql(Fp$1.sqr(root$1), n)) throw new Error("Cannot find square root");
			return root$1;
		};
	}
	const Q1div2 = (Q + _1n$4) / _2n$3;
	return function tonelliSlow(Fp$1, n) {
		if (Fp$1.pow(n, legendreC) === Fp$1.neg(Fp$1.ONE)) throw new Error("Cannot find square root");
		let r = S;
		let g = Fp$1.pow(Fp$1.mul(Fp$1.ONE, Z), Q);
		let x = Fp$1.pow(n, Q1div2);
		let b = Fp$1.pow(n, Q);
		while (!Fp$1.eql(b, Fp$1.ONE)) {
			if (Fp$1.eql(b, Fp$1.ZERO)) return Fp$1.ZERO;
			let m = 1;
			for (let t2 = Fp$1.sqr(b); m < r; m++) {
				if (Fp$1.eql(t2, Fp$1.ONE)) break;
				t2 = Fp$1.sqr(t2);
			}
			const ge = Fp$1.pow(g, _1n$4 << BigInt(r - m - 1));
			g = Fp$1.sqr(ge);
			x = Fp$1.mul(x, ge);
			b = Fp$1.mul(b, g);
			r = m;
		}
		return x;
	};
}
function FpSqrt(P) {
	if (P % _4n$1 === _3n$1) {
		const p1div4 = (P + _1n$4) / _4n$1;
		return function sqrt3mod4(Fp$1, n) {
			const root$1 = Fp$1.pow(n, p1div4);
			if (!Fp$1.eql(Fp$1.sqr(root$1), n)) throw new Error("Cannot find square root");
			return root$1;
		};
	}
	if (P % _8n === _5n) {
		const c1 = (P - _5n) / _8n;
		return function sqrt5mod8(Fp$1, n) {
			const n2 = Fp$1.mul(n, _2n$3);
			const v = Fp$1.pow(n2, c1);
			const nv = Fp$1.mul(n, v);
			const i = Fp$1.mul(Fp$1.mul(nv, _2n$3), v);
			const root$1 = Fp$1.mul(nv, Fp$1.sub(i, Fp$1.ONE));
			if (!Fp$1.eql(Fp$1.sqr(root$1), n)) throw new Error("Cannot find square root");
			return root$1;
		};
	}
	if (P % _16n === _9n) {}
	return tonelliShanks(P);
}
var FIELD_FIELDS = [
	"create",
	"isValid",
	"is0",
	"neg",
	"inv",
	"sqrt",
	"sqr",
	"eql",
	"add",
	"sub",
	"mul",
	"pow",
	"div",
	"addN",
	"subN",
	"mulN",
	"sqrN"
];
function validateField(field) {
	return validateObject(field, FIELD_FIELDS.reduce((map$1, val) => {
		map$1[val] = "function";
		return map$1;
	}, {
		ORDER: "bigint",
		MASK: "bigint",
		BYTES: "isSafeInteger",
		BITS: "isSafeInteger"
	}));
}
/**
* Same as `pow` but for Fp: non-constant-time.
* Unsafe in some contexts: uses ladder, so can expose bigint bits.
*/
function FpPow(f, num, power) {
	if (power < _0n$3) throw new Error("Expected power > 0");
	if (power === _0n$3) return f.ONE;
	if (power === _1n$4) return num;
	let p = f.ONE;
	let d = num;
	while (power > _0n$3) {
		if (power & _1n$4) p = f.mul(p, d);
		d = f.sqr(d);
		power >>= _1n$4;
	}
	return p;
}
/**
* Efficiently invert an array of Field elements.
* `inv(0)` will return `undefined` here: make sure to throw an error.
*/
function FpInvertBatch(f, nums) {
	const tmp = new Array(nums.length);
	const lastMultiplied = nums.reduce((acc, num, i) => {
		if (f.is0(num)) return acc;
		tmp[i] = acc;
		return f.mul(acc, num);
	}, f.ONE);
	const inverted = f.inv(lastMultiplied);
	nums.reduceRight((acc, num, i) => {
		if (f.is0(num)) return acc;
		tmp[i] = f.mul(acc, tmp[i]);
		return f.mul(acc, num);
	}, inverted);
	return tmp;
}
function nLength(n, nBitLength) {
	const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
	return {
		nBitLength: _nBitLength,
		nByteLength: Math.ceil(_nBitLength / 8)
	};
}
/**
* Initializes a finite field over prime. **Non-primes are not supported.**
* Do not init in loop: slow. Very fragile: always run a benchmark on a change.
* Major performance optimizations:
* * a) denormalized operations like mulN instead of mul
* * b) same object shape: never add or remove keys
* * c) Object.freeze
* @param ORDER prime positive bigint
* @param bitLen how many bits the field consumes
* @param isLE (def: false) if encoding / decoding should be in little-endian
* @param redef optional faster redefinitions of sqrt and other methods
*/
function Field(ORDER, bitLen$1, isLE$1 = false, redef = {}) {
	if (ORDER <= _0n$3) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
	const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen$1);
	if (BYTES > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
	const sqrtP = FpSqrt(ORDER);
	const f = Object.freeze({
		ORDER,
		BITS,
		BYTES,
		MASK: bitMask(BITS),
		ZERO: _0n$3,
		ONE: _1n$4,
		create: (num) => mod(num, ORDER),
		isValid: (num) => {
			if (typeof num !== "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
			return _0n$3 <= num && num < ORDER;
		},
		is0: (num) => num === _0n$3,
		isOdd: (num) => (num & _1n$4) === _1n$4,
		neg: (num) => mod(-num, ORDER),
		eql: (lhs, rhs) => lhs === rhs,
		sqr: (num) => mod(num * num, ORDER),
		add: (lhs, rhs) => mod(lhs + rhs, ORDER),
		sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
		mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
		pow: (num, power) => FpPow(f, num, power),
		div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
		sqrN: (num) => num * num,
		addN: (lhs, rhs) => lhs + rhs,
		subN: (lhs, rhs) => lhs - rhs,
		mulN: (lhs, rhs) => lhs * rhs,
		inv: (num) => invert(num, ORDER),
		sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
		invertBatch: (lst) => FpInvertBatch(f, lst),
		cmov: (a, b, c) => c ? b : a,
		toBytes: (num) => isLE$1 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
		fromBytes: (bytes$1) => {
			if (bytes$1.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes$1.length}`);
			return isLE$1 ? bytesToNumberLE(bytes$1) : bytesToNumberBE(bytes$1);
		}
	});
	return Object.freeze(f);
}
/**
* Returns total number of bytes consumed by the field element.
* For example, 32 bytes for usual 256-bit weierstrass curve.
* @param fieldOrder number of field elements, usually CURVE.n
* @returns byte length of field
*/
function getFieldBytesLength(fieldOrder) {
	if (typeof fieldOrder !== "bigint") throw new Error("field order must be bigint");
	const bitLength = fieldOrder.toString(2).length;
	return Math.ceil(bitLength / 8);
}
/**
* Returns minimal amount of bytes that can be safely reduced
* by field order.
* Should be 2^-128 for 128-bit curve such as P256.
* @param fieldOrder number of field elements, usually CURVE.n
* @returns byte length of target hash
*/
function getMinHashLength(fieldOrder) {
	const length = getFieldBytesLength(fieldOrder);
	return length + Math.ceil(length / 2);
}
/**
* "Constant-time" private key generation utility.
* Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
* and convert them into private scalar, with the modulo bias being negligible.
* Needs at least 48 bytes of input for 32-byte private key.
* https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
* FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
* RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
* @param hash hash output from SHA3 or a similar function
* @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
* @param isLE interpret hash bytes as LE num
* @returns valid private scalar
*/
function mapHashToField(key, fieldOrder, isLE$1 = false) {
	const len = key.length;
	const fieldLen = getFieldBytesLength(fieldOrder);
	const minLen = getMinHashLength(fieldOrder);
	if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
	const reduced = mod(isLE$1 ? bytesToNumberBE(key) : bytesToNumberLE(key), fieldOrder - _1n$4) + _1n$4;
	return isLE$1 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/curve.js
var _0n$2 = BigInt(0);
var _1n$3 = BigInt(1);
function wNAF(c, bits) {
	const constTimeNegate = (condition, item) => {
		const neg = item.negate();
		return condition ? neg : item;
	};
	const opts = (W) => {
		return {
			windows: Math.ceil(bits / W) + 1,
			windowSize: 2 ** (W - 1)
		};
	};
	return {
		constTimeNegate,
		unsafeLadder(elm, n) {
			let p = c.ZERO;
			let d = elm;
			while (n > _0n$2) {
				if (n & _1n$3) p = p.add(d);
				d = d.double();
				n >>= _1n$3;
			}
			return p;
		},
		precomputeWindow(elm, W) {
			const { windows, windowSize } = opts(W);
			const points = [];
			let p = elm;
			let base = p;
			for (let window$1 = 0; window$1 < windows; window$1++) {
				base = p;
				points.push(base);
				for (let i = 1; i < windowSize; i++) {
					base = base.add(p);
					points.push(base);
				}
				p = base.double();
			}
			return points;
		},
		wNAF(W, precomputes, n) {
			const { windows, windowSize } = opts(W);
			let p = c.ZERO;
			let f = c.BASE;
			const mask = BigInt(2 ** W - 1);
			const maxNumber = 2 ** W;
			const shiftBy = BigInt(W);
			for (let window$1 = 0; window$1 < windows; window$1++) {
				const offset = window$1 * windowSize;
				let wbits = Number(n & mask);
				n >>= shiftBy;
				if (wbits > windowSize) {
					wbits -= maxNumber;
					n += _1n$3;
				}
				const offset1 = offset;
				const offset2 = offset + Math.abs(wbits) - 1;
				const cond1 = window$1 % 2 !== 0;
				const cond2 = wbits < 0;
				if (wbits === 0) f = f.add(constTimeNegate(cond1, precomputes[offset1]));
				else p = p.add(constTimeNegate(cond2, precomputes[offset2]));
			}
			return {
				p,
				f
			};
		},
		wNAFCached(P, precomputesMap, n, transform) {
			const W = P._WINDOW_SIZE || 1;
			let comp = precomputesMap.get(P);
			if (!comp) {
				comp = this.precomputeWindow(P, W);
				if (W !== 1) precomputesMap.set(P, transform(comp));
			}
			return this.wNAF(W, comp, n);
		}
	};
}
function validateBasic(curve) {
	validateField(curve.Fp);
	validateObject(curve, {
		n: "bigint",
		h: "bigint",
		Gx: "field",
		Gy: "field"
	}, {
		nBitLength: "isSafeInteger",
		nByteLength: "isSafeInteger"
	});
	return Object.freeze({
		...nLength(curve.n, curve.nBitLength),
		...curve,
		p: curve.Fp.ORDER
	});
}

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
	const opts = validateBasic(curve);
	validateObject(opts, {
		a: "field",
		b: "field"
	}, {
		allowedPrivateKeyLengths: "array",
		wrapPrivateKey: "boolean",
		isTorsionFree: "function",
		clearCofactor: "function",
		allowInfinityPoint: "boolean",
		fromBytes: "function",
		toBytes: "function"
	});
	const { endo, Fp: Fp$1, a } = opts;
	if (endo) {
		if (!Fp$1.eql(a, Fp$1.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
		if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
	}
	return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
const DER = {
	Err: class DERErr extends Error {
		constructor(m = "") {
			super(m);
		}
	},
	_parseInt(data) {
		const { Err: E$1 } = DER;
		if (data.length < 2 || data[0] !== 2) throw new E$1("Invalid signature integer tag");
		const len = data[1];
		const res = data.subarray(2, len + 2);
		if (!len || res.length !== len) throw new E$1("Invalid signature integer: wrong length");
		if (res[0] & 128) throw new E$1("Invalid signature integer: negative");
		if (res[0] === 0 && !(res[1] & 128)) throw new E$1("Invalid signature integer: unnecessary leading zero");
		return {
			d: b2n(res),
			l: data.subarray(len + 2)
		};
	},
	toSig(hex) {
		const { Err: E$1 } = DER;
		const data = typeof hex === "string" ? h2b(hex) : hex;
		abytes(data);
		let l = data.length;
		if (l < 2 || data[0] != 48) throw new E$1("Invalid signature tag");
		if (data[1] !== l - 2) throw new E$1("Invalid signature: incorrect length");
		const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
		const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
		if (rBytesLeft.length) throw new E$1("Invalid signature: left bytes after parsing");
		return {
			r,
			s
		};
	},
	hexFromSig(sig) {
		const slice$1 = (s$1) => Number.parseInt(s$1[0], 16) & 8 ? "00" + s$1 : s$1;
		const h = (num) => {
			const hex = num.toString(16);
			return hex.length & 1 ? `0${hex}` : hex;
		};
		const s = slice$1(h(sig.s));
		const r = slice$1(h(sig.r));
		const shl = s.length / 2;
		const rhl = r.length / 2;
		const sl = h(shl);
		const rl = h(rhl);
		return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
	}
};
var _0n$1 = BigInt(0), _1n$2 = BigInt(1), _2n$2 = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
	const CURVE = validatePointOpts(opts);
	const { Fp: Fp$1 } = CURVE;
	const toBytes$2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
		const a = point.toAffine();
		return concatBytes$2(Uint8Array.from([4]), Fp$1.toBytes(a.x), Fp$1.toBytes(a.y));
	});
	const fromBytes = CURVE.fromBytes || ((bytes$1) => {
		const tail = bytes$1.subarray(1);
		return {
			x: Fp$1.fromBytes(tail.subarray(0, Fp$1.BYTES)),
			y: Fp$1.fromBytes(tail.subarray(Fp$1.BYTES, 2 * Fp$1.BYTES))
		};
	});
	/**
	* y = x + ax + b: Short weierstrass curve formula
	* @returns y
	*/
	function weierstrassEquation(x) {
		const { a, b } = CURVE;
		const x2 = Fp$1.sqr(x);
		const x3 = Fp$1.mul(x2, x);
		return Fp$1.add(Fp$1.add(x3, Fp$1.mul(x, a)), b);
	}
	if (!Fp$1.eql(Fp$1.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error("bad generator point: equation left != right");
	function isWithinCurveOrder(num) {
		return typeof num === "bigint" && _0n$1 < num && num < CURVE.n;
	}
	function assertGE(num) {
		if (!isWithinCurveOrder(num)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
	}
	function normPrivateKeyToScalar(key) {
		const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
		if (lengths && typeof key !== "bigint") {
			if (isBytes(key)) key = bytesToHex$1(key);
			if (typeof key !== "string" || !lengths.includes(key.length)) throw new Error("Invalid key");
			key = key.padStart(nByteLength * 2, "0");
		}
		let num;
		try {
			num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
		} catch (error$1) {
			throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
		}
		if (wrapPrivateKey) num = mod(num, n);
		assertGE(num);
		return num;
	}
	const pointPrecomputes = /* @__PURE__ */ new Map();
	function assertPrjPoint(other) {
		if (!(other instanceof Point$1)) throw new Error("ProjectivePoint expected");
	}
	/**
	* Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
	* Default Point works in 2d / affine coordinates: (x, y)
	* We're doing calculations in projective, because its operations don't require costly inversion.
	*/
	class Point$1 {
		constructor(px, py, pz) {
			this.px = px;
			this.py = py;
			this.pz = pz;
			if (px == null || !Fp$1.isValid(px)) throw new Error("x required");
			if (py == null || !Fp$1.isValid(py)) throw new Error("y required");
			if (pz == null || !Fp$1.isValid(pz)) throw new Error("z required");
		}
		static fromAffine(p) {
			const { x, y } = p || {};
			if (!p || !Fp$1.isValid(x) || !Fp$1.isValid(y)) throw new Error("invalid affine point");
			if (p instanceof Point$1) throw new Error("projective point not allowed");
			const is0 = (i) => Fp$1.eql(i, Fp$1.ZERO);
			if (is0(x) && is0(y)) return Point$1.ZERO;
			return new Point$1(x, y, Fp$1.ONE);
		}
		get x() {
			return this.toAffine().x;
		}
		get y() {
			return this.toAffine().y;
		}
		/**
		* Takes a bunch of Projective Points but executes only one
		* inversion on all of them. Inversion is very slow operation,
		* so this improves performance massively.
		* Optimization: converts a list of projective points to a list of identical points with Z=1.
		*/
		static normalizeZ(points) {
			const toInv = Fp$1.invertBatch(points.map((p) => p.pz));
			return points.map((p, i) => p.toAffine(toInv[i])).map(Point$1.fromAffine);
		}
		/**
		* Converts hash string or Uint8Array to Point.
		* @param hex short/long ECDSA hex
		*/
		static fromHex(hex) {
			const P = Point$1.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
			P.assertValidity();
			return P;
		}
		static fromPrivateKey(privateKey) {
			return Point$1.BASE.multiply(normPrivateKeyToScalar(privateKey));
		}
		_setWindowSize(windowSize) {
			this._WINDOW_SIZE = windowSize;
			pointPrecomputes.delete(this);
		}
		assertValidity() {
			if (this.is0()) {
				if (CURVE.allowInfinityPoint && !Fp$1.is0(this.py)) return;
				throw new Error("bad point: ZERO");
			}
			const { x, y } = this.toAffine();
			if (!Fp$1.isValid(x) || !Fp$1.isValid(y)) throw new Error("bad point: x or y not FE");
			const left = Fp$1.sqr(y);
			const right = weierstrassEquation(x);
			if (!Fp$1.eql(left, right)) throw new Error("bad point: equation left != right");
			if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
		}
		hasEvenY() {
			const { y } = this.toAffine();
			if (Fp$1.isOdd) return !Fp$1.isOdd(y);
			throw new Error("Field doesn't support isOdd");
		}
		/**
		* Compare one point to another.
		*/
		equals(other) {
			assertPrjPoint(other);
			const { px: X1, py: Y1, pz: Z1 } = this;
			const { px: X2, py: Y2, pz: Z2 } = other;
			const U1 = Fp$1.eql(Fp$1.mul(X1, Z2), Fp$1.mul(X2, Z1));
			const U2 = Fp$1.eql(Fp$1.mul(Y1, Z2), Fp$1.mul(Y2, Z1));
			return U1 && U2;
		}
		/**
		* Flips point to one corresponding to (x, -y) in Affine coordinates.
		*/
		negate() {
			return new Point$1(this.px, Fp$1.neg(this.py), this.pz);
		}
		double() {
			const { a, b } = CURVE;
			const b3 = Fp$1.mul(b, _3n);
			const { px: X1, py: Y1, pz: Z1 } = this;
			let X3 = Fp$1.ZERO, Y3 = Fp$1.ZERO, Z3 = Fp$1.ZERO;
			let t0 = Fp$1.mul(X1, X1);
			let t1 = Fp$1.mul(Y1, Y1);
			let t2 = Fp$1.mul(Z1, Z1);
			let t3 = Fp$1.mul(X1, Y1);
			t3 = Fp$1.add(t3, t3);
			Z3 = Fp$1.mul(X1, Z1);
			Z3 = Fp$1.add(Z3, Z3);
			X3 = Fp$1.mul(a, Z3);
			Y3 = Fp$1.mul(b3, t2);
			Y3 = Fp$1.add(X3, Y3);
			X3 = Fp$1.sub(t1, Y3);
			Y3 = Fp$1.add(t1, Y3);
			Y3 = Fp$1.mul(X3, Y3);
			X3 = Fp$1.mul(t3, X3);
			Z3 = Fp$1.mul(b3, Z3);
			t2 = Fp$1.mul(a, t2);
			t3 = Fp$1.sub(t0, t2);
			t3 = Fp$1.mul(a, t3);
			t3 = Fp$1.add(t3, Z3);
			Z3 = Fp$1.add(t0, t0);
			t0 = Fp$1.add(Z3, t0);
			t0 = Fp$1.add(t0, t2);
			t0 = Fp$1.mul(t0, t3);
			Y3 = Fp$1.add(Y3, t0);
			t2 = Fp$1.mul(Y1, Z1);
			t2 = Fp$1.add(t2, t2);
			t0 = Fp$1.mul(t2, t3);
			X3 = Fp$1.sub(X3, t0);
			Z3 = Fp$1.mul(t2, t1);
			Z3 = Fp$1.add(Z3, Z3);
			Z3 = Fp$1.add(Z3, Z3);
			return new Point$1(X3, Y3, Z3);
		}
		add(other) {
			assertPrjPoint(other);
			const { px: X1, py: Y1, pz: Z1 } = this;
			const { px: X2, py: Y2, pz: Z2 } = other;
			let X3 = Fp$1.ZERO, Y3 = Fp$1.ZERO, Z3 = Fp$1.ZERO;
			const a = CURVE.a;
			const b3 = Fp$1.mul(CURVE.b, _3n);
			let t0 = Fp$1.mul(X1, X2);
			let t1 = Fp$1.mul(Y1, Y2);
			let t2 = Fp$1.mul(Z1, Z2);
			let t3 = Fp$1.add(X1, Y1);
			let t4 = Fp$1.add(X2, Y2);
			t3 = Fp$1.mul(t3, t4);
			t4 = Fp$1.add(t0, t1);
			t3 = Fp$1.sub(t3, t4);
			t4 = Fp$1.add(X1, Z1);
			let t5 = Fp$1.add(X2, Z2);
			t4 = Fp$1.mul(t4, t5);
			t5 = Fp$1.add(t0, t2);
			t4 = Fp$1.sub(t4, t5);
			t5 = Fp$1.add(Y1, Z1);
			X3 = Fp$1.add(Y2, Z2);
			t5 = Fp$1.mul(t5, X3);
			X3 = Fp$1.add(t1, t2);
			t5 = Fp$1.sub(t5, X3);
			Z3 = Fp$1.mul(a, t4);
			X3 = Fp$1.mul(b3, t2);
			Z3 = Fp$1.add(X3, Z3);
			X3 = Fp$1.sub(t1, Z3);
			Z3 = Fp$1.add(t1, Z3);
			Y3 = Fp$1.mul(X3, Z3);
			t1 = Fp$1.add(t0, t0);
			t1 = Fp$1.add(t1, t0);
			t2 = Fp$1.mul(a, t2);
			t4 = Fp$1.mul(b3, t4);
			t1 = Fp$1.add(t1, t2);
			t2 = Fp$1.sub(t0, t2);
			t2 = Fp$1.mul(a, t2);
			t4 = Fp$1.add(t4, t2);
			t0 = Fp$1.mul(t1, t4);
			Y3 = Fp$1.add(Y3, t0);
			t0 = Fp$1.mul(t5, t4);
			X3 = Fp$1.mul(t3, X3);
			X3 = Fp$1.sub(X3, t0);
			t0 = Fp$1.mul(t3, t1);
			Z3 = Fp$1.mul(t5, Z3);
			Z3 = Fp$1.add(Z3, t0);
			return new Point$1(X3, Y3, Z3);
		}
		subtract(other) {
			return this.add(other.negate());
		}
		is0() {
			return this.equals(Point$1.ZERO);
		}
		wNAF(n) {
			return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
				const toInv = Fp$1.invertBatch(comp.map((p) => p.pz));
				return comp.map((p, i) => p.toAffine(toInv[i])).map(Point$1.fromAffine);
			});
		}
		/**
		* Non-constant-time multiplication. Uses double-and-add algorithm.
		* It's faster, but should only be used when you don't care about
		* an exposed private key e.g. sig verification, which works over *public* keys.
		*/
		multiplyUnsafe(n) {
			const I = Point$1.ZERO;
			if (n === _0n$1) return I;
			assertGE(n);
			if (n === _1n$2) return this;
			const { endo } = CURVE;
			if (!endo) return wnaf.unsafeLadder(this, n);
			let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
			let k1p = I;
			let k2p = I;
			let d = this;
			while (k1 > _0n$1 || k2 > _0n$1) {
				if (k1 & _1n$2) k1p = k1p.add(d);
				if (k2 & _1n$2) k2p = k2p.add(d);
				d = d.double();
				k1 >>= _1n$2;
				k2 >>= _1n$2;
			}
			if (k1neg) k1p = k1p.negate();
			if (k2neg) k2p = k2p.negate();
			k2p = new Point$1(Fp$1.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
			return k1p.add(k2p);
		}
		/**
		* Constant time multiplication.
		* Uses wNAF method. Windowed method may be 10% faster,
		* but takes 2x longer to generate and consumes 2x memory.
		* Uses precomputes when available.
		* Uses endomorphism for Koblitz curves.
		* @param scalar by which the point would be multiplied
		* @returns New point
		*/
		multiply(scalar) {
			assertGE(scalar);
			let n = scalar;
			let point, fake;
			const { endo } = CURVE;
			if (endo) {
				const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
				let { p: k1p, f: f1p } = this.wNAF(k1);
				let { p: k2p, f: f2p } = this.wNAF(k2);
				k1p = wnaf.constTimeNegate(k1neg, k1p);
				k2p = wnaf.constTimeNegate(k2neg, k2p);
				k2p = new Point$1(Fp$1.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
				point = k1p.add(k2p);
				fake = f1p.add(f2p);
			} else {
				const { p, f } = this.wNAF(n);
				point = p;
				fake = f;
			}
			return Point$1.normalizeZ([point, fake])[0];
		}
		/**
		* Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
		* Not using Strauss-Shamir trick: precomputation tables are faster.
		* The trick could be useful if both P and Q are not G (not in our case).
		* @returns non-zero affine point
		*/
		multiplyAndAddUnsafe(Q, a, b) {
			const G = Point$1.BASE;
			const mul = (P, a$1) => a$1 === _0n$1 || a$1 === _1n$2 || !P.equals(G) ? P.multiplyUnsafe(a$1) : P.multiply(a$1);
			const sum = mul(this, a).add(mul(Q, b));
			return sum.is0() ? void 0 : sum;
		}
		toAffine(iz) {
			const { px: x, py: y, pz: z } = this;
			const is0 = this.is0();
			if (iz == null) iz = is0 ? Fp$1.ONE : Fp$1.inv(z);
			const ax = Fp$1.mul(x, iz);
			const ay = Fp$1.mul(y, iz);
			const zz = Fp$1.mul(z, iz);
			if (is0) return {
				x: Fp$1.ZERO,
				y: Fp$1.ZERO
			};
			if (!Fp$1.eql(zz, Fp$1.ONE)) throw new Error("invZ was invalid");
			return {
				x: ax,
				y: ay
			};
		}
		isTorsionFree() {
			const { h: cofactor, isTorsionFree } = CURVE;
			if (cofactor === _1n$2) return true;
			if (isTorsionFree) return isTorsionFree(Point$1, this);
			throw new Error("isTorsionFree() has not been declared for the elliptic curve");
		}
		clearCofactor() {
			const { h: cofactor, clearCofactor } = CURVE;
			if (cofactor === _1n$2) return this;
			if (clearCofactor) return clearCofactor(Point$1, this);
			return this.multiplyUnsafe(CURVE.h);
		}
		toRawBytes(isCompressed = true) {
			this.assertValidity();
			return toBytes$2(Point$1, this, isCompressed);
		}
		toHex(isCompressed = true) {
			return bytesToHex$1(this.toRawBytes(isCompressed));
		}
	}
	Point$1.BASE = new Point$1(CURVE.Gx, CURVE.Gy, Fp$1.ONE);
	Point$1.ZERO = new Point$1(Fp$1.ZERO, Fp$1.ONE, Fp$1.ZERO);
	const _bits = CURVE.nBitLength;
	const wnaf = wNAF(Point$1, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
	return {
		CURVE,
		ProjectivePoint: Point$1,
		normPrivateKeyToScalar,
		weierstrassEquation,
		isWithinCurveOrder
	};
}
function validateOpts(curve) {
	const opts = validateBasic(curve);
	validateObject(opts, {
		hash: "hash",
		hmac: "function",
		randomBytes: "function"
	}, {
		bits2int: "function",
		bits2int_modN: "function",
		lowS: "boolean"
	});
	return Object.freeze({
		lowS: true,
		...opts
	});
}
function weierstrass(curveDef) {
	const CURVE = validateOpts(curveDef);
	const { Fp: Fp$1, n: CURVE_ORDER } = CURVE;
	const compressedLen = Fp$1.BYTES + 1;
	const uncompressedLen = 2 * Fp$1.BYTES + 1;
	function isValidFieldElement(num) {
		return _0n$1 < num && num < Fp$1.ORDER;
	}
	function modN(a) {
		return mod(a, CURVE_ORDER);
	}
	function invN(a) {
		return invert(a, CURVE_ORDER);
	}
	const { ProjectivePoint: Point$1, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
		...CURVE,
		toBytes(_c, point, isCompressed) {
			const a = point.toAffine();
			const x = Fp$1.toBytes(a.x);
			const cat = concatBytes$2;
			if (isCompressed) return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
			else return cat(Uint8Array.from([4]), x, Fp$1.toBytes(a.y));
		},
		fromBytes(bytes$1) {
			const len = bytes$1.length;
			const head = bytes$1[0];
			const tail = bytes$1.subarray(1);
			if (len === compressedLen && (head === 2 || head === 3)) {
				const x = bytesToNumberBE(tail);
				if (!isValidFieldElement(x)) throw new Error("Point is not on curve");
				const y2 = weierstrassEquation(x);
				let y;
				try {
					y = Fp$1.sqrt(y2);
				} catch (sqrtError) {
					const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
					throw new Error("Point is not on curve" + suffix);
				}
				const isYOdd = (y & _1n$2) === _1n$2;
				if ((head & 1) === 1 !== isYOdd) y = Fp$1.neg(y);
				return {
					x,
					y
				};
			} else if (len === uncompressedLen && head === 4) return {
				x: Fp$1.fromBytes(tail.subarray(0, Fp$1.BYTES)),
				y: Fp$1.fromBytes(tail.subarray(Fp$1.BYTES, 2 * Fp$1.BYTES))
			};
			else throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
		}
	});
	const numToNByteStr = (num) => bytesToHex$1(numberToBytesBE(num, CURVE.nByteLength));
	function isBiggerThanHalfOrder(number$2) {
		return number$2 > CURVE_ORDER >> _1n$2;
	}
	function normalizeS(s) {
		return isBiggerThanHalfOrder(s) ? modN(-s) : s;
	}
	const slcNum = (b, from$3, to) => bytesToNumberBE(b.slice(from$3, to));
	/**
	* ECDSA signature with its (r, s) properties. Supports DER & compact representations.
	*/
	class Signature {
		constructor(r, s, recovery) {
			this.r = r;
			this.s = s;
			this.recovery = recovery;
			this.assertValidity();
		}
		static fromCompact(hex) {
			const l = CURVE.nByteLength;
			hex = ensureBytes("compactSignature", hex, l * 2);
			return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
		}
		static fromDER(hex) {
			const { r, s } = DER.toSig(ensureBytes("DER", hex));
			return new Signature(r, s);
		}
		assertValidity() {
			if (!isWithinCurveOrder(this.r)) throw new Error("r must be 0 < r < CURVE.n");
			if (!isWithinCurveOrder(this.s)) throw new Error("s must be 0 < s < CURVE.n");
		}
		addRecoveryBit(recovery) {
			return new Signature(this.r, this.s, recovery);
		}
		recoverPublicKey(msgHash) {
			const { r, s, recovery: rec } = this;
			const h = bits2int_modN(ensureBytes("msgHash", msgHash));
			if (rec == null || ![
				0,
				1,
				2,
				3
			].includes(rec)) throw new Error("recovery id invalid");
			const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
			if (radj >= Fp$1.ORDER) throw new Error("recovery id 2 or 3 invalid");
			const prefix = (rec & 1) === 0 ? "02" : "03";
			const R = Point$1.fromHex(prefix + numToNByteStr(radj));
			const ir = invN(radj);
			const u1 = modN(-h * ir);
			const u2 = modN(s * ir);
			const Q = Point$1.BASE.multiplyAndAddUnsafe(R, u1, u2);
			if (!Q) throw new Error("point at infinify");
			Q.assertValidity();
			return Q;
		}
		hasHighS() {
			return isBiggerThanHalfOrder(this.s);
		}
		normalizeS() {
			return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
		}
		toDERRawBytes() {
			return hexToBytes$1(this.toDERHex());
		}
		toDERHex() {
			return DER.hexFromSig({
				r: this.r,
				s: this.s
			});
		}
		toCompactRawBytes() {
			return hexToBytes$1(this.toCompactHex());
		}
		toCompactHex() {
			return numToNByteStr(this.r) + numToNByteStr(this.s);
		}
	}
	const utils$1 = {
		isValidPrivateKey(privateKey) {
			try {
				normPrivateKeyToScalar(privateKey);
				return true;
			} catch (error$1) {
				return false;
			}
		},
		normPrivateKeyToScalar,
		randomPrivateKey: () => {
			const length = getMinHashLength(CURVE.n);
			return mapHashToField(CURVE.randomBytes(length), CURVE.n);
		},
		precompute(windowSize = 8, point = Point$1.BASE) {
			point._setWindowSize(windowSize);
			point.multiply(BigInt(3));
			return point;
		}
	};
	/**
	* Computes public key for a private key. Checks for validity of the private key.
	* @param privateKey private key
	* @param isCompressed whether to return compact (default), or full key
	* @returns Public key, full when isCompressed=false; short when isCompressed=true
	*/
	function getPublicKey(privateKey, isCompressed = true) {
		return Point$1.fromPrivateKey(privateKey).toRawBytes(isCompressed);
	}
	/**
	* Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
	*/
	function isProbPub(item) {
		const arr$1 = isBytes(item);
		const str$1 = typeof item === "string";
		const len = (arr$1 || str$1) && item.length;
		if (arr$1) return len === compressedLen || len === uncompressedLen;
		if (str$1) return len === 2 * compressedLen || len === 2 * uncompressedLen;
		if (item instanceof Point$1) return true;
		return false;
	}
	/**
	* ECDH (Elliptic Curve Diffie Hellman).
	* Computes shared public key from private key and public key.
	* Checks: 1) private key validity 2) shared key is on-curve.
	* Does NOT hash the result.
	* @param privateA private key
	* @param publicB different public key
	* @param isCompressed whether to return compact (default), or full key
	* @returns shared public key
	*/
	function getSharedSecret(privateA, publicB, isCompressed = true) {
		if (isProbPub(privateA)) throw new Error("first arg must be private key");
		if (!isProbPub(publicB)) throw new Error("second arg must be public key");
		return Point$1.fromHex(publicB).multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
	}
	const bits2int = CURVE.bits2int || function(bytes$1) {
		const num = bytesToNumberBE(bytes$1);
		const delta = bytes$1.length * 8 - CURVE.nBitLength;
		return delta > 0 ? num >> BigInt(delta) : num;
	};
	const bits2int_modN = CURVE.bits2int_modN || function(bytes$1) {
		return modN(bits2int(bytes$1));
	};
	const ORDER_MASK = bitMask(CURVE.nBitLength);
	/**
	* Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
	*/
	function int2octets(num) {
		if (typeof num !== "bigint") throw new Error("bigint expected");
		if (!(_0n$1 <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
		return numberToBytesBE(num, CURVE.nByteLength);
	}
	function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
		if (["recovered", "canonical"].some((k) => k in opts)) throw new Error("sign() legacy options not supported");
		const { hash: hash$1, randomBytes: randomBytes$2 } = CURVE;
		let { lowS, prehash, extraEntropy: ent } = opts;
		if (lowS == null) lowS = true;
		msgHash = ensureBytes("msgHash", msgHash);
		if (prehash) msgHash = ensureBytes("prehashed msgHash", hash$1(msgHash));
		const h1int = bits2int_modN(msgHash);
		const d = normPrivateKeyToScalar(privateKey);
		const seedArgs = [int2octets(d), int2octets(h1int)];
		if (ent != null && ent !== false) {
			const e = ent === true ? randomBytes$2(Fp$1.BYTES) : ent;
			seedArgs.push(ensureBytes("extraEntropy", e));
		}
		const seed = concatBytes$2(...seedArgs);
		const m = h1int;
		function k2sig(kBytes) {
			const k = bits2int(kBytes);
			if (!isWithinCurveOrder(k)) return;
			const ik = invN(k);
			const q = Point$1.BASE.multiply(k).toAffine();
			const r = modN(q.x);
			if (r === _0n$1) return;
			const s = modN(ik * modN(m + r * d));
			if (s === _0n$1) return;
			let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$2);
			let normS = s;
			if (lowS && isBiggerThanHalfOrder(s)) {
				normS = normalizeS(s);
				recovery ^= 1;
			}
			return new Signature(r, normS, recovery);
		}
		return {
			seed,
			k2sig
		};
	}
	const defaultSigOpts = {
		lowS: CURVE.lowS,
		prehash: false
	};
	const defaultVerOpts = {
		lowS: CURVE.lowS,
		prehash: false
	};
	/**
	* Signs message hash with a private key.
	* ```
	* sign(m, d, k) where
	*   (x, y) = G  k
	*   r = x mod n
	*   s = (m + dr)/k mod n
	* ```
	* @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
	* @param privKey private key
	* @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
	* @returns signature with recovery param
	*/
	function sign$1(msgHash, privKey, opts = defaultSigOpts) {
		const { seed, k2sig } = prepSig(msgHash, privKey, opts);
		const C = CURVE;
		return createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac)(seed, k2sig);
	}
	Point$1.BASE._setWindowSize(8);
	/**
	* Verifies a signature against message hash and public key.
	* Rejects lowS signatures by default: to override,
	* specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
	*
	* ```
	* verify(r, s, h, P) where
	*   U1 = hs^-1 mod n
	*   U2 = rs^-1 mod n
	*   R = U1G - U2P
	*   mod(R.x, n) == r
	* ```
	*/
	function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
		const sg = signature;
		msgHash = ensureBytes("msgHash", msgHash);
		publicKey = ensureBytes("publicKey", publicKey);
		if ("strict" in opts) throw new Error("options.strict was renamed to lowS");
		const { lowS, prehash } = opts;
		let _sig = void 0;
		let P;
		try {
			if (typeof sg === "string" || isBytes(sg)) try {
				_sig = Signature.fromDER(sg);
			} catch (derError) {
				if (!(derError instanceof DER.Err)) throw derError;
				_sig = Signature.fromCompact(sg);
			}
			else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
				const { r: r$1, s: s$1 } = sg;
				_sig = new Signature(r$1, s$1);
			} else throw new Error("PARSE");
			P = Point$1.fromHex(publicKey);
		} catch (error$1) {
			if (error$1.message === "PARSE") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
			return false;
		}
		if (lowS && _sig.hasHighS()) return false;
		if (prehash) msgHash = CURVE.hash(msgHash);
		const { r, s } = _sig;
		const h = bits2int_modN(msgHash);
		const is = invN(s);
		const u1 = modN(h * is);
		const u2 = modN(r * is);
		const R = Point$1.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
		if (!R) return false;
		return modN(R.x) === r;
	}
	return {
		CURVE,
		getPublicKey,
		getSharedSecret,
		sign: sign$1,
		verify,
		ProjectivePoint: Point$1,
		Signature,
		utils: utils$1
	};
}

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash$1) {
	return {
		hash: hash$1,
		hmac: (key, ...msgs) => hmac(hash$1, key, concatBytes$1(...msgs)),
		randomBytes: randomBytes$1
	};
}
function createCurve(curveDef, defHash) {
	const create$5 = (hash$1) => weierstrass({
		...curveDef,
		...getHash(hash$1)
	});
	return Object.freeze({
		...create$5(defHash),
		create: create$5
	});
}

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n$1 = BigInt(1);
var _2n$1 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n$1) / b;
/**
* n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
* (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
*/
function sqrtMod(y) {
	const P = secp256k1P;
	const _3n$2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
	const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
	const b2 = y * y * y % P;
	const b3 = b2 * b2 * y % P;
	const b11 = pow2(pow2(pow2(b3, _3n$2, P) * b3 % P, _3n$2, P) * b3 % P, _2n$1, P) * b2 % P;
	const b22 = pow2(b11, _11n, P) * b11 % P;
	const b44 = pow2(b22, _22n, P) * b22 % P;
	const b88 = pow2(b44, _44n, P) * b44 % P;
	const root$1 = pow2(pow2(pow2(pow2(pow2(pow2(b88, _88n, P) * b88 % P, _44n, P) * b44 % P, _3n$2, P) * b3 % P, _23n, P) * b22 % P, _6n, P) * b2 % P, _2n$1, P);
	if (!Fp.eql(Fp.sqr(root$1), y)) throw new Error("Cannot find square root");
	return root$1;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
	a: BigInt(0),
	b: BigInt(7),
	Fp,
	n: secp256k1N,
	Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
	Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
	h: BigInt(1),
	lowS: true,
	endo: {
		beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
		splitScalar: (k) => {
			const n = secp256k1N;
			const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
			const b1 = -_1n$1 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
			const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
			const b2 = a1;
			const POW_2_128 = BigInt("0x100000000000000000000000000000000");
			const c1 = divNearest(b2 * k, n);
			const c2 = divNearest(-b1 * k, n);
			let k1 = mod(k - c1 * a1 - c2 * a2, n);
			let k2 = mod(-c1 * b1 - c2 * b2, n);
			const k1neg = k1 > POW_2_128;
			const k2neg = k2 > POW_2_128;
			if (k1neg) k1 = n - k1;
			if (k2neg) k2 = n - k2;
			if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error("splitScalar: Endomorphism failed, k=" + k);
			return {
				k1neg,
				k1,
				k2neg,
				k2
			};
		}
	}
}, sha256);
var Point = secp256k1.ProjectivePoint;

//#endregion
//#region node_modules/ethereum-cryptography/esm/utils.js
var assertBool = _assert_default.bool;
var assertBytes = _assert_default.bytes;
function wrapHash(hash$1) {
	return (msg) => {
		_assert_default.bytes(msg);
		return hash$1(msg);
	};
}
const crypto$1 = (() => {
	const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
	const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
	return {
		node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
		web: webCrypto
	};
})();

//#endregion
//#region node_modules/@ethereumjs/util/dist/esm/internal.js
/**
* Pads a `String` to have an even length
* @param value
* @return output
*/
function padToEven(value$2) {
	let a = value$2;
	if (typeof a !== "string") throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
	if (a.length % 2) a = `0${a}`;
	return a;
}

//#endregion
//#region node_modules/@ethereumjs/util/dist/esm/bytes.js
var hexToBytesMapFirstKey = {};
var hexToBytesMapSecondKey = {};
for (let i = 0; i < 16; i++) {
	const vSecondKey = i;
	const vFirstKey = i * 16;
	const key = i.toString(16).toLowerCase();
	hexToBytesMapSecondKey[key] = vSecondKey;
	hexToBytesMapSecondKey[key.toUpperCase()] = vSecondKey;
	hexToBytesMapFirstKey[key] = vFirstKey;
	hexToBytesMapFirstKey[key.toUpperCase()] = vFirstKey;
}
/**
* NOTE: only use this function if the string is even, and only consists of hex characters
* If this is not the case, this function could return weird results
* @deprecated
*/
function _unprefixedHexToBytes(hex) {
	const byteLen = hex.length;
	const bytes$1 = new Uint8Array(byteLen / 2);
	for (let i = 0; i < byteLen; i += 2) bytes$1[i / 2] = hexToBytesMapFirstKey[hex[i]] + hexToBytesMapSecondKey[hex[i + 1]];
	return bytes$1;
}
/****************  Borrowed from @chainsafe/ssz */
var hexByByte = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
var BIGINT_CACHE = [];
for (let i = 0; i <= 256 * 256 - 1; i++) BIGINT_CACHE[i] = BigInt(i);
/**
* Converts a {@link PrefixedHexString} to a {@link Uint8Array}
* @param {PrefixedHexString | string} hex The 0x-prefixed hex string to convert
* @returns {Uint8Array} The converted bytes
* @throws If the input is not a valid 0x-prefixed hex string
*/
const hexToBytes = (hex) => {
	if (typeof hex !== "string") throw new Error(`hex argument type ${typeof hex} must be of type string`);
	if (!/^0x[0-9a-fA-F]*$/.test(hex)) throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`);
	const unprefixedHex = hex.slice(2);
	return _unprefixedHexToBytes(unprefixedHex.length % 2 === 0 ? unprefixedHex : padToEven(unprefixedHex));
};
/**
* Converts a {@link number} into a {@link PrefixedHexString}
* @param {number} i
* @return {PrefixedHexString}
*/
const intToHex = (i) => {
	if (!Number.isSafeInteger(i) || i < 0) throw new Error(`Received an invalid integer type: ${i}`);
	return `0x${i.toString(16)}`;
};
/**
* Converts an {@link number} to a {@link Uint8Array}
* @param {Number} i
* @return {Uint8Array}
*/
const intToBytes = (i) => {
	return hexToBytes(intToHex(i));
};

//#endregion
//#region node_modules/@ethereumjs/util/dist/esm/constants.js
const SECP256K1_ORDER = secp256k1.CURVE.n;
const SECP256K1_ORDER_DIV_2 = secp256k1.CURVE.n / BigInt(2);
/**
* Keccak-256 hash of null
*/
const KECCAK256_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
/**
* Keccak-256 hash of null
*/
const KECCAK256_NULL = hexToBytes(KECCAK256_NULL_S);
/**
* Keccak-256 of an RLP of an empty array
*/
const KECCAK256_RLP_ARRAY_S = "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
/**
* Keccak-256 of an RLP of an empty array
*/
const KECCAK256_RLP_ARRAY = hexToBytes(KECCAK256_RLP_ARRAY_S);
/**
* Keccak-256 hash of the RLP of null
*/
const KECCAK256_RLP_S = "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
/**
* Keccak-256 hash of the RLP of null
*/
const KECCAK256_RLP = hexToBytes(KECCAK256_RLP_S);
/**
*  RLP encoded empty string
*/
const RLP_EMPTY_STRING = Uint8Array.from([128]);
const BIGINT_2 = BigInt(2);
const BIGINT_256 = BigInt(256);
const BIGINT_2EXP256 = BIGINT_2 ** BIGINT_256;

//#endregion
//#region node_modules/@ethereumjs/rlp/dist/esm/index.js
var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
	if (le) return {
		h: Number(n & U32_MASK64),
		l: Number(n >> _32n & U32_MASK64)
	};
	return {
		h: Number(n >> _32n & U32_MASK64) | 0,
		l: Number(n & U32_MASK64) | 0
	};
}
function split(lst, le = false) {
	let Ah = new Uint32Array(lst.length);
	let Al = new Uint32Array(lst.length);
	for (let i = 0; i < lst.length; i++) {
		const { h, l } = fromBig(lst[i], le);
		[Ah[i], Al[i]] = [h, l];
	}
	return [Ah, Al];
}
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;

//#endregion
//#region node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha3.js
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
var _7n = /* @__PURE__ */ BigInt(7);
var _256n = /* @__PURE__ */ BigInt(256);
var _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
	[x, y] = [y, (2 * x + 3 * y) % 5];
	SHA3_PI.push(2 * (5 * y + x));
	SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
	let t = _0n;
	for (let j = 0; j < 7; j++) {
		R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
		if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
	}
	_SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
	const B = new Uint32Array(10);
	for (let round = 24 - rounds; round < 24; round++) {
		for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
		for (let x = 0; x < 10; x += 2) {
			const idx1 = (x + 8) % 10;
			const idx0 = (x + 2) % 10;
			const B0 = B[idx0];
			const B1 = B[idx0 + 1];
			const Th = rotlH(B0, B1, 1) ^ B[idx1];
			const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
			for (let y = 0; y < 50; y += 10) {
				s[x + y] ^= Th;
				s[x + y + 1] ^= Tl;
			}
		}
		let curH = s[2];
		let curL = s[3];
		for (let t = 0; t < 24; t++) {
			const shift = SHA3_ROTL[t];
			const Th = rotlH(curH, curL, shift);
			const Tl = rotlL(curH, curL, shift);
			const PI = SHA3_PI[t];
			curH = s[PI];
			curL = s[PI + 1];
			s[PI] = Th;
			s[PI + 1] = Tl;
		}
		for (let y = 0; y < 50; y += 10) {
			for (let x = 0; x < 10; x++) B[x] = s[y + x];
			for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
		}
		s[0] ^= SHA3_IOTA_H[round];
		s[1] ^= SHA3_IOTA_L[round];
	}
	B.fill(0);
}
var Keccak = class Keccak extends Hash {
	constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
		super();
		this.blockLen = blockLen;
		this.suffix = suffix;
		this.outputLen = outputLen;
		this.enableXOF = enableXOF;
		this.rounds = rounds;
		this.pos = 0;
		this.posOut = 0;
		this.finished = false;
		this.destroyed = false;
		number$1(outputLen);
		if (0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
		this.state = new Uint8Array(200);
		this.state32 = u32(this.state);
	}
	keccak() {
		if (!isLE) byteSwap32(this.state32);
		keccakP(this.state32, this.rounds);
		if (!isLE) byteSwap32(this.state32);
		this.posOut = 0;
		this.pos = 0;
	}
	update(data) {
		exists(this);
		const { blockLen, state } = this;
		data = toBytes$1(data);
		const len = data.length;
		for (let pos = 0; pos < len;) {
			const take$1 = Math.min(blockLen - this.pos, len - pos);
			for (let i = 0; i < take$1; i++) state[this.pos++] ^= data[pos++];
			if (this.pos === blockLen) this.keccak();
		}
		return this;
	}
	finish() {
		if (this.finished) return;
		this.finished = true;
		const { state, suffix, pos, blockLen } = this;
		state[pos] ^= suffix;
		if ((suffix & 128) !== 0 && pos === blockLen - 1) this.keccak();
		state[blockLen - 1] ^= 128;
		this.keccak();
	}
	writeInto(out) {
		exists(this, false);
		bytes(out);
		this.finish();
		const bufferOut = this.state;
		const { blockLen } = this;
		for (let pos = 0, len = out.length; pos < len;) {
			if (this.posOut >= blockLen) this.keccak();
			const take$1 = Math.min(blockLen - this.posOut, len - pos);
			out.set(bufferOut.subarray(this.posOut, this.posOut + take$1), pos);
			this.posOut += take$1;
			pos += take$1;
		}
		return out;
	}
	xofInto(out) {
		if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
		return this.writeInto(out);
	}
	xof(bytes$1) {
		number$1(bytes$1);
		return this.xofInto(new Uint8Array(bytes$1));
	}
	digestInto(out) {
		output(out, this);
		if (this.finished) throw new Error("digest() was already called");
		this.writeInto(out);
		this.destroy();
		return out;
	}
	digest() {
		return this.digestInto(new Uint8Array(this.outputLen));
	}
	destroy() {
		this.destroyed = true;
		this.state.fill(0);
	}
	_cloneInto(to) {
		const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
		to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
		to.state32.set(this.state32);
		to.pos = this.pos;
		to.posOut = this.posOut;
		to.finished = this.finished;
		to.rounds = rounds;
		to.suffix = suffix;
		to.outputLen = outputLen;
		to.enableXOF = enableXOF;
		to.destroyed = this.destroyed;
		return to;
	}
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
const sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
/**
* SHA3-256 hash function
* @param message - that would be hashed
*/
const sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
const sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
const sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
const keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
/**
* keccak-256 hash function. Different from SHA3-256.
* @param message - that would be hashed
*/
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
const keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
const keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
const shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
const shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

//#endregion
//#region node_modules/ethereum-cryptography/esm/keccak.js
const keccak224 = wrapHash(keccak_224);
const keccak256$1 = (() => {
	const k = wrapHash(keccak_256);
	k.create = keccak_256.create;
	return k;
})();
const keccak384 = wrapHash(keccak_384);
const keccak512 = wrapHash(keccak_512);

//#endregion
//#region node_modules/@ethereumjs/util/dist/esm/account.js
var emptyUint8Arr = new Uint8Array(0);

//#endregion
//#region node_modules/@ethereumjs/util/dist/esm/db.js
var KeyEncoding;
(function(KeyEncoding$1) {
	KeyEncoding$1["String"] = "string";
	KeyEncoding$1["Bytes"] = "view";
	KeyEncoding$1["Number"] = "number";
})(KeyEncoding || (KeyEncoding = {}));
var ValueEncoding;
(function(ValueEncoding$1) {
	ValueEncoding$1["String"] = "string";
	ValueEncoding$1["Bytes"] = "view";
	ValueEncoding$1["JSON"] = "json";
})(ValueEncoding || (ValueEncoding = {}));

//#endregion
//#region node_modules/@ethereumjs/util/dist/esm/types.js
/**
* Type output options
*/
var TypeOutput;
(function(TypeOutput$1) {
	TypeOutput$1[TypeOutput$1["Number"] = 0] = "Number";
	TypeOutput$1[TypeOutput$1["BigInt"] = 1] = "BigInt";
	TypeOutput$1[TypeOutput$1["Uint8Array"] = 2] = "Uint8Array";
	TypeOutput$1[TypeOutput$1["PrefixedHexString"] = 3] = "PrefixedHexString";
})(TypeOutput || (TypeOutput = {}));

//#endregion
//#region node_modules/@ethereumjs/util/dist/esm/asyncEventEmitter.js
var import_events = require_events();

//#endregion
//#region node_modules/ethereum-cryptography/esm/sha256.js
const sha256$1 = wrapHash(sha256);

//#endregion
//#region node_modules/@ethereumjs/util/dist/esm/blobs.js
/**
* These utilities for constructing blobs are borrowed from https://github.com/Inphi/eip4844-interop.git
*/
var BYTES_PER_FIELD_ELEMENT = 32;
var FIELD_ELEMENTS_PER_BLOB = 4096;
var USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;
var MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * 2 - 1;
var BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;

//#endregion
//#region node_modules/@ethereumjs/util/dist/esm/requests.js
var CLRequestType;
(function(CLRequestType$1) {
	CLRequestType$1[CLRequestType$1["Deposit"] = 0] = "Deposit";
	CLRequestType$1[CLRequestType$1["Withdrawal"] = 1] = "Withdrawal";
	CLRequestType$1[CLRequestType$1["Consolidation"] = 2] = "Consolidation";
})(CLRequestType || (CLRequestType = {}));

//#endregion
//#region node_modules/@ethereumjs/util/dist/esm/verkle.js
var VerkleLeafType;
(function(VerkleLeafType$1) {
	VerkleLeafType$1[VerkleLeafType$1["Version"] = 0] = "Version";
	VerkleLeafType$1[VerkleLeafType$1["Balance"] = 1] = "Balance";
	VerkleLeafType$1[VerkleLeafType$1["Nonce"] = 2] = "Nonce";
	VerkleLeafType$1[VerkleLeafType$1["CodeHash"] = 3] = "CodeHash";
	VerkleLeafType$1[VerkleLeafType$1["CodeSize"] = 4] = "CodeSize";
})(VerkleLeafType || (VerkleLeafType = {}));
const VERKLE_VERSION_LEAF_KEY = intToBytes(VerkleLeafType.Version);
const VERKLE_BALANCE_LEAF_KEY = intToBytes(VerkleLeafType.Balance);
const VERKLE_NONCE_LEAF_KEY = intToBytes(VerkleLeafType.Nonce);
const VERKLE_CODE_HASH_LEAF_KEY = intToBytes(VerkleLeafType.CodeHash);
const VERKLE_CODE_SIZE_LEAF_KEY = intToBytes(VerkleLeafType.CodeSize);
const VERKLE_MAIN_STORAGE_OFFSET = BigInt(256) ** BigInt(31);

//#endregion
//#region node_modules/base64url/dist/pad-string.js
var require_pad_string = /* @__PURE__ */ __commonJS({ "node_modules/base64url/dist/pad-string.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function padString(input) {
		var segmentLength = 4;
		var stringLength = input.length;
		var diff = stringLength % segmentLength;
		if (!diff) return input;
		var position = stringLength;
		var padLength = segmentLength - diff;
		var paddedStringLength = stringLength + padLength;
		var buffer = Buffer.alloc(paddedStringLength);
		buffer.write(input);
		while (padLength--) buffer.write("=", position++);
		return buffer.toString();
	}
	exports.default = padString;
}) });

//#endregion
//#region node_modules/base64url/dist/base64url.js
var require_base64url$1 = /* @__PURE__ */ __commonJS({ "node_modules/base64url/dist/base64url.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var pad_string_1 = require_pad_string();
	function encode$1(input, encoding) {
		if (encoding === void 0) encoding = "utf8";
		if (Buffer.isBuffer(input)) return fromBase64(input.toString("base64"));
		return fromBase64(Buffer.from(input, encoding).toString("base64"));
	}
	function decode$2(base64url$1, encoding) {
		if (encoding === void 0) encoding = "utf8";
		return Buffer.from(toBase64(base64url$1), "base64").toString(encoding);
	}
	function toBase64(base64url$1) {
		base64url$1 = base64url$1.toString();
		return pad_string_1.default(base64url$1).replace(/\-/g, "+").replace(/_/g, "/");
	}
	function fromBase64(base64) {
		return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function toBuffer(base64url$1) {
		return Buffer.from(toBase64(base64url$1), "base64");
	}
	var base64url = encode$1;
	base64url.encode = encode$1;
	base64url.decode = decode$2;
	base64url.toBase64 = toBase64;
	base64url.fromBase64 = fromBase64;
	base64url.toBuffer = toBuffer;
	exports.default = base64url;
}) });

//#endregion
//#region node_modules/base64url/index.js
var require_base64url = /* @__PURE__ */ __commonJS({ "node_modules/base64url/index.js": ((exports, module) => {
	module.exports = require_base64url$1().default;
	module.exports.default = module.exports;
}) });

//#endregion
//#region node_modules/@toruslabs/constants/dist/constants.esm.js
var import_base64url = /* @__PURE__ */ __toESM(require_base64url());
var TORUS_LEGACY_NETWORK = {
	MAINNET: "mainnet",
	TESTNET: "testnet",
	CYAN: "cyan",
	AQUA: "aqua",
	CELESTE: "celeste"
};
var TORUS_SAPPHIRE_NETWORK = {
	SAPPHIRE_DEVNET: "sapphire_devnet",
	SAPPHIRE_MAINNET: "sapphire_mainnet"
};
var PROXY_CONTRACT_ADDRESS = {
	[TORUS_LEGACY_NETWORK.MAINNET]: "0xf20336e16B5182637f09821c27BDe29b0AFcfe80",
	[TORUS_LEGACY_NETWORK.TESTNET]: "0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A",
	[TORUS_LEGACY_NETWORK.CYAN]: "0x9f072ba19b3370e512aa1b4bfcdaf97283168005",
	[TORUS_LEGACY_NETWORK.AQUA]: "0x29Dea82a0509153b91040ee13cDBba0f03efb625",
	[TORUS_LEGACY_NETWORK.CELESTE]: "0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c"
};
var LEGACY_NETWORKS_ROUTE_MAP = {
	[TORUS_LEGACY_NETWORK.AQUA]: {
		migrationCompleted: true,
		networkIdentifier: "aqua",
		networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
	},
	[TORUS_LEGACY_NETWORK.CELESTE]: {
		migrationCompleted: true,
		networkIdentifier: "celeste",
		networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
	},
	[TORUS_LEGACY_NETWORK.CYAN]: {
		migrationCompleted: true,
		networkIdentifier: "cyan",
		networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
	},
	[TORUS_LEGACY_NETWORK.MAINNET]: {
		migrationCompleted: true,
		networkIdentifier: "mainnet",
		networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
	},
	[TORUS_LEGACY_NETWORK.TESTNET]: {
		migrationCompleted: true,
		networkIdentifier: "teal",
		networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET
	}
};
var NETWORK_MAP = {
	[TORUS_LEGACY_NETWORK.MAINNET]: "mainnet",
	[TORUS_LEGACY_NETWORK.TESTNET]: "goerli",
	[TORUS_LEGACY_NETWORK.CYAN]: "polygon-mainnet",
	[TORUS_LEGACY_NETWORK.AQUA]: "polygon-mainnet",
	[TORUS_LEGACY_NETWORK.CELESTE]: "polygon-mainnet"
};
var SIGNER_MAP = {
	[TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: "https://signer.web3auth.io",
	[TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: "https://signer.web3auth.io",
	[TORUS_LEGACY_NETWORK.MAINNET]: "https://signer.web3auth.io",
	[TORUS_LEGACY_NETWORK.TESTNET]: "https://signer.web3auth.io",
	[TORUS_LEGACY_NETWORK.CYAN]: "https://signer-polygon.web3auth.io",
	[TORUS_LEGACY_NETWORK.AQUA]: "https://signer-polygon.web3auth.io",
	[TORUS_LEGACY_NETWORK.CELESTE]: "https://signer-polygon.web3auth.io"
};
var METADATA_MAP = {
	[TORUS_LEGACY_NETWORK.MAINNET]: "https://metadata.web3auth.io",
	[TORUS_LEGACY_NETWORK.TESTNET]: "https://metadata.web3auth.io",
	[TORUS_LEGACY_NETWORK.CYAN]: "https://metadata.web3auth.io",
	[TORUS_LEGACY_NETWORK.AQUA]: "https://metadata.web3auth.io",
	[TORUS_LEGACY_NETWORK.CELESTE]: "https://metadata.web3auth.io"
};

//#endregion
//#region node_modules/color-name/index.js
var require_color_name = /* @__PURE__ */ __commonJS({ "node_modules/color-name/index.js": ((exports, module) => {
	module.exports = {
		"aliceblue": [
			240,
			248,
			255
		],
		"antiquewhite": [
			250,
			235,
			215
		],
		"aqua": [
			0,
			255,
			255
		],
		"aquamarine": [
			127,
			255,
			212
		],
		"azure": [
			240,
			255,
			255
		],
		"beige": [
			245,
			245,
			220
		],
		"bisque": [
			255,
			228,
			196
		],
		"black": [
			0,
			0,
			0
		],
		"blanchedalmond": [
			255,
			235,
			205
		],
		"blue": [
			0,
			0,
			255
		],
		"blueviolet": [
			138,
			43,
			226
		],
		"brown": [
			165,
			42,
			42
		],
		"burlywood": [
			222,
			184,
			135
		],
		"cadetblue": [
			95,
			158,
			160
		],
		"chartreuse": [
			127,
			255,
			0
		],
		"chocolate": [
			210,
			105,
			30
		],
		"coral": [
			255,
			127,
			80
		],
		"cornflowerblue": [
			100,
			149,
			237
		],
		"cornsilk": [
			255,
			248,
			220
		],
		"crimson": [
			220,
			20,
			60
		],
		"cyan": [
			0,
			255,
			255
		],
		"darkblue": [
			0,
			0,
			139
		],
		"darkcyan": [
			0,
			139,
			139
		],
		"darkgoldenrod": [
			184,
			134,
			11
		],
		"darkgray": [
			169,
			169,
			169
		],
		"darkgreen": [
			0,
			100,
			0
		],
		"darkgrey": [
			169,
			169,
			169
		],
		"darkkhaki": [
			189,
			183,
			107
		],
		"darkmagenta": [
			139,
			0,
			139
		],
		"darkolivegreen": [
			85,
			107,
			47
		],
		"darkorange": [
			255,
			140,
			0
		],
		"darkorchid": [
			153,
			50,
			204
		],
		"darkred": [
			139,
			0,
			0
		],
		"darksalmon": [
			233,
			150,
			122
		],
		"darkseagreen": [
			143,
			188,
			143
		],
		"darkslateblue": [
			72,
			61,
			139
		],
		"darkslategray": [
			47,
			79,
			79
		],
		"darkslategrey": [
			47,
			79,
			79
		],
		"darkturquoise": [
			0,
			206,
			209
		],
		"darkviolet": [
			148,
			0,
			211
		],
		"deeppink": [
			255,
			20,
			147
		],
		"deepskyblue": [
			0,
			191,
			255
		],
		"dimgray": [
			105,
			105,
			105
		],
		"dimgrey": [
			105,
			105,
			105
		],
		"dodgerblue": [
			30,
			144,
			255
		],
		"firebrick": [
			178,
			34,
			34
		],
		"floralwhite": [
			255,
			250,
			240
		],
		"forestgreen": [
			34,
			139,
			34
		],
		"fuchsia": [
			255,
			0,
			255
		],
		"gainsboro": [
			220,
			220,
			220
		],
		"ghostwhite": [
			248,
			248,
			255
		],
		"gold": [
			255,
			215,
			0
		],
		"goldenrod": [
			218,
			165,
			32
		],
		"gray": [
			128,
			128,
			128
		],
		"green": [
			0,
			128,
			0
		],
		"greenyellow": [
			173,
			255,
			47
		],
		"grey": [
			128,
			128,
			128
		],
		"honeydew": [
			240,
			255,
			240
		],
		"hotpink": [
			255,
			105,
			180
		],
		"indianred": [
			205,
			92,
			92
		],
		"indigo": [
			75,
			0,
			130
		],
		"ivory": [
			255,
			255,
			240
		],
		"khaki": [
			240,
			230,
			140
		],
		"lavender": [
			230,
			230,
			250
		],
		"lavenderblush": [
			255,
			240,
			245
		],
		"lawngreen": [
			124,
			252,
			0
		],
		"lemonchiffon": [
			255,
			250,
			205
		],
		"lightblue": [
			173,
			216,
			230
		],
		"lightcoral": [
			240,
			128,
			128
		],
		"lightcyan": [
			224,
			255,
			255
		],
		"lightgoldenrodyellow": [
			250,
			250,
			210
		],
		"lightgray": [
			211,
			211,
			211
		],
		"lightgreen": [
			144,
			238,
			144
		],
		"lightgrey": [
			211,
			211,
			211
		],
		"lightpink": [
			255,
			182,
			193
		],
		"lightsalmon": [
			255,
			160,
			122
		],
		"lightseagreen": [
			32,
			178,
			170
		],
		"lightskyblue": [
			135,
			206,
			250
		],
		"lightslategray": [
			119,
			136,
			153
		],
		"lightslategrey": [
			119,
			136,
			153
		],
		"lightsteelblue": [
			176,
			196,
			222
		],
		"lightyellow": [
			255,
			255,
			224
		],
		"lime": [
			0,
			255,
			0
		],
		"limegreen": [
			50,
			205,
			50
		],
		"linen": [
			250,
			240,
			230
		],
		"magenta": [
			255,
			0,
			255
		],
		"maroon": [
			128,
			0,
			0
		],
		"mediumaquamarine": [
			102,
			205,
			170
		],
		"mediumblue": [
			0,
			0,
			205
		],
		"mediumorchid": [
			186,
			85,
			211
		],
		"mediumpurple": [
			147,
			112,
			219
		],
		"mediumseagreen": [
			60,
			179,
			113
		],
		"mediumslateblue": [
			123,
			104,
			238
		],
		"mediumspringgreen": [
			0,
			250,
			154
		],
		"mediumturquoise": [
			72,
			209,
			204
		],
		"mediumvioletred": [
			199,
			21,
			133
		],
		"midnightblue": [
			25,
			25,
			112
		],
		"mintcream": [
			245,
			255,
			250
		],
		"mistyrose": [
			255,
			228,
			225
		],
		"moccasin": [
			255,
			228,
			181
		],
		"navajowhite": [
			255,
			222,
			173
		],
		"navy": [
			0,
			0,
			128
		],
		"oldlace": [
			253,
			245,
			230
		],
		"olive": [
			128,
			128,
			0
		],
		"olivedrab": [
			107,
			142,
			35
		],
		"orange": [
			255,
			165,
			0
		],
		"orangered": [
			255,
			69,
			0
		],
		"orchid": [
			218,
			112,
			214
		],
		"palegoldenrod": [
			238,
			232,
			170
		],
		"palegreen": [
			152,
			251,
			152
		],
		"paleturquoise": [
			175,
			238,
			238
		],
		"palevioletred": [
			219,
			112,
			147
		],
		"papayawhip": [
			255,
			239,
			213
		],
		"peachpuff": [
			255,
			218,
			185
		],
		"peru": [
			205,
			133,
			63
		],
		"pink": [
			255,
			192,
			203
		],
		"plum": [
			221,
			160,
			221
		],
		"powderblue": [
			176,
			224,
			230
		],
		"purple": [
			128,
			0,
			128
		],
		"rebeccapurple": [
			102,
			51,
			153
		],
		"red": [
			255,
			0,
			0
		],
		"rosybrown": [
			188,
			143,
			143
		],
		"royalblue": [
			65,
			105,
			225
		],
		"saddlebrown": [
			139,
			69,
			19
		],
		"salmon": [
			250,
			128,
			114
		],
		"sandybrown": [
			244,
			164,
			96
		],
		"seagreen": [
			46,
			139,
			87
		],
		"seashell": [
			255,
			245,
			238
		],
		"sienna": [
			160,
			82,
			45
		],
		"silver": [
			192,
			192,
			192
		],
		"skyblue": [
			135,
			206,
			235
		],
		"slateblue": [
			106,
			90,
			205
		],
		"slategray": [
			112,
			128,
			144
		],
		"slategrey": [
			112,
			128,
			144
		],
		"snow": [
			255,
			250,
			250
		],
		"springgreen": [
			0,
			255,
			127
		],
		"steelblue": [
			70,
			130,
			180
		],
		"tan": [
			210,
			180,
			140
		],
		"teal": [
			0,
			128,
			128
		],
		"thistle": [
			216,
			191,
			216
		],
		"tomato": [
			255,
			99,
			71
		],
		"turquoise": [
			64,
			224,
			208
		],
		"violet": [
			238,
			130,
			238
		],
		"wheat": [
			245,
			222,
			179
		],
		"white": [
			255,
			255,
			255
		],
		"whitesmoke": [
			245,
			245,
			245
		],
		"yellow": [
			255,
			255,
			0
		],
		"yellowgreen": [
			154,
			205,
			50
		]
	};
}) });

//#endregion
//#region node_modules/is-arrayish/index.js
var require_is_arrayish = /* @__PURE__ */ __commonJS({ "node_modules/is-arrayish/index.js": ((exports, module) => {
	module.exports = function isArrayish$1(obj) {
		if (!obj || typeof obj === "string") return false;
		return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
	};
}) });

//#endregion
//#region node_modules/simple-swizzle/index.js
var require_simple_swizzle = /* @__PURE__ */ __commonJS({ "node_modules/simple-swizzle/index.js": ((exports, module) => {
	var isArrayish = require_is_arrayish();
	var concat = Array.prototype.concat;
	var slice = Array.prototype.slice;
	var swizzle$1 = module.exports = function swizzle$2(args) {
		var results = [];
		for (var i = 0, len = args.length; i < len; i++) {
			var arg = args[i];
			if (isArrayish(arg)) results = concat.call(results, slice.call(arg));
			else results.push(arg);
		}
		return results;
	};
	swizzle$1.wrap = function(fn) {
		return function() {
			return fn(swizzle$1(arguments));
		};
	};
}) });

//#endregion
//#region node_modules/color-string/index.js
var require_color_string = /* @__PURE__ */ __commonJS({ "node_modules/color-string/index.js": ((exports, module) => {
	var colorNames = require_color_name();
	var swizzle = require_simple_swizzle();
	var hasOwnProperty = Object.hasOwnProperty;
	var reverseNames = Object.create(null);
	for (var name in colorNames) if (hasOwnProperty.call(colorNames, name)) reverseNames[colorNames[name]] = name;
	var cs = module.exports = {
		to: {},
		get: {}
	};
	cs.get = function(string$1) {
		var prefix = string$1.substring(0, 3).toLowerCase();
		var val;
		var model;
		switch (prefix) {
			case "hsl":
				val = cs.get.hsl(string$1);
				model = "hsl";
				break;
			case "hwb":
				val = cs.get.hwb(string$1);
				model = "hwb";
				break;
			default:
				val = cs.get.rgb(string$1);
				model = "rgb";
				break;
		}
		if (!val) return null;
		return {
			model,
			value: val
		};
	};
	cs.get.rgb = function(string$1) {
		if (!string$1) return null;
		var abbr = /^#([a-f0-9]{3,4})$/i;
		var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
		var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
		var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
		var keyword = /^(\w+)$/;
		var rgb = [
			0,
			0,
			0,
			1
		];
		var match;
		var i;
		var hexAlpha;
		if (match = string$1.match(hex)) {
			hexAlpha = match[2];
			match = match[1];
			for (i = 0; i < 3; i++) {
				var i2 = i * 2;
				rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
			}
			if (hexAlpha) rgb[3] = parseInt(hexAlpha, 16) / 255;
		} else if (match = string$1.match(abbr)) {
			match = match[1];
			hexAlpha = match[3];
			for (i = 0; i < 3; i++) rgb[i] = parseInt(match[i] + match[i], 16);
			if (hexAlpha) rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		} else if (match = string$1.match(rgba)) {
			for (i = 0; i < 3; i++) rgb[i] = parseInt(match[i + 1], 0);
			if (match[4]) if (match[5]) rgb[3] = parseFloat(match[4]) * .01;
			else rgb[3] = parseFloat(match[4]);
		} else if (match = string$1.match(per)) {
			for (i = 0; i < 3; i++) rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
			if (match[4]) if (match[5]) rgb[3] = parseFloat(match[4]) * .01;
			else rgb[3] = parseFloat(match[4]);
		} else if (match = string$1.match(keyword)) {
			if (match[1] === "transparent") return [
				0,
				0,
				0,
				0
			];
			if (!hasOwnProperty.call(colorNames, match[1])) return null;
			rgb = colorNames[match[1]];
			rgb[3] = 1;
			return rgb;
		} else return null;
		for (i = 0; i < 3; i++) rgb[i] = clamp(rgb[i], 0, 255);
		rgb[3] = clamp(rgb[3], 0, 1);
		return rgb;
	};
	cs.get.hsl = function(string$1) {
		if (!string$1) return null;
		var match = string$1.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);
		if (match) {
			var alpha = parseFloat(match[4]);
			return [
				(parseFloat(match[1]) % 360 + 360) % 360,
				clamp(parseFloat(match[2]), 0, 100),
				clamp(parseFloat(match[3]), 0, 100),
				clamp(isNaN(alpha) ? 1 : alpha, 0, 1)
			];
		}
		return null;
	};
	cs.get.hwb = function(string$1) {
		if (!string$1) return null;
		var match = string$1.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);
		if (match) {
			var alpha = parseFloat(match[4]);
			return [
				(parseFloat(match[1]) % 360 + 360) % 360,
				clamp(parseFloat(match[2]), 0, 100),
				clamp(parseFloat(match[3]), 0, 100),
				clamp(isNaN(alpha) ? 1 : alpha, 0, 1)
			];
		}
		return null;
	};
	cs.to.hex = function() {
		var rgba = swizzle(arguments);
		return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
	};
	cs.to.rgb = function() {
		var rgba = swizzle(arguments);
		return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
	};
	cs.to.rgb.percent = function() {
		var rgba = swizzle(arguments);
		var r = Math.round(rgba[0] / 255 * 100);
		var g = Math.round(rgba[1] / 255 * 100);
		var b = Math.round(rgba[2] / 255 * 100);
		return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
	};
	cs.to.hsl = function() {
		var hsla = swizzle(arguments);
		return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
	};
	cs.to.hwb = function() {
		var hwba = swizzle(arguments);
		var a = "";
		if (hwba.length >= 4 && hwba[3] !== 1) a = ", " + hwba[3];
		return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
	};
	cs.to.keyword = function(rgb) {
		return reverseNames[rgb.slice(0, 3)];
	};
	function clamp(num, min, max) {
		return Math.min(Math.max(min, num), max);
	}
	function hexDouble(num) {
		var str$1 = Math.round(num).toString(16).toUpperCase();
		return str$1.length < 2 ? "0" + str$1 : str$1;
	}
}) });

//#endregion
//#region node_modules/color-convert/conversions.js
var require_conversions = /* @__PURE__ */ __commonJS({ "node_modules/color-convert/conversions.js": ((exports, module) => {
	var cssKeywords = require_color_name();
	var reverseKeywords = {};
	for (const key of Object.keys(cssKeywords)) reverseKeywords[cssKeywords[key]] = key;
	var convert$2 = {
		rgb: {
			channels: 3,
			labels: "rgb"
		},
		hsl: {
			channels: 3,
			labels: "hsl"
		},
		hsv: {
			channels: 3,
			labels: "hsv"
		},
		hwb: {
			channels: 3,
			labels: "hwb"
		},
		cmyk: {
			channels: 4,
			labels: "cmyk"
		},
		xyz: {
			channels: 3,
			labels: "xyz"
		},
		lab: {
			channels: 3,
			labels: "lab"
		},
		lch: {
			channels: 3,
			labels: "lch"
		},
		hex: {
			channels: 1,
			labels: ["hex"]
		},
		keyword: {
			channels: 1,
			labels: ["keyword"]
		},
		ansi16: {
			channels: 1,
			labels: ["ansi16"]
		},
		ansi256: {
			channels: 1,
			labels: ["ansi256"]
		},
		hcg: {
			channels: 3,
			labels: [
				"h",
				"c",
				"g"
			]
		},
		apple: {
			channels: 3,
			labels: [
				"r16",
				"g16",
				"b16"
			]
		},
		gray: {
			channels: 1,
			labels: ["gray"]
		}
	};
	module.exports = convert$2;
	for (const model of Object.keys(convert$2)) {
		if (!("channels" in convert$2[model])) throw new Error("missing channels property: " + model);
		if (!("labels" in convert$2[model])) throw new Error("missing channel labels property: " + model);
		if (convert$2[model].labels.length !== convert$2[model].channels) throw new Error("channel and label counts mismatch: " + model);
		const { channels, labels } = convert$2[model];
		delete convert$2[model].channels;
		delete convert$2[model].labels;
		Object.defineProperty(convert$2[model], "channels", { value: channels });
		Object.defineProperty(convert$2[model], "labels", { value: labels });
	}
	convert$2.rgb.hsl = function(rgb) {
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const min = Math.min(r, g, b);
		const max = Math.max(r, g, b);
		const delta = max - min;
		let h;
		let s;
		if (max === min) h = 0;
		else if (r === max) h = (g - b) / delta;
		else if (g === max) h = 2 + (b - r) / delta;
		else if (b === max) h = 4 + (r - g) / delta;
		h = Math.min(h * 60, 360);
		if (h < 0) h += 360;
		const l = (min + max) / 2;
		if (max === min) s = 0;
		else if (l <= .5) s = delta / (max + min);
		else s = delta / (2 - max - min);
		return [
			h,
			s * 100,
			l * 100
		];
	};
	convert$2.rgb.hsv = function(rgb) {
		let rdif;
		let gdif;
		let bdif;
		let h;
		let s;
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const v = Math.max(r, g, b);
		const diff = v - Math.min(r, g, b);
		const diffc = function(c) {
			return (v - c) / 6 / diff + 1 / 2;
		};
		if (diff === 0) {
			h = 0;
			s = 0;
		} else {
			s = diff / v;
			rdif = diffc(r);
			gdif = diffc(g);
			bdif = diffc(b);
			if (r === v) h = bdif - gdif;
			else if (g === v) h = 1 / 3 + rdif - bdif;
			else if (b === v) h = 2 / 3 + gdif - rdif;
			if (h < 0) h += 1;
			else if (h > 1) h -= 1;
		}
		return [
			h * 360,
			s * 100,
			v * 100
		];
	};
	convert$2.rgb.hwb = function(rgb) {
		const r = rgb[0];
		const g = rgb[1];
		let b = rgb[2];
		const h = convert$2.rgb.hsl(rgb)[0];
		const w = 1 / 255 * Math.min(r, Math.min(g, b));
		b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
		return [
			h,
			w * 100,
			b * 100
		];
	};
	convert$2.rgb.cmyk = function(rgb) {
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const k = Math.min(1 - r, 1 - g, 1 - b);
		const c = (1 - r - k) / (1 - k) || 0;
		const m = (1 - g - k) / (1 - k) || 0;
		const y = (1 - b - k) / (1 - k) || 0;
		return [
			c * 100,
			m * 100,
			y * 100,
			k * 100
		];
	};
	function comparativeDistance(x, y) {
		return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
	}
	convert$2.rgb.keyword = function(rgb) {
		const reversed = reverseKeywords[rgb];
		if (reversed) return reversed;
		let currentClosestDistance = Infinity;
		let currentClosestKeyword;
		for (const keyword of Object.keys(cssKeywords)) {
			const value$2 = cssKeywords[keyword];
			const distance = comparativeDistance(rgb, value$2);
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
		return currentClosestKeyword;
	};
	convert$2.keyword.rgb = function(keyword) {
		return cssKeywords[keyword];
	};
	convert$2.rgb.xyz = function(rgb) {
		let r = rgb[0] / 255;
		let g = rgb[1] / 255;
		let b = rgb[2] / 255;
		r = r > .04045 ? ((r + .055) / 1.055) ** 2.4 : r / 12.92;
		g = g > .04045 ? ((g + .055) / 1.055) ** 2.4 : g / 12.92;
		b = b > .04045 ? ((b + .055) / 1.055) ** 2.4 : b / 12.92;
		const x = r * .4124 + g * .3576 + b * .1805;
		const y = r * .2126 + g * .7152 + b * .0722;
		const z = r * .0193 + g * .1192 + b * .9505;
		return [
			x * 100,
			y * 100,
			z * 100
		];
	};
	convert$2.rgb.lab = function(rgb) {
		const xyz = convert$2.rgb.xyz(rgb);
		let x = xyz[0];
		let y = xyz[1];
		let z = xyz[2];
		x /= 95.047;
		y /= 100;
		z /= 108.883;
		x = x > .008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
		y = y > .008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
		z = z > .008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
		return [
			116 * y - 16,
			500 * (x - y),
			200 * (y - z)
		];
	};
	convert$2.hsl.rgb = function(hsl) {
		const h = hsl[0] / 360;
		const s = hsl[1] / 100;
		const l = hsl[2] / 100;
		let t2;
		let t3;
		let val;
		if (s === 0) {
			val = l * 255;
			return [
				val,
				val,
				val
			];
		}
		if (l < .5) t2 = l * (1 + s);
		else t2 = l + s - l * s;
		const t1 = 2 * l - t2;
		const rgb = [
			0,
			0,
			0
		];
		for (let i = 0; i < 3; i++) {
			t3 = h + 1 / 3 * -(i - 1);
			if (t3 < 0) t3++;
			if (t3 > 1) t3--;
			if (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;
			else if (2 * t3 < 1) val = t2;
			else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
			else val = t1;
			rgb[i] = val * 255;
		}
		return rgb;
	};
	convert$2.hsl.hsv = function(hsl) {
		const h = hsl[0];
		let s = hsl[1] / 100;
		let l = hsl[2] / 100;
		let smin = s;
		const lmin = Math.max(l, .01);
		l *= 2;
		s *= l <= 1 ? l : 2 - l;
		smin *= lmin <= 1 ? lmin : 2 - lmin;
		const v = (l + s) / 2;
		return [
			h,
			(l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s)) * 100,
			v * 100
		];
	};
	convert$2.hsv.rgb = function(hsv) {
		const h = hsv[0] / 60;
		const s = hsv[1] / 100;
		let v = hsv[2] / 100;
		const hi = Math.floor(h) % 6;
		const f = h - Math.floor(h);
		const p = 255 * v * (1 - s);
		const q = 255 * v * (1 - s * f);
		const t = 255 * v * (1 - s * (1 - f));
		v *= 255;
		switch (hi) {
			case 0: return [
				v,
				t,
				p
			];
			case 1: return [
				q,
				v,
				p
			];
			case 2: return [
				p,
				v,
				t
			];
			case 3: return [
				p,
				q,
				v
			];
			case 4: return [
				t,
				p,
				v
			];
			case 5: return [
				v,
				p,
				q
			];
		}
	};
	convert$2.hsv.hsl = function(hsv) {
		const h = hsv[0];
		const s = hsv[1] / 100;
		const v = hsv[2] / 100;
		const vmin = Math.max(v, .01);
		let sl;
		let l;
		l = (2 - s) * v;
		const lmin = (2 - s) * vmin;
		sl = s * vmin;
		sl /= lmin <= 1 ? lmin : 2 - lmin;
		sl = sl || 0;
		l /= 2;
		return [
			h,
			sl * 100,
			l * 100
		];
	};
	convert$2.hwb.rgb = function(hwb) {
		const h = hwb[0] / 360;
		let wh = hwb[1] / 100;
		let bl = hwb[2] / 100;
		const ratio = wh + bl;
		let f;
		if (ratio > 1) {
			wh /= ratio;
			bl /= ratio;
		}
		const i = Math.floor(6 * h);
		const v = 1 - bl;
		f = 6 * h - i;
		if ((i & 1) !== 0) f = 1 - f;
		const n = wh + f * (v - wh);
		let r;
		let g;
		let b;
		switch (i) {
			default:
			case 6:
			case 0:
				r = v;
				g = n;
				b = wh;
				break;
			case 1:
				r = n;
				g = v;
				b = wh;
				break;
			case 2:
				r = wh;
				g = v;
				b = n;
				break;
			case 3:
				r = wh;
				g = n;
				b = v;
				break;
			case 4:
				r = n;
				g = wh;
				b = v;
				break;
			case 5:
				r = v;
				g = wh;
				b = n;
				break;
		}
		return [
			r * 255,
			g * 255,
			b * 255
		];
	};
	convert$2.cmyk.rgb = function(cmyk) {
		const c = cmyk[0] / 100;
		const m = cmyk[1] / 100;
		const y = cmyk[2] / 100;
		const k = cmyk[3] / 100;
		const r = 1 - Math.min(1, c * (1 - k) + k);
		const g = 1 - Math.min(1, m * (1 - k) + k);
		const b = 1 - Math.min(1, y * (1 - k) + k);
		return [
			r * 255,
			g * 255,
			b * 255
		];
	};
	convert$2.xyz.rgb = function(xyz) {
		const x = xyz[0] / 100;
		const y = xyz[1] / 100;
		const z = xyz[2] / 100;
		let r;
		let g;
		let b;
		r = x * 3.2406 + y * -1.5372 + z * -.4986;
		g = x * -.9689 + y * 1.8758 + z * .0415;
		b = x * .0557 + y * -.204 + z * 1.057;
		r = r > .0031308 ? 1.055 * r ** (1 / 2.4) - .055 : r * 12.92;
		g = g > .0031308 ? 1.055 * g ** (1 / 2.4) - .055 : g * 12.92;
		b = b > .0031308 ? 1.055 * b ** (1 / 2.4) - .055 : b * 12.92;
		r = Math.min(Math.max(0, r), 1);
		g = Math.min(Math.max(0, g), 1);
		b = Math.min(Math.max(0, b), 1);
		return [
			r * 255,
			g * 255,
			b * 255
		];
	};
	convert$2.xyz.lab = function(xyz) {
		let x = xyz[0];
		let y = xyz[1];
		let z = xyz[2];
		x /= 95.047;
		y /= 100;
		z /= 108.883;
		x = x > .008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
		y = y > .008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
		z = z > .008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
		return [
			116 * y - 16,
			500 * (x - y),
			200 * (y - z)
		];
	};
	convert$2.lab.xyz = function(lab) {
		const l = lab[0];
		const a = lab[1];
		const b = lab[2];
		let x;
		let y;
		let z;
		y = (l + 16) / 116;
		x = a / 500 + y;
		z = y - b / 200;
		const y2 = y ** 3;
		const x2 = x ** 3;
		const z2 = z ** 3;
		y = y2 > .008856 ? y2 : (y - 16 / 116) / 7.787;
		x = x2 > .008856 ? x2 : (x - 16 / 116) / 7.787;
		z = z2 > .008856 ? z2 : (z - 16 / 116) / 7.787;
		x *= 95.047;
		y *= 100;
		z *= 108.883;
		return [
			x,
			y,
			z
		];
	};
	convert$2.lab.lch = function(lab) {
		const l = lab[0];
		const a = lab[1];
		const b = lab[2];
		let h;
		h = Math.atan2(b, a) * 360 / 2 / Math.PI;
		if (h < 0) h += 360;
		return [
			l,
			Math.sqrt(a * a + b * b),
			h
		];
	};
	convert$2.lch.lab = function(lch) {
		const l = lch[0];
		const c = lch[1];
		const hr = lch[2] / 360 * 2 * Math.PI;
		return [
			l,
			c * Math.cos(hr),
			c * Math.sin(hr)
		];
	};
	convert$2.rgb.ansi16 = function(args, saturation = null) {
		const [r, g, b] = args;
		let value$2 = saturation === null ? convert$2.rgb.hsv(args)[2] : saturation;
		value$2 = Math.round(value$2 / 50);
		if (value$2 === 0) return 30;
		let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
		if (value$2 === 2) ansi += 60;
		return ansi;
	};
	convert$2.hsv.ansi16 = function(args) {
		return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
	};
	convert$2.rgb.ansi256 = function(args) {
		const r = args[0];
		const g = args[1];
		const b = args[2];
		if (r === g && g === b) {
			if (r < 8) return 16;
			if (r > 248) return 231;
			return Math.round((r - 8) / 247 * 24) + 232;
		}
		return 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
	};
	convert$2.ansi16.rgb = function(args) {
		let color = args % 10;
		if (color === 0 || color === 7) {
			if (args > 50) color += 3.5;
			color = color / 10.5 * 255;
			return [
				color,
				color,
				color
			];
		}
		const mult = (~~(args > 50) + 1) * .5;
		return [
			(color & 1) * mult * 255,
			(color >> 1 & 1) * mult * 255,
			(color >> 2 & 1) * mult * 255
		];
	};
	convert$2.ansi256.rgb = function(args) {
		if (args >= 232) {
			const c = (args - 232) * 10 + 8;
			return [
				c,
				c,
				c
			];
		}
		args -= 16;
		let rem;
		return [
			Math.floor(args / 36) / 5 * 255,
			Math.floor((rem = args % 36) / 6) / 5 * 255,
			rem % 6 / 5 * 255
		];
	};
	convert$2.rgb.hex = function(args) {
		const string$1 = (((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255)).toString(16).toUpperCase();
		return "000000".substring(string$1.length) + string$1;
	};
	convert$2.hex.rgb = function(args) {
		const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
		if (!match) return [
			0,
			0,
			0
		];
		let colorString$1 = match[0];
		if (match[0].length === 3) colorString$1 = colorString$1.split("").map((char) => {
			return char + char;
		}).join("");
		const integer = parseInt(colorString$1, 16);
		return [
			integer >> 16 & 255,
			integer >> 8 & 255,
			integer & 255
		];
	};
	convert$2.rgb.hcg = function(rgb) {
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const max = Math.max(Math.max(r, g), b);
		const min = Math.min(Math.min(r, g), b);
		const chroma = max - min;
		let grayscale;
		let hue;
		if (chroma < 1) grayscale = min / (1 - chroma);
		else grayscale = 0;
		if (chroma <= 0) hue = 0;
		else if (max === r) hue = (g - b) / chroma % 6;
		else if (max === g) hue = 2 + (b - r) / chroma;
		else hue = 4 + (r - g) / chroma;
		hue /= 6;
		hue %= 1;
		return [
			hue * 360,
			chroma * 100,
			grayscale * 100
		];
	};
	convert$2.hsl.hcg = function(hsl) {
		const s = hsl[1] / 100;
		const l = hsl[2] / 100;
		const c = l < .5 ? 2 * s * l : 2 * s * (1 - l);
		let f = 0;
		if (c < 1) f = (l - .5 * c) / (1 - c);
		return [
			hsl[0],
			c * 100,
			f * 100
		];
	};
	convert$2.hsv.hcg = function(hsv) {
		const s = hsv[1] / 100;
		const v = hsv[2] / 100;
		const c = s * v;
		let f = 0;
		if (c < 1) f = (v - c) / (1 - c);
		return [
			hsv[0],
			c * 100,
			f * 100
		];
	};
	convert$2.hcg.rgb = function(hcg) {
		const h = hcg[0] / 360;
		const c = hcg[1] / 100;
		const g = hcg[2] / 100;
		if (c === 0) return [
			g * 255,
			g * 255,
			g * 255
		];
		const pure = [
			0,
			0,
			0
		];
		const hi = h % 1 * 6;
		const v = hi % 1;
		const w = 1 - v;
		let mg = 0;
		switch (Math.floor(hi)) {
			case 0:
				pure[0] = 1;
				pure[1] = v;
				pure[2] = 0;
				break;
			case 1:
				pure[0] = w;
				pure[1] = 1;
				pure[2] = 0;
				break;
			case 2:
				pure[0] = 0;
				pure[1] = 1;
				pure[2] = v;
				break;
			case 3:
				pure[0] = 0;
				pure[1] = w;
				pure[2] = 1;
				break;
			case 4:
				pure[0] = v;
				pure[1] = 0;
				pure[2] = 1;
				break;
			default:
				pure[0] = 1;
				pure[1] = 0;
				pure[2] = w;
		}
		mg = (1 - c) * g;
		return [
			(c * pure[0] + mg) * 255,
			(c * pure[1] + mg) * 255,
			(c * pure[2] + mg) * 255
		];
	};
	convert$2.hcg.hsv = function(hcg) {
		const c = hcg[1] / 100;
		const v = c + hcg[2] / 100 * (1 - c);
		let f = 0;
		if (v > 0) f = c / v;
		return [
			hcg[0],
			f * 100,
			v * 100
		];
	};
	convert$2.hcg.hsl = function(hcg) {
		const c = hcg[1] / 100;
		const l = hcg[2] / 100 * (1 - c) + .5 * c;
		let s = 0;
		if (l > 0 && l < .5) s = c / (2 * l);
		else if (l >= .5 && l < 1) s = c / (2 * (1 - l));
		return [
			hcg[0],
			s * 100,
			l * 100
		];
	};
	convert$2.hcg.hwb = function(hcg) {
		const c = hcg[1] / 100;
		const v = c + hcg[2] / 100 * (1 - c);
		return [
			hcg[0],
			(v - c) * 100,
			(1 - v) * 100
		];
	};
	convert$2.hwb.hcg = function(hwb) {
		const w = hwb[1] / 100;
		const v = 1 - hwb[2] / 100;
		const c = v - w;
		let g = 0;
		if (c < 1) g = (v - c) / (1 - c);
		return [
			hwb[0],
			c * 100,
			g * 100
		];
	};
	convert$2.apple.rgb = function(apple) {
		return [
			apple[0] / 65535 * 255,
			apple[1] / 65535 * 255,
			apple[2] / 65535 * 255
		];
	};
	convert$2.rgb.apple = function(rgb) {
		return [
			rgb[0] / 255 * 65535,
			rgb[1] / 255 * 65535,
			rgb[2] / 255 * 65535
		];
	};
	convert$2.gray.rgb = function(args) {
		return [
			args[0] / 100 * 255,
			args[0] / 100 * 255,
			args[0] / 100 * 255
		];
	};
	convert$2.gray.hsl = function(args) {
		return [
			0,
			0,
			args[0]
		];
	};
	convert$2.gray.hsv = convert$2.gray.hsl;
	convert$2.gray.hwb = function(gray) {
		return [
			0,
			100,
			gray[0]
		];
	};
	convert$2.gray.cmyk = function(gray) {
		return [
			0,
			0,
			0,
			gray[0]
		];
	};
	convert$2.gray.lab = function(gray) {
		return [
			gray[0],
			0,
			0
		];
	};
	convert$2.gray.hex = function(gray) {
		const val = Math.round(gray[0] / 100 * 255) & 255;
		const string$1 = ((val << 16) + (val << 8) + val).toString(16).toUpperCase();
		return "000000".substring(string$1.length) + string$1;
	};
	convert$2.rgb.gray = function(rgb) {
		return [(rgb[0] + rgb[1] + rgb[2]) / 3 / 255 * 100];
	};
}) });

//#endregion
//#region node_modules/color-convert/route.js
var require_route = /* @__PURE__ */ __commonJS({ "node_modules/color-convert/route.js": ((exports, module) => {
	var conversions$1 = require_conversions();
	function buildGraph() {
		const graph = {};
		const models$1 = Object.keys(conversions$1);
		for (let len = models$1.length, i = 0; i < len; i++) graph[models$1[i]] = {
			distance: -1,
			parent: null
		};
		return graph;
	}
	function deriveBFS(fromModel) {
		const graph = buildGraph();
		const queue$1 = [fromModel];
		graph[fromModel].distance = 0;
		while (queue$1.length) {
			const current = queue$1.pop();
			const adjacents = Object.keys(conversions$1[current]);
			for (let len = adjacents.length, i = 0; i < len; i++) {
				const adjacent = adjacents[i];
				const node = graph[adjacent];
				if (node.distance === -1) {
					node.distance = graph[current].distance + 1;
					node.parent = current;
					queue$1.unshift(adjacent);
				}
			}
		}
		return graph;
	}
	function link(from$3, to) {
		return function(args) {
			return to(from$3(args));
		};
	}
	function wrapConversion(toModel, graph) {
		const path = [graph[toModel].parent, toModel];
		let fn = conversions$1[graph[toModel].parent][toModel];
		let cur = graph[toModel].parent;
		while (graph[cur].parent) {
			path.unshift(graph[cur].parent);
			fn = link(conversions$1[graph[cur].parent][cur], fn);
			cur = graph[cur].parent;
		}
		fn.conversion = path;
		return fn;
	}
	module.exports = function(fromModel) {
		const graph = deriveBFS(fromModel);
		const conversion = {};
		const models$1 = Object.keys(graph);
		for (let len = models$1.length, i = 0; i < len; i++) {
			const toModel = models$1[i];
			if (graph[toModel].parent === null) continue;
			conversion[toModel] = wrapConversion(toModel, graph);
		}
		return conversion;
	};
}) });

//#endregion
//#region node_modules/color-convert/index.js
var require_color_convert = /* @__PURE__ */ __commonJS({ "node_modules/color-convert/index.js": ((exports, module) => {
	var conversions = require_conversions();
	var route = require_route();
	var convert$1 = {};
	var models = Object.keys(conversions);
	function wrapRaw(fn) {
		const wrappedFn = function(...args) {
			const arg0 = args[0];
			if (arg0 === void 0 || arg0 === null) return arg0;
			if (arg0.length > 1) args = arg0;
			return fn(args);
		};
		if ("conversion" in fn) wrappedFn.conversion = fn.conversion;
		return wrappedFn;
	}
	function wrapRounded(fn) {
		const wrappedFn = function(...args) {
			const arg0 = args[0];
			if (arg0 === void 0 || arg0 === null) return arg0;
			if (arg0.length > 1) args = arg0;
			const result = fn(args);
			if (typeof result === "object") for (let len = result.length, i = 0; i < len; i++) result[i] = Math.round(result[i]);
			return result;
		};
		if ("conversion" in fn) wrappedFn.conversion = fn.conversion;
		return wrappedFn;
	}
	models.forEach((fromModel) => {
		convert$1[fromModel] = {};
		Object.defineProperty(convert$1[fromModel], "channels", { value: conversions[fromModel].channels });
		Object.defineProperty(convert$1[fromModel], "labels", { value: conversions[fromModel].labels });
		const routes = route(fromModel);
		Object.keys(routes).forEach((toModel) => {
			const fn = routes[toModel];
			convert$1[fromModel][toModel] = wrapRounded(fn);
			convert$1[fromModel][toModel].raw = wrapRaw(fn);
		});
	});
	module.exports = convert$1;
}) });

//#endregion
//#region node_modules/color/index.js
var require_color = /* @__PURE__ */ __commonJS({ "node_modules/color/index.js": ((exports, module) => {
	var colorString = require_color_string();
	var convert = require_color_convert();
	var skippedModels = [
		"keyword",
		"gray",
		"hex"
	];
	var hashedModelKeys = {};
	for (const model of Object.keys(convert)) hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
	var limiters = {};
	function Color$1(object$1, model) {
		if (!(this instanceof Color$1)) return new Color$1(object$1, model);
		if (model && model in skippedModels) model = null;
		if (model && !(model in convert)) throw new Error("Unknown model: " + model);
		let i;
		let channels;
		if (object$1 == null) {
			this.model = "rgb";
			this.color = [
				0,
				0,
				0
			];
			this.valpha = 1;
		} else if (object$1 instanceof Color$1) {
			this.model = object$1.model;
			this.color = [...object$1.color];
			this.valpha = object$1.valpha;
		} else if (typeof object$1 === "string") {
			const result = colorString.get(object$1);
			if (result === null) throw new Error("Unable to parse color from string: " + object$1);
			this.model = result.model;
			channels = convert[this.model].channels;
			this.color = result.value.slice(0, channels);
			this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
		} else if (object$1.length > 0) {
			this.model = model || "rgb";
			channels = convert[this.model].channels;
			this.color = zeroArray(Array.prototype.slice.call(object$1, 0, channels), channels);
			this.valpha = typeof object$1[channels] === "number" ? object$1[channels] : 1;
		} else if (typeof object$1 === "number") {
			this.model = "rgb";
			this.color = [
				object$1 >> 16 & 255,
				object$1 >> 8 & 255,
				object$1 & 255
			];
			this.valpha = 1;
		} else {
			this.valpha = 1;
			const keys = Object.keys(object$1);
			if ("alpha" in object$1) {
				keys.splice(keys.indexOf("alpha"), 1);
				this.valpha = typeof object$1.alpha === "number" ? object$1.alpha : 0;
			}
			const hashedKeys = keys.sort().join("");
			if (!(hashedKeys in hashedModelKeys)) throw new Error("Unable to parse color from object: " + JSON.stringify(object$1));
			this.model = hashedModelKeys[hashedKeys];
			const { labels } = convert[this.model];
			const color = [];
			for (i = 0; i < labels.length; i++) color.push(object$1[labels[i]]);
			this.color = zeroArray(color);
		}
		if (limiters[this.model]) {
			channels = convert[this.model].channels;
			for (i = 0; i < channels; i++) {
				const limit = limiters[this.model][i];
				if (limit) this.color[i] = limit(this.color[i]);
			}
		}
		this.valpha = Math.max(0, Math.min(1, this.valpha));
		if (Object.freeze) Object.freeze(this);
	}
	Color$1.prototype = {
		toString() {
			return this.string();
		},
		toJSON() {
			return this[this.model]();
		},
		string(places) {
			let self$1 = this.model in colorString.to ? this : this.rgb();
			self$1 = self$1.round(typeof places === "number" ? places : 1);
			const args = self$1.valpha === 1 ? self$1.color : [...self$1.color, this.valpha];
			return colorString.to[self$1.model](args);
		},
		percentString(places) {
			const self$1 = this.rgb().round(typeof places === "number" ? places : 1);
			const args = self$1.valpha === 1 ? self$1.color : [...self$1.color, this.valpha];
			return colorString.to.rgb.percent(args);
		},
		array() {
			return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
		},
		object() {
			const result = {};
			const { channels } = convert[this.model];
			const { labels } = convert[this.model];
			for (let i = 0; i < channels; i++) result[labels[i]] = this.color[i];
			if (this.valpha !== 1) result.alpha = this.valpha;
			return result;
		},
		unitArray() {
			const rgb = this.rgb().color;
			rgb[0] /= 255;
			rgb[1] /= 255;
			rgb[2] /= 255;
			if (this.valpha !== 1) rgb.push(this.valpha);
			return rgb;
		},
		unitObject() {
			const rgb = this.rgb().object();
			rgb.r /= 255;
			rgb.g /= 255;
			rgb.b /= 255;
			if (this.valpha !== 1) rgb.alpha = this.valpha;
			return rgb;
		},
		round(places) {
			places = Math.max(places || 0, 0);
			return new Color$1([...this.color.map(roundToPlace(places)), this.valpha], this.model);
		},
		alpha(value$2) {
			if (value$2 !== void 0) return new Color$1([...this.color, Math.max(0, Math.min(1, value$2))], this.model);
			return this.valpha;
		},
		red: getset("rgb", 0, maxfn(255)),
		green: getset("rgb", 1, maxfn(255)),
		blue: getset("rgb", 2, maxfn(255)),
		hue: getset([
			"hsl",
			"hsv",
			"hsl",
			"hwb",
			"hcg"
		], 0, (value$2) => (value$2 % 360 + 360) % 360),
		saturationl: getset("hsl", 1, maxfn(100)),
		lightness: getset("hsl", 2, maxfn(100)),
		saturationv: getset("hsv", 1, maxfn(100)),
		value: getset("hsv", 2, maxfn(100)),
		chroma: getset("hcg", 1, maxfn(100)),
		gray: getset("hcg", 2, maxfn(100)),
		white: getset("hwb", 1, maxfn(100)),
		wblack: getset("hwb", 2, maxfn(100)),
		cyan: getset("cmyk", 0, maxfn(100)),
		magenta: getset("cmyk", 1, maxfn(100)),
		yellow: getset("cmyk", 2, maxfn(100)),
		black: getset("cmyk", 3, maxfn(100)),
		x: getset("xyz", 0, maxfn(95.047)),
		y: getset("xyz", 1, maxfn(100)),
		z: getset("xyz", 2, maxfn(108.833)),
		l: getset("lab", 0, maxfn(100)),
		a: getset("lab", 1),
		b: getset("lab", 2),
		keyword(value$2) {
			if (value$2 !== void 0) return new Color$1(value$2);
			return convert[this.model].keyword(this.color);
		},
		hex(value$2) {
			if (value$2 !== void 0) return new Color$1(value$2);
			return colorString.to.hex(this.rgb().round().color);
		},
		hexa(value$2) {
			if (value$2 !== void 0) return new Color$1(value$2);
			const rgbArray = this.rgb().round().color;
			let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
			if (alphaHex.length === 1) alphaHex = "0" + alphaHex;
			return colorString.to.hex(rgbArray) + alphaHex;
		},
		rgbNumber() {
			const rgb = this.rgb().color;
			return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
		},
		luminosity() {
			const rgb = this.rgb().color;
			const lum = [];
			for (const [i, element] of rgb.entries()) {
				const chan = element / 255;
				lum[i] = chan <= .04045 ? chan / 12.92 : ((chan + .055) / 1.055) ** 2.4;
			}
			return .2126 * lum[0] + .7152 * lum[1] + .0722 * lum[2];
		},
		contrast(color2) {
			const lum1 = this.luminosity();
			const lum2 = color2.luminosity();
			if (lum1 > lum2) return (lum1 + .05) / (lum2 + .05);
			return (lum2 + .05) / (lum1 + .05);
		},
		level(color2) {
			const contrastRatio = this.contrast(color2);
			if (contrastRatio >= 7) return "AAA";
			return contrastRatio >= 4.5 ? "AA" : "";
		},
		isDark() {
			const rgb = this.rgb().color;
			return (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4 < 128;
		},
		isLight() {
			return !this.isDark();
		},
		negate() {
			const rgb = this.rgb();
			for (let i = 0; i < 3; i++) rgb.color[i] = 255 - rgb.color[i];
			return rgb;
		},
		lighten(ratio) {
			const hsl = this.hsl();
			hsl.color[2] += hsl.color[2] * ratio;
			return hsl;
		},
		darken(ratio) {
			const hsl = this.hsl();
			hsl.color[2] -= hsl.color[2] * ratio;
			return hsl;
		},
		saturate(ratio) {
			const hsl = this.hsl();
			hsl.color[1] += hsl.color[1] * ratio;
			return hsl;
		},
		desaturate(ratio) {
			const hsl = this.hsl();
			hsl.color[1] -= hsl.color[1] * ratio;
			return hsl;
		},
		whiten(ratio) {
			const hwb = this.hwb();
			hwb.color[1] += hwb.color[1] * ratio;
			return hwb;
		},
		blacken(ratio) {
			const hwb = this.hwb();
			hwb.color[2] += hwb.color[2] * ratio;
			return hwb;
		},
		grayscale() {
			const rgb = this.rgb().color;
			const value$2 = rgb[0] * .3 + rgb[1] * .59 + rgb[2] * .11;
			return Color$1.rgb(value$2, value$2, value$2);
		},
		fade(ratio) {
			return this.alpha(this.valpha - this.valpha * ratio);
		},
		opaquer(ratio) {
			return this.alpha(this.valpha + this.valpha * ratio);
		},
		rotate(degrees) {
			const hsl = this.hsl();
			let hue = hsl.color[0];
			hue = (hue + degrees) % 360;
			hue = hue < 0 ? 360 + hue : hue;
			hsl.color[0] = hue;
			return hsl;
		},
		mix(mixinColor, weight) {
			if (!mixinColor || !mixinColor.rgb) throw new Error("Argument to \"mix\" was not a Color instance, but rather an instance of " + typeof mixinColor);
			const color1 = mixinColor.rgb();
			const color2 = this.rgb();
			const p = weight === void 0 ? .5 : weight;
			const w = 2 * p - 1;
			const a = color1.alpha() - color2.alpha();
			const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
			const w2 = 1 - w1;
			return Color$1.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
		}
	};
	for (const model of Object.keys(convert)) {
		if (skippedModels.includes(model)) continue;
		const { channels } = convert[model];
		Color$1.prototype[model] = function(...args) {
			if (this.model === model) return new Color$1(this);
			if (args.length > 0) return new Color$1(args, model);
			return new Color$1([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
		};
		Color$1[model] = function(...args) {
			let color = args[0];
			if (typeof color === "number") color = zeroArray(args, channels);
			return new Color$1(color, model);
		};
	}
	function roundTo(number$2, places) {
		return Number(number$2.toFixed(places));
	}
	function roundToPlace(places) {
		return function(number$2) {
			return roundTo(number$2, places);
		};
	}
	function getset(model, channel, modifier) {
		model = Array.isArray(model) ? model : [model];
		for (const m of model) (limiters[m] || (limiters[m] = []))[channel] = modifier;
		model = model[0];
		return function(value$2) {
			let result;
			if (value$2 !== void 0) {
				if (modifier) value$2 = modifier(value$2);
				result = this[model]();
				result.color[channel] = value$2;
				return result;
			}
			result = this[model]().color[channel];
			if (modifier) result = modifier(result);
			return result;
		};
	}
	function maxfn(max) {
		return function(v) {
			return Math.max(0, Math.min(max, v));
		};
	}
	function assertArray(value$2) {
		return Array.isArray(value$2) ? value$2 : [value$2];
	}
	function zeroArray(array$1, length) {
		for (let i = 0; i < length; i++) if (typeof array$1[i] !== "number") array$1[i] = 0;
		return array$1;
	}
	module.exports = Color$1;
}) });

//#endregion
//#region node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
var import_color = /* @__PURE__ */ __toESM(require_color());
function storageAvailable$1(type$5) {
	let storageExists = false;
	let storageLength = 0;
	let storage;
	try {
		storage = window[type$5];
		storageExists = true;
		storageLength = storage.length;
		const x = "__storage_test__";
		storage.setItem(x, x);
		storage.removeItem(x);
		return true;
	} catch (err) {
		const error$1 = err;
		return error$1 && (error$1.code === 22 || error$1.code === 1014 || error$1.name === "QuotaExceededError" || error$1.name === "NS_ERROR_DOM_QUOTA_REACHED") && storageExists && storageLength !== 0;
	}
}
var MemoryStore = class {
	constructor() {
		_defineProperty(this, "store", /* @__PURE__ */ new Map());
	}
	getItem(key) {
		return this.store.get(key) || null;
	}
	setItem(key, value$2) {
		this.store.set(key, value$2);
	}
	removeItem(key) {
		this.store.delete(key);
	}
};
var BrowserStorage = class {
	constructor(storeKey, storage) {
		_defineProperty(this, "storage", void 0);
		_defineProperty(this, "_storeKey", void 0);
		this.storage = storage;
		this._storeKey = storeKey;
		try {
			if (!storage.getItem(storeKey)) this.resetStore();
		} catch (error$1) {}
	}
	static getInstance(key) {
		let storageKey$2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "local";
		if (!this.instanceMap.has(key)) {
			let storage;
			if (storageKey$2 === "local" && storageAvailable$1("localStorage")) storage = window.localStorage;
			else if (storageKey$2 === "session" && storageAvailable$1("sessionStorage")) storage = window.sessionStorage;
			else storage = new MemoryStore();
			this.instanceMap.set(key, new this(key, storage));
		}
		return this.instanceMap.get(key);
	}
	toJSON() {
		return this.storage.getItem(this._storeKey);
	}
	resetStore() {
		const currStore = this.getStore();
		this.storage.removeItem(this._storeKey);
		return currStore;
	}
	getStore() {
		return JSON.parse(this.storage.getItem(this._storeKey) || "{}");
	}
	get(key) {
		return JSON.parse(this.storage.getItem(this._storeKey) || "{}")[key];
	}
	set(key, value$2) {
		const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
		store[key] = value$2;
		this.storage.setItem(this._storeKey, JSON.stringify(store));
	}
};
_defineProperty(BrowserStorage, "instanceMap", /* @__PURE__ */ new Map());
var OPENLOGIN_NETWORK = _objectSpread2(_objectSpread2({}, TORUS_SAPPHIRE_NETWORK), TORUS_LEGACY_NETWORK);

//#endregion
//#region node_modules/oblivious-set/dist/esm/src/index.js
/**
* this is a set which automatically forgets
* a given entry when a new entry is set and the ttl
* of the old one is over
*/
var ObliviousSet = class {
	ttl;
	map = /* @__PURE__ */ new Map();
	/**
	* Creating calls to setTimeout() is expensive,
	* so we only do that if there is not timeout already open.
	*/
	_to = false;
	constructor(ttl) {
		this.ttl = ttl;
	}
	has(value$2) {
		return this.map.has(value$2);
	}
	add(value$2) {
		this.map.set(value$2, now());
		/**
		* When a new value is added,
		* start the cleanup at the next tick
		* to not block the cpu for more important stuff
		* that might happen.
		*/
		if (!this._to) {
			this._to = true;
			setTimeout(() => {
				this._to = false;
				removeTooOldValues(this);
			}, 0);
		}
	}
	clear() {
		this.map.clear();
	}
};
/**
* Removes all entries from the set
* where the TTL has expired
*/
function removeTooOldValues(obliviousSet) {
	const olderThen = now() - obliviousSet.ttl;
	const iterator = obliviousSet.map[Symbol.iterator]();
	/**
	* Because we can assume the new values are added at the bottom,
	* we start from the top and stop as soon as we reach a non-too-old value.
	*/
	while (true) {
		const next$1 = iterator.next().value;
		if (!next$1) return;
		const value$2 = next$1[0];
		if (next$1[1] < olderThen) obliviousSet.map.delete(value$2);
		else return;
	}
}
function now() {
	return Date.now();
}

//#endregion
//#region node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES = Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
	PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = {
	type: "error",
	data: "parser error"
};

//#endregion
//#region node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
var isView$1 = (obj) => {
	return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type: type$5, data }, supportsBinary, callback) => {
	if (withNativeBlob$1 && data instanceof Blob) if (supportsBinary) return callback(data);
	else return encodeBlobAsBase64(data, callback);
	else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) if (supportsBinary) return callback(data);
	else return encodeBlobAsBase64(new Blob([data]), callback);
	return callback(PACKET_TYPES[type$5] + (data || ""));
};
var encodeBlobAsBase64 = (data, callback) => {
	const fileReader = new FileReader();
	fileReader.onload = function() {
		const content = fileReader.result.split(",")[1];
		callback("b" + (content || ""));
	};
	return fileReader.readAsDataURL(data);
};
function toArray(data) {
	if (data instanceof Uint8Array) return data;
	else if (data instanceof ArrayBuffer) return new Uint8Array(data);
	else return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
}
var TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
	if (withNativeBlob$1 && packet.data instanceof Blob) return packet.data.arrayBuffer().then(toArray).then(callback);
	else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) return callback(toArray(packet.data));
	encodePacket(packet, false, (encoded) => {
		if (!TEXT_ENCODER) TEXT_ENCODER = new TextEncoder();
		callback(TEXT_ENCODER.encode(encoded));
	});
}

//#endregion
//#region node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i = 0; i < 64; i++) lookup$1[chars.charCodeAt(i)] = i;
const decode$1 = (base64) => {
	let bufferLength = base64.length * .75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
	if (base64[base64.length - 1] === "=") {
		bufferLength--;
		if (base64[base64.length - 2] === "=") bufferLength--;
	}
	const arraybuffer = new ArrayBuffer(bufferLength), bytes$1 = new Uint8Array(arraybuffer);
	for (i = 0; i < len; i += 4) {
		encoded1 = lookup$1[base64.charCodeAt(i)];
		encoded2 = lookup$1[base64.charCodeAt(i + 1)];
		encoded3 = lookup$1[base64.charCodeAt(i + 2)];
		encoded4 = lookup$1[base64.charCodeAt(i + 3)];
		bytes$1[p++] = encoded1 << 2 | encoded2 >> 4;
		bytes$1[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
		bytes$1[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
	}
	return arraybuffer;
};

//#endregion
//#region node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
	if (typeof encodedPacket !== "string") return {
		type: "message",
		data: mapBinary(encodedPacket, binaryType)
	};
	const type$5 = encodedPacket.charAt(0);
	if (type$5 === "b") return {
		type: "message",
		data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
	};
	if (!PACKET_TYPES_REVERSE[type$5]) return ERROR_PACKET;
	return encodedPacket.length > 1 ? {
		type: PACKET_TYPES_REVERSE[type$5],
		data: encodedPacket.substring(1)
	} : { type: PACKET_TYPES_REVERSE[type$5] };
};
var decodeBase64Packet = (data, binaryType) => {
	if (withNativeArrayBuffer$1) return mapBinary(decode$1(data), binaryType);
	else return {
		base64: true,
		data
	};
};
var mapBinary = (data, binaryType) => {
	switch (binaryType) {
		case "blob": if (data instanceof Blob) return data;
		else return new Blob([data]);
		case "arraybuffer":
		default: if (data instanceof ArrayBuffer) return data;
		else return data.buffer;
	}
};

//#endregion
//#region node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
	const length = packets.length;
	const encodedPackets = new Array(length);
	let count = 0;
	packets.forEach((packet, i) => {
		encodePacket(packet, false, (encodedPacket) => {
			encodedPackets[i] = encodedPacket;
			if (++count === length) callback(encodedPackets.join(SEPARATOR));
		});
	});
};
var decodePayload = (encodedPayload, binaryType) => {
	const encodedPackets = encodedPayload.split(SEPARATOR);
	const packets = [];
	for (let i = 0; i < encodedPackets.length; i++) {
		const decodedPacket = decodePacket(encodedPackets[i], binaryType);
		packets.push(decodedPacket);
		if (decodedPacket.type === "error") break;
	}
	return packets;
};
function createPacketEncoderStream() {
	return new TransformStream({ transform(packet, controller) {
		encodePacketToBinary(packet, (encodedPacket) => {
			const payloadLength = encodedPacket.length;
			let header;
			if (payloadLength < 126) {
				header = new Uint8Array(1);
				new DataView(header.buffer).setUint8(0, payloadLength);
			} else if (payloadLength < 65536) {
				header = new Uint8Array(3);
				const view = new DataView(header.buffer);
				view.setUint8(0, 126);
				view.setUint16(1, payloadLength);
			} else {
				header = new Uint8Array(9);
				const view = new DataView(header.buffer);
				view.setUint8(0, 127);
				view.setBigUint64(1, BigInt(payloadLength));
			}
			if (packet.data && typeof packet.data !== "string") header[0] |= 128;
			controller.enqueue(header);
			controller.enqueue(encodedPacket);
		});
	} });
}
var TEXT_DECODER;
function totalLength(chunks) {
	return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
	if (chunks[0].length === size) return chunks.shift();
	const buffer = new Uint8Array(size);
	let j = 0;
	for (let i = 0; i < size; i++) {
		buffer[i] = chunks[0][j++];
		if (j === chunks[0].length) {
			chunks.shift();
			j = 0;
		}
	}
	if (chunks.length && j < chunks[0].length) chunks[0] = chunks[0].slice(j);
	return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
	if (!TEXT_DECODER) TEXT_DECODER = new TextDecoder();
	const chunks = [];
	let state = 0;
	let expectedLength = -1;
	let isBinary$1 = false;
	return new TransformStream({ transform(chunk, controller) {
		chunks.push(chunk);
		while (true) {
			if (state === 0) {
				if (totalLength(chunks) < 1) break;
				const header = concatChunks(chunks, 1);
				isBinary$1 = (header[0] & 128) === 128;
				expectedLength = header[0] & 127;
				if (expectedLength < 126) state = 3;
				else if (expectedLength === 126) state = 1;
				else state = 2;
			} else if (state === 1) {
				if (totalLength(chunks) < 2) break;
				const headerArray = concatChunks(chunks, 2);
				expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
				state = 3;
			} else if (state === 2) {
				if (totalLength(chunks) < 8) break;
				const headerArray = concatChunks(chunks, 8);
				const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
				const n = view.getUint32(0);
				if (n > Math.pow(2, 21) - 1) {
					controller.enqueue(ERROR_PACKET);
					break;
				}
				expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
				state = 3;
			} else {
				if (totalLength(chunks) < expectedLength) break;
				const data = concatChunks(chunks, expectedLength);
				controller.enqueue(decodePacket(isBinary$1 ? data : TEXT_DECODER.decode(data), binaryType));
				state = 0;
			}
			if (expectedLength === 0 || expectedLength > maxPayload) {
				controller.enqueue(ERROR_PACKET);
				break;
			}
		}
	} });
}
const protocol$2 = 4;

//#endregion
//#region node_modules/@socket.io/component-emitter/lib/esm/index.js
/**
* Initialize a new `Emitter`.
*
* @api public
*/
function Emitter(obj) {
	if (obj) return mixin(obj);
}
/**
* Mixin the emitter properties.
*
* @param {Object} obj
* @return {Object}
* @api private
*/
function mixin(obj) {
	for (var key in Emitter.prototype) obj[key] = Emitter.prototype[key];
	return obj;
}
/**
* Listen on the given `event` with `fn`.
*
* @param {String} event
* @param {Function} fn
* @return {Emitter}
* @api public
*/
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
	this._callbacks = this._callbacks || {};
	(this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
	return this;
};
/**
* Adds an `event` listener that will be invoked a single
* time then automatically removed.
*
* @param {String} event
* @param {Function} fn
* @return {Emitter}
* @api public
*/
Emitter.prototype.once = function(event, fn) {
	function on$1() {
		this.off(event, on$1);
		fn.apply(this, arguments);
	}
	on$1.fn = fn;
	this.on(event, on$1);
	return this;
};
/**
* Remove the given callback for `event` or all
* registered callbacks.
*
* @param {String} event
* @param {Function} fn
* @return {Emitter}
* @api public
*/
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
	this._callbacks = this._callbacks || {};
	if (0 == arguments.length) {
		this._callbacks = {};
		return this;
	}
	var callbacks = this._callbacks["$" + event];
	if (!callbacks) return this;
	if (1 == arguments.length) {
		delete this._callbacks["$" + event];
		return this;
	}
	var cb;
	for (var i = 0; i < callbacks.length; i++) {
		cb = callbacks[i];
		if (cb === fn || cb.fn === fn) {
			callbacks.splice(i, 1);
			break;
		}
	}
	if (callbacks.length === 0) delete this._callbacks["$" + event];
	return this;
};
/**
* Emit `event` with the given args.
*
* @param {String} event
* @param {Mixed} ...
* @return {Emitter}
*/
Emitter.prototype.emit = function(event) {
	this._callbacks = this._callbacks || {};
	var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
	for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
	if (callbacks) {
		callbacks = callbacks.slice(0);
		for (var i = 0, len = callbacks.length; i < len; ++i) callbacks[i].apply(this, args);
	}
	return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
/**
* Return array of callbacks for `event`.
*
* @param {String} event
* @return {Array}
* @api public
*/
Emitter.prototype.listeners = function(event) {
	this._callbacks = this._callbacks || {};
	return this._callbacks["$" + event] || [];
};
/**
* Check if this emitter has `event` handlers.
*
* @param {String} event
* @return {Boolean}
* @api public
*/
Emitter.prototype.hasListeners = function(event) {
	return !!this.listeners(event).length;
};

//#endregion
//#region node_modules/engine.io-client/build/esm/globals.js
const nextTick = (() => {
	if (typeof Promise === "function" && typeof Promise.resolve === "function") return (cb) => Promise.resolve().then(cb);
	else return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
})();
const globalThisShim = (() => {
	if (typeof self !== "undefined") return self;
	else if (typeof window !== "undefined") return window;
	else return Function("return this")();
})();
const defaultBinaryType = "arraybuffer";
function createCookieJar() {}

//#endregion
//#region node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
	return attr.reduce((acc, k) => {
		if (obj.hasOwnProperty(k)) acc[k] = obj[k];
		return acc;
	}, {});
}
var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
	if (opts.useNativeTimers) {
		obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
		obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
	} else {
		obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
		obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
	}
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
	if (typeof obj === "string") return utf8Length(obj);
	return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str$1) {
	let c = 0, length = 0;
	for (let i = 0, l = str$1.length; i < l; i++) {
		c = str$1.charCodeAt(i);
		if (c < 128) length += 1;
		else if (c < 2048) length += 2;
		else if (c < 55296 || c >= 57344) length += 3;
		else {
			i++;
			length += 4;
		}
	}
	return length;
}
/**
* Generates a random 8-characters string.
*/
function randomString() {
	return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}

//#endregion
//#region node_modules/engine.io-client/build/esm/contrib/parseqs.js
/**
* Compiles a querystring
* Returns string representation of the object
*
* @param {Object}
* @api private
*/
function encode(obj) {
	let str$1 = "";
	for (let i in obj) if (obj.hasOwnProperty(i)) {
		if (str$1.length) str$1 += "&";
		str$1 += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
	}
	return str$1;
}
/**
* Parses a simple querystring into an object
*
* @param {String} qs
* @api private
*/
function decode(qs) {
	let qry = {};
	let pairs = qs.split("&");
	for (let i = 0, l = pairs.length; i < l; i++) {
		let pair = pairs[i].split("=");
		qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	}
	return qry;
}

//#endregion
//#region node_modules/engine.io-client/build/esm/transport.js
var TransportError = class extends Error {
	constructor(reason, description, context) {
		super(reason);
		this.description = description;
		this.context = context;
		this.type = "TransportError";
	}
};
var Transport = class extends Emitter {
	/**
	* Transport abstract constructor.
	*
	* @param {Object} opts - options
	* @protected
	*/
	constructor(opts) {
		super();
		this.writable = false;
		installTimerFunctions(this, opts);
		this.opts = opts;
		this.query = opts.query;
		this.socket = opts.socket;
		this.supportsBinary = !opts.forceBase64;
	}
	/**
	* Emits an error.
	*
	* @param {String} reason
	* @param description
	* @param context - the error context
	* @return {Transport} for chaining
	* @protected
	*/
	onError(reason, description, context) {
		super.emitReserved("error", new TransportError(reason, description, context));
		return this;
	}
	/**
	* Opens the transport.
	*/
	open() {
		this.readyState = "opening";
		this.doOpen();
		return this;
	}
	/**
	* Closes the transport.
	*/
	close() {
		if (this.readyState === "opening" || this.readyState === "open") {
			this.doClose();
			this.onClose();
		}
		return this;
	}
	/**
	* Sends multiple packets.
	*
	* @param {Array} packets
	*/
	send(packets) {
		if (this.readyState === "open") this.write(packets);
	}
	/**
	* Called upon open
	*
	* @protected
	*/
	onOpen() {
		this.readyState = "open";
		this.writable = true;
		super.emitReserved("open");
	}
	/**
	* Called with data.
	*
	* @param {String} data
	* @protected
	*/
	onData(data) {
		const packet = decodePacket(data, this.socket.binaryType);
		this.onPacket(packet);
	}
	/**
	* Called with a decoded packet.
	*
	* @protected
	*/
	onPacket(packet) {
		super.emitReserved("packet", packet);
	}
	/**
	* Called upon close.
	*
	* @protected
	*/
	onClose(details) {
		this.readyState = "closed";
		super.emitReserved("close", details);
	}
	/**
	* Pauses the transport, in order not to lose packets during an upgrade.
	*
	* @param onPause
	*/
	pause(onPause) {}
	createUri(schema, query = {}) {
		return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
	}
	_hostname() {
		const hostname = this.opts.hostname;
		return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
	}
	_port() {
		if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) return ":" + this.opts.port;
		else return "";
	}
	_query(query) {
		const encodedQuery = encode(query);
		return encodedQuery.length ? "?" + encodedQuery : "";
	}
};

//#endregion
//#region node_modules/engine.io-client/build/esm/transports/polling.js
var Polling = class extends Transport {
	constructor() {
		super(...arguments);
		this._polling = false;
	}
	get name() {
		return "polling";
	}
	/**
	* Opens the socket (triggers polling). We write a PING message to determine
	* when the transport is open.
	*
	* @protected
	*/
	doOpen() {
		this._poll();
	}
	/**
	* Pauses polling.
	*
	* @param {Function} onPause - callback upon buffers are flushed and transport is paused
	* @package
	*/
	pause(onPause) {
		this.readyState = "pausing";
		const pause = () => {
			this.readyState = "paused";
			onPause();
		};
		if (this._polling || !this.writable) {
			let total = 0;
			if (this._polling) {
				total++;
				this.once("pollComplete", function() {
					--total || pause();
				});
			}
			if (!this.writable) {
				total++;
				this.once("drain", function() {
					--total || pause();
				});
			}
		} else pause();
	}
	/**
	* Starts polling cycle.
	*
	* @private
	*/
	_poll() {
		this._polling = true;
		this.doPoll();
		this.emitReserved("poll");
	}
	/**
	* Overloads onData to detect payloads.
	*
	* @protected
	*/
	onData(data) {
		const callback = (packet) => {
			if ("opening" === this.readyState && packet.type === "open") this.onOpen();
			if ("close" === packet.type) {
				this.onClose({ description: "transport closed by the server" });
				return false;
			}
			this.onPacket(packet);
		};
		decodePayload(data, this.socket.binaryType).forEach(callback);
		if ("closed" !== this.readyState) {
			this._polling = false;
			this.emitReserved("pollComplete");
			if ("open" === this.readyState) this._poll();
		}
	}
	/**
	* For polling, send a close packet.
	*
	* @protected
	*/
	doClose() {
		const close$5 = () => {
			this.write([{ type: "close" }]);
		};
		if ("open" === this.readyState) close$5();
		else this.once("open", close$5);
	}
	/**
	* Writes a packets payload.
	*
	* @param {Array} packets - data packets
	* @protected
	*/
	write(packets) {
		this.writable = false;
		encodePayload(packets, (data) => {
			this.doWrite(data, () => {
				this.writable = true;
				this.emitReserved("drain");
			});
		});
	}
	/**
	* Generates uri for connection.
	*
	* @private
	*/
	uri() {
		const schema = this.opts.secure ? "https" : "http";
		const query = this.query || {};
		if (false !== this.opts.timestampRequests) query[this.opts.timestampParam] = randomString();
		if (!this.supportsBinary && !query.sid) query.b64 = 1;
		return this.createUri(schema, query);
	}
};

//#endregion
//#region node_modules/engine.io-client/build/esm/contrib/has-cors.js
var value$1 = false;
try {
	value$1 = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {}
const hasCORS = value$1;

//#endregion
//#region node_modules/engine.io-client/build/esm/transports/polling-xhr.js
function empty() {}
var BaseXHR = class extends Polling {
	/**
	* XHR Polling constructor.
	*
	* @param {Object} opts
	* @package
	*/
	constructor(opts) {
		super(opts);
		if (typeof location !== "undefined") {
			const isSSL = "https:" === location.protocol;
			let port = location.port;
			if (!port) port = isSSL ? "443" : "80";
			this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
		}
	}
	/**
	* Sends data.
	*
	* @param {String} data to send.
	* @param {Function} called upon flush.
	* @private
	*/
	doWrite(data, fn) {
		const req = this.request({
			method: "POST",
			data
		});
		req.on("success", fn);
		req.on("error", (xhrStatus, context) => {
			this.onError("xhr post error", xhrStatus, context);
		});
	}
	/**
	* Starts a poll cycle.
	*
	* @private
	*/
	doPoll() {
		const req = this.request();
		req.on("data", this.onData.bind(this));
		req.on("error", (xhrStatus, context) => {
			this.onError("xhr poll error", xhrStatus, context);
		});
		this.pollXhr = req;
	}
};
var Request = class Request extends Emitter {
	/**
	* Request constructor
	*
	* @param {Object} options
	* @package
	*/
	constructor(createRequest, uri, opts) {
		super();
		this.createRequest = createRequest;
		installTimerFunctions(this, opts);
		this._opts = opts;
		this._method = opts.method || "GET";
		this._uri = uri;
		this._data = void 0 !== opts.data ? opts.data : null;
		this._create();
	}
	/**
	* Creates the XHR object and sends the request.
	*
	* @private
	*/
	_create() {
		var _a;
		const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
		opts.xdomain = !!this._opts.xd;
		const xhr = this._xhr = this.createRequest(opts);
		try {
			xhr.open(this._method, this._uri, true);
			try {
				if (this._opts.extraHeaders) {
					xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
					for (let i in this._opts.extraHeaders) if (this._opts.extraHeaders.hasOwnProperty(i)) xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
				}
			} catch (e) {}
			if ("POST" === this._method) try {
				xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
			} catch (e) {}
			try {
				xhr.setRequestHeader("Accept", "*/*");
			} catch (e) {}
			(_a = this._opts.cookieJar) === null || _a === void 0 || _a.addCookies(xhr);
			if ("withCredentials" in xhr) xhr.withCredentials = this._opts.withCredentials;
			if (this._opts.requestTimeout) xhr.timeout = this._opts.requestTimeout;
			xhr.onreadystatechange = () => {
				var _a$1;
				if (xhr.readyState === 3) (_a$1 = this._opts.cookieJar) === null || _a$1 === void 0 || _a$1.parseCookies(xhr.getResponseHeader("set-cookie"));
				if (4 !== xhr.readyState) return;
				if (200 === xhr.status || 1223 === xhr.status) this._onLoad();
				else this.setTimeoutFn(() => {
					this._onError(typeof xhr.status === "number" ? xhr.status : 0);
				}, 0);
			};
			xhr.send(this._data);
		} catch (e) {
			this.setTimeoutFn(() => {
				this._onError(e);
			}, 0);
			return;
		}
		if (typeof document !== "undefined") {
			this._index = Request.requestsCount++;
			Request.requests[this._index] = this;
		}
	}
	/**
	* Called upon error.
	*
	* @private
	*/
	_onError(err) {
		this.emitReserved("error", err, this._xhr);
		this._cleanup(true);
	}
	/**
	* Cleans up house.
	*
	* @private
	*/
	_cleanup(fromError) {
		if ("undefined" === typeof this._xhr || null === this._xhr) return;
		this._xhr.onreadystatechange = empty;
		if (fromError) try {
			this._xhr.abort();
		} catch (e) {}
		if (typeof document !== "undefined") delete Request.requests[this._index];
		this._xhr = null;
	}
	/**
	* Called upon load.
	*
	* @private
	*/
	_onLoad() {
		const data = this._xhr.responseText;
		if (data !== null) {
			this.emitReserved("data", data);
			this.emitReserved("success");
			this._cleanup();
		}
	}
	/**
	* Aborts the request.
	*
	* @package
	*/
	abort() {
		this._cleanup();
	}
};
Request.requestsCount = 0;
Request.requests = {};
/**
* Aborts pending requests when unloading the window. This is needed to prevent
* memory leaks (e.g. when using IE) and to ensure that no spurious error is
* emitted.
*/
if (typeof document !== "undefined") {
	if (typeof attachEvent === "function") attachEvent("onunload", unloadHandler);
	else if (typeof addEventListener === "function") {
		const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
		addEventListener(terminationEvent, unloadHandler, false);
	}
}
function unloadHandler() {
	for (let i in Request.requests) if (Request.requests.hasOwnProperty(i)) Request.requests[i].abort();
}
var hasXHR2 = (function() {
	const xhr = newRequest({ xdomain: false });
	return xhr && xhr.responseType !== null;
})();
/**
* HTTP long-polling based on the built-in `XMLHttpRequest` object.
*
* Usage: browser
*
* @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
*/
var XHR = class extends BaseXHR {
	constructor(opts) {
		super(opts);
		const forceBase64 = opts && opts.forceBase64;
		this.supportsBinary = hasXHR2 && !forceBase64;
	}
	request(opts = {}) {
		Object.assign(opts, { xd: this.xd }, this.opts);
		return new Request(newRequest, this.uri(), opts);
	}
};
function newRequest(opts) {
	const xdomain = opts.xdomain;
	try {
		if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) return new XMLHttpRequest();
	} catch (e) {}
	if (!xdomain) try {
		return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
	} catch (e) {}
}

//#endregion
//#region node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var BaseWS = class extends Transport {
	get name() {
		return "websocket";
	}
	doOpen() {
		const uri = this.uri();
		const protocols = this.opts.protocols;
		const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
		if (this.opts.extraHeaders) opts.headers = this.opts.extraHeaders;
		try {
			this.ws = this.createSocket(uri, protocols, opts);
		} catch (err) {
			return this.emitReserved("error", err);
		}
		this.ws.binaryType = this.socket.binaryType;
		this.addEventListeners();
	}
	/**
	* Adds event listeners to the socket
	*
	* @private
	*/
	addEventListeners() {
		this.ws.onopen = () => {
			if (this.opts.autoUnref) this.ws._socket.unref();
			this.onOpen();
		};
		this.ws.onclose = (closeEvent) => this.onClose({
			description: "websocket connection closed",
			context: closeEvent
		});
		this.ws.onmessage = (ev) => this.onData(ev.data);
		this.ws.onerror = (e) => this.onError("websocket error", e);
	}
	write(packets) {
		this.writable = false;
		for (let i = 0; i < packets.length; i++) {
			const packet = packets[i];
			const lastPacket = i === packets.length - 1;
			encodePacket(packet, this.supportsBinary, (data) => {
				try {
					this.doWrite(packet, data);
				} catch (e) {}
				if (lastPacket) nextTick(() => {
					this.writable = true;
					this.emitReserved("drain");
				}, this.setTimeoutFn);
			});
		}
	}
	doClose() {
		if (typeof this.ws !== "undefined") {
			this.ws.onerror = () => {};
			this.ws.close();
			this.ws = null;
		}
	}
	/**
	* Generates uri for connection.
	*
	* @private
	*/
	uri() {
		const schema = this.opts.secure ? "wss" : "ws";
		const query = this.query || {};
		if (this.opts.timestampRequests) query[this.opts.timestampParam] = randomString();
		if (!this.supportsBinary) query.b64 = 1;
		return this.createUri(schema, query);
	}
};
var WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
/**
* WebSocket transport based on the built-in `WebSocket` object.
*
* Usage: browser, Node.js (since v21), Deno, Bun
*
* @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
* @see https://caniuse.com/mdn-api_websocket
* @see https://nodejs.org/api/globals.html#websocket
*/
var WS = class extends BaseWS {
	createSocket(uri, protocols, opts) {
		return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
	}
	doWrite(_packet, data) {
		this.ws.send(data);
	}
};

//#endregion
//#region node_modules/engine.io-client/build/esm/transports/webtransport.js
/**
* WebTransport transport based on the built-in `WebTransport` object.
*
* Usage: browser, Node.js (with the `@fails-components/webtransport` package)
*
* @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
* @see https://caniuse.com/webtransport
*/
var WT = class extends Transport {
	get name() {
		return "webtransport";
	}
	doOpen() {
		try {
			this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
		} catch (err) {
			return this.emitReserved("error", err);
		}
		this._transport.closed.then(() => {
			this.onClose();
		}).catch((err) => {
			this.onError("webtransport error", err);
		});
		this._transport.ready.then(() => {
			this._transport.createBidirectionalStream().then((stream) => {
				const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
				const reader = stream.readable.pipeThrough(decoderStream).getReader();
				const encoderStream = createPacketEncoderStream();
				encoderStream.readable.pipeTo(stream.writable);
				this._writer = encoderStream.writable.getWriter();
				const read = () => {
					reader.read().then(({ done, value: value$2 }) => {
						if (done) return;
						this.onPacket(value$2);
						read();
					}).catch((err) => {});
				};
				read();
				const packet = { type: "open" };
				if (this.query.sid) packet.data = `{"sid":"${this.query.sid}"}`;
				this._writer.write(packet).then(() => this.onOpen());
			});
		});
	}
	write(packets) {
		this.writable = false;
		for (let i = 0; i < packets.length; i++) {
			const packet = packets[i];
			const lastPacket = i === packets.length - 1;
			this._writer.write(packet).then(() => {
				if (lastPacket) nextTick(() => {
					this.writable = true;
					this.emitReserved("drain");
				}, this.setTimeoutFn);
			});
		}
	}
	doClose() {
		var _a;
		(_a = this._transport) === null || _a === void 0 || _a.close();
	}
};

//#endregion
//#region node_modules/engine.io-client/build/esm/transports/index.js
const transports = {
	websocket: WS,
	webtransport: WT,
	polling: XHR
};

//#endregion
//#region node_modules/engine.io-client/build/esm/contrib/parseuri.js
/**
* Parses a URI
*
* Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
*
* See:
* - https://developer.mozilla.org/en-US/docs/Web/API/URL
* - https://caniuse.com/url
* - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
*
* History of the parse() method:
* - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
* - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
* - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
*
* @author Steven Levithan <stevenlevithan.com> (MIT license)
* @api private
*/
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
	"source",
	"protocol",
	"authority",
	"userInfo",
	"user",
	"password",
	"host",
	"port",
	"relative",
	"path",
	"directory",
	"file",
	"query",
	"anchor"
];
function parse(str$1) {
	if (str$1.length > 8e3) throw "URI too long";
	const src = str$1, b = str$1.indexOf("["), e = str$1.indexOf("]");
	if (b != -1 && e != -1) str$1 = str$1.substring(0, b) + str$1.substring(b, e).replace(/:/g, ";") + str$1.substring(e, str$1.length);
	let m = re.exec(str$1 || ""), uri = {}, i = 14;
	while (i--) uri[parts[i]] = m[i] || "";
	if (b != -1 && e != -1) {
		uri.source = src;
		uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
		uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
		uri.ipv6uri = true;
	}
	uri.pathNames = pathNames(uri, uri["path"]);
	uri.queryKey = queryKey(uri, uri["query"]);
	return uri;
}
function pathNames(obj, path) {
	const names = path.replace(/\/{2,9}/g, "/").split("/");
	if (path.slice(0, 1) == "/" || path.length === 0) names.splice(0, 1);
	if (path.slice(-1) == "/") names.splice(names.length - 1, 1);
	return names;
}
function queryKey(uri, query) {
	const data = {};
	query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
		if ($1) data[$1] = $2;
	});
	return data;
}

//#endregion
//#region node_modules/engine.io-client/build/esm/socket.js
var withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
var OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) addEventListener("offline", () => {
	OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
}, false);
/**
* This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
* with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
*
* This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
* successfully establishes the connection.
*
* In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
*
* @example
* import { SocketWithoutUpgrade, WebSocket } from "engine.io-client";
*
* const socket = new SocketWithoutUpgrade({
*   transports: [WebSocket]
* });
*
* socket.on("open", () => {
*   socket.send("hello");
* });
*
* @see SocketWithUpgrade
* @see Socket
*/
var SocketWithoutUpgrade = class SocketWithoutUpgrade extends Emitter {
	/**
	* Socket constructor.
	*
	* @param {String|Object} uri - uri or options
	* @param {Object} opts - options
	*/
	constructor(uri, opts) {
		super();
		this.binaryType = defaultBinaryType;
		this.writeBuffer = [];
		this._prevBufferLen = 0;
		this._pingInterval = -1;
		this._pingTimeout = -1;
		this._maxPayload = -1;
		/**
		* The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
		* callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
		*/
		this._pingTimeoutTime = Infinity;
		if (uri && "object" === typeof uri) {
			opts = uri;
			uri = null;
		}
		if (uri) {
			const parsedUri = parse(uri);
			opts.hostname = parsedUri.host;
			opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
			opts.port = parsedUri.port;
			if (parsedUri.query) opts.query = parsedUri.query;
		} else if (opts.host) opts.hostname = parse(opts.host).host;
		installTimerFunctions(this, opts);
		this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
		if (opts.hostname && !opts.port) opts.port = this.secure ? "443" : "80";
		this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
		this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
		this.transports = [];
		this._transportsByName = {};
		opts.transports.forEach((t) => {
			const transportName = t.prototype.name;
			this.transports.push(transportName);
			this._transportsByName[transportName] = t;
		});
		this.opts = Object.assign({
			path: "/engine.io",
			agent: false,
			withCredentials: false,
			upgrade: true,
			timestampParam: "t",
			rememberUpgrade: false,
			addTrailingSlash: true,
			rejectUnauthorized: true,
			perMessageDeflate: { threshold: 1024 },
			transportOptions: {},
			closeOnBeforeunload: false
		}, opts);
		this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
		if (typeof this.opts.query === "string") this.opts.query = decode(this.opts.query);
		if (withEventListeners) {
			if (this.opts.closeOnBeforeunload) {
				this._beforeunloadEventListener = () => {
					if (this.transport) {
						this.transport.removeAllListeners();
						this.transport.close();
					}
				};
				addEventListener("beforeunload", this._beforeunloadEventListener, false);
			}
			if (this.hostname !== "localhost") {
				this._offlineEventListener = () => {
					this._onClose("transport close", { description: "network connection lost" });
				};
				OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
			}
		}
		if (this.opts.withCredentials) this._cookieJar = /* @__PURE__ */ createCookieJar();
		this._open();
	}
	/**
	* Creates transport of the given type.
	*
	* @param {String} name - transport name
	* @return {Transport}
	* @private
	*/
	createTransport(name$1) {
		const query = Object.assign({}, this.opts.query);
		query.EIO = protocol$2;
		query.transport = name$1;
		if (this.id) query.sid = this.id;
		const opts = Object.assign({}, this.opts, {
			query,
			socket: this,
			hostname: this.hostname,
			secure: this.secure,
			port: this.port
		}, this.opts.transportOptions[name$1]);
		return new this._transportsByName[name$1](opts);
	}
	/**
	* Initializes transport to use and starts probe.
	*
	* @private
	*/
	_open() {
		if (this.transports.length === 0) {
			this.setTimeoutFn(() => {
				this.emitReserved("error", "No transports available");
			}, 0);
			return;
		}
		const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
		this.readyState = "opening";
		const transport = this.createTransport(transportName);
		transport.open();
		this.setTransport(transport);
	}
	/**
	* Sets the current transport. Disables the existing one (if any).
	*
	* @private
	*/
	setTransport(transport) {
		if (this.transport) this.transport.removeAllListeners();
		this.transport = transport;
		transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
	}
	/**
	* Called when connection is deemed open.
	*
	* @private
	*/
	onOpen() {
		this.readyState = "open";
		SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
		this.emitReserved("open");
		this.flush();
	}
	/**
	* Handles a packet.
	*
	* @private
	*/
	_onPacket(packet) {
		if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
			this.emitReserved("packet", packet);
			this.emitReserved("heartbeat");
			switch (packet.type) {
				case "open":
					this.onHandshake(JSON.parse(packet.data));
					break;
				case "ping":
					this._sendPacket("pong");
					this.emitReserved("ping");
					this.emitReserved("pong");
					this._resetPingTimeout();
					break;
				case "error":
					const err = /* @__PURE__ */ new Error("server error");
					err.code = packet.data;
					this._onError(err);
					break;
				case "message":
					this.emitReserved("data", packet.data);
					this.emitReserved("message", packet.data);
					break;
			}
		}
	}
	/**
	* Called upon handshake completion.
	*
	* @param {Object} data - handshake obj
	* @private
	*/
	onHandshake(data) {
		this.emitReserved("handshake", data);
		this.id = data.sid;
		this.transport.query.sid = data.sid;
		this._pingInterval = data.pingInterval;
		this._pingTimeout = data.pingTimeout;
		this._maxPayload = data.maxPayload;
		this.onOpen();
		if ("closed" === this.readyState) return;
		this._resetPingTimeout();
	}
	/**
	* Sets and resets ping timeout timer based on server pings.
	*
	* @private
	*/
	_resetPingTimeout() {
		this.clearTimeoutFn(this._pingTimeoutTimer);
		const delay = this._pingInterval + this._pingTimeout;
		this._pingTimeoutTime = Date.now() + delay;
		this._pingTimeoutTimer = this.setTimeoutFn(() => {
			this._onClose("ping timeout");
		}, delay);
		if (this.opts.autoUnref) this._pingTimeoutTimer.unref();
	}
	/**
	* Called on `drain` event
	*
	* @private
	*/
	_onDrain() {
		this.writeBuffer.splice(0, this._prevBufferLen);
		this._prevBufferLen = 0;
		if (0 === this.writeBuffer.length) this.emitReserved("drain");
		else this.flush();
	}
	/**
	* Flush write buffers.
	*
	* @private
	*/
	flush() {
		if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
			const packets = this._getWritablePackets();
			this.transport.send(packets);
			this._prevBufferLen = packets.length;
			this.emitReserved("flush");
		}
	}
	/**
	* Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
	* long-polling)
	*
	* @private
	*/
	_getWritablePackets() {
		if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1)) return this.writeBuffer;
		let payloadSize = 1;
		for (let i = 0; i < this.writeBuffer.length; i++) {
			const data = this.writeBuffer[i].data;
			if (data) payloadSize += byteLength(data);
			if (i > 0 && payloadSize > this._maxPayload) return this.writeBuffer.slice(0, i);
			payloadSize += 2;
		}
		return this.writeBuffer;
	}
	/**
	* Checks whether the heartbeat timer has expired but the socket has not yet been notified.
	*
	* Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
	* `write()` method then the message would not be buffered by the Socket.IO client.
	*
	* @return {boolean}
	* @private
	*/
	_hasPingExpired() {
		if (!this._pingTimeoutTime) return true;
		const hasExpired = Date.now() > this._pingTimeoutTime;
		if (hasExpired) {
			this._pingTimeoutTime = 0;
			nextTick(() => {
				this._onClose("ping timeout");
			}, this.setTimeoutFn);
		}
		return hasExpired;
	}
	/**
	* Sends a message.
	*
	* @param {String} msg - message.
	* @param {Object} options.
	* @param {Function} fn - callback function.
	* @return {Socket} for chaining.
	*/
	write(msg, options, fn) {
		this._sendPacket("message", msg, options, fn);
		return this;
	}
	/**
	* Sends a message. Alias of {@link Socket#write}.
	*
	* @param {String} msg - message.
	* @param {Object} options.
	* @param {Function} fn - callback function.
	* @return {Socket} for chaining.
	*/
	send(msg, options, fn) {
		this._sendPacket("message", msg, options, fn);
		return this;
	}
	/**
	* Sends a packet.
	*
	* @param {String} type: packet type.
	* @param {String} data.
	* @param {Object} options.
	* @param {Function} fn - callback function.
	* @private
	*/
	_sendPacket(type$5, data, options, fn) {
		if ("function" === typeof data) {
			fn = data;
			data = void 0;
		}
		if ("function" === typeof options) {
			fn = options;
			options = null;
		}
		if ("closing" === this.readyState || "closed" === this.readyState) return;
		options = options || {};
		options.compress = false !== options.compress;
		const packet = {
			type: type$5,
			data,
			options
		};
		this.emitReserved("packetCreate", packet);
		this.writeBuffer.push(packet);
		if (fn) this.once("flush", fn);
		this.flush();
	}
	/**
	* Closes the connection.
	*/
	close() {
		const close$5 = () => {
			this._onClose("forced close");
			this.transport.close();
		};
		const cleanupAndClose = () => {
			this.off("upgrade", cleanupAndClose);
			this.off("upgradeError", cleanupAndClose);
			close$5();
		};
		const waitForUpgrade = () => {
			this.once("upgrade", cleanupAndClose);
			this.once("upgradeError", cleanupAndClose);
		};
		if ("opening" === this.readyState || "open" === this.readyState) {
			this.readyState = "closing";
			if (this.writeBuffer.length) this.once("drain", () => {
				if (this.upgrading) waitForUpgrade();
				else close$5();
			});
			else if (this.upgrading) waitForUpgrade();
			else close$5();
		}
		return this;
	}
	/**
	* Called upon transport error
	*
	* @private
	*/
	_onError(err) {
		SocketWithoutUpgrade.priorWebsocketSuccess = false;
		if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
			this.transports.shift();
			return this._open();
		}
		this.emitReserved("error", err);
		this._onClose("transport error", err);
	}
	/**
	* Called upon transport close.
	*
	* @private
	*/
	_onClose(reason, description) {
		if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
			this.clearTimeoutFn(this._pingTimeoutTimer);
			this.transport.removeAllListeners("close");
			this.transport.close();
			this.transport.removeAllListeners();
			if (withEventListeners) {
				if (this._beforeunloadEventListener) removeEventListener("beforeunload", this._beforeunloadEventListener, false);
				if (this._offlineEventListener) {
					const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
					if (i !== -1) OFFLINE_EVENT_LISTENERS.splice(i, 1);
				}
			}
			this.readyState = "closed";
			this.id = null;
			this.emitReserved("close", reason, description);
			this.writeBuffer = [];
			this._prevBufferLen = 0;
		}
	}
};
SocketWithoutUpgrade.protocol = protocol$2;
/**
* This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
* with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
*
* This class comes with an upgrade mechanism, which means that once the connection is established with the first
* low-level transport, it will try to upgrade to a better transport.
*
* In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
*
* @example
* import { SocketWithUpgrade, WebSocket } from "engine.io-client";
*
* const socket = new SocketWithUpgrade({
*   transports: [WebSocket]
* });
*
* socket.on("open", () => {
*   socket.send("hello");
* });
*
* @see SocketWithoutUpgrade
* @see Socket
*/
var SocketWithUpgrade = class extends SocketWithoutUpgrade {
	constructor() {
		super(...arguments);
		this._upgrades = [];
	}
	onOpen() {
		super.onOpen();
		if ("open" === this.readyState && this.opts.upgrade) for (let i = 0; i < this._upgrades.length; i++) this._probe(this._upgrades[i]);
	}
	/**
	* Probes a transport.
	*
	* @param {String} name - transport name
	* @private
	*/
	_probe(name$1) {
		let transport = this.createTransport(name$1);
		let failed = false;
		SocketWithoutUpgrade.priorWebsocketSuccess = false;
		const onTransportOpen = () => {
			if (failed) return;
			transport.send([{
				type: "ping",
				data: "probe"
			}]);
			transport.once("packet", (msg) => {
				if (failed) return;
				if ("pong" === msg.type && "probe" === msg.data) {
					this.upgrading = true;
					this.emitReserved("upgrading", transport);
					if (!transport) return;
					SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
					this.transport.pause(() => {
						if (failed) return;
						if ("closed" === this.readyState) return;
						cleanup();
						this.setTransport(transport);
						transport.send([{ type: "upgrade" }]);
						this.emitReserved("upgrade", transport);
						transport = null;
						this.upgrading = false;
						this.flush();
					});
				} else {
					const err = /* @__PURE__ */ new Error("probe error");
					err.transport = transport.name;
					this.emitReserved("upgradeError", err);
				}
			});
		};
		function freezeTransport() {
			if (failed) return;
			failed = true;
			cleanup();
			transport.close();
			transport = null;
		}
		const onerror = (err) => {
			const error$1 = /* @__PURE__ */ new Error("probe error: " + err);
			error$1.transport = transport.name;
			freezeTransport();
			this.emitReserved("upgradeError", error$1);
		};
		function onTransportClose() {
			onerror("transport closed");
		}
		function onclose() {
			onerror("socket closed");
		}
		function onupgrade(to) {
			if (transport && to.name !== transport.name) freezeTransport();
		}
		const cleanup = () => {
			transport.removeListener("open", onTransportOpen);
			transport.removeListener("error", onerror);
			transport.removeListener("close", onTransportClose);
			this.off("close", onclose);
			this.off("upgrading", onupgrade);
		};
		transport.once("open", onTransportOpen);
		transport.once("error", onerror);
		transport.once("close", onTransportClose);
		this.once("close", onclose);
		this.once("upgrading", onupgrade);
		if (this._upgrades.indexOf("webtransport") !== -1 && name$1 !== "webtransport") this.setTimeoutFn(() => {
			if (!failed) transport.open();
		}, 200);
		else transport.open();
	}
	onHandshake(data) {
		this._upgrades = this._filterUpgrades(data.upgrades);
		super.onHandshake(data);
	}
	/**
	* Filters upgrades, returning only those matching client transports.
	*
	* @param {Array} upgrades - server upgrades
	* @private
	*/
	_filterUpgrades(upgrades) {
		const filteredUpgrades = [];
		for (let i = 0; i < upgrades.length; i++) if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
		return filteredUpgrades;
	}
};
/**
* This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
* with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
*
* This class comes with an upgrade mechanism, which means that once the connection is established with the first
* low-level transport, it will try to upgrade to a better transport.
*
* @example
* import { Socket } from "engine.io-client";
*
* const socket = new Socket();
*
* socket.on("open", () => {
*   socket.send("hello");
* });
*
* @see SocketWithoutUpgrade
* @see SocketWithUpgrade
*/
var Socket$1 = class extends SocketWithUpgrade {
	constructor(uri, opts = {}) {
		const o = typeof uri === "object" ? uri : opts;
		if (!o.transports || o.transports && typeof o.transports[0] === "string") o.transports = (o.transports || [
			"polling",
			"websocket",
			"webtransport"
		]).map((transportName) => transports[transportName]).filter((t) => !!t);
		super(uri, o);
	}
};

//#endregion
//#region node_modules/engine.io-client/build/esm/index.js
const protocol$1 = Socket$1.protocol;

//#endregion
//#region node_modules/socket.io-client/build/esm/url.js
/**
* URL parser.
*
* @param uri - url
* @param path - the request path of the connection
* @param loc - An object meant to mimic window.location.
*        Defaults to window.location.
* @public
*/
function url(uri, path = "", loc) {
	let obj = uri;
	loc = loc || typeof location !== "undefined" && location;
	if (null == uri) uri = loc.protocol + "//" + loc.host;
	if (typeof uri === "string") {
		if ("/" === uri.charAt(0)) if ("/" === uri.charAt(1)) uri = loc.protocol + uri;
		else uri = loc.host + uri;
		if (!/^(https?|wss?):\/\//.test(uri)) if ("undefined" !== typeof loc) uri = loc.protocol + "//" + uri;
		else uri = "https://" + uri;
		obj = parse(uri);
	}
	if (!obj.port) {
		if (/^(http|ws)$/.test(obj.protocol)) obj.port = "80";
		else if (/^(http|ws)s$/.test(obj.protocol)) obj.port = "443";
	}
	obj.path = obj.path || "/";
	const host = obj.host.indexOf(":") !== -1 ? "[" + obj.host + "]" : obj.host;
	obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
	obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
	return obj;
}

//#endregion
//#region node_modules/socket.io-parser/build/esm/is-binary.js
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
	return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
/**
* Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
*
* @private
*/
function isBinary(obj) {
	return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
	if (!obj || typeof obj !== "object") return false;
	if (Array.isArray(obj)) {
		for (let i = 0, l = obj.length; i < l; i++) if (hasBinary(obj[i])) return true;
		return false;
	}
	if (isBinary(obj)) return true;
	if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) return hasBinary(obj.toJSON(), true);
	for (const key in obj) if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) return true;
	return false;
}

//#endregion
//#region node_modules/socket.io-parser/build/esm/binary.js
/**
* Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
*
* @param {Object} packet - socket.io event packet
* @return {Object} with deconstructed packet and list of buffers
* @public
*/
function deconstructPacket(packet) {
	const buffers = [];
	const packetData = packet.data;
	const pack = packet;
	pack.data = _deconstructPacket(packetData, buffers);
	pack.attachments = buffers.length;
	return {
		packet: pack,
		buffers
	};
}
function _deconstructPacket(data, buffers) {
	if (!data) return data;
	if (isBinary(data)) {
		const placeholder = {
			_placeholder: true,
			num: buffers.length
		};
		buffers.push(data);
		return placeholder;
	} else if (Array.isArray(data)) {
		const newData = new Array(data.length);
		for (let i = 0; i < data.length; i++) newData[i] = _deconstructPacket(data[i], buffers);
		return newData;
	} else if (typeof data === "object" && !(data instanceof Date)) {
		const newData = {};
		for (const key in data) if (Object.prototype.hasOwnProperty.call(data, key)) newData[key] = _deconstructPacket(data[key], buffers);
		return newData;
	}
	return data;
}
/**
* Reconstructs a binary packet from its placeholder packet and buffers
*
* @param {Object} packet - event packet with placeholders
* @param {Array} buffers - binary buffers to put in placeholder positions
* @return {Object} reconstructed packet
* @public
*/
function reconstructPacket(packet, buffers) {
	packet.data = _reconstructPacket(packet.data, buffers);
	delete packet.attachments;
	return packet;
}
function _reconstructPacket(data, buffers) {
	if (!data) return data;
	if (data && data._placeholder === true) if (typeof data.num === "number" && data.num >= 0 && data.num < buffers.length) return buffers[data.num];
	else throw new Error("illegal attachments");
	else if (Array.isArray(data)) for (let i = 0; i < data.length; i++) data[i] = _reconstructPacket(data[i], buffers);
	else if (typeof data === "object") {
		for (const key in data) if (Object.prototype.hasOwnProperty.call(data, key)) data[key] = _reconstructPacket(data[key], buffers);
	}
	return data;
}

//#endregion
//#region node_modules/socket.io-parser/build/esm/index.js
var esm_exports = /* @__PURE__ */ __export({
	Decoder: () => Decoder,
	Encoder: () => Encoder,
	PacketType: () => PacketType,
	protocol: () => protocol
});
/**
* These strings must not be used as event names, as they have a special meaning.
*/
var RESERVED_EVENTS$1 = [
	"connect",
	"connect_error",
	"disconnect",
	"disconnecting",
	"newListener",
	"removeListener"
];
/**
* Protocol version.
*
* @public
*/
const protocol = 5;
var PacketType;
(function(PacketType$1) {
	PacketType$1[PacketType$1["CONNECT"] = 0] = "CONNECT";
	PacketType$1[PacketType$1["DISCONNECT"] = 1] = "DISCONNECT";
	PacketType$1[PacketType$1["EVENT"] = 2] = "EVENT";
	PacketType$1[PacketType$1["ACK"] = 3] = "ACK";
	PacketType$1[PacketType$1["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
	PacketType$1[PacketType$1["BINARY_EVENT"] = 5] = "BINARY_EVENT";
	PacketType$1[PacketType$1["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
/**
* A socket.io Encoder instance
*/
var Encoder = class {
	/**
	* Encoder constructor
	*
	* @param {function} replacer - custom replacer to pass down to JSON.parse
	*/
	constructor(replacer) {
		this.replacer = replacer;
	}
	/**
	* Encode a packet as a single string if non-binary, or as a
	* buffer sequence, depending on packet type.
	*
	* @param {Object} obj - packet object
	*/
	encode(obj) {
		if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
			if (hasBinary(obj)) return this.encodeAsBinary({
				type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
				nsp: obj.nsp,
				data: obj.data,
				id: obj.id
			});
		}
		return [this.encodeAsString(obj)];
	}
	/**
	* Encode packet as string.
	*/
	encodeAsString(obj) {
		let str$1 = "" + obj.type;
		if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) str$1 += obj.attachments + "-";
		if (obj.nsp && "/" !== obj.nsp) str$1 += obj.nsp + ",";
		if (null != obj.id) str$1 += obj.id;
		if (null != obj.data) str$1 += JSON.stringify(obj.data, this.replacer);
		return str$1;
	}
	/**
	* Encode packet as 'buffer sequence' by removing blobs, and
	* deconstructing packet into object with placeholders and
	* a list of buffers.
	*/
	encodeAsBinary(obj) {
		const deconstruction = deconstructPacket(obj);
		const pack = this.encodeAsString(deconstruction.packet);
		const buffers = deconstruction.buffers;
		buffers.unshift(pack);
		return buffers;
	}
};
function isObject(value$2) {
	return Object.prototype.toString.call(value$2) === "[object Object]";
}
/**
* A socket.io Decoder instance
*
* @return {Object} decoder
*/
var Decoder = class Decoder extends Emitter {
	/**
	* Decoder constructor
	*
	* @param {function} reviver - custom reviver to pass down to JSON.stringify
	*/
	constructor(reviver) {
		super();
		this.reviver = reviver;
	}
	/**
	* Decodes an encoded packet string into packet JSON.
	*
	* @param {String} obj - encoded packet
	*/
	add(obj) {
		let packet;
		if (typeof obj === "string") {
			if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet");
			packet = this.decodeString(obj);
			const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
			if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
				packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
				this.reconstructor = new BinaryReconstructor(packet);
				if (packet.attachments === 0) super.emitReserved("decoded", packet);
			} else super.emitReserved("decoded", packet);
		} else if (isBinary(obj) || obj.base64) if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
		else {
			packet = this.reconstructor.takeBinaryData(obj);
			if (packet) {
				this.reconstructor = null;
				super.emitReserved("decoded", packet);
			}
		}
		else throw new Error("Unknown type: " + obj);
	}
	/**
	* Decode a packet String (JSON data)
	*
	* @param {String} str
	* @return {Object} packet
	*/
	decodeString(str$1) {
		let i = 0;
		const p = { type: Number(str$1.charAt(0)) };
		if (PacketType[p.type] === void 0) throw new Error("unknown packet type " + p.type);
		if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
			const start = i + 1;
			while (str$1.charAt(++i) !== "-" && i != str$1.length);
			const buf = str$1.substring(start, i);
			if (buf != Number(buf) || str$1.charAt(i) !== "-") throw new Error("Illegal attachments");
			p.attachments = Number(buf);
		}
		if ("/" === str$1.charAt(i + 1)) {
			const start = i + 1;
			while (++i) {
				if ("," === str$1.charAt(i)) break;
				if (i === str$1.length) break;
			}
			p.nsp = str$1.substring(start, i);
		} else p.nsp = "/";
		const next$1 = str$1.charAt(i + 1);
		if ("" !== next$1 && Number(next$1) == next$1) {
			const start = i + 1;
			while (++i) {
				const c = str$1.charAt(i);
				if (null == c || Number(c) != c) {
					--i;
					break;
				}
				if (i === str$1.length) break;
			}
			p.id = Number(str$1.substring(start, i + 1));
		}
		if (str$1.charAt(++i)) {
			const payload = this.tryParse(str$1.substr(i));
			if (Decoder.isPayloadValid(p.type, payload)) p.data = payload;
			else throw new Error("invalid payload");
		}
		return p;
	}
	tryParse(str$1) {
		try {
			return JSON.parse(str$1, this.reviver);
		} catch (e) {
			return false;
		}
	}
	static isPayloadValid(type$5, payload) {
		switch (type$5) {
			case PacketType.CONNECT: return isObject(payload);
			case PacketType.DISCONNECT: return payload === void 0;
			case PacketType.CONNECT_ERROR: return typeof payload === "string" || isObject(payload);
			case PacketType.EVENT:
			case PacketType.BINARY_EVENT: return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
			case PacketType.ACK:
			case PacketType.BINARY_ACK: return Array.isArray(payload);
		}
	}
	/**
	* Deallocates a parser's resources
	*/
	destroy() {
		if (this.reconstructor) {
			this.reconstructor.finishedReconstruction();
			this.reconstructor = null;
		}
	}
};
/**
* A manager of a binary event's 'buffer sequence'. Should
* be constructed whenever a packet of type BINARY_EVENT is
* decoded.
*
* @param {Object} packet
* @return {BinaryReconstructor} initialized reconstructor
*/
var BinaryReconstructor = class {
	constructor(packet) {
		this.packet = packet;
		this.buffers = [];
		this.reconPack = packet;
	}
	/**
	* Method to be called when binary data received from connection
	* after a BINARY_EVENT packet.
	*
	* @param {Buffer | ArrayBuffer} binData - the raw binary data received
	* @return {null | Object} returns null if more binary data is expected or
	*   a reconstructed packet object if all buffers have been received.
	*/
	takeBinaryData(binData) {
		this.buffers.push(binData);
		if (this.buffers.length === this.reconPack.attachments) {
			const packet = reconstructPacket(this.reconPack, this.buffers);
			this.finishedReconstruction();
			return packet;
		}
		return null;
	}
	/**
	* Cleans up binary packet reconstruction variables.
	*/
	finishedReconstruction() {
		this.reconPack = null;
		this.buffers = [];
	}
};

//#endregion
//#region node_modules/socket.io-client/build/esm/on.js
function on(obj, ev, fn) {
	obj.on(ev, fn);
	return function subDestroy() {
		obj.off(ev, fn);
	};
}

//#endregion
//#region node_modules/socket.io-client/build/esm/socket.js
/**
* Internal events.
* These events can't be emitted by the user.
*/
var RESERVED_EVENTS = Object.freeze({
	connect: 1,
	connect_error: 1,
	disconnect: 1,
	disconnecting: 1,
	newListener: 1,
	removeListener: 1
});
/**
* A Socket is the fundamental class for interacting with the server.
*
* A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
*
* @example
* const socket = io();
*
* socket.on("connect", () => {
*   console.log("connected");
* });
*
* // send an event to the server
* socket.emit("foo", "bar");
*
* socket.on("foobar", () => {
*   // an event was received from the server
* });
*
* // upon disconnection
* socket.on("disconnect", (reason) => {
*   console.log(`disconnected due to ${reason}`);
* });
*/
var Socket = class extends Emitter {
	/**
	* `Socket` constructor.
	*/
	constructor(io, nsp, opts) {
		super();
		/**
		* Whether the socket is currently connected to the server.
		*
		* @example
		* const socket = io();
		*
		* socket.on("connect", () => {
		*   console.log(socket.connected); // true
		* });
		*
		* socket.on("disconnect", () => {
		*   console.log(socket.connected); // false
		* });
		*/
		this.connected = false;
		/**
		* Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
		* be transmitted by the server.
		*/
		this.recovered = false;
		/**
		* Buffer for packets received before the CONNECT packet
		*/
		this.receiveBuffer = [];
		/**
		* Buffer for packets that will be sent once the socket is connected
		*/
		this.sendBuffer = [];
		/**
		* The queue of packets to be sent with retry in case of failure.
		*
		* Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
		* @private
		*/
		this._queue = [];
		/**
		* A sequence to generate the ID of the {@link QueuedPacket}.
		* @private
		*/
		this._queueSeq = 0;
		this.ids = 0;
		/**
		* A map containing acknowledgement handlers.
		*
		* The `withError` attribute is used to differentiate handlers that accept an error as first argument:
		*
		* - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
		* - `socket.timeout(5000).emit("test", (err, value) => { ... })`
		* - `const value = await socket.emitWithAck("test")`
		*
		* From those that don't:
		*
		* - `socket.emit("test", (value) => { ... });`
		*
		* In the first case, the handlers will be called with an error when:
		*
		* - the timeout is reached
		* - the socket gets disconnected
		*
		* In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
		* an acknowledgement from the server.
		*
		* @private
		*/
		this.acks = {};
		this.flags = {};
		this.io = io;
		this.nsp = nsp;
		if (opts && opts.auth) this.auth = opts.auth;
		this._opts = Object.assign({}, opts);
		if (this.io._autoConnect) this.open();
	}
	/**
	* Whether the socket is currently disconnected
	*
	* @example
	* const socket = io();
	*
	* socket.on("connect", () => {
	*   console.log(socket.disconnected); // false
	* });
	*
	* socket.on("disconnect", () => {
	*   console.log(socket.disconnected); // true
	* });
	*/
	get disconnected() {
		return !this.connected;
	}
	/**
	* Subscribe to open, close and packet events
	*
	* @private
	*/
	subEvents() {
		if (this.subs) return;
		const io = this.io;
		this.subs = [
			on(io, "open", this.onopen.bind(this)),
			on(io, "packet", this.onpacket.bind(this)),
			on(io, "error", this.onerror.bind(this)),
			on(io, "close", this.onclose.bind(this))
		];
	}
	/**
	* Whether the Socket will try to reconnect when its Manager connects or reconnects.
	*
	* @example
	* const socket = io();
	*
	* console.log(socket.active); // true
	*
	* socket.on("disconnect", (reason) => {
	*   if (reason === "io server disconnect") {
	*     // the disconnection was initiated by the server, you need to manually reconnect
	*     console.log(socket.active); // false
	*   }
	*   // else the socket will automatically try to reconnect
	*   console.log(socket.active); // true
	* });
	*/
	get active() {
		return !!this.subs;
	}
	/**
	* "Opens" the socket.
	*
	* @example
	* const socket = io({
	*   autoConnect: false
	* });
	*
	* socket.connect();
	*/
	connect() {
		if (this.connected) return this;
		this.subEvents();
		if (!this.io["_reconnecting"]) this.io.open();
		if ("open" === this.io._readyState) this.onopen();
		return this;
	}
	/**
	* Alias for {@link connect()}.
	*/
	open() {
		return this.connect();
	}
	/**
	* Sends a `message` event.
	*
	* This method mimics the WebSocket.send() method.
	*
	* @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
	*
	* @example
	* socket.send("hello");
	*
	* // this is equivalent to
	* socket.emit("message", "hello");
	*
	* @return self
	*/
	send(...args) {
		args.unshift("message");
		this.emit.apply(this, args);
		return this;
	}
	/**
	* Override `emit`.
	* If the event is in `events`, it's emitted normally.
	*
	* @example
	* socket.emit("hello", "world");
	*
	* // all serializable datastructures are supported (no need to call JSON.stringify)
	* socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
	*
	* // with an acknowledgement from the server
	* socket.emit("hello", "world", (val) => {
	*   // ...
	* });
	*
	* @return self
	*/
	emit(ev, ...args) {
		var _a, _b, _c;
		if (RESERVED_EVENTS.hasOwnProperty(ev)) throw new Error("\"" + ev.toString() + "\" is a reserved event name");
		args.unshift(ev);
		if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
			this._addToQueue(args);
			return this;
		}
		const packet = {
			type: PacketType.EVENT,
			data: args
		};
		packet.options = {};
		packet.options.compress = this.flags.compress !== false;
		if ("function" === typeof args[args.length - 1]) {
			const id = this.ids++;
			const ack = args.pop();
			this._registerAckCallback(id, ack);
			packet.id = id;
		}
		const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
		const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
		if (this.flags.volatile && !isTransportWritable) {} else if (isConnected) {
			this.notifyOutgoingListeners(packet);
			this.packet(packet);
		} else this.sendBuffer.push(packet);
		this.flags = {};
		return this;
	}
	/**
	* @private
	*/
	_registerAckCallback(id, ack) {
		var _a;
		const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
		if (timeout === void 0) {
			this.acks[id] = ack;
			return;
		}
		const timer = this.io.setTimeoutFn(() => {
			delete this.acks[id];
			for (let i = 0; i < this.sendBuffer.length; i++) if (this.sendBuffer[i].id === id) this.sendBuffer.splice(i, 1);
			ack.call(this, /* @__PURE__ */ new Error("operation has timed out"));
		}, timeout);
		const fn = (...args) => {
			this.io.clearTimeoutFn(timer);
			ack.apply(this, args);
		};
		fn.withError = true;
		this.acks[id] = fn;
	}
	/**
	* Emits an event and waits for an acknowledgement
	*
	* @example
	* // without timeout
	* const response = await socket.emitWithAck("hello", "world");
	*
	* // with a specific timeout
	* try {
	*   const response = await socket.timeout(1000).emitWithAck("hello", "world");
	* } catch (err) {
	*   // the server did not acknowledge the event in the given delay
	* }
	*
	* @return a Promise that will be fulfilled when the server acknowledges the event
	*/
	emitWithAck(ev, ...args) {
		return new Promise((resolve, reject) => {
			const fn = (arg1, arg2) => {
				return arg1 ? reject(arg1) : resolve(arg2);
			};
			fn.withError = true;
			args.push(fn);
			this.emit(ev, ...args);
		});
	}
	/**
	* Add the packet to the queue.
	* @param args
	* @private
	*/
	_addToQueue(args) {
		let ack;
		if (typeof args[args.length - 1] === "function") ack = args.pop();
		const packet = {
			id: this._queueSeq++,
			tryCount: 0,
			pending: false,
			args,
			flags: Object.assign({ fromQueue: true }, this.flags)
		};
		args.push((err, ...responseArgs) => {
			if (packet !== this._queue[0]) return;
			if (err !== null) {
				if (packet.tryCount > this._opts.retries) {
					this._queue.shift();
					if (ack) ack(err);
				}
			} else {
				this._queue.shift();
				if (ack) ack(null, ...responseArgs);
			}
			packet.pending = false;
			return this._drainQueue();
		});
		this._queue.push(packet);
		this._drainQueue();
	}
	/**
	* Send the first packet of the queue, and wait for an acknowledgement from the server.
	* @param force - whether to resend a packet that has not been acknowledged yet
	*
	* @private
	*/
	_drainQueue(force = false) {
		if (!this.connected || this._queue.length === 0) return;
		const packet = this._queue[0];
		if (packet.pending && !force) return;
		packet.pending = true;
		packet.tryCount++;
		this.flags = packet.flags;
		this.emit.apply(this, packet.args);
	}
	/**
	* Sends a packet.
	*
	* @param packet
	* @private
	*/
	packet(packet) {
		packet.nsp = this.nsp;
		this.io._packet(packet);
	}
	/**
	* Called upon engine `open`.
	*
	* @private
	*/
	onopen() {
		if (typeof this.auth == "function") this.auth((data) => {
			this._sendConnectPacket(data);
		});
		else this._sendConnectPacket(this.auth);
	}
	/**
	* Sends a CONNECT packet to initiate the Socket.IO session.
	*
	* @param data
	* @private
	*/
	_sendConnectPacket(data) {
		this.packet({
			type: PacketType.CONNECT,
			data: this._pid ? Object.assign({
				pid: this._pid,
				offset: this._lastOffset
			}, data) : data
		});
	}
	/**
	* Called upon engine or manager `error`.
	*
	* @param err
	* @private
	*/
	onerror(err) {
		if (!this.connected) this.emitReserved("connect_error", err);
	}
	/**
	* Called upon engine `close`.
	*
	* @param reason
	* @param description
	* @private
	*/
	onclose(reason, description) {
		this.connected = false;
		delete this.id;
		this.emitReserved("disconnect", reason, description);
		this._clearAcks();
	}
	/**
	* Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
	* the server.
	*
	* @private
	*/
	_clearAcks() {
		Object.keys(this.acks).forEach((id) => {
			if (!this.sendBuffer.some((packet) => String(packet.id) === id)) {
				const ack = this.acks[id];
				delete this.acks[id];
				if (ack.withError) ack.call(this, /* @__PURE__ */ new Error("socket has been disconnected"));
			}
		});
	}
	/**
	* Called with socket packet.
	*
	* @param packet
	* @private
	*/
	onpacket(packet) {
		if (!(packet.nsp === this.nsp)) return;
		switch (packet.type) {
			case PacketType.CONNECT:
				if (packet.data && packet.data.sid) this.onconnect(packet.data.sid, packet.data.pid);
				else this.emitReserved("connect_error", /* @__PURE__ */ new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
				break;
			case PacketType.EVENT:
			case PacketType.BINARY_EVENT:
				this.onevent(packet);
				break;
			case PacketType.ACK:
			case PacketType.BINARY_ACK:
				this.onack(packet);
				break;
			case PacketType.DISCONNECT:
				this.ondisconnect();
				break;
			case PacketType.CONNECT_ERROR:
				this.destroy();
				const err = new Error(packet.data.message);
				err.data = packet.data.data;
				this.emitReserved("connect_error", err);
				break;
		}
	}
	/**
	* Called upon a server event.
	*
	* @param packet
	* @private
	*/
	onevent(packet) {
		const args = packet.data || [];
		if (null != packet.id) args.push(this.ack(packet.id));
		if (this.connected) this.emitEvent(args);
		else this.receiveBuffer.push(Object.freeze(args));
	}
	emitEvent(args) {
		if (this._anyListeners && this._anyListeners.length) {
			const listeners = this._anyListeners.slice();
			for (const listener of listeners) listener.apply(this, args);
		}
		super.emit.apply(this, args);
		if (this._pid && args.length && typeof args[args.length - 1] === "string") this._lastOffset = args[args.length - 1];
	}
	/**
	* Produces an ack callback to emit with an event.
	*
	* @private
	*/
	ack(id) {
		const self$1 = this;
		let sent = false;
		return function(...args) {
			if (sent) return;
			sent = true;
			self$1.packet({
				type: PacketType.ACK,
				id,
				data: args
			});
		};
	}
	/**
	* Called upon a server acknowledgement.
	*
	* @param packet
	* @private
	*/
	onack(packet) {
		const ack = this.acks[packet.id];
		if (typeof ack !== "function") return;
		delete this.acks[packet.id];
		if (ack.withError) packet.data.unshift(null);
		ack.apply(this, packet.data);
	}
	/**
	* Called upon server connect.
	*
	* @private
	*/
	onconnect(id, pid) {
		this.id = id;
		this.recovered = pid && this._pid === pid;
		this._pid = pid;
		this.connected = true;
		this.emitBuffered();
		this.emitReserved("connect");
		this._drainQueue(true);
	}
	/**
	* Emit buffered events (received and emitted).
	*
	* @private
	*/
	emitBuffered() {
		this.receiveBuffer.forEach((args) => this.emitEvent(args));
		this.receiveBuffer = [];
		this.sendBuffer.forEach((packet) => {
			this.notifyOutgoingListeners(packet);
			this.packet(packet);
		});
		this.sendBuffer = [];
	}
	/**
	* Called upon server disconnect.
	*
	* @private
	*/
	ondisconnect() {
		this.destroy();
		this.onclose("io server disconnect");
	}
	/**
	* Called upon forced client/server side disconnections,
	* this method ensures the manager stops tracking us and
	* that reconnections don't get triggered for this.
	*
	* @private
	*/
	destroy() {
		if (this.subs) {
			this.subs.forEach((subDestroy) => subDestroy());
			this.subs = void 0;
		}
		this.io["_destroy"](this);
	}
	/**
	* Disconnects the socket manually. In that case, the socket will not try to reconnect.
	*
	* If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
	*
	* @example
	* const socket = io();
	*
	* socket.on("disconnect", (reason) => {
	*   // console.log(reason); prints "io client disconnect"
	* });
	*
	* socket.disconnect();
	*
	* @return self
	*/
	disconnect() {
		if (this.connected) this.packet({ type: PacketType.DISCONNECT });
		this.destroy();
		if (this.connected) this.onclose("io client disconnect");
		return this;
	}
	/**
	* Alias for {@link disconnect()}.
	*
	* @return self
	*/
	close() {
		return this.disconnect();
	}
	/**
	* Sets the compress flag.
	*
	* @example
	* socket.compress(false).emit("hello");
	*
	* @param compress - if `true`, compresses the sending data
	* @return self
	*/
	compress(compress) {
		this.flags.compress = compress;
		return this;
	}
	/**
	* Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
	* ready to send messages.
	*
	* @example
	* socket.volatile.emit("hello"); // the server may or may not receive it
	*
	* @returns self
	*/
	get volatile() {
		this.flags.volatile = true;
		return this;
	}
	/**
	* Sets a modifier for a subsequent event emission that the callback will be called with an error when the
	* given number of milliseconds have elapsed without an acknowledgement from the server:
	*
	* @example
	* socket.timeout(5000).emit("my-event", (err) => {
	*   if (err) {
	*     // the server did not acknowledge the event in the given delay
	*   }
	* });
	*
	* @returns self
	*/
	timeout(timeout) {
		this.flags.timeout = timeout;
		return this;
	}
	/**
	* Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	* callback.
	*
	* @example
	* socket.onAny((event, ...args) => {
	*   console.log(`got ${event}`);
	* });
	*
	* @param listener
	*/
	onAny(listener) {
		this._anyListeners = this._anyListeners || [];
		this._anyListeners.push(listener);
		return this;
	}
	/**
	* Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	* callback. The listener is added to the beginning of the listeners array.
	*
	* @example
	* socket.prependAny((event, ...args) => {
	*   console.log(`got event ${event}`);
	* });
	*
	* @param listener
	*/
	prependAny(listener) {
		this._anyListeners = this._anyListeners || [];
		this._anyListeners.unshift(listener);
		return this;
	}
	/**
	* Removes the listener that will be fired when any event is emitted.
	*
	* @example
	* const catchAllListener = (event, ...args) => {
	*   console.log(`got event ${event}`);
	* }
	*
	* socket.onAny(catchAllListener);
	*
	* // remove a specific listener
	* socket.offAny(catchAllListener);
	*
	* // or remove all listeners
	* socket.offAny();
	*
	* @param listener
	*/
	offAny(listener) {
		if (!this._anyListeners) return this;
		if (listener) {
			const listeners = this._anyListeners;
			for (let i = 0; i < listeners.length; i++) if (listener === listeners[i]) {
				listeners.splice(i, 1);
				return this;
			}
		} else this._anyListeners = [];
		return this;
	}
	/**
	* Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
	* e.g. to remove listeners.
	*/
	listenersAny() {
		return this._anyListeners || [];
	}
	/**
	* Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	* callback.
	*
	* Note: acknowledgements sent to the server are not included.
	*
	* @example
	* socket.onAnyOutgoing((event, ...args) => {
	*   console.log(`sent event ${event}`);
	* });
	*
	* @param listener
	*/
	onAnyOutgoing(listener) {
		this._anyOutgoingListeners = this._anyOutgoingListeners || [];
		this._anyOutgoingListeners.push(listener);
		return this;
	}
	/**
	* Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	* callback. The listener is added to the beginning of the listeners array.
	*
	* Note: acknowledgements sent to the server are not included.
	*
	* @example
	* socket.prependAnyOutgoing((event, ...args) => {
	*   console.log(`sent event ${event}`);
	* });
	*
	* @param listener
	*/
	prependAnyOutgoing(listener) {
		this._anyOutgoingListeners = this._anyOutgoingListeners || [];
		this._anyOutgoingListeners.unshift(listener);
		return this;
	}
	/**
	* Removes the listener that will be fired when any event is emitted.
	*
	* @example
	* const catchAllListener = (event, ...args) => {
	*   console.log(`sent event ${event}`);
	* }
	*
	* socket.onAnyOutgoing(catchAllListener);
	*
	* // remove a specific listener
	* socket.offAnyOutgoing(catchAllListener);
	*
	* // or remove all listeners
	* socket.offAnyOutgoing();
	*
	* @param [listener] - the catch-all listener (optional)
	*/
	offAnyOutgoing(listener) {
		if (!this._anyOutgoingListeners) return this;
		if (listener) {
			const listeners = this._anyOutgoingListeners;
			for (let i = 0; i < listeners.length; i++) if (listener === listeners[i]) {
				listeners.splice(i, 1);
				return this;
			}
		} else this._anyOutgoingListeners = [];
		return this;
	}
	/**
	* Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
	* e.g. to remove listeners.
	*/
	listenersAnyOutgoing() {
		return this._anyOutgoingListeners || [];
	}
	/**
	* Notify the listeners for each packet sent
	*
	* @param packet
	*
	* @private
	*/
	notifyOutgoingListeners(packet) {
		if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
			const listeners = this._anyOutgoingListeners.slice();
			for (const listener of listeners) listener.apply(this, packet.data);
		}
	}
};

//#endregion
//#region node_modules/socket.io-client/build/esm/contrib/backo2.js
/**
* Initialize backoff timer with `opts`.
*
* - `min` initial timeout in milliseconds [100]
* - `max` max timeout [10000]
* - `jitter` [0]
* - `factor` [2]
*
* @param {Object} opts
* @api public
*/
function Backoff(opts) {
	opts = opts || {};
	this.ms = opts.min || 100;
	this.max = opts.max || 1e4;
	this.factor = opts.factor || 2;
	this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	this.attempts = 0;
}
/**
* Return the backoff duration.
*
* @return {Number}
* @api public
*/
Backoff.prototype.duration = function() {
	var ms = this.ms * Math.pow(this.factor, this.attempts++);
	if (this.jitter) {
		var rand = Math.random();
		var deviation = Math.floor(rand * this.jitter * ms);
		ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
	}
	return Math.min(ms, this.max) | 0;
};
/**
* Reset the number of attempts.
*
* @api public
*/
Backoff.prototype.reset = function() {
	this.attempts = 0;
};
/**
* Set the minimum duration
*
* @api public
*/
Backoff.prototype.setMin = function(min) {
	this.ms = min;
};
/**
* Set the maximum duration
*
* @api public
*/
Backoff.prototype.setMax = function(max) {
	this.max = max;
};
/**
* Set the jitter
*
* @api public
*/
Backoff.prototype.setJitter = function(jitter) {
	this.jitter = jitter;
};

//#endregion
//#region node_modules/socket.io-client/build/esm/manager.js
var Manager = class extends Emitter {
	constructor(uri, opts) {
		var _a;
		super();
		this.nsps = {};
		this.subs = [];
		if (uri && "object" === typeof uri) {
			opts = uri;
			uri = void 0;
		}
		opts = opts || {};
		opts.path = opts.path || "/socket.io";
		this.opts = opts;
		installTimerFunctions(this, opts);
		this.reconnection(opts.reconnection !== false);
		this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
		this.reconnectionDelay(opts.reconnectionDelay || 1e3);
		this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
		this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : .5);
		this.backoff = new Backoff({
			min: this.reconnectionDelay(),
			max: this.reconnectionDelayMax(),
			jitter: this.randomizationFactor()
		});
		this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
		this._readyState = "closed";
		this.uri = uri;
		const _parser = opts.parser || esm_exports;
		this.encoder = new _parser.Encoder();
		this.decoder = new _parser.Decoder();
		this._autoConnect = opts.autoConnect !== false;
		if (this._autoConnect) this.open();
	}
	reconnection(v) {
		if (!arguments.length) return this._reconnection;
		this._reconnection = !!v;
		if (!v) this.skipReconnect = true;
		return this;
	}
	reconnectionAttempts(v) {
		if (v === void 0) return this._reconnectionAttempts;
		this._reconnectionAttempts = v;
		return this;
	}
	reconnectionDelay(v) {
		var _a;
		if (v === void 0) return this._reconnectionDelay;
		this._reconnectionDelay = v;
		(_a = this.backoff) === null || _a === void 0 || _a.setMin(v);
		return this;
	}
	randomizationFactor(v) {
		var _a;
		if (v === void 0) return this._randomizationFactor;
		this._randomizationFactor = v;
		(_a = this.backoff) === null || _a === void 0 || _a.setJitter(v);
		return this;
	}
	reconnectionDelayMax(v) {
		var _a;
		if (v === void 0) return this._reconnectionDelayMax;
		this._reconnectionDelayMax = v;
		(_a = this.backoff) === null || _a === void 0 || _a.setMax(v);
		return this;
	}
	timeout(v) {
		if (!arguments.length) return this._timeout;
		this._timeout = v;
		return this;
	}
	/**
	* Starts trying to reconnect if reconnection is enabled and we have not
	* started reconnecting yet
	*
	* @private
	*/
	maybeReconnectOnOpen() {
		if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) this.reconnect();
	}
	/**
	* Sets the current transport `socket`.
	*
	* @param {Function} fn - optional, callback
	* @return self
	* @public
	*/
	open(fn) {
		if (~this._readyState.indexOf("open")) return this;
		this.engine = new Socket$1(this.uri, this.opts);
		const socket = this.engine;
		const self$1 = this;
		this._readyState = "opening";
		this.skipReconnect = false;
		const openSubDestroy = on(socket, "open", function() {
			self$1.onopen();
			fn && fn();
		});
		const onError = (err) => {
			this.cleanup();
			this._readyState = "closed";
			this.emitReserved("error", err);
			if (fn) fn(err);
			else this.maybeReconnectOnOpen();
		};
		const errorSub = on(socket, "error", onError);
		if (false !== this._timeout) {
			const timeout = this._timeout;
			const timer = this.setTimeoutFn(() => {
				openSubDestroy();
				onError(/* @__PURE__ */ new Error("timeout"));
				socket.close();
			}, timeout);
			if (this.opts.autoUnref) timer.unref();
			this.subs.push(() => {
				this.clearTimeoutFn(timer);
			});
		}
		this.subs.push(openSubDestroy);
		this.subs.push(errorSub);
		return this;
	}
	/**
	* Alias for open()
	*
	* @return self
	* @public
	*/
	connect(fn) {
		return this.open(fn);
	}
	/**
	* Called upon transport open.
	*
	* @private
	*/
	onopen() {
		this.cleanup();
		this._readyState = "open";
		this.emitReserved("open");
		const socket = this.engine;
		this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
	}
	/**
	* Called upon a ping.
	*
	* @private
	*/
	onping() {
		this.emitReserved("ping");
	}
	/**
	* Called with data.
	*
	* @private
	*/
	ondata(data) {
		try {
			this.decoder.add(data);
		} catch (e) {
			this.onclose("parse error", e);
		}
	}
	/**
	* Called when parser fully decodes a packet.
	*
	* @private
	*/
	ondecoded(packet) {
		nextTick(() => {
			this.emitReserved("packet", packet);
		}, this.setTimeoutFn);
	}
	/**
	* Called upon socket error.
	*
	* @private
	*/
	onerror(err) {
		this.emitReserved("error", err);
	}
	/**
	* Creates a new socket for the given `nsp`.
	*
	* @return {Socket}
	* @public
	*/
	socket(nsp, opts) {
		let socket = this.nsps[nsp];
		if (!socket) {
			socket = new Socket(this, nsp, opts);
			this.nsps[nsp] = socket;
		} else if (this._autoConnect && !socket.active) socket.connect();
		return socket;
	}
	/**
	* Called upon a socket close.
	*
	* @param socket
	* @private
	*/
	_destroy(socket) {
		const nsps = Object.keys(this.nsps);
		for (const nsp of nsps) if (this.nsps[nsp].active) return;
		this._close();
	}
	/**
	* Writes a packet.
	*
	* @param packet
	* @private
	*/
	_packet(packet) {
		const encodedPackets = this.encoder.encode(packet);
		for (let i = 0; i < encodedPackets.length; i++) this.engine.write(encodedPackets[i], packet.options);
	}
	/**
	* Clean up transport subscriptions and packet buffer.
	*
	* @private
	*/
	cleanup() {
		this.subs.forEach((subDestroy) => subDestroy());
		this.subs.length = 0;
		this.decoder.destroy();
	}
	/**
	* Close the current socket.
	*
	* @private
	*/
	_close() {
		this.skipReconnect = true;
		this._reconnecting = false;
		this.onclose("forced close");
	}
	/**
	* Alias for close()
	*
	* @private
	*/
	disconnect() {
		return this._close();
	}
	/**
	* Called when:
	*
	* - the low-level engine is closed
	* - the parser encountered a badly formatted packet
	* - all sockets are disconnected
	*
	* @private
	*/
	onclose(reason, description) {
		var _a;
		this.cleanup();
		(_a = this.engine) === null || _a === void 0 || _a.close();
		this.backoff.reset();
		this._readyState = "closed";
		this.emitReserved("close", reason, description);
		if (this._reconnection && !this.skipReconnect) this.reconnect();
	}
	/**
	* Attempt a reconnection.
	*
	* @private
	*/
	reconnect() {
		if (this._reconnecting || this.skipReconnect) return this;
		const self$1 = this;
		if (this.backoff.attempts >= this._reconnectionAttempts) {
			this.backoff.reset();
			this.emitReserved("reconnect_failed");
			this._reconnecting = false;
		} else {
			const delay = this.backoff.duration();
			this._reconnecting = true;
			const timer = this.setTimeoutFn(() => {
				if (self$1.skipReconnect) return;
				this.emitReserved("reconnect_attempt", self$1.backoff.attempts);
				if (self$1.skipReconnect) return;
				self$1.open((err) => {
					if (err) {
						self$1._reconnecting = false;
						self$1.reconnect();
						this.emitReserved("reconnect_error", err);
					} else self$1.onreconnect();
				});
			}, delay);
			if (this.opts.autoUnref) timer.unref();
			this.subs.push(() => {
				this.clearTimeoutFn(timer);
			});
		}
	}
	/**
	* Called upon successful reconnect.
	*
	* @private
	*/
	onreconnect() {
		const attempt = this.backoff.attempts;
		this._reconnecting = false;
		this.backoff.reset();
		this.emitReserved("reconnect", attempt);
	}
};

//#endregion
//#region node_modules/socket.io-client/build/esm/index.js
/**
* Managers cache.
*/
var cache = {};
function lookup(uri, opts) {
	if (typeof uri === "object") {
		opts = uri;
		uri = void 0;
	}
	opts = opts || {};
	const parsed = url(uri, opts.path || "/socket.io");
	const source = parsed.source;
	const id = parsed.id;
	const path = parsed.path;
	const sameNamespace = cache[id] && path in cache[id]["nsps"];
	const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
	let io;
	if (newConnection) io = new Manager(source, opts);
	else {
		if (!cache[id]) cache[id] = new Manager(source, opts);
		io = cache[id];
	}
	if (parsed.query && !opts.query) opts.query = parsed.queryKey;
	return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
	Manager,
	Socket,
	io: lookup,
	connect: lookup
});

//#endregion
//#region node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js
var import_browser_external_crypto = /* @__PURE__ */ __toESM(require_browser_external_crypto());
var import_elliptic$1 = require_elliptic();
var ec$2 = new import_elliptic$1.ec("secp256k1");
var browserCrypto = global.crypto || global.msCrypto || {};
var subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
var ZERO32 = Buffer.alloc(32, 0);
function assert(condition, message) {
	if (!condition) throw new Error(message || "Assertion failed");
}
function isScalar(x) {
	return Buffer.isBuffer(x) && x.length === 32;
}
function isValidPrivateKey(privateKey) {
	if (!isScalar(privateKey)) return false;
	return privateKey.compare(ZERO32) > 0 && privateKey.compare(EC_GROUP_ORDER) < 0;
}
function equalConstTime(b1, b2) {
	if (b1.length !== b2.length) return false;
	let res = 0;
	for (let i = 0; i < b1.length; i++) res |= b1[i] ^ b2[i];
	return res === 0;
}
function randomBytes(size) {
	const arr$1 = new Uint8Array(size);
	if (typeof browserCrypto.getRandomValues === "undefined") return Buffer.from(import_browser_external_crypto.default.randomBytes(size));
	browserCrypto.getRandomValues(arr$1);
	return Buffer.from(arr$1);
}
async function sha512(msg) {
	if (subtle) {
		const hash$1 = await subtle.digest("SHA-512", msg);
		return new Uint8Array(hash$1);
	}
	const result = import_browser_external_crypto.default.createHash("sha512").update(msg).digest();
	return new Uint8Array(result);
}
function getAes(op) {
	return async function(iv, key, data) {
		if (subtle) {
			const cryptoKey = await subtle.importKey("raw", key, { name: "AES-CBC" }, false, [op]);
			const encAlgorithm = {
				name: "AES-CBC",
				iv
			};
			const result = await subtle[op](encAlgorithm, cryptoKey, data);
			return Buffer.from(new Uint8Array(result));
		} else if (op === "encrypt") {
			const cipher = import_browser_external_crypto.default.createCipheriv("aes-256-cbc", key, iv);
			const firstChunk = cipher.update(data);
			const secondChunk = cipher.final();
			return Buffer.concat([firstChunk, secondChunk]);
		} else if (op === "decrypt") {
			const decipher = import_browser_external_crypto.default.createDecipheriv("aes-256-cbc", key, iv);
			const firstChunk = decipher.update(data);
			const secondChunk = decipher.final();
			return Buffer.concat([firstChunk, secondChunk]);
		}
		throw new Error(`Unsupported operation: ${op}`);
	};
}
var aesCbcEncrypt = getAes("encrypt");
var aesCbcDecrypt = getAes("decrypt");
async function hmacSha256Sign(key, msg) {
	if (subtle) {
		const cryptoKey = await subtle.importKey("raw", new Uint8Array(key), {
			name: "HMAC",
			hash: { name: "SHA-256" }
		}, false, ["sign", "verify"]);
		const sig = await subtle.sign("HMAC", cryptoKey, msg);
		return Buffer.from(new Uint8Array(sig));
	}
	const hmac$1 = import_browser_external_crypto.default.createHmac("sha256", Buffer.from(key));
	hmac$1.update(msg);
	return hmac$1.digest();
}
async function hmacSha256Verify(key, msg, sig) {
	return equalConstTime(await hmacSha256Sign(key, msg), sig);
}
var getPublic = function(privateKey) {
	assert(privateKey.length === 32, "Bad private key");
	assert(isValidPrivateKey(privateKey), "Bad private key");
	return Buffer.from(ec$2.keyFromPrivate(privateKey).getPublic("array"));
};
var sign = async function(privateKey, msg) {
	assert(privateKey.length === 32, "Bad private key");
	assert(isValidPrivateKey(privateKey), "Bad private key");
	assert(msg.length > 0, "Message should not be empty");
	assert(msg.length <= 32, "Message is too long");
	return Buffer.from(ec$2.sign(msg, privateKey, { canonical: true }).toDER());
};
var derive = async function(privateKeyA, publicKeyB) {
	assert(Buffer.isBuffer(privateKeyA), "Bad private key");
	assert(Buffer.isBuffer(publicKeyB), "Bad public key");
	assert(privateKeyA.length === 32, "Bad private key");
	assert(isValidPrivateKey(privateKeyA), "Bad private key");
	assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
	if (publicKeyB.length === 65) assert(publicKeyB[0] === 4, "Bad public key");
	if (publicKeyB.length === 33) assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
	const keyA = ec$2.keyFromPrivate(privateKeyA);
	const keyB = ec$2.keyFromPublic(publicKeyB);
	const Px = keyA.derive(keyB.getPublic());
	return Buffer.from(Px.toArray());
};
var deriveUnpadded = derive;
var derivePadded = async function(privateKeyA, publicKeyB) {
	assert(Buffer.isBuffer(privateKeyA), "Bad private key");
	assert(Buffer.isBuffer(publicKeyB), "Bad public key");
	assert(privateKeyA.length === 32, "Bad private key");
	assert(isValidPrivateKey(privateKeyA), "Bad private key");
	assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
	if (publicKeyB.length === 65) assert(publicKeyB[0] === 4, "Bad public key");
	if (publicKeyB.length === 33) assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
	const keyA = ec$2.keyFromPrivate(privateKeyA);
	const keyB = ec$2.keyFromPublic(publicKeyB);
	const Px = keyA.derive(keyB.getPublic());
	return Buffer.from(Px.toString(16, 64), "hex");
};
var encrypt = async function(publicKeyTo, msg, opts) {
	opts = opts || {};
	let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
	while (!isValidPrivateKey(ephemPrivateKey)) ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
	const ephemPublicKey = getPublic(ephemPrivateKey);
	const hash$1 = await sha512(await deriveUnpadded(ephemPrivateKey, publicKeyTo));
	const iv = opts.iv || randomBytes(16);
	const encryptionKey = hash$1.slice(0, 32);
	const macKey = hash$1.slice(32);
	const ciphertext = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);
	const dataToMac = Buffer.concat([
		iv,
		ephemPublicKey,
		ciphertext
	]);
	return {
		iv,
		ephemPublicKey,
		ciphertext,
		mac: await hmacSha256Sign(Buffer.from(macKey), dataToMac)
	};
};
var decrypt = async function(privateKey, opts, _padding) {
	const padding = _padding !== null && _padding !== void 0 ? _padding : false;
	const hash$1 = await sha512(await (padding ? derivePadded : deriveUnpadded)(privateKey, opts.ephemPublicKey));
	const encryptionKey = hash$1.slice(0, 32);
	const macKey = hash$1.slice(32);
	const dataToMac = Buffer.concat([
		opts.iv,
		opts.ephemPublicKey,
		opts.ciphertext
	]);
	const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);
	if (!macGood && padding === false) return decrypt(privateKey, opts, true);
	else if (!macGood && padding === true) throw new Error("bad MAC after trying padded");
	const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);
	return Buffer.from(new Uint8Array(msg));
};

//#endregion
//#region node_modules/jsonify/lib/parse.js
var require_parse = /* @__PURE__ */ __commonJS({ "node_modules/jsonify/lib/parse.js": ((exports, module) => {
	var at;
	var ch;
	var escapee = {
		"\"": "\"",
		"\\": "\\",
		"/": "/",
		b: "\b",
		f: "\f",
		n: "\n",
		r: "\r",
		t: "	"
	};
	var text;
	function error(m) {
		throw {
			name: "SyntaxError",
			message: m,
			at,
			text
		};
	}
	function next(c) {
		if (c && c !== ch) error("Expected '" + c + "' instead of '" + ch + "'");
		ch = text.charAt(at);
		at += 1;
		return ch;
	}
	function number() {
		var num;
		var str$1 = "";
		if (ch === "-") {
			str$1 = "-";
			next("-");
		}
		while (ch >= "0" && ch <= "9") {
			str$1 += ch;
			next();
		}
		if (ch === ".") {
			str$1 += ".";
			while (next() && ch >= "0" && ch <= "9") str$1 += ch;
		}
		if (ch === "e" || ch === "E") {
			str$1 += ch;
			next();
			if (ch === "-" || ch === "+") {
				str$1 += ch;
				next();
			}
			while (ch >= "0" && ch <= "9") {
				str$1 += ch;
				next();
			}
		}
		num = Number(str$1);
		if (!isFinite(num)) error("Bad number");
		return num;
	}
	function string() {
		var hex;
		var i;
		var str$1 = "";
		var uffff;
		if (ch === "\"") while (next()) if (ch === "\"") {
			next();
			return str$1;
		} else if (ch === "\\") {
			next();
			if (ch === "u") {
				uffff = 0;
				for (i = 0; i < 4; i += 1) {
					hex = parseInt(next(), 16);
					if (!isFinite(hex)) break;
					uffff = uffff * 16 + hex;
				}
				str$1 += String.fromCharCode(uffff);
			} else if (typeof escapee[ch] === "string") str$1 += escapee[ch];
			else break;
		} else str$1 += ch;
		error("Bad string");
	}
	function white() {
		while (ch && ch <= " ") next();
	}
	function word() {
		switch (ch) {
			case "t":
				next("t");
				next("r");
				next("u");
				next("e");
				return true;
			case "f":
				next("f");
				next("a");
				next("l");
				next("s");
				next("e");
				return false;
			case "n":
				next("n");
				next("u");
				next("l");
				next("l");
				return null;
			default: error("Unexpected '" + ch + "'");
		}
	}
	function array() {
		var arr$1 = [];
		if (ch === "[") {
			next("[");
			white();
			if (ch === "]") {
				next("]");
				return arr$1;
			}
			while (ch) {
				arr$1.push(value());
				white();
				if (ch === "]") {
					next("]");
					return arr$1;
				}
				next(",");
				white();
			}
		}
		error("Bad array");
	}
	function object() {
		var key;
		var obj = {};
		if (ch === "{") {
			next("{");
			white();
			if (ch === "}") {
				next("}");
				return obj;
			}
			while (ch) {
				key = string();
				white();
				next(":");
				if (Object.prototype.hasOwnProperty.call(obj, key)) error("Duplicate key \"" + key + "\"");
				obj[key] = value();
				white();
				if (ch === "}") {
					next("}");
					return obj;
				}
				next(",");
				white();
			}
		}
		error("Bad object");
	}
	function value() {
		white();
		switch (ch) {
			case "{": return object();
			case "[": return array();
			case "\"": return string();
			case "-": return number();
			default: return ch >= "0" && ch <= "9" ? number() : word();
		}
	}
	module.exports = function(source, reviver) {
		var result;
		text = source;
		at = 0;
		ch = " ";
		result = value();
		white();
		if (ch) error("Syntax error");
		return typeof reviver === "function" ? function walk(holder, key) {
			var k;
			var v;
			var val = holder[key];
			if (val && typeof val === "object") {
				for (k in value) if (Object.prototype.hasOwnProperty.call(val, k)) {
					v = walk(val, k);
					if (typeof v === "undefined") delete val[k];
					else val[k] = v;
				}
			}
			return reviver.call(holder, key, val);
		}({ "": result }, "") : result;
	};
}) });

//#endregion
//#region node_modules/jsonify/lib/stringify.js
var require_stringify = /* @__PURE__ */ __commonJS({ "node_modules/jsonify/lib/stringify.js": ((exports, module) => {
	var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
	var gap;
	var indent;
	var meta = {
		"\b": "\\b",
		"	": "\\t",
		"\n": "\\n",
		"\f": "\\f",
		"\r": "\\r",
		"\"": "\\\"",
		"\\": "\\\\"
	};
	var rep;
	function quote(string$1) {
		escapable.lastIndex = 0;
		return escapable.test(string$1) ? "\"" + string$1.replace(escapable, function(a) {
			var c = meta[a];
			return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
		}) + "\"" : "\"" + string$1 + "\"";
	}
	function str(key, holder) {
		var i;
		var k;
		var v;
		var length;
		var mind = gap;
		var partial;
		var value$2 = holder[key];
		if (value$2 && typeof value$2 === "object" && typeof value$2.toJSON === "function") value$2 = value$2.toJSON(key);
		if (typeof rep === "function") value$2 = rep.call(holder, key, value$2);
		switch (typeof value$2) {
			case "string": return quote(value$2);
			case "number": return isFinite(value$2) ? String(value$2) : "null";
			case "boolean":
			case "null": return String(value$2);
			case "object":
				if (!value$2) return "null";
				gap += indent;
				partial = [];
				if (Object.prototype.toString.apply(value$2) === "[object Array]") {
					length = value$2.length;
					for (i = 0; i < length; i += 1) partial[i] = str(i, value$2) || "null";
					v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
					gap = mind;
					return v;
				}
				if (rep && typeof rep === "object") {
					length = rep.length;
					for (i = 0; i < length; i += 1) {
						k = rep[i];
						if (typeof k === "string") {
							v = str(k, value$2);
							if (v) partial.push(quote(k) + (gap ? ": " : ":") + v);
						}
					}
				} else for (k in value$2) if (Object.prototype.hasOwnProperty.call(value$2, k)) {
					v = str(k, value$2);
					if (v) partial.push(quote(k) + (gap ? ": " : ":") + v);
				}
				v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
				gap = mind;
				return v;
			default:
		}
	}
	module.exports = function(value$2, replacer, space) {
		var i;
		gap = "";
		indent = "";
		if (typeof space === "number") for (i = 0; i < space; i += 1) indent += " ";
		else if (typeof space === "string") indent = space;
		rep = replacer;
		if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) throw new Error("JSON.stringify");
		return str("", { "": value$2 });
	};
}) });

//#endregion
//#region node_modules/jsonify/index.js
var require_jsonify = /* @__PURE__ */ __commonJS({ "node_modules/jsonify/index.js": ((exports) => {
	exports.parse = require_parse();
	exports.stringify = require_stringify();
}) });

//#endregion
//#region node_modules/json-stable-stringify/index.js
var require_json_stable_stringify = /* @__PURE__ */ __commonJS({ "node_modules/json-stable-stringify/index.js": ((exports, module) => {
	/** @type {typeof JSON.stringify} */
	var jsonStringify = (typeof JSON !== "undefined" ? JSON : require_jsonify()).stringify;
	var isArray = require_isarray();
	var objectKeys = require_object_keys();
	var callBind = require_call_bind();
	var callBound = require_call_bound();
	var $join = callBound("Array.prototype.join");
	var $indexOf = callBound("Array.prototype.indexOf");
	var $splice = callBound("Array.prototype.splice");
	var $sort = callBound("Array.prototype.sort");
	/** @type {(n: number, char: string) => string} */
	var strRepeat = function repeat(n, char) {
		var str$1 = "";
		for (var i = 0; i < n; i += 1) str$1 += char;
		return str$1;
	};
	/** @type {(parent: import('.').Node, key: import('.').Key, value: unknown) => unknown} */
	var defaultReplacer = function(_parent, _key, value$2) {
		return value$2;
	};
	/** @type {import('.')} */
	module.exports = function stableStringify(obj) {
		/** @type {Parameters<import('.')>[1]} */
		var opts = arguments.length > 1 ? arguments[1] : void 0;
		var space = opts && opts.space || "";
		if (typeof space === "number") space = strRepeat(space, " ");
		var cycles = !!opts && typeof opts.cycles === "boolean" && opts.cycles;
		/** @type {undefined | typeof defaultReplacer} */
		var replacer = opts && opts.replacer ? callBind(opts.replacer) : defaultReplacer;
		if (opts && typeof opts.collapseEmpty !== "undefined" && typeof opts.collapseEmpty !== "boolean") throw new TypeError("`collapseEmpty` must be a boolean, if provided");
		var collapseEmpty = !!opts && opts.collapseEmpty;
		var cmpOpt = typeof opts === "function" ? opts : opts && opts.cmp;
		/** @type {undefined | (<T extends import('.').NonArrayNode>(node: T) => (a: Exclude<keyof T, symbol | number>, b: Exclude<keyof T, symbol | number>) => number)} */
		var cmp = cmpOpt && function(node) {
			var get = cmpOpt.length > 2 && function get$1(k) {
				return node[k];
			};
			return function(a, b) {
				return cmpOpt({
					key: a,
					value: node[a]
				}, {
					key: b,
					value: node[b]
				}, get ? (				/** @type {import('.').Getter} */ {
					__proto__: null,
					get
				}) : void 0);
			};
		};
		/** @type {import('.').Node[]} */
		var seen = [];
		return function stringify$2(parent, key, node, level) {
			var indent$1 = space ? "\n" + strRepeat(level, space) : "";
			var colonSeparator = space ? ": " : ":";
			if (node && node.toJSON && typeof node.toJSON === "function") node = node.toJSON();
			node = replacer(parent, key, node);
			if (node === void 0) return;
			if (typeof node !== "object" || node === null) return jsonStringify(node);
			/** @type {(out: string[], brackets: '[]' | '{}') => string} */
			var groupOutput = function(out$1, brackets) {
				return collapseEmpty && out$1.length === 0 ? brackets : (brackets === "[]" ? "[" : "{") + $join(out$1, ",") + indent$1 + (brackets === "[]" ? "]" : "}");
			};
			if (isArray(node)) {
				var out = [];
				for (var i = 0; i < node.length; i++) {
					var item = stringify$2(node, i, node[i], level + 1) || jsonStringify(null);
					out[out.length] = indent$1 + space + item;
				}
				return groupOutput(out, "[]");
			}
			if ($indexOf(seen, node) !== -1) {
				if (cycles) return jsonStringify("__cycle__");
				throw new TypeError("Converting circular structure to JSON");
			} else seen[seen.length] = node;
			/** @type {import('.').Key[]} */
			var keys = $sort(objectKeys(node), cmp && cmp(node));
			var out = [];
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				var value$2 = stringify$2(
					node,
					key,
					/** @type {import('.').NonArrayNode} */
					node[key],
					level + 1
				);
				if (!value$2) continue;
				var keyValue = jsonStringify(key) + colonSeparator + value$2;
				out[out.length] = indent$1 + space + keyValue;
			}
			$splice(seen, $indexOf(seen, node), 1);
			return groupOutput(out, "{}");
		}({ "": obj }, "", obj, 0);
	};
}) });

//#endregion
//#region node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js
var import_json_stable_stringify = /* @__PURE__ */ __toESM(require_json_stable_stringify());
var import_elliptic = require_elliptic();
function keccak256(a) {
	return Buffer.from(keccak256$1(a));
}
var ec = new import_elliptic.ec("secp256k1");
function encParamsHexToBuf(encParamsHex) {
	return {
		iv: Buffer.from(encParamsHex.iv, "hex"),
		ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, "hex"),
		ciphertext: Buffer.from(encParamsHex.ciphertext, "hex"),
		mac: Buffer.from(encParamsHex.mac, "hex")
	};
}
function encParamsBufToHex(encParams) {
	return {
		iv: Buffer.from(encParams.iv).toString("hex"),
		ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString("hex"),
		ciphertext: Buffer.from(encParams.ciphertext).toString("hex"),
		mac: Buffer.from(encParams.mac).toString("hex")
	};
}
async function encryptData(privKeyHex, d) {
	const serializedDec = JSON.stringify(d);
	const serializedBuf = Buffer.from(serializedDec, "utf-8");
	const encParamsHex = encParamsBufToHex(await encrypt(getPublic(Buffer.from(privKeyHex, "hex")), serializedBuf));
	return JSON.stringify(encParamsHex);
}
async function decryptData(privKeyHex, d) {
	const encParams = encParamsHexToBuf(JSON.parse(d));
	const keyPair = ec.keyFromPrivate(privKeyHex);
	const serializedDec = (await decrypt(Buffer.from(keyPair.getPrivate().toString("hex", 64), "hex"), encParams)).toString("utf-8");
	return JSON.parse(serializedDec);
}

//#endregion
//#region node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js
var import_loglevel$2 = /* @__PURE__ */ __toESM(require_loglevel());
/**
* returns true if the given object is a promise
*/
function isPromise(obj) {
	if (obj && typeof obj.then === "function") return true;
	else return false;
}
Promise.resolve(false);
Promise.resolve(true);
var PROMISE_RESOLVED_VOID = Promise.resolve();
function sleep(time, resolveWith) {
	if (!time) time = 0;
	return new Promise((res) => setTimeout(() => res(resolveWith), time));
}
function randomInt(min, max) {
	return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
* https://stackoverflow.com/a/8084248
*/
function randomToken() {
	return Math.random().toString(36).substring(2);
}
var lastMs = 0;
/**
* returns the current time in micro-seconds,
* WARNING: This is a pseudo-function
* Performance.now is not reliable in webworkers, so we just make sure to never return the same time.
* This is enough in browsers, and this function will not be used in nodejs.
* The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.
*/
function microSeconds$5() {
	let ret = Date.now() * 1e3;
	if (ret <= lastMs) ret = lastMs + 1;
	lastMs = ret;
	return ret;
}
var log$2 = import_loglevel$2.default.getLogger("broadcast-channel");
log$2.setLevel("error");
var microSeconds$4 = microSeconds$5;
var type$4 = "native";
function create$4(channelName) {
	const state = {
		time: microSeconds$5(),
		messagesCallback: null,
		bc: new BroadcastChannel(channelName),
		subFns: []
	};
	state.bc.onmessage = (msg) => {
		if (state.messagesCallback) state.messagesCallback(msg.data);
	};
	return state;
}
function close$4(channelState) {
	channelState.bc.close();
	channelState.subFns = [];
}
function postMessage$4(channelState, messageJson) {
	try {
		channelState.bc.postMessage(messageJson, false);
		return PROMISE_RESOLVED_VOID;
	} catch (err) {
		return Promise.reject(err);
	}
}
function onMessage$4(channelState, fn) {
	channelState.messagesCallback = fn;
}
function canBeUsed$4() {
	/**
	* in the electron-renderer, isNode will be true even if we are in browser-context
	* so we also check if window is undefined
	*/
	if (typeof window === "undefined") return false;
	if (typeof BroadcastChannel === "function") {
		if (BroadcastChannel._pubkey) throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
		return true;
	} else return false;
}
function averageResponseTime$4() {
	return 150;
}
var NativeMethod = {
	create: create$4,
	close: close$4,
	onMessage: onMessage$4,
	postMessage: postMessage$4,
	canBeUsed: canBeUsed$4,
	type: type$4,
	averageResponseTime: averageResponseTime$4,
	microSeconds: microSeconds$4
};
function fillOptionsWithDefaults() {
	let originalOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
	const options = JSON.parse(JSON.stringify(originalOptions));
	if (typeof options.webWorkerSupport === "undefined") options.webWorkerSupport = true;
	if (!options.idb) options.idb = {};
	if (!options.idb.ttl) options.idb.ttl = 1e3 * 45;
	if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;
	if (originalOptions.idb && typeof originalOptions.idb.onclose === "function") options.idb.onclose = originalOptions.idb.onclose;
	if (!options.localstorage) options.localstorage = {};
	if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1e3 * 60;
	if (!options.server) options.server = {};
	if (!options.server.url) options.server.url = "https://session.web3auth.io";
	if (!options.server.removeTimeout) options.server.removeTimeout = 1e3 * 60 * 5;
	if (originalOptions.methods) options.methods = originalOptions.methods;
	return options;
}
/**
* this method uses indexeddb to store the messages
* There is currently no observerAPI for idb
* @link https://github.com/w3c/IndexedDB/issues/51
*
* When working on this, ensure to use these performance optimizations:
* @link https://rxdb.info/slow-indexeddb.html
*/
var microSeconds$3 = microSeconds$5;
var DB_PREFIX = "pubkey.broadcast-channel-0-";
var OBJECT_STORE_ID = "messages";
/**
* Use relaxed durability for faster performance on all transactions.
* @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/
*/
var TRANSACTION_SETTINGS = { durability: "relaxed" };
var type$3 = "idb";
function getIdb() {
	if (typeof indexedDB !== "undefined") return indexedDB;
	if (typeof window !== "undefined") {
		if (typeof window.mozIndexedDB !== "undefined") return window.mozIndexedDB;
		if (typeof window.webkitIndexedDB !== "undefined") return window.webkitIndexedDB;
		if (typeof window.msIndexedDB !== "undefined") return window.msIndexedDB;
	}
	return false;
}
/**
* If possible, we should explicitly commit IndexedDB transactions
* for better performance.
* @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/
*/
function commitIndexedDBTransaction(tx) {
	if (tx.commit) tx.commit();
}
function createDatabase(channelName) {
	const IndexedDB = getIdb();
	const dbName = DB_PREFIX + channelName;
	/**
	* All IndexedDB databases are opened without version
	* because it is a bit faster, especially on firefox
	* @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version
	*/
	const openRequest = IndexedDB.open(dbName);
	openRequest.onupgradeneeded = (ev) => {
		ev.target.result.createObjectStore(OBJECT_STORE_ID, {
			keyPath: "id",
			autoIncrement: true
		});
	};
	return new Promise((res, rej) => {
		openRequest.onerror = (ev) => rej(ev);
		openRequest.onsuccess = () => {
			res(openRequest.result);
		};
	});
}
/**
* writes the new message to the database
* so other readers can find it
*/
function writeMessage(db, readerUuid, messageJson) {
	const writeObject = {
		uuid: readerUuid,
		time: Date.now(),
		data: messageJson
	};
	const tx = db.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
	return new Promise((res, rej) => {
		tx.oncomplete = () => res();
		tx.onerror = (ev) => rej(ev);
		tx.objectStore(OBJECT_STORE_ID).add(writeObject);
		commitIndexedDBTransaction(tx);
	});
}
function getAllMessages(db) {
	const tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
	const objectStore = tx.objectStore(OBJECT_STORE_ID);
	const ret = [];
	return new Promise((res) => {
		objectStore.openCursor().onsuccess = (ev) => {
			const cursor = ev.target.result;
			if (cursor) {
				ret.push(cursor.value);
				cursor.continue();
			} else {
				commitIndexedDBTransaction(tx);
				res(ret);
			}
		};
	});
}
function getMessagesHigherThan(db, lastCursorId) {
	const tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
	const objectStore = tx.objectStore(OBJECT_STORE_ID);
	const ret = [];
	let keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
	/**
	* Optimization shortcut,
	* if getAll() can be used, do not use a cursor.
	* @link https://rxdb.info/slow-indexeddb.html
	*/
	if (objectStore.getAll) {
		const getAllRequest = objectStore.getAll(keyRangeValue);
		return new Promise((res, rej) => {
			getAllRequest.onerror = (err) => rej(err);
			getAllRequest.onsuccess = function(e) {
				res(e.target.result);
			};
		});
	}
	function openCursor() {
		try {
			keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
			return objectStore.openCursor(keyRangeValue);
		} catch (e) {
			return objectStore.openCursor();
		}
	}
	return new Promise((res, rej) => {
		const openCursorRequest = openCursor();
		openCursorRequest.onerror = (err) => rej(err);
		openCursorRequest.onsuccess = (ev) => {
			const cursor = ev.target.result;
			if (cursor) if (cursor.value.id < lastCursorId + 1) cursor.continue(lastCursorId + 1);
			else {
				ret.push(cursor.value);
				cursor.continue();
			}
			else {
				commitIndexedDBTransaction(tx);
				res(ret);
			}
		};
	});
}
function removeMessagesById(db, ids) {
	const objectStore = db.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS).objectStore(OBJECT_STORE_ID);
	return Promise.all(ids.map((id) => {
		const deleteRequest = objectStore.delete(id);
		return new Promise((res) => {
			deleteRequest.onsuccess = () => res();
		});
	}));
}
function getOldMessages(db, ttl) {
	const olderThen = Date.now() - ttl;
	const tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
	const objectStore = tx.objectStore(OBJECT_STORE_ID);
	const ret = [];
	return new Promise((res) => {
		objectStore.openCursor().onsuccess = (ev) => {
			const cursor = ev.target.result;
			if (cursor) {
				const msgObk = cursor.value;
				if (msgObk.time < olderThen) {
					ret.push(msgObk);
					cursor.continue();
				} else {
					commitIndexedDBTransaction(tx);
					res(ret);
					return;
				}
			} else res(ret);
		};
	});
}
function cleanOldMessages(db, ttl) {
	return getOldMessages(db, ttl).then((tooOld) => {
		return removeMessagesById(db, tooOld.map((msg) => msg.id));
	});
}
function create$3(channelName, options) {
	options = fillOptionsWithDefaults(options);
	return createDatabase(channelName).then((db) => {
		const state = {
			closed: false,
			lastCursorId: 0,
			channelName,
			options,
			uuid: randomToken(),
			eMIs: new ObliviousSet(options.idb.ttl * 2),
			writeBlockPromise: PROMISE_RESOLVED_VOID,
			messagesCallback: null,
			readQueuePromises: [],
			db,
			time: microSeconds$5()
		};
		/**
		* Handle abrupt closes that do not originate from db.close().
		* This could happen, for example, if the underlying storage is
		* removed or if the user clears the database in the browser's
		* history preferences.
		*/
		db.onclose = function() {
			state.closed = true;
			if (options.idb.onclose) options.idb.onclose();
		};
		/**
		* if service-workers are used,
		* we have no 'storage'-event if they post a message,
		* therefore we also have to set an interval
		*/
		_readLoop(state);
		return state;
	});
}
function _readLoop(state) {
	if (state.closed) return;
	readNewMessages(state).then(() => sleep(state.options.idb.fallbackInterval)).then(() => _readLoop(state));
}
function _filterMessage(msgObj, state) {
	if (msgObj.uuid === state.uuid) return false;
	if (state.eMIs.has(msgObj.id)) return false;
	if (msgObj.data.time < state.messagesCallbackTime) return false;
	return true;
}
/**
* reads all new messages from the database and emits them
*/
function readNewMessages(state) {
	if (state.closed) return PROMISE_RESOLVED_VOID;
	if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;
	return getMessagesHigherThan(state.db, state.lastCursorId).then((newerMessages) => {
		newerMessages.filter((msgObj) => !!msgObj).map((msgObj) => {
			if (msgObj.id > state.lastCursorId) state.lastCursorId = msgObj.id;
			return msgObj;
		}).filter((msgObj) => _filterMessage(msgObj, state)).sort((msgObjA, msgObjB) => msgObjA.time - msgObjB.time).forEach((msgObj) => {
			if (state.messagesCallback) {
				state.eMIs.add(msgObj.id);
				state.messagesCallback(msgObj.data);
			}
		});
		return PROMISE_RESOLVED_VOID;
	});
}
function close$3(channelState) {
	channelState.closed = true;
	channelState.db.close();
}
function postMessage$3(channelState, messageJson) {
	channelState.writeBlockPromise = channelState.writeBlockPromise.then(() => writeMessage(channelState.db, channelState.uuid, messageJson)).then(() => {
		if (randomInt(0, 10) === 0) cleanOldMessages(channelState.db, channelState.options.idb.ttl);
	});
	return channelState.writeBlockPromise;
}
function onMessage$3(channelState, fn, time) {
	channelState.messagesCallbackTime = time;
	channelState.messagesCallback = fn;
	readNewMessages(channelState);
}
function canBeUsed$3() {
	if (!getIdb()) return false;
	return true;
}
function averageResponseTime$3(options) {
	return options.idb.fallbackInterval * 2;
}
var IndexeDbMethod = {
	getIdb,
	createDatabase,
	create: create$3,
	close: close$3,
	onMessage: onMessage$3,
	postMessage: postMessage$3,
	canBeUsed: canBeUsed$3,
	type: type$3,
	averageResponseTime: averageResponseTime$3,
	microSeconds: microSeconds$3,
	writeMessage,
	getAllMessages,
	cleanOldMessages,
	getMessagesHigherThan,
	getOldMessages
};
/**
* A localStorage-only method which uses localstorage and its 'storage'-event
* This does not work inside of webworkers because they have no access to locastorage
* This is basically implemented to support IE9 or your grandmothers toaster.
* @link https://caniuse.com/#feat=namevalue-storage
* @link https://caniuse.com/#feat=indexeddb
*/
var microSeconds$2 = microSeconds$5;
var KEY_PREFIX$1 = "pubkey.broadcastChannel-";
var type$2 = "localstorage";
/**
* copied from crosstab
* @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32
*/
function getLocalStorage() {
	let localStorage;
	if (typeof window === "undefined") return null;
	try {
		localStorage = window.localStorage;
		localStorage = window["ie8-eventlistener/storage"] || window.localStorage;
	} catch (e) {}
	return localStorage;
}
function storageKey$1(channelName) {
	return KEY_PREFIX$1 + channelName;
}
/**
* writes the new message to the storage
* and fires the storage-event so other readers can find it
*/
function postMessage$2(channelState, messageJson) {
	return new Promise((res) => {
		sleep().then(() => {
			const key = storageKey$1(channelState.channelName);
			const writeObj = {
				token: randomToken(),
				time: Date.now(),
				data: messageJson,
				uuid: channelState.uuid
			};
			const value$2 = JSON.stringify(writeObj);
			getLocalStorage().setItem(key, value$2);
			/**
			* StorageEvent does not fire the 'storage' event
			* in the window that changes the state of the local storage.
			* So we fire it manually
			*/
			const ev = document.createEvent("Event");
			ev.initEvent("storage", true, true);
			ev.key = key;
			ev.newValue = value$2;
			window.dispatchEvent(ev);
			res();
		});
	});
}
function addStorageEventListener(channelName, fn) {
	const key = storageKey$1(channelName);
	const listener = (ev) => {
		if (ev.key === key) fn(JSON.parse(ev.newValue));
	};
	window.addEventListener("storage", listener);
	return listener;
}
function removeStorageEventListener(listener) {
	window.removeEventListener("storage", listener);
}
function create$2(channelName, options) {
	options = fillOptionsWithDefaults(options);
	if (!canBeUsed$2()) throw new Error("BroadcastChannel: localstorage cannot be used");
	const uuid = randomToken();
	/**
	* eMIs
	* contains all messages that have been emitted before
	* @type {ObliviousSet}
	*/
	const eMIs = new ObliviousSet(options.localstorage.removeTimeout);
	const state = {
		channelName,
		uuid,
		time: microSeconds$5(),
		eMIs
	};
	state.listener = addStorageEventListener(channelName, (msgObj) => {
		if (!state.messagesCallback) return;
		if (msgObj.uuid === uuid) return;
		if (!msgObj.token || eMIs.has(msgObj.token)) return;
		if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return;
		eMIs.add(msgObj.token);
		state.messagesCallback(msgObj.data);
	});
	return state;
}
function close$2(channelState) {
	removeStorageEventListener(channelState.listener);
}
function onMessage$2(channelState, fn, time) {
	channelState.messagesCallbackTime = time;
	channelState.messagesCallback = fn;
}
function canBeUsed$2() {
	const ls = getLocalStorage();
	if (!ls) return false;
	try {
		const key = "__broadcastchannel_check";
		ls.setItem(key, "works");
		ls.removeItem(key);
	} catch (e) {
		return false;
	}
	return true;
}
function averageResponseTime$2() {
	const defaultTime = 120;
	const userAgent = navigator.userAgent.toLowerCase();
	if (userAgent.includes("safari") && !userAgent.includes("chrome")) return defaultTime * 2;
	return defaultTime;
}
var LocalstorageMethod = {
	getLocalStorage,
	create: create$2,
	close: close$2,
	onMessage: onMessage$2,
	postMessage: postMessage$2,
	canBeUsed: canBeUsed$2,
	type: type$2,
	averageResponseTime: averageResponseTime$2,
	microSeconds: microSeconds$2,
	storageKey: storageKey$1,
	addStorageEventListener,
	removeStorageEventListener
};
/**
* A localStorage-only method which uses localstorage and its 'storage'-event
* This does not work inside of webworkers because they have no access to locastorage
* This is basically implemented to support IE9 or your grandmothers toaster.
* @link https://caniuse.com/#feat=namevalue-storage
* @link https://caniuse.com/#feat=indexeddb
*/
var microSeconds$1 = microSeconds$5;
var KEY_PREFIX = "pubkey.broadcastChannel-";
var type$1 = "server";
var SOCKET_CONN_INSTANCE = null;
var runningChannels = /* @__PURE__ */ new Set();
function storageKey(channelName) {
	return KEY_PREFIX + channelName;
}
/**
* writes the new message to the storage
* and fires the storage-event so other readers can find it
*/
function postMessage$1(channelState, messageJson) {
	return new Promise((res, rej) => {
		sleep().then(async () => {
			const key = storageKey(channelState.channelName);
			const channelEncPrivKey = keccak256(Buffer.from(key, "utf8"));
			const encData = await encryptData(channelEncPrivKey.toString("hex"), {
				token: randomToken(),
				time: Date.now(),
				data: messageJson,
				uuid: channelState.uuid
			});
			const body = {
				sameOriginCheck: true,
				sameIpCheck: true,
				key: getPublic(channelEncPrivKey).toString("hex"),
				data: encData,
				signature: (await sign(channelEncPrivKey, keccak256(Buffer.from(encData, "utf8")))).toString("hex")
			};
			if (channelState.timeout) body.timeout = channelState.timeout;
			return fetch(channelState.serverUrl + "/channel/set", {
				method: "POST",
				body: JSON.stringify(body),
				headers: { "Content-Type": "application/json; charset=utf-8" }
			}).then(res).catch(rej);
		});
	});
}
function getSocketInstance(serverUrl) {
	if (SOCKET_CONN_INSTANCE) return SOCKET_CONN_INSTANCE;
	const SOCKET_CONN = lookup(serverUrl, {
		transports: ["websocket", "polling"],
		withCredentials: true,
		reconnectionDelayMax: 1e4,
		reconnectionAttempts: 10
	});
	SOCKET_CONN.on("connect_error", (err) => {
		SOCKET_CONN.io.opts.transports = ["polling", "websocket"];
		log$2.error("connect error", err);
	});
	SOCKET_CONN.on("connect", async () => {
		const { engine } = SOCKET_CONN.io;
		log$2.debug("initially connected to", engine.transport.name);
		engine.once("upgrade", () => {
			log$2.debug("upgraded", engine.transport.name);
		});
		engine.once("close", (reason) => {
			log$2.debug("connection closed", reason);
		});
	});
	SOCKET_CONN.on("error", (err) => {
		log$2.error("socket errored", err);
		SOCKET_CONN.disconnect();
	});
	SOCKET_CONN_INSTANCE = SOCKET_CONN;
	return SOCKET_CONN;
}
function setupSocketConnection(serverUrl, channelState, fn) {
	const socketConn = getSocketInstance(serverUrl);
	const key = storageKey(channelState.channelName);
	const channelEncPrivKey = keccak256(Buffer.from(key, "utf8"));
	const channelPubKey = getPublic(channelEncPrivKey).toString("hex");
	if (socketConn.connected) socketConn.emit("check_auth_status", channelPubKey, {
		sameOriginCheck: true,
		sameIpCheck: true
	});
	else socketConn.once("connect", () => {
		log$2.debug("connected with socket");
		socketConn.emit("check_auth_status", channelPubKey, {
			sameOriginCheck: true,
			sameIpCheck: true
		});
	});
	const reconnect = () => {
		socketConn.once("connect", async () => {
			if (runningChannels.has(channelState.channelName)) socketConn.emit("check_auth_status", channelPubKey, {
				sameOriginCheck: true,
				sameIpCheck: true
			});
		});
	};
	const visibilityListener = () => {
		if (!socketConn || !runningChannels.has(channelState.channelName)) {
			document.removeEventListener("visibilitychange", visibilityListener);
			return;
		}
		if (!socketConn.connected && document.visibilityState === "visible") reconnect();
	};
	const listener = async (ev) => {
		try {
			const decData = await decryptData(channelEncPrivKey.toString("hex"), ev);
			log$2.info(decData);
			fn(decData);
		} catch (error$1) {
			log$2.error(error$1);
		}
	};
	socketConn.on("disconnect", () => {
		log$2.debug("socket disconnected");
		if (runningChannels.has(channelState.channelName)) {
			log$2.error("socket disconnected unexpectedly, reconnecting socket");
			reconnect();
		}
	});
	socketConn.on(`${channelPubKey}_success`, listener);
	if (typeof document !== "undefined") document.addEventListener("visibilitychange", visibilityListener);
	return socketConn;
}
function create$1(channelName, options) {
	options = fillOptionsWithDefaults(options);
	const state = {
		channelName,
		uuid: randomToken(),
		eMIs: new ObliviousSet(options.server.removeTimeout),
		serverUrl: options.server.url,
		time: microSeconds$5()
	};
	if (options.server.timeout) state.timeout = options.server.timeout;
	setupSocketConnection(options.server.url, state, (msgObj) => {
		if (!state.messagesCallback) return;
		if (msgObj.uuid === state.uuid) return;
		if (!msgObj.token || state.eMIs.has(msgObj.token)) return;
		state.eMIs.add(msgObj.token);
		state.messagesCallback(msgObj.data);
	});
	runningChannels.add(channelName);
	return state;
}
function close$1(channelState) {
	runningChannels.delete(channelState.channelName);
}
function onMessage$1(channelState, fn, time) {
	channelState.messagesCallbackTime = time;
	channelState.messagesCallback = fn;
}
function canBeUsed$1() {
	return true;
}
function averageResponseTime$1() {
	return 500;
}
var ServerMethod = {
	create: create$1,
	close: close$1,
	onMessage: onMessage$1,
	postMessage: postMessage$1,
	canBeUsed: canBeUsed$1,
	type: type$1,
	averageResponseTime: averageResponseTime$1,
	microSeconds: microSeconds$1
};
var microSeconds = microSeconds$5;
var type = "simulate";
var SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
var SIMULATE_DELAY_TIME = 5;
function create(channelName) {
	const state = {
		time: microSeconds$5(),
		name: channelName,
		messagesCallback: null
	};
	SIMULATE_CHANNELS.add(state);
	return state;
}
function close(channelState) {
	SIMULATE_CHANNELS.delete(channelState);
}
function postMessage(channelState, messageJson) {
	return new Promise((res) => setTimeout(() => {
		Array.from(SIMULATE_CHANNELS).forEach((channel) => {
			if (channel.name === channelState.name && channel !== channelState && !!channel.messagesCallback && channel.time < messageJson.time) channel.messagesCallback(messageJson);
		});
		res();
	}, SIMULATE_DELAY_TIME));
}
function onMessage(channelState, fn) {
	channelState.messagesCallback = fn;
}
function canBeUsed() {
	return true;
}
function averageResponseTime() {
	return SIMULATE_DELAY_TIME;
}
var SimulateMethod = {
	create,
	close,
	onMessage,
	postMessage,
	canBeUsed,
	type,
	averageResponseTime,
	microSeconds
};
var METHODS = [
	NativeMethod,
	IndexeDbMethod,
	LocalstorageMethod,
	ServerMethod
];
function chooseMethod(options) {
	let chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);
	if (options.type) {
		if (options.type === "simulate") return SimulateMethod;
		const ret = chooseMethods.find((m) => m.type === options.type);
		if (!ret) throw new Error("method-type " + options.type + " not found");
		else return ret;
	}
	/**
	* if no webworker support is needed,
	* remove idb from the list so that localstorage is been chosen
	*/
	if (!options.webWorkerSupport) chooseMethods = chooseMethods.filter((m) => m.type !== "idb");
	const useMethod = chooseMethods.find((method) => method.canBeUsed(options));
	if (!useMethod) throw new Error(`No useable method found in ${JSON.stringify(METHODS.map((m) => m.type))}`);
	else return useMethod;
}
/**
* Contains all open channels,
* used in tests to ensure everything is closed.
*/
var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
var lastId = 0;
var BroadcastChannel$1 = function(name$1, options) {
	this.id = lastId++;
	OPEN_BROADCAST_CHANNELS.add(this);
	this.name = name$1;
	if (ENFORCED_OPTIONS) options = ENFORCED_OPTIONS;
	this.options = fillOptionsWithDefaults(options);
	this.method = chooseMethod(this.options);
	this._iL = false;
	/**
	* _onMessageListener
	* setting onmessage twice,
	* will overwrite the first listener
	*/
	this._onML = null;
	/**
	* _addEventListeners
	*/
	this._addEL = {
		message: [],
		internal: []
	};
	/**
	* Unsend message promises
	* where the sending is still in progress
	* @type {Set<Promise>}
	*/
	this._uMP = /* @__PURE__ */ new Set();
	/**
	* _beforeClose
	* array of promises that will be awaited
	* before the channel is closed
	*/
	this._befC = [];
	/**
	* _preparePromise
	*/
	this._prepP = null;
	_prepareChannel(this);
};
/**
* used to identify if someone overwrites
* window.BroadcastChannel with this
* See methods/native.js
*/
BroadcastChannel$1._pubkey = true;
/**
* if set, this method is enforced,
* no mather what the options are
*/
var ENFORCED_OPTIONS;
BroadcastChannel$1.prototype = {
	postMessage(msg) {
		if (this.closed) throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + JSON.stringify(msg));
		return _post(this, "message", msg);
	},
	postInternal(msg) {
		return _post(this, "internal", msg);
	},
	set onmessage(fn) {
		const listenObj = {
			time: this.method.microSeconds(),
			fn
		};
		_removeListenerObject(this, "message", this._onML);
		if (fn && typeof fn === "function") {
			this._onML = listenObj;
			_addListenerObject(this, "message", listenObj);
		} else this._onML = null;
	},
	addEventListener(type$5, fn) {
		const listenObj = {
			time: this.method.microSeconds(),
			fn
		};
		_addListenerObject(this, type$5, listenObj);
	},
	removeEventListener(type$5, fn) {
		const obj = this._addEL[type$5].find((obj$1) => obj$1.fn === fn);
		_removeListenerObject(this, type$5, obj);
	},
	close() {
		if (this.closed) return;
		OPEN_BROADCAST_CHANNELS.delete(this);
		this.closed = true;
		const awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
		this._onML = null;
		this._addEL.message = [];
		return awaitPrepare.then(() => Promise.all(Array.from(this._uMP))).then(() => Promise.all(this._befC.map((fn) => fn()))).then(() => this.method.close(this._state));
	},
	get type() {
		return this.method.type;
	},
	get isClosed() {
		return this.closed;
	}
};
/**
* Post a message over the channel
* @returns {Promise} that resolved when the message sending is done
*/
function _post(broadcastChannel, type$5, msg) {
	const msgObj = {
		time: broadcastChannel.method.microSeconds(),
		type: type$5,
		data: msg
	};
	return (broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID).then(() => {
		const sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);
		broadcastChannel._uMP.add(sendPromise);
		sendPromise.catch().then(() => broadcastChannel._uMP.delete(sendPromise));
		return sendPromise;
	});
}
function _prepareChannel(channel) {
	const maybePromise = channel.method.create(channel.name, channel.options);
	if (isPromise(maybePromise)) {
		channel._prepP = maybePromise;
		maybePromise.then((s) => {
			channel._state = s;
		});
	} else channel._state = maybePromise;
}
function _hasMessageListeners(channel) {
	if (channel._addEL.message.length > 0) return true;
	if (channel._addEL.internal.length > 0) return true;
	return false;
}
function _addListenerObject(channel, type$5, obj) {
	channel._addEL[type$5].push(obj);
	_startListening(channel);
}
function _removeListenerObject(channel, type$5, obj) {
	channel._addEL[type$5] = channel._addEL[type$5].filter((o) => o !== obj);
	_stopListening(channel);
}
function _startListening(channel) {
	if (!channel._iL && _hasMessageListeners(channel)) {
		const listenerFn = (msgObj) => {
			channel._addEL[msgObj.type].forEach((listenerObject) => {
				/**
				* Getting the current time in JavaScript has no good precision.
				* So instead of only listening to events that happend 'after' the listener
				* was added, we also listen to events that happended 100ms before it.
				* This ensures that when another process, like a WebWorker, sends events
				* we do not miss them out because their timestamp is a bit off compared to the main process.
				* Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.
				* @link https://johnresig.com/blog/accuracy-of-javascript-time/
				*/
				if (msgObj.time >= listenerObject.time) listenerObject.fn(msgObj.data);
				else if (channel.method.type === "server") listenerObject.fn(msgObj.data);
			});
		};
		const time = channel.method.microSeconds();
		if (channel._prepP) channel._prepP.then(() => {
			channel._iL = true;
			channel.method.onMessage(channel._state, listenerFn, time);
		});
		else {
			channel._iL = true;
			channel.method.onMessage(channel._state, listenerFn, time);
		}
	}
}
function _stopListening(channel) {
	if (channel._iL && !_hasMessageListeners(channel)) {
		channel._iL = false;
		const time = channel.method.microSeconds();
		channel.method.onMessage(channel._state, null, time);
	}
}

//#endregion
//#region node_modules/bowser/es5.js
var require_es5 = /* @__PURE__ */ __commonJS({ "node_modules/bowser/es5.js": ((exports, module) => {
	(function(e, t) {
		"object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.bowser = t() : e.bowser = t();
	})(exports, (function() {
		return function(e) {
			var t = {};
			function r(i) {
				if (t[i]) return t[i].exports;
				var n = t[i] = {
					i,
					l: !1,
					exports: {}
				};
				return e[i].call(n.exports, n, n.exports, r), n.l = !0, n.exports;
			}
			return r.m = e, r.c = t, r.d = function(e$1, t$1, i) {
				r.o(e$1, t$1) || Object.defineProperty(e$1, t$1, {
					enumerable: !0,
					get: i
				});
			}, r.r = function(e$1) {
				"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e$1, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e$1, "__esModule", { value: !0 });
			}, r.t = function(e$1, t$1) {
				if (1 & t$1 && (e$1 = r(e$1)), 8 & t$1) return e$1;
				if (4 & t$1 && "object" == typeof e$1 && e$1 && e$1.__esModule) return e$1;
				var i = Object.create(null);
				if (r.r(i), Object.defineProperty(i, "default", {
					enumerable: !0,
					value: e$1
				}), 2 & t$1 && "string" != typeof e$1) for (var n in e$1) r.d(i, n, function(t$2) {
					return e$1[t$2];
				}.bind(null, n));
				return i;
			}, r.n = function(e$1) {
				var t$1 = e$1 && e$1.__esModule ? function() {
					return e$1.default;
				} : function() {
					return e$1;
				};
				return r.d(t$1, "a", t$1), t$1;
			}, r.o = function(e$1, t$1) {
				return Object.prototype.hasOwnProperty.call(e$1, t$1);
			}, r.p = "", r(r.s = 90);
		}({
			17: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i = r(18);
				t.default = function() {
					function e$1() {}
					return e$1.getFirstMatch = function(e$2, t$1) {
						var r$1 = t$1.match(e$2);
						return r$1 && r$1.length > 0 && r$1[1] || "";
					}, e$1.getSecondMatch = function(e$2, t$1) {
						var r$1 = t$1.match(e$2);
						return r$1 && r$1.length > 1 && r$1[2] || "";
					}, e$1.matchAndReturnConst = function(e$2, t$1, r$1) {
						if (e$2.test(t$1)) return r$1;
					}, e$1.getWindowsVersionName = function(e$2) {
						switch (e$2) {
							case "NT": return "NT";
							case "XP": return "XP";
							case "NT 5.0": return "2000";
							case "NT 5.1": return "XP";
							case "NT 5.2": return "2003";
							case "NT 6.0": return "Vista";
							case "NT 6.1": return "7";
							case "NT 6.2": return "8";
							case "NT 6.3": return "8.1";
							case "NT 10.0": return "10";
							default: return;
						}
					}, e$1.getMacOSVersionName = function(e$2) {
						var t$1 = e$2.split(".").splice(0, 2).map((function(e$3) {
							return parseInt(e$3, 10) || 0;
						}));
						t$1.push(0);
						var r$1 = t$1[0], i$1 = t$1[1];
						if (10 === r$1) switch (i$1) {
							case 5: return "Leopard";
							case 6: return "Snow Leopard";
							case 7: return "Lion";
							case 8: return "Mountain Lion";
							case 9: return "Mavericks";
							case 10: return "Yosemite";
							case 11: return "El Capitan";
							case 12: return "Sierra";
							case 13: return "High Sierra";
							case 14: return "Mojave";
							case 15: return "Catalina";
							default: return;
						}
						switch (r$1) {
							case 11: return "Big Sur";
							case 12: return "Monterey";
							case 13: return "Ventura";
							case 14: return "Sonoma";
							case 15: return "Sequoia";
							default: return;
						}
					}, e$1.getAndroidVersionName = function(e$2) {
						var t$1 = e$2.split(".").splice(0, 2).map((function(e$3) {
							return parseInt(e$3, 10) || 0;
						}));
						if (t$1.push(0), !(1 === t$1[0] && t$1[1] < 5)) return 1 === t$1[0] && t$1[1] < 6 ? "Cupcake" : 1 === t$1[0] && t$1[1] >= 6 ? "Donut" : 2 === t$1[0] && t$1[1] < 2 ? "Eclair" : 2 === t$1[0] && 2 === t$1[1] ? "Froyo" : 2 === t$1[0] && t$1[1] > 2 ? "Gingerbread" : 3 === t$1[0] ? "Honeycomb" : 4 === t$1[0] && t$1[1] < 1 ? "Ice Cream Sandwich" : 4 === t$1[0] && t$1[1] < 4 ? "Jelly Bean" : 4 === t$1[0] && t$1[1] >= 4 ? "KitKat" : 5 === t$1[0] ? "Lollipop" : 6 === t$1[0] ? "Marshmallow" : 7 === t$1[0] ? "Nougat" : 8 === t$1[0] ? "Oreo" : 9 === t$1[0] ? "Pie" : void 0;
					}, e$1.getVersionPrecision = function(e$2) {
						return e$2.split(".").length;
					}, e$1.compareVersions = function(t$1, r$1, i$1) {
						void 0 === i$1 && (i$1 = !1);
						var n = e$1.getVersionPrecision(t$1), a = e$1.getVersionPrecision(r$1), o = Math.max(n, a), s = 0, u = e$1.map([t$1, r$1], (function(t$2) {
							var r$2 = o - e$1.getVersionPrecision(t$2), i$2 = t$2 + new Array(r$2 + 1).join(".0");
							return e$1.map(i$2.split("."), (function(e$2) {
								return new Array(20 - e$2.length).join("0") + e$2;
							})).reverse();
						}));
						for (i$1 && (s = o - Math.min(n, a)), o -= 1; o >= s;) {
							if (u[0][o] > u[1][o]) return 1;
							if (u[0][o] === u[1][o]) {
								if (o === s) return 0;
								o -= 1;
							} else if (u[0][o] < u[1][o]) return -1;
						}
					}, e$1.map = function(e$2, t$1) {
						var r$1, i$1 = [];
						if (Array.prototype.map) return Array.prototype.map.call(e$2, t$1);
						for (r$1 = 0; r$1 < e$2.length; r$1 += 1) i$1.push(t$1(e$2[r$1]));
						return i$1;
					}, e$1.find = function(e$2, t$1) {
						var r$1, i$1;
						if (Array.prototype.find) return Array.prototype.find.call(e$2, t$1);
						for (r$1 = 0, i$1 = e$2.length; r$1 < i$1; r$1 += 1) {
							var n = e$2[r$1];
							if (t$1(n, r$1)) return n;
						}
					}, e$1.assign = function(e$2) {
						for (var t$1, r$1, i$1 = e$2, n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) a[o - 1] = arguments[o];
						if (Object.assign) return Object.assign.apply(Object, [e$2].concat(a));
						var s = function() {
							var e$3 = a[t$1];
							"object" == typeof e$3 && null !== e$3 && Object.keys(e$3).forEach((function(t$2) {
								i$1[t$2] = e$3[t$2];
							}));
						};
						for (t$1 = 0, r$1 = a.length; t$1 < r$1; t$1 += 1) s();
						return e$2;
					}, e$1.getBrowserAlias = function(e$2) {
						return i.BROWSER_ALIASES_MAP[e$2];
					}, e$1.getBrowserTypeByAlias = function(e$2) {
						return i.BROWSER_MAP[e$2] || "";
					}, e$1;
				}(), e.exports = t.default;
			},
			18: function(e, t, r) {
				t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0;
				t.BROWSER_ALIASES_MAP = {
					AmazonBot: "amazonbot",
					"Amazon Silk": "amazon_silk",
					"Android Browser": "android",
					BaiduSpider: "baiduspider",
					Bada: "bada",
					BingCrawler: "bingcrawler",
					BlackBerry: "blackberry",
					"ChatGPT-User": "chatgpt_user",
					Chrome: "chrome",
					ClaudeBot: "claudebot",
					Chromium: "chromium",
					Diffbot: "diffbot",
					DuckDuckBot: "duckduckbot",
					Electron: "electron",
					Epiphany: "epiphany",
					FacebookExternalHit: "facebookexternalhit",
					Firefox: "firefox",
					Focus: "focus",
					Generic: "generic",
					"Google Search": "google_search",
					Googlebot: "googlebot",
					GPTBot: "gptbot",
					"Internet Explorer": "ie",
					InternetArchiveCrawler: "internetarchivecrawler",
					"K-Meleon": "k_meleon",
					LibreWolf: "librewolf",
					Maxthon: "maxthon",
					"Meta-ExternalAds": "meta_externalads",
					"Meta-ExternalAgent": "meta_externalagent",
					"Meta-ExternalFetcher": "meta_externalfetcher",
					"Meta-WebIndexer": "meta_webindexer",
					"Microsoft Edge": "edge",
					"MZ Browser": "mz",
					"NAVER Whale Browser": "naver",
					"OAI-SearchBot": "oai_searchbot",
					Omgilibot: "omgilibot",
					Opera: "opera",
					"Opera Coast": "opera_coast",
					"Pale Moon": "pale_moon",
					PerplexityBot: "perplexitybot",
					"Perplexity-User": "perplexity_user",
					PhantomJS: "phantomjs",
					PingdomBot: "pingdombot",
					Puffin: "puffin",
					QQ: "qq",
					QQLite: "qqlite",
					QupZilla: "qupzilla",
					Roku: "roku",
					Safari: "safari",
					Sailfish: "sailfish",
					"Samsung Internet for Android": "samsung_internet",
					SeaMonkey: "seamonkey",
					Sleipnir: "sleipnir",
					"Sogou Browser": "sogou",
					Swing: "swing",
					Tizen: "tizen",
					"UC Browser": "uc",
					Vivaldi: "vivaldi",
					"WebOS Browser": "webos",
					WeChat: "wechat",
					YahooSlurp: "yahooslurp",
					"Yandex Browser": "yandex",
					YandexBot: "yandexbot",
					YouBot: "youbot"
				};
				t.BROWSER_MAP = {
					amazonbot: "AmazonBot",
					amazon_silk: "Amazon Silk",
					android: "Android Browser",
					baiduspider: "BaiduSpider",
					bada: "Bada",
					bingcrawler: "BingCrawler",
					blackberry: "BlackBerry",
					chatgpt_user: "ChatGPT-User",
					chrome: "Chrome",
					claudebot: "ClaudeBot",
					chromium: "Chromium",
					diffbot: "Diffbot",
					duckduckbot: "DuckDuckBot",
					edge: "Microsoft Edge",
					electron: "Electron",
					epiphany: "Epiphany",
					facebookexternalhit: "FacebookExternalHit",
					firefox: "Firefox",
					focus: "Focus",
					generic: "Generic",
					google_search: "Google Search",
					googlebot: "Googlebot",
					gptbot: "GPTBot",
					ie: "Internet Explorer",
					internetarchivecrawler: "InternetArchiveCrawler",
					k_meleon: "K-Meleon",
					librewolf: "LibreWolf",
					maxthon: "Maxthon",
					meta_externalads: "Meta-ExternalAds",
					meta_externalagent: "Meta-ExternalAgent",
					meta_externalfetcher: "Meta-ExternalFetcher",
					meta_webindexer: "Meta-WebIndexer",
					mz: "MZ Browser",
					naver: "NAVER Whale Browser",
					oai_searchbot: "OAI-SearchBot",
					omgilibot: "Omgilibot",
					opera: "Opera",
					opera_coast: "Opera Coast",
					pale_moon: "Pale Moon",
					perplexitybot: "PerplexityBot",
					perplexity_user: "Perplexity-User",
					phantomjs: "PhantomJS",
					pingdombot: "PingdomBot",
					puffin: "Puffin",
					qq: "QQ Browser",
					qqlite: "QQ Browser Lite",
					qupzilla: "QupZilla",
					roku: "Roku",
					safari: "Safari",
					sailfish: "Sailfish",
					samsung_internet: "Samsung Internet for Android",
					seamonkey: "SeaMonkey",
					sleipnir: "Sleipnir",
					sogou: "Sogou Browser",
					swing: "Swing",
					tizen: "Tizen",
					uc: "UC Browser",
					vivaldi: "Vivaldi",
					webos: "WebOS Browser",
					wechat: "WeChat",
					yahooslurp: "YahooSlurp",
					yandex: "Yandex Browser",
					yandexbot: "YandexBot",
					youbot: "YouBot"
				};
				t.PLATFORMS_MAP = {
					bot: "bot",
					desktop: "desktop",
					mobile: "mobile",
					tablet: "tablet",
					tv: "tv"
				};
				t.OS_MAP = {
					Android: "Android",
					Bada: "Bada",
					BlackBerry: "BlackBerry",
					ChromeOS: "Chrome OS",
					HarmonyOS: "HarmonyOS",
					iOS: "iOS",
					Linux: "Linux",
					MacOS: "macOS",
					PlayStation4: "PlayStation 4",
					Roku: "Roku",
					Tizen: "Tizen",
					WebOS: "WebOS",
					Windows: "Windows",
					WindowsPhone: "Windows Phone"
				};
				t.ENGINE_MAP = {
					Blink: "Blink",
					EdgeHTML: "EdgeHTML",
					Gecko: "Gecko",
					Presto: "Presto",
					Trident: "Trident",
					WebKit: "WebKit"
				};
			},
			90: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i, n = (i = r(91)) && i.__esModule ? i : { default: i }, a = r(18);
				function o(e$1, t$1) {
					for (var r$1 = 0; r$1 < t$1.length; r$1++) {
						var i$1 = t$1[r$1];
						i$1.enumerable = i$1.enumerable || !1, i$1.configurable = !0, "value" in i$1 && (i$1.writable = !0), Object.defineProperty(e$1, i$1.key, i$1);
					}
				}
				t.default = function() {
					function e$1() {}
					var t$1, r$1, i$1;
					return e$1.getParser = function(e$2, t$2) {
						if (void 0 === t$2 && (t$2 = !1), "string" != typeof e$2) throw new Error("UserAgent should be a string");
						return new n.default(e$2, t$2);
					}, e$1.parse = function(e$2) {
						return new n.default(e$2).getResult();
					}, t$1 = e$1, i$1 = [
						{
							key: "BROWSER_MAP",
							get: function() {
								return a.BROWSER_MAP;
							}
						},
						{
							key: "ENGINE_MAP",
							get: function() {
								return a.ENGINE_MAP;
							}
						},
						{
							key: "OS_MAP",
							get: function() {
								return a.OS_MAP;
							}
						},
						{
							key: "PLATFORMS_MAP",
							get: function() {
								return a.PLATFORMS_MAP;
							}
						}
					], (r$1 = null) && o(t$1.prototype, r$1), i$1 && o(t$1, i$1), e$1;
				}(), e.exports = t.default;
			},
			91: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i = u(r(92)), n = u(r(93)), a = u(r(94)), o = u(r(95)), s = u(r(17));
				function u(e$1) {
					return e$1 && e$1.__esModule ? e$1 : { default: e$1 };
				}
				t.default = function() {
					function e$1(e$2, t$2) {
						if (void 0 === t$2 && (t$2 = !1), null == e$2 || "" === e$2) throw new Error("UserAgent parameter can't be empty");
						this._ua = e$2, this.parsedResult = {}, !0 !== t$2 && this.parse();
					}
					var t$1 = e$1.prototype;
					return t$1.getUA = function() {
						return this._ua;
					}, t$1.test = function(e$2) {
						return e$2.test(this._ua);
					}, t$1.parseBrowser = function() {
						var e$2 = this;
						this.parsedResult.browser = {};
						var t$2 = s.default.find(i.default, (function(t$3) {
							if ("function" == typeof t$3.test) return t$3.test(e$2);
							if (Array.isArray(t$3.test)) return t$3.test.some((function(t$4) {
								return e$2.test(t$4);
							}));
							throw new Error("Browser's test function is not valid");
						}));
						return t$2 && (this.parsedResult.browser = t$2.describe(this.getUA())), this.parsedResult.browser;
					}, t$1.getBrowser = function() {
						return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
					}, t$1.getBrowserName = function(e$2) {
						return e$2 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
					}, t$1.getBrowserVersion = function() {
						return this.getBrowser().version;
					}, t$1.getOS = function() {
						return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
					}, t$1.parseOS = function() {
						var e$2 = this;
						this.parsedResult.os = {};
						var t$2 = s.default.find(n.default, (function(t$3) {
							if ("function" == typeof t$3.test) return t$3.test(e$2);
							if (Array.isArray(t$3.test)) return t$3.test.some((function(t$4) {
								return e$2.test(t$4);
							}));
							throw new Error("Browser's test function is not valid");
						}));
						return t$2 && (this.parsedResult.os = t$2.describe(this.getUA())), this.parsedResult.os;
					}, t$1.getOSName = function(e$2) {
						var t$2 = this.getOS().name;
						return e$2 ? String(t$2).toLowerCase() || "" : t$2 || "";
					}, t$1.getOSVersion = function() {
						return this.getOS().version;
					}, t$1.getPlatform = function() {
						return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
					}, t$1.getPlatformType = function(e$2) {
						void 0 === e$2 && (e$2 = !1);
						var t$2 = this.getPlatform().type;
						return e$2 ? String(t$2).toLowerCase() || "" : t$2 || "";
					}, t$1.parsePlatform = function() {
						var e$2 = this;
						this.parsedResult.platform = {};
						var t$2 = s.default.find(a.default, (function(t$3) {
							if ("function" == typeof t$3.test) return t$3.test(e$2);
							if (Array.isArray(t$3.test)) return t$3.test.some((function(t$4) {
								return e$2.test(t$4);
							}));
							throw new Error("Browser's test function is not valid");
						}));
						return t$2 && (this.parsedResult.platform = t$2.describe(this.getUA())), this.parsedResult.platform;
					}, t$1.getEngine = function() {
						return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
					}, t$1.getEngineName = function(e$2) {
						return e$2 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
					}, t$1.parseEngine = function() {
						var e$2 = this;
						this.parsedResult.engine = {};
						var t$2 = s.default.find(o.default, (function(t$3) {
							if ("function" == typeof t$3.test) return t$3.test(e$2);
							if (Array.isArray(t$3.test)) return t$3.test.some((function(t$4) {
								return e$2.test(t$4);
							}));
							throw new Error("Browser's test function is not valid");
						}));
						return t$2 && (this.parsedResult.engine = t$2.describe(this.getUA())), this.parsedResult.engine;
					}, t$1.parse = function() {
						return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
					}, t$1.getResult = function() {
						return s.default.assign({}, this.parsedResult);
					}, t$1.satisfies = function(e$2) {
						var t$2 = this, r$1 = {}, i$1 = 0, n$1 = {}, a$1 = 0;
						if (Object.keys(e$2).forEach((function(t$3) {
							var o$2 = e$2[t$3];
							"string" == typeof o$2 ? (n$1[t$3] = o$2, a$1 += 1) : "object" == typeof o$2 && (r$1[t$3] = o$2, i$1 += 1);
						})), i$1 > 0) {
							var o$1 = Object.keys(r$1), u$1 = s.default.find(o$1, (function(e$3) {
								return t$2.isOS(e$3);
							}));
							if (u$1) {
								var d = this.satisfies(r$1[u$1]);
								if (void 0 !== d) return d;
							}
							var c = s.default.find(o$1, (function(e$3) {
								return t$2.isPlatform(e$3);
							}));
							if (c) {
								var f = this.satisfies(r$1[c]);
								if (void 0 !== f) return f;
							}
						}
						if (a$1 > 0) {
							var l = Object.keys(n$1), b = s.default.find(l, (function(e$3) {
								return t$2.isBrowser(e$3, !0);
							}));
							if (void 0 !== b) return this.compareVersion(n$1[b]);
						}
					}, t$1.isBrowser = function(e$2, t$2) {
						void 0 === t$2 && (t$2 = !1);
						var r$1 = this.getBrowserName().toLowerCase(), i$1 = e$2.toLowerCase(), n$1 = s.default.getBrowserTypeByAlias(i$1);
						return t$2 && n$1 && (i$1 = n$1.toLowerCase()), i$1 === r$1;
					}, t$1.compareVersion = function(e$2) {
						var t$2 = [0], r$1 = e$2, i$1 = !1, n$1 = this.getBrowserVersion();
						if ("string" == typeof n$1) return ">" === e$2[0] || "<" === e$2[0] ? (r$1 = e$2.substr(1), "=" === e$2[1] ? (i$1 = !0, r$1 = e$2.substr(2)) : t$2 = [], ">" === e$2[0] ? t$2.push(1) : t$2.push(-1)) : "=" === e$2[0] ? r$1 = e$2.substr(1) : "~" === e$2[0] && (i$1 = !0, r$1 = e$2.substr(1)), t$2.indexOf(s.default.compareVersions(n$1, r$1, i$1)) > -1;
					}, t$1.isOS = function(e$2) {
						return this.getOSName(!0) === String(e$2).toLowerCase();
					}, t$1.isPlatform = function(e$2) {
						return this.getPlatformType(!0) === String(e$2).toLowerCase();
					}, t$1.isEngine = function(e$2) {
						return this.getEngineName(!0) === String(e$2).toLowerCase();
					}, t$1.is = function(e$2, t$2) {
						return void 0 === t$2 && (t$2 = !1), this.isBrowser(e$2, t$2) || this.isOS(e$2) || this.isPlatform(e$2);
					}, t$1.some = function(e$2) {
						var t$2 = this;
						return void 0 === e$2 && (e$2 = []), e$2.some((function(e$3) {
							return t$2.is(e$3);
						}));
					}, e$1;
				}(), e.exports = t.default;
			},
			92: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i, n = (i = r(17)) && i.__esModule ? i : { default: i };
				var a = /version\/(\d+(\.?_?\d+)+)/i;
				t.default = [
					{
						test: [/gptbot/i],
						describe: function(e$1) {
							var t$1 = { name: "GPTBot" }, r$1 = n.default.getFirstMatch(/gptbot\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/chatgpt-user/i],
						describe: function(e$1) {
							var t$1 = { name: "ChatGPT-User" }, r$1 = n.default.getFirstMatch(/chatgpt-user\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/oai-searchbot/i],
						describe: function(e$1) {
							var t$1 = { name: "OAI-SearchBot" }, r$1 = n.default.getFirstMatch(/oai-searchbot\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [
							/claudebot/i,
							/claude-web/i,
							/claude-user/i,
							/claude-searchbot/i
						],
						describe: function(e$1) {
							var t$1 = { name: "ClaudeBot" }, r$1 = n.default.getFirstMatch(/(?:claudebot|claude-web|claude-user|claude-searchbot)\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/omgilibot/i, /webzio-extended/i],
						describe: function(e$1) {
							var t$1 = { name: "Omgilibot" }, r$1 = n.default.getFirstMatch(/(?:omgilibot|webzio-extended)\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/diffbot/i],
						describe: function(e$1) {
							var t$1 = { name: "Diffbot" }, r$1 = n.default.getFirstMatch(/diffbot\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/perplexitybot/i],
						describe: function(e$1) {
							var t$1 = { name: "PerplexityBot" }, r$1 = n.default.getFirstMatch(/perplexitybot\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/perplexity-user/i],
						describe: function(e$1) {
							var t$1 = { name: "Perplexity-User" }, r$1 = n.default.getFirstMatch(/perplexity-user\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/youbot/i],
						describe: function(e$1) {
							var t$1 = { name: "YouBot" }, r$1 = n.default.getFirstMatch(/youbot\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/meta-webindexer/i],
						describe: function(e$1) {
							var t$1 = { name: "Meta-WebIndexer" }, r$1 = n.default.getFirstMatch(/meta-webindexer\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/meta-externalads/i],
						describe: function(e$1) {
							var t$1 = { name: "Meta-ExternalAds" }, r$1 = n.default.getFirstMatch(/meta-externalads\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/meta-externalagent/i],
						describe: function(e$1) {
							var t$1 = { name: "Meta-ExternalAgent" }, r$1 = n.default.getFirstMatch(/meta-externalagent\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/meta-externalfetcher/i],
						describe: function(e$1) {
							var t$1 = { name: "Meta-ExternalFetcher" }, r$1 = n.default.getFirstMatch(/meta-externalfetcher\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/googlebot/i],
						describe: function(e$1) {
							var t$1 = { name: "Googlebot" }, r$1 = n.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/amazonbot/i],
						describe: function(e$1) {
							var t$1 = { name: "AmazonBot" }, r$1 = n.default.getFirstMatch(/amazonbot\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/bingbot/i],
						describe: function(e$1) {
							var t$1 = { name: "BingCrawler" }, r$1 = n.default.getFirstMatch(/bingbot\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/baiduspider/i],
						describe: function(e$1) {
							var t$1 = { name: "BaiduSpider" }, r$1 = n.default.getFirstMatch(/baiduspider\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/duckduckbot/i],
						describe: function(e$1) {
							var t$1 = { name: "DuckDuckBot" }, r$1 = n.default.getFirstMatch(/duckduckbot\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/ia_archiver/i],
						describe: function(e$1) {
							var t$1 = { name: "InternetArchiveCrawler" }, r$1 = n.default.getFirstMatch(/ia_archiver\/(\d+(\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/facebookexternalhit/i, /facebookcatalog/i],
						describe: function() {
							return { name: "FacebookExternalHit" };
						}
					},
					{
						test: [/yahoo!?[\s/]*slurp/i],
						describe: function() {
							return { name: "YahooSlurp" };
						}
					},
					{
						test: [/yandexbot/i, /yandexmobilebot/i],
						describe: function() {
							return { name: "YandexBot" };
						}
					},
					{
						test: [/pingdom/i],
						describe: function() {
							return { name: "PingdomBot" };
						}
					},
					{
						test: [/opera/i],
						describe: function(e$1) {
							var t$1 = { name: "Opera" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/opr\/|opios/i],
						describe: function(e$1) {
							var t$1 = { name: "Opera" }, r$1 = n.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/SamsungBrowser/i],
						describe: function(e$1) {
							var t$1 = { name: "Samsung Internet for Android" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/Whale/i],
						describe: function(e$1) {
							var t$1 = { name: "NAVER Whale Browser" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/PaleMoon/i],
						describe: function(e$1) {
							var t$1 = { name: "Pale Moon" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:PaleMoon)[\s/](\d+(?:\.\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/MZBrowser/i],
						describe: function(e$1) {
							var t$1 = { name: "MZ Browser" }, r$1 = n.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/focus/i],
						describe: function(e$1) {
							var t$1 = { name: "Focus" }, r$1 = n.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/swing/i],
						describe: function(e$1) {
							var t$1 = { name: "Swing" }, r$1 = n.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/coast/i],
						describe: function(e$1) {
							var t$1 = { name: "Opera Coast" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/opt\/\d+(?:.?_?\d+)+/i],
						describe: function(e$1) {
							var t$1 = { name: "Opera Touch" }, r$1 = n.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/yabrowser/i],
						describe: function(e$1) {
							var t$1 = { name: "Yandex Browser" }, r$1 = n.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/ucbrowser/i],
						describe: function(e$1) {
							var t$1 = { name: "UC Browser" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/Maxthon|mxios/i],
						describe: function(e$1) {
							var t$1 = { name: "Maxthon" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/epiphany/i],
						describe: function(e$1) {
							var t$1 = { name: "Epiphany" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/puffin/i],
						describe: function(e$1) {
							var t$1 = { name: "Puffin" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/sleipnir/i],
						describe: function(e$1) {
							var t$1 = { name: "Sleipnir" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/k-meleon/i],
						describe: function(e$1) {
							var t$1 = { name: "K-Meleon" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/micromessenger/i],
						describe: function(e$1) {
							var t$1 = { name: "WeChat" }, r$1 = n.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/qqbrowser/i],
						describe: function(e$1) {
							var t$1 = { name: /qqbrowserlite/i.test(e$1) ? "QQ Browser Lite" : "QQ Browser" }, r$1 = n.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/msie|trident/i],
						describe: function(e$1) {
							var t$1 = { name: "Internet Explorer" }, r$1 = n.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/\sedg\//i],
						describe: function(e$1) {
							var t$1 = { name: "Microsoft Edge" }, r$1 = n.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/edg([ea]|ios)/i],
						describe: function(e$1) {
							var t$1 = { name: "Microsoft Edge" }, r$1 = n.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/vivaldi/i],
						describe: function(e$1) {
							var t$1 = { name: "Vivaldi" }, r$1 = n.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/seamonkey/i],
						describe: function(e$1) {
							var t$1 = { name: "SeaMonkey" }, r$1 = n.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/sailfish/i],
						describe: function(e$1) {
							var t$1 = { name: "Sailfish" }, r$1 = n.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/silk/i],
						describe: function(e$1) {
							var t$1 = { name: "Amazon Silk" }, r$1 = n.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/phantom/i],
						describe: function(e$1) {
							var t$1 = { name: "PhantomJS" }, r$1 = n.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/slimerjs/i],
						describe: function(e$1) {
							var t$1 = { name: "SlimerJS" }, r$1 = n.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
						describe: function(e$1) {
							var t$1 = { name: "BlackBerry" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/(web|hpw)[o0]s/i],
						describe: function(e$1) {
							var t$1 = { name: "WebOS Browser" }, r$1 = n.default.getFirstMatch(a, e$1) || n.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/bada/i],
						describe: function(e$1) {
							var t$1 = { name: "Bada" }, r$1 = n.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/tizen/i],
						describe: function(e$1) {
							var t$1 = { name: "Tizen" }, r$1 = n.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/qupzilla/i],
						describe: function(e$1) {
							var t$1 = { name: "QupZilla" }, r$1 = n.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/librewolf/i],
						describe: function(e$1) {
							var t$1 = { name: "LibreWolf" }, r$1 = n.default.getFirstMatch(/(?:librewolf)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/firefox|iceweasel|fxios/i],
						describe: function(e$1) {
							var t$1 = { name: "Firefox" }, r$1 = n.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/electron/i],
						describe: function(e$1) {
							var t$1 = { name: "Electron" }, r$1 = n.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [
							/sogoumobilebrowser/i,
							/metasr/i,
							/se 2\.[x]/i
						],
						describe: function(e$1) {
							var t$1 = { name: "Sogou Browser" }, r$1 = n.default.getFirstMatch(/(?:sogoumobilebrowser)[\s/](\d+(\.?_?\d+)+)/i, e$1), i$1 = n.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e$1), a$1 = n.default.getFirstMatch(/se ([\d.]+)x/i, e$1), o = r$1 || i$1 || a$1;
							return o && (t$1.version = o), t$1;
						}
					},
					{
						test: [/MiuiBrowser/i],
						describe: function(e$1) {
							var t$1 = { name: "Miui" }, r$1 = n.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/chromium/i],
						describe: function(e$1) {
							var t$1 = { name: "Chromium" }, r$1 = n.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/chrome|crios|crmo/i],
						describe: function(e$1) {
							var t$1 = { name: "Chrome" }, r$1 = n.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/GSA/i],
						describe: function(e$1) {
							var t$1 = { name: "Google Search" }, r$1 = n.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: function(e$1) {
							var t$1 = !e$1.test(/like android/i), r$1 = e$1.test(/android/i);
							return t$1 && r$1;
						},
						describe: function(e$1) {
							var t$1 = { name: "Android Browser" }, r$1 = n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/playstation 4/i],
						describe: function(e$1) {
							var t$1 = { name: "PlayStation 4" }, r$1 = n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/safari|applewebkit/i],
						describe: function(e$1) {
							var t$1 = { name: "Safari" }, r$1 = n.default.getFirstMatch(a, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/.*/i],
						describe: function(e$1) {
							var t$1 = -1 !== e$1.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
							return {
								name: n.default.getFirstMatch(t$1, e$1),
								version: n.default.getSecondMatch(t$1, e$1)
							};
						}
					}
				], e.exports = t.default;
			},
			93: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i, n = (i = r(17)) && i.__esModule ? i : { default: i }, a = r(18);
				t.default = [
					{
						test: [/Roku\/DVP/],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e$1);
							return {
								name: a.OS_MAP.Roku,
								version: t$1
							};
						}
					},
					{
						test: [/windows phone/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e$1);
							return {
								name: a.OS_MAP.WindowsPhone,
								version: t$1
							};
						}
					},
					{
						test: [/windows /i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e$1), r$1 = n.default.getWindowsVersionName(t$1);
							return {
								name: a.OS_MAP.Windows,
								version: t$1,
								versionName: r$1
							};
						}
					},
					{
						test: [/Macintosh(.*?) FxiOS(.*?)\//],
						describe: function(e$1) {
							var t$1 = { name: a.OS_MAP.iOS }, r$1 = n.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/macintosh/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e$1).replace(/[_\s]/g, "."), r$1 = n.default.getMacOSVersionName(t$1), i$1 = {
								name: a.OS_MAP.MacOS,
								version: t$1
							};
							return r$1 && (i$1.versionName = r$1), i$1;
						}
					},
					{
						test: [/(ipod|iphone|ipad)/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e$1).replace(/[_\s]/g, ".");
							return {
								name: a.OS_MAP.iOS,
								version: t$1
							};
						}
					},
					{
						test: [/OpenHarmony/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/OpenHarmony\s+(\d+(\.\d+)*)/i, e$1);
							return {
								name: a.OS_MAP.HarmonyOS,
								version: t$1
							};
						}
					},
					{
						test: function(e$1) {
							var t$1 = !e$1.test(/like android/i), r$1 = e$1.test(/android/i);
							return t$1 && r$1;
						},
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e$1), r$1 = n.default.getAndroidVersionName(t$1), i$1 = {
								name: a.OS_MAP.Android,
								version: t$1
							};
							return r$1 && (i$1.versionName = r$1), i$1;
						}
					},
					{
						test: [/(web|hpw)[o0]s/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e$1), r$1 = { name: a.OS_MAP.WebOS };
							return t$1 && t$1.length && (r$1.version = t$1), r$1;
						}
					},
					{
						test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e$1) || n.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e$1) || n.default.getFirstMatch(/\bbb(\d+)/i, e$1);
							return {
								name: a.OS_MAP.BlackBerry,
								version: t$1
							};
						}
					},
					{
						test: [/bada/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e$1);
							return {
								name: a.OS_MAP.Bada,
								version: t$1
							};
						}
					},
					{
						test: [/tizen/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e$1);
							return {
								name: a.OS_MAP.Tizen,
								version: t$1
							};
						}
					},
					{
						test: [/linux/i],
						describe: function() {
							return { name: a.OS_MAP.Linux };
						}
					},
					{
						test: [/CrOS/],
						describe: function() {
							return { name: a.OS_MAP.ChromeOS };
						}
					},
					{
						test: [/PlayStation 4/],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e$1);
							return {
								name: a.OS_MAP.PlayStation4,
								version: t$1
							};
						}
					}
				], e.exports = t.default;
			},
			94: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i, n = (i = r(17)) && i.__esModule ? i : { default: i }, a = r(18);
				t.default = [
					{
						test: [/googlebot/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Google"
							};
						}
					},
					{
						test: [/amazonbot/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Amazon"
							};
						}
					},
					{
						test: [/gptbot/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "OpenAI"
							};
						}
					},
					{
						test: [/chatgpt-user/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "OpenAI"
							};
						}
					},
					{
						test: [/oai-searchbot/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "OpenAI"
							};
						}
					},
					{
						test: [/baiduspider/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Baidu"
							};
						}
					},
					{
						test: [/bingbot/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Bing"
							};
						}
					},
					{
						test: [/duckduckbot/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "DuckDuckGo"
							};
						}
					},
					{
						test: [
							/claudebot/i,
							/claude-web/i,
							/claude-user/i,
							/claude-searchbot/i
						],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Anthropic"
							};
						}
					},
					{
						test: [/omgilibot/i, /webzio-extended/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Webz.io"
							};
						}
					},
					{
						test: [/diffbot/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Diffbot"
							};
						}
					},
					{
						test: [/perplexitybot/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Perplexity AI"
							};
						}
					},
					{
						test: [/perplexity-user/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Perplexity AI"
							};
						}
					},
					{
						test: [/youbot/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "You.com"
							};
						}
					},
					{
						test: [/ia_archiver/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Internet Archive"
							};
						}
					},
					{
						test: [/meta-webindexer/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Meta"
							};
						}
					},
					{
						test: [/meta-externalads/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Meta"
							};
						}
					},
					{
						test: [/meta-externalagent/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Meta"
							};
						}
					},
					{
						test: [/meta-externalfetcher/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Meta"
							};
						}
					},
					{
						test: [/facebookexternalhit/i, /facebookcatalog/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Meta"
							};
						}
					},
					{
						test: [/yahoo/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Yahoo"
							};
						}
					},
					{
						test: [/yandexbot/i, /yandexmobilebot/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Yandex"
							};
						}
					},
					{
						test: [/pingdom/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.bot,
								vendor: "Pingdom"
							};
						}
					},
					{
						test: [/huawei/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/(can-l01)/i, e$1) && "Nova", r$1 = {
								type: a.PLATFORMS_MAP.mobile,
								vendor: "Huawei"
							};
							return t$1 && (r$1.model = t$1), r$1;
						}
					},
					{
						test: [/nexus\s*(?:7|8|9|10).*/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.tablet,
								vendor: "Nexus"
							};
						}
					},
					{
						test: [/ipad/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.tablet,
								vendor: "Apple",
								model: "iPad"
							};
						}
					},
					{
						test: [/Macintosh(.*?) FxiOS(.*?)\//],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.tablet,
								vendor: "Apple",
								model: "iPad"
							};
						}
					},
					{
						test: [/kftt build/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.tablet,
								vendor: "Amazon",
								model: "Kindle Fire HD 7"
							};
						}
					},
					{
						test: [/silk/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.tablet,
								vendor: "Amazon"
							};
						}
					},
					{
						test: [/tablet(?! pc)/i],
						describe: function() {
							return { type: a.PLATFORMS_MAP.tablet };
						}
					},
					{
						test: function(e$1) {
							var t$1 = e$1.test(/ipod|iphone/i), r$1 = e$1.test(/like (ipod|iphone)/i);
							return t$1 && !r$1;
						},
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/(ipod|iphone)/i, e$1);
							return {
								type: a.PLATFORMS_MAP.mobile,
								vendor: "Apple",
								model: t$1
							};
						}
					},
					{
						test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.mobile,
								vendor: "Nexus"
							};
						}
					},
					{
						test: [/Nokia/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/Nokia\s+([0-9]+(\.[0-9]+)?)/i, e$1), r$1 = {
								type: a.PLATFORMS_MAP.mobile,
								vendor: "Nokia"
							};
							return t$1 && (r$1.model = t$1), r$1;
						}
					},
					{
						test: [/[^-]mobi/i],
						describe: function() {
							return { type: a.PLATFORMS_MAP.mobile };
						}
					},
					{
						test: function(e$1) {
							return "blackberry" === e$1.getBrowserName(!0);
						},
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.mobile,
								vendor: "BlackBerry"
							};
						}
					},
					{
						test: function(e$1) {
							return "bada" === e$1.getBrowserName(!0);
						},
						describe: function() {
							return { type: a.PLATFORMS_MAP.mobile };
						}
					},
					{
						test: function(e$1) {
							return "windows phone" === e$1.getBrowserName();
						},
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.mobile,
								vendor: "Microsoft"
							};
						}
					},
					{
						test: function(e$1) {
							var t$1 = Number(String(e$1.getOSVersion()).split(".")[0]);
							return "android" === e$1.getOSName(!0) && t$1 >= 3;
						},
						describe: function() {
							return { type: a.PLATFORMS_MAP.tablet };
						}
					},
					{
						test: function(e$1) {
							return "android" === e$1.getOSName(!0);
						},
						describe: function() {
							return { type: a.PLATFORMS_MAP.mobile };
						}
					},
					{
						test: function(e$1) {
							return "macos" === e$1.getOSName(!0);
						},
						describe: function() {
							return {
								type: a.PLATFORMS_MAP.desktop,
								vendor: "Apple"
							};
						}
					},
					{
						test: function(e$1) {
							return "windows" === e$1.getOSName(!0);
						},
						describe: function() {
							return { type: a.PLATFORMS_MAP.desktop };
						}
					},
					{
						test: function(e$1) {
							return "linux" === e$1.getOSName(!0);
						},
						describe: function() {
							return { type: a.PLATFORMS_MAP.desktop };
						}
					},
					{
						test: function(e$1) {
							return "playstation 4" === e$1.getOSName(!0);
						},
						describe: function() {
							return { type: a.PLATFORMS_MAP.tv };
						}
					},
					{
						test: function(e$1) {
							return "roku" === e$1.getOSName(!0);
						},
						describe: function() {
							return { type: a.PLATFORMS_MAP.tv };
						}
					}
				], e.exports = t.default;
			},
			95: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i, n = (i = r(17)) && i.__esModule ? i : { default: i }, a = r(18);
				t.default = [
					{
						test: function(e$1) {
							return "microsoft edge" === e$1.getBrowserName(!0);
						},
						describe: function(e$1) {
							if (/\sedg\//i.test(e$1)) return { name: a.ENGINE_MAP.Blink };
							var t$1 = n.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e$1);
							return {
								name: a.ENGINE_MAP.EdgeHTML,
								version: t$1
							};
						}
					},
					{
						test: [/trident/i],
						describe: function(e$1) {
							var t$1 = { name: a.ENGINE_MAP.Trident }, r$1 = n.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: function(e$1) {
							return e$1.test(/presto/i);
						},
						describe: function(e$1) {
							var t$1 = { name: a.ENGINE_MAP.Presto }, r$1 = n.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: function(e$1) {
							var t$1 = e$1.test(/gecko/i), r$1 = e$1.test(/like gecko/i);
							return t$1 && !r$1;
						},
						describe: function(e$1) {
							var t$1 = { name: a.ENGINE_MAP.Gecko }, r$1 = n.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/(apple)?webkit\/537\.36/i],
						describe: function() {
							return { name: a.ENGINE_MAP.Blink };
						}
					},
					{
						test: [/(apple)?webkit/i],
						describe: function(e$1) {
							var t$1 = { name: a.ENGINE_MAP.WebKit }, r$1 = n.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					}
				], e.exports = t.default;
			}
		});
	}));
}) });

//#endregion
//#region node_modules/jwt-decode/build/esm/index.js
var import_es5 = /* @__PURE__ */ __toESM(require_es5());
var InvalidTokenError = class extends Error {};
InvalidTokenError.prototype.name = "InvalidTokenError";

//#endregion
//#region node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js
var import_loglevel$1 = /* @__PURE__ */ __toESM(require_loglevel());
var COMMUNICATION_NOTIFICATIONS = {
	IFRAME_STATUS: "iframe_status",
	CLOSE_WINDOW: "close_window",
	USER_LOGGED_IN: "user_logged_in",
	USER_LOGGED_OUT: "user_logged_out"
};
var COMMUNICATION_JRPC_METHODS = {
	LOGOUT: "logout",
	WALLET_INSTANCE_ID: "wallet_instance_id",
	USER_INFO: "user_info",
	SET_PROVIDER: "set_provider",
	TOPUP: "topup",
	IFRAME_STATUS: "iframe_status",
	CLOSED_WINDOW: "closed_window",
	WINDOW_BLOCKED: "window_blocked",
	GET_PROVIDER_STATE: "get_provider_state",
	LOGIN_WITH_PRIVATE_KEY: "login_with_private_key",
	SHOW_WALLET_CONNECT: "show_wallet_connect",
	SHOW_CHECKOUT: "show_checkout",
	SHOW_WALLET_UI: "show_wallet_ui",
	LOGIN_WITH_SESSION_ID: "login_with_session_id"
};
var PROVIDER_JRPC_METHODS = { GET_PROVIDER_STATE: "wallet_get_provider_state" };
var PROVIDER_NOTIFICATIONS = {
	ACCOUNTS_CHANGED: "wallet_accounts_changed",
	CHAIN_CHANGED: "wallet_chain_changed",
	UNLOCK_STATE_CHANGED: "wallet_unlock_state_changed"
};
/**
* State change callbacks
*/
/**
* Base controller configuration
*/
/**
* Base state representation
*/
var LOGIN_PROVIDER$1 = {
	GOOGLE: "google",
	FACEBOOK: "facebook",
	REDDIT: "reddit",
	DISCORD: "discord",
	TWITCH: "twitch",
	APPLE: "apple",
	LINE: "line",
	GITHUB: "github",
	KAKAO: "kakao",
	LINKEDIN: "linkedin",
	TWITTER: "twitter",
	WEIBO: "weibo",
	WECHAT: "wechat",
	EMAIL_PASSWORDLESS: "email_passwordless",
	SMS_PASSWORDLESS: "sms_passwordless"
};
function createLoggerMiddleware(options) {
	return function loggerMiddleware(request, response, next$1) {
		next$1((callback) => {
			if (response.error) import_loglevel$1.default.warn("Error in RPC response:\n", response);
			if (request.isTorusInternal) return;
			import_loglevel$1.default.info(`RPC (${options.origin}):`, request, "->", response);
			callback();
		});
	};
}
var ACCOUNT_CATEGORY = {
	NORMAL: "normal",
	THRESHOLD: "threshold",
	IMPORTED: "imported",
	APP_SCOPED: "app_scoped",
	ACCOUNT_ABSTRACTION: "account_abstraction",
	EXTERNAL: "external",
	MPC: "mpc",
	SFA: "sfa"
};
/**
* Preferences controller state
*/
/**
* @param address - address of the user
* @param jwtToken - if jwt token already exists, it will be used instead of fetching from backend
* @param calledFromEmbed - if called from embed
* @param userInfo - optional user info
* @param rehydrate - Rehydrate the preferences from the local storage
*/
var DEFAULT_INTERVAL = 180 * 1e3;
var DEFAULT_PREFERENCES = {
	selectedCurrency: "USD",
	theme: "dark",
	locale: "en",
	accountType: ACCOUNT_CATEGORY.NORMAL,
	contacts: [],
	jwtToken: "",
	fetchedPastTx: [],
	pastTransactions: [],
	paymentTx: [],
	defaultPublicAddress: "",
	customTokens: [],
	customNfts: [],
	crashReport: true,
	userInfo: {
		aggregateVerifier: "",
		email: "",
		name: "",
		profileImage: "",
		typeOfLogin: LOGIN_PROVIDER$1.GOOGLE,
		verifier: "",
		verifierId: ""
	}
};

//#endregion
//#region node_modules/eth-rpc-errors/dist/classes.js
var require_classes = /* @__PURE__ */ __commonJS({ "node_modules/eth-rpc-errors/dist/classes.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.EthereumProviderError = exports.EthereumRpcError = void 0;
	var fast_safe_stringify_1 = require_fast_safe_stringify();
	/**
	* Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors
	* per EIP-1474.
	* Permits any integer error code.
	*/
	var EthereumRpcError$1 = class extends Error {
		constructor(code, message, data) {
			if (!Number.isInteger(code)) throw new Error("\"code\" must be an integer.");
			if (!message || typeof message !== "string") throw new Error("\"message\" must be a nonempty string.");
			super(message);
			this.code = code;
			if (data !== void 0) this.data = data;
		}
		/**
		* Returns a plain object with all public class properties.
		*/
		serialize() {
			const serialized = {
				code: this.code,
				message: this.message
			};
			if (this.data !== void 0) serialized.data = this.data;
			if (this.stack) serialized.stack = this.stack;
			return serialized;
		}
		/**
		* Return a string representation of the serialized error, omitting
		* any circular references.
		*/
		toString() {
			return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
		}
	};
	exports.EthereumRpcError = EthereumRpcError$1;
	/**
	* Error subclass implementing Ethereum Provider errors per EIP-1193.
	* Permits integer error codes in the [ 1000 <= 4999 ] range.
	*/
	var EthereumProviderError = class extends EthereumRpcError$1 {
		/**
		* Create an Ethereum Provider JSON-RPC error.
		* `code` must be an integer in the 1000 <= 4999 range.
		*/
		constructor(code, message, data) {
			if (!isValidEthProviderCode(code)) throw new Error("\"code\" must be an integer such that: 1000 <= code <= 4999");
			super(code, message, data);
		}
	};
	exports.EthereumProviderError = EthereumProviderError;
	function isValidEthProviderCode(code) {
		return Number.isInteger(code) && code >= 1e3 && code <= 4999;
	}
	function stringifyReplacer(_, value$2) {
		if (value$2 === "[Circular]") return;
		return value$2;
	}
}) });

//#endregion
//#region node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = /* @__PURE__ */ __commonJS({ "node_modules/eth-rpc-errors/dist/error-constants.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.errorValues = exports.errorCodes = void 0;
	exports.errorCodes = {
		rpc: {
			invalidInput: -32e3,
			resourceNotFound: -32001,
			resourceUnavailable: -32002,
			transactionRejected: -32003,
			methodNotSupported: -32004,
			limitExceeded: -32005,
			parse: -32700,
			invalidRequest: -32600,
			methodNotFound: -32601,
			invalidParams: -32602,
			internal: -32603
		},
		provider: {
			userRejectedRequest: 4001,
			unauthorized: 4100,
			unsupportedMethod: 4200,
			disconnected: 4900,
			chainDisconnected: 4901
		}
	};
	exports.errorValues = {
		"-32700": {
			standard: "JSON RPC 2.0",
			message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
		},
		"-32600": {
			standard: "JSON RPC 2.0",
			message: "The JSON sent is not a valid Request object."
		},
		"-32601": {
			standard: "JSON RPC 2.0",
			message: "The method does not exist / is not available."
		},
		"-32602": {
			standard: "JSON RPC 2.0",
			message: "Invalid method parameter(s)."
		},
		"-32603": {
			standard: "JSON RPC 2.0",
			message: "Internal JSON-RPC error."
		},
		"-32000": {
			standard: "EIP-1474",
			message: "Invalid input."
		},
		"-32001": {
			standard: "EIP-1474",
			message: "Resource not found."
		},
		"-32002": {
			standard: "EIP-1474",
			message: "Resource unavailable."
		},
		"-32003": {
			standard: "EIP-1474",
			message: "Transaction rejected."
		},
		"-32004": {
			standard: "EIP-1474",
			message: "Method not supported."
		},
		"-32005": {
			standard: "EIP-1474",
			message: "Request limit exceeded."
		},
		"4001": {
			standard: "EIP-1193",
			message: "User rejected the request."
		},
		"4100": {
			standard: "EIP-1193",
			message: "The requested account and/or method has not been authorized by the user."
		},
		"4200": {
			standard: "EIP-1193",
			message: "The requested method is not supported by this Ethereum provider."
		},
		"4900": {
			standard: "EIP-1193",
			message: "The provider is disconnected from all chains."
		},
		"4901": {
			standard: "EIP-1193",
			message: "The provider is disconnected from the specified chain."
		}
	};
}) });

//#endregion
//#region node_modules/eth-rpc-errors/dist/utils.js
var require_utils = /* @__PURE__ */ __commonJS({ "node_modules/eth-rpc-errors/dist/utils.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
	var error_constants_1$2 = require_error_constants();
	var classes_1$2 = require_classes();
	var FALLBACK_ERROR_CODE = error_constants_1$2.errorCodes.rpc.internal;
	var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
	var FALLBACK_ERROR = {
		code: FALLBACK_ERROR_CODE,
		message: getMessageFromCode(FALLBACK_ERROR_CODE)
	};
	exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
	/**
	* Gets the message for a given code, or a fallback message if the code has
	* no corresponding message.
	*/
	function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
		if (Number.isInteger(code)) {
			const codeString = code.toString();
			if (hasKey(error_constants_1$2.errorValues, codeString)) return error_constants_1$2.errorValues[codeString].message;
			if (isJsonRpcServerError(code)) return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
		}
		return fallbackMessage;
	}
	exports.getMessageFromCode = getMessageFromCode;
	/**
	* Returns whether the given code is valid.
	* A code is only valid if it has a message.
	*/
	function isValidCode(code) {
		if (!Number.isInteger(code)) return false;
		const codeString = code.toString();
		if (error_constants_1$2.errorValues[codeString]) return true;
		if (isJsonRpcServerError(code)) return true;
		return false;
	}
	exports.isValidCode = isValidCode;
	/**
	* Serializes the given error to an Ethereum JSON RPC-compatible error object.
	* Merely copies the given error's values if it is already compatible.
	* If the given error is not fully compatible, it will be preserved on the
	* returned object's data.originalError property.
	*/
	function serializeError(error$1, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
		var _a, _b;
		if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") throw new Error("Must provide fallback error with integer number code and string message.");
		if (error$1 instanceof classes_1$2.EthereumRpcError) return error$1.serialize();
		const serialized = {};
		if (error$1 && typeof error$1 === "object" && !Array.isArray(error$1) && hasKey(error$1, "code") && isValidCode(error$1.code)) {
			const _error = error$1;
			serialized.code = _error.code;
			if (_error.message && typeof _error.message === "string") {
				serialized.message = _error.message;
				if (hasKey(_error, "data")) serialized.data = _error.data;
			} else {
				serialized.message = getMessageFromCode(serialized.code);
				serialized.data = { originalError: assignOriginalError(error$1) };
			}
		} else {
			serialized.code = fallbackError.code;
			const message = (_a = error$1) === null || _a === void 0 ? void 0 : _a.message;
			serialized.message = message && typeof message === "string" ? message : fallbackError.message;
			serialized.data = { originalError: assignOriginalError(error$1) };
		}
		const stack = (_b = error$1) === null || _b === void 0 ? void 0 : _b.stack;
		if (shouldIncludeStack && error$1 && stack && typeof stack === "string") serialized.stack = stack;
		return serialized;
	}
	exports.serializeError = serializeError;
	function isJsonRpcServerError(code) {
		return code >= -32099 && code <= -32e3;
	}
	function assignOriginalError(error$1) {
		if (error$1 && typeof error$1 === "object" && !Array.isArray(error$1)) return Object.assign({}, error$1);
		return error$1;
	}
	function hasKey(obj, key) {
		return Object.prototype.hasOwnProperty.call(obj, key);
	}
}) });

//#endregion
//#region node_modules/eth-rpc-errors/dist/errors.js
var require_errors = /* @__PURE__ */ __commonJS({ "node_modules/eth-rpc-errors/dist/errors.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ethErrors = void 0;
	var classes_1$1 = require_classes();
	var utils_1$1 = require_utils();
	var error_constants_1$1 = require_error_constants();
	exports.ethErrors = {
		rpc: {
			parse: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.parse, arg),
			invalidRequest: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.invalidRequest, arg),
			invalidParams: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.invalidParams, arg),
			methodNotFound: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.methodNotFound, arg),
			internal: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.internal, arg),
			server: (opts) => {
				if (!opts || typeof opts !== "object" || Array.isArray(opts)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
				const { code } = opts;
				if (!Number.isInteger(code) || code > -32005 || code < -32099) throw new Error("\"code\" must be an integer such that: -32099 <= code <= -32005");
				return getEthJsonRpcError(code, opts);
			},
			invalidInput: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.invalidInput, arg),
			resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.resourceNotFound, arg),
			resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.resourceUnavailable, arg),
			transactionRejected: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.transactionRejected, arg),
			methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.methodNotSupported, arg),
			limitExceeded: (arg) => getEthJsonRpcError(error_constants_1$1.errorCodes.rpc.limitExceeded, arg)
		},
		provider: {
			userRejectedRequest: (arg) => {
				return getEthProviderError(error_constants_1$1.errorCodes.provider.userRejectedRequest, arg);
			},
			unauthorized: (arg) => {
				return getEthProviderError(error_constants_1$1.errorCodes.provider.unauthorized, arg);
			},
			unsupportedMethod: (arg) => {
				return getEthProviderError(error_constants_1$1.errorCodes.provider.unsupportedMethod, arg);
			},
			disconnected: (arg) => {
				return getEthProviderError(error_constants_1$1.errorCodes.provider.disconnected, arg);
			},
			chainDisconnected: (arg) => {
				return getEthProviderError(error_constants_1$1.errorCodes.provider.chainDisconnected, arg);
			},
			custom: (opts) => {
				if (!opts || typeof opts !== "object" || Array.isArray(opts)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
				const { code, message, data } = opts;
				if (!message || typeof message !== "string") throw new Error("\"message\" must be a nonempty string");
				return new classes_1$1.EthereumProviderError(code, message, data);
			}
		}
	};
	function getEthJsonRpcError(code, arg) {
		const [message, data] = parseOpts(arg);
		return new classes_1$1.EthereumRpcError(code, message || utils_1$1.getMessageFromCode(code), data);
	}
	function getEthProviderError(code, arg) {
		const [message, data] = parseOpts(arg);
		return new classes_1$1.EthereumProviderError(code, message || utils_1$1.getMessageFromCode(code), data);
	}
	function parseOpts(arg) {
		if (arg) {
			if (typeof arg === "string") return [arg];
			else if (typeof arg === "object" && !Array.isArray(arg)) {
				const { message, data } = arg;
				if (message && typeof message !== "string") throw new Error("Must specify string message.");
				return [message || void 0, data];
			}
		}
		return [];
	}
}) });

//#endregion
//#region node_modules/eth-rpc-errors/dist/index.js
var require_dist = /* @__PURE__ */ __commonJS({ "node_modules/eth-rpc-errors/dist/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
	var classes_1 = require_classes();
	Object.defineProperty(exports, "EthereumRpcError", {
		enumerable: true,
		get: function() {
			return classes_1.EthereumRpcError;
		}
	});
	Object.defineProperty(exports, "EthereumProviderError", {
		enumerable: true,
		get: function() {
			return classes_1.EthereumProviderError;
		}
	});
	var utils_1 = require_utils();
	Object.defineProperty(exports, "serializeError", {
		enumerable: true,
		get: function() {
			return utils_1.serializeError;
		}
	});
	Object.defineProperty(exports, "getMessageFromCode", {
		enumerable: true,
		get: function() {
			return utils_1.getMessageFromCode;
		}
	});
	var errors_1 = require_errors();
	Object.defineProperty(exports, "ethErrors", {
		enumerable: true,
		get: function() {
			return errors_1.ethErrors;
		}
	});
	var error_constants_1 = require_error_constants();
	Object.defineProperty(exports, "errorCodes", {
		enumerable: true,
		get: function() {
			return error_constants_1.errorCodes;
		}
	});
}) });

//#endregion
//#region node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = /* @__PURE__ */ __commonJS({ "node_modules/fast-deep-equal/index.js": ((exports, module) => {
	module.exports = function equal(a, b) {
		if (a === b) return true;
		if (a && b && typeof a == "object" && typeof b == "object") {
			if (a.constructor !== b.constructor) return false;
			var length, i, keys;
			if (Array.isArray(a)) {
				length = a.length;
				if (length != b.length) return false;
				for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
				return true;
			}
			if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
			if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
			if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
			keys = Object.keys(a);
			length = keys.length;
			if (length !== Object.keys(b).length) return false;
			for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
			for (i = length; i-- !== 0;) {
				var key = keys[i];
				if (!equal(a[key], b[key])) return false;
			}
			return true;
		}
		return a !== a && b !== b;
	};
}) });

//#endregion
//#region node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js
var import_dist = require_dist();
var import_pump = /* @__PURE__ */ __toESM(require_pump());
var import_loglevel = /* @__PURE__ */ __toESM(require_loglevel());
var import_fast_deep_equal = /* @__PURE__ */ __toESM(require_fast_deep_equal());
var version = "2.1.0";
function isStream(stream) {
	return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isWritableStream(stream) {
	return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}
function isReadableStream(stream) {
	return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
}
function isDuplexStream(stream) {
	return isWritableStream(stream) && isReadableStream(stream);
}
var messages = {
	errors: {
		disconnected: () => "Torus: Lost connection to Torus.",
		permanentlyDisconnected: () => "Torus: Disconnected from iframe. Page reload required.",
		unsupportedSync: (method) => `Torus: The Torus Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,
		invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.",
		invalidOptions: (maxEventListeners) => `Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,
		invalidRequestArgs: () => `Expected a single, non-array, object argument.`,
		invalidRequestMethod: () => `'args.method' must be a non-empty string.`,
		invalidRequestParams: () => `'args.params' must be an object or array if provided.`,
		invalidLoggerObject: () => `'args.logger' must be an object if provided.`,
		invalidLoggerMethod: (method) => `'args.logger' must include required method '${method}'.`
	},
	info: { connected: (chainId) => `Torus: Connected to chain with ID "${chainId}".` },
	warnings: {}
};
var TORUS_BUILD_ENV = {
	PRODUCTION: "production",
	DEVELOPMENT: "development",
	TESTING: "testing"
};
var BUTTON_POSITION = {
	BOTTOM_LEFT: "bottom-left",
	TOP_LEFT: "top-left",
	BOTTOM_RIGHT: "bottom-right",
	TOP_RIGHT: "top-right"
};
var LOGIN_PROVIDER = {
	GOOGLE: "google",
	FACEBOOK: "facebook",
	REDDIT: "reddit",
	DISCORD: "discord",
	TWITCH: "twitch",
	APPLE: "apple",
	LINE: "line",
	GITHUB: "github",
	KAKAO: "kakao",
	LINKEDIN: "linkedin",
	TWITTER: "twitter",
	WEIBO: "weibo",
	WECHAT: "wechat",
	EMAIL_PASSWORDLESS: "email_passwordless"
};
var configuration = {
	supportedVerifierList: [
		LOGIN_PROVIDER.GOOGLE,
		LOGIN_PROVIDER.REDDIT,
		LOGIN_PROVIDER.DISCORD
	],
	api: "https://api.tor.us",
	translations: {
		en: { embed: {
			continue: "Continue",
			actionRequired: "Authorization required",
			pendingAction: "Click continue to proceed with your request in a popup",
			cookiesRequired: "Cookies Required",
			enableCookies: "Please enable cookies in your browser preferences to access Torus",
			clickHere: "More Info"
		} },
		de: { embed: {
			continue: "Fortsetzen",
			actionRequired: "Autorisierung erforderlich",
			pendingAction: "Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren",
			cookiesRequired: "Cookies bentigt",
			enableCookies: "Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen",
			clickHere: "Mehr Info"
		} },
		ja: { embed: {
			continue: "",
			actionRequired: "",
			pendingAction: "",
			cookiesRequired: "",
			enableCookies: "TorusCookie",
			clickHere: ""
		} },
		ko: { embed: {
			continue: "",
			actionRequired: " ",
			pendingAction: "    .",
			cookiesRequired: " ",
			enableCookies: "     Torus .",
			clickHere: "  "
		} },
		zh: { embed: {
			continue: "",
			actionRequired: "",
			pendingAction: "",
			cookiesRequired: "Cookie",
			enableCookies: "cookieTorus",
			clickHere: ""
		} }
	},
	prodTorusUrl: "",
	localStorageKeyPrefix: `torus-`
};
var log = import_loglevel.default.getLogger("solana-embed");
/**
* json-rpc-engine middleware that logs RPC errors and and validates req.method.
*
* @param log - The logging API to use.
* @returns  json-rpc-engine middleware function
*/
function createErrorMiddleware() {
	return (req, res, next$1) => {
		if (typeof req.method !== "string" || !req.method) res.error = import_dist.ethErrors.rpc.invalidRequest({
			message: `The request 'method' must be a non-empty string.`,
			data: req
		});
		next$1((done) => {
			const { error: error$1 } = res;
			if (!error$1) return done();
			log.error(`Torus - RPC Error: ${error$1.message}`, error$1);
			return done();
		});
	};
}
/**
* Logs a stream disconnection error. Emits an 'error' if given an
* EventEmitter that has listeners for the 'error' event.
*
* @param log - The logging API to use.
* @param remoteLabel - The label of the disconnected stream.
* @param error - The associated error to log.
* @param emitter - The logging API to use.
*/
function logStreamDisconnectWarning(remoteLabel, error$1, emitter) {
	let warningMsg = `Torus: Lost connection to "${remoteLabel}".`;
	if (error$1?.stack) warningMsg += `\n${error$1.stack}`;
	log.warn(warningMsg);
	if (emitter && emitter.listenerCount("error") > 0) emitter.emit("error", warningMsg);
}
var getWindowId = () => Math.random().toString(36).slice(2);
var getTorusUrl = async (buildEnv) => {
	let torusUrl;
	let logLevel$1;
	switch (buildEnv) {
		case "testing":
			torusUrl = "https://solana-testing.tor.us";
			logLevel$1 = "debug";
			break;
		case "development":
			torusUrl = "http://localhost:8080";
			logLevel$1 = "debug";
			break;
		default:
			torusUrl = `https://solana.tor.us`;
			logLevel$1 = "error";
			break;
	}
	return {
		torusUrl,
		logLevel: logLevel$1
	};
};
var getUserLanguage = () => {
	let userLanguage = window.navigator.language || "en-US";
	const userLanguages = userLanguage.split("-");
	userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : "en";
	return userLanguage;
};
var FEATURES_PROVIDER_CHANGE_WINDOW = {
	height: 660,
	width: 375
};
var FEATURES_DEFAULT_WALLET_WINDOW = {
	height: 740,
	width: 1315
};
var FEATURES_DEFAULT_POPUP_WINDOW = {
	height: 700,
	width: 1200
};
var FEATURES_CONFIRM_WINDOW = {
	height: 600,
	width: 400
};
function storageAvailable(type$5) {
	let storage;
	try {
		storage = window[type$5];
		const x = "__storage_test__";
		storage.setItem(x, x);
		storage.removeItem(x);
		return true;
	} catch (error$1) {
		const e = error$1;
		return e && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && storage && storage.length !== 0;
	}
}
/**
* popup handler utils
*/
function getPopupFeatures(_ref) {
	let { width: w, height: h } = _ref;
	const dualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : window.screenX;
	const dualScreenTop = window.screenTop !== void 0 ? window.screenTop : window.screenY;
	const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
	const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
	const systemZoom = 1;
	const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
	const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
	return `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;
}
var BaseProvider = class extends SafeEventEmitter {
	constructor(connectionStream, _ref) {
		let { maxEventListeners = 100, jsonRpcStreamName = "provider" } = _ref;
		super();
		/**
		* Indicating that this provider is a Torus provider.
		*/
		_defineProperty(this, "isTorus", void 0);
		_defineProperty(this, "_rpcEngine", void 0);
		_defineProperty(this, "jsonRpcConnectionEvents", void 0);
		_defineProperty(this, "_state", void 0);
		if (!isDuplexStream(connectionStream)) throw new Error(messages.errors.invalidDuplexStream());
		this.isTorus = true;
		this.setMaxListeners(maxEventListeners);
		this._handleConnect = this._handleConnect.bind(this);
		this._handleDisconnect = this._handleDisconnect.bind(this);
		this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
		this._rpcRequest = this._rpcRequest.bind(this);
		this._initializeState = this._initializeState.bind(this);
		this.request = this.request.bind(this);
		this.sendAsync = this.sendAsync.bind(this);
		const mux = new ObjectMultiplex();
		(0, import_pump.default)(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, "Torus"));
		mux.ignoreStream("phishing");
		const jsonRpcConnection = createStreamMiddleware();
		(0, import_pump.default)(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, "Torus RpcProvider"));
		const rpcEngine = new JRPCEngine();
		rpcEngine.push(createIdRemapMiddleware());
		rpcEngine.push(createErrorMiddleware());
		rpcEngine.push(createLoggerMiddleware({ origin: location.origin }));
		rpcEngine.push(jsonRpcConnection.middleware);
		this._rpcEngine = rpcEngine;
		this.jsonRpcConnectionEvents = jsonRpcConnection.events;
	}
	/**
	* Submits an RPC request for the given method, with the given params.
	* Resolves with the result of the method call, or rejects on error.
	*/
	async request(args) {
		if (!args || typeof args !== "object" || Array.isArray(args)) throw import_dist.ethErrors.rpc.invalidRequest({
			message: messages.errors.invalidRequestArgs(),
			data: args
		});
		const { method, params } = args;
		if (typeof method !== "string" || method.length === 0) throw import_dist.ethErrors.rpc.invalidRequest({
			message: messages.errors.invalidRequestMethod(),
			data: args
		});
		if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) throw import_dist.ethErrors.rpc.invalidRequest({
			message: messages.errors.invalidRequestParams(),
			data: args
		});
		return new Promise((resolve, reject) => {
			this._rpcRequest({
				method,
				params
			}, getRpcPromiseCallback(resolve, reject));
		});
	}
	/**
	* Submits an RPC request per the given JSON-RPC request object.
	*/
	send(payload, callback) {
		this._rpcRequest(payload, callback);
	}
	/**
	* Submits an RPC request per the given JSON-RPC request object.
	*/
	sendAsync(payload) {
		return new Promise((resolve, reject) => {
			this._rpcRequest(payload, getRpcPromiseCallback(resolve, reject));
		});
	}
	/**
	* Called when connection is lost to critical streams.
	*
	* emits TorusInpageProvider#disconnect
	*/
	_handleStreamDisconnect(streamName, error$1) {
		logStreamDisconnectWarning(streamName, error$1, this);
		this._handleDisconnect(false, error$1 ? error$1.message : void 0);
	}
};
var htmlToElement = (html) => {
	const template = window.document.createElement("template");
	template.innerHTML = html.trim();
	return template.content.firstChild;
};
function isLegacyTransactionInstance(transaction) {
	return transaction.version === void 0;
}
var PopupHandler = class extends SafeEventEmitter {
	constructor(_ref) {
		let { url: url$1, target, features, timeout = 3e4 } = _ref;
		super();
		_defineProperty(this, "url", void 0);
		_defineProperty(this, "target", void 0);
		_defineProperty(this, "features", void 0);
		_defineProperty(this, "window", void 0);
		_defineProperty(this, "windowTimer", void 0);
		_defineProperty(this, "iClosedWindow", void 0);
		_defineProperty(this, "timeout", void 0);
		this.url = url$1;
		this.target = target || "_blank";
		this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);
		this.window = void 0;
		this.windowTimer = void 0;
		this.iClosedWindow = false;
		this.timeout = timeout;
		this._setupTimer();
	}
	_setupTimer() {
		this.windowTimer = Number(setInterval(() => {
			if (this.window && this.window.closed) {
				clearInterval(this.windowTimer);
				setTimeout(() => {
					if (!this.iClosedWindow) this.emit("close");
					this.iClosedWindow = false;
					this.window = void 0;
				}, this.timeout);
			}
			if (this.window === void 0) clearInterval(this.windowTimer);
		}, 500));
	}
	open() {
		this.window = window.open(this.url.href, this.target, this.features);
		if (this.window?.focus) this.window.focus();
		return Promise.resolve();
	}
	close() {
		this.iClosedWindow = true;
		if (this.window) this.window.close();
	}
	redirect(locationReplaceOnRedirect) {
		if (locationReplaceOnRedirect) window.location.replace(this.url.href);
		else window.location.href = this.url.href;
	}
};
var TorusCommunicationProvider = class TorusCommunicationProvider extends BaseProvider {
	constructor(connectionStream, _ref) {
		let { maxEventListeners = 100, jsonRpcStreamName = "provider" } = _ref;
		super(connectionStream, {
			maxEventListeners,
			jsonRpcStreamName
		});
		_defineProperty(this, "embedTranslations", void 0);
		_defineProperty(this, "torusUrl", void 0);
		_defineProperty(this, "dappStorageKey", void 0);
		_defineProperty(this, "windowRefs", void 0);
		_defineProperty(this, "tryWindowHandle", void 0);
		_defineProperty(this, "torusAlertContainer", void 0);
		_defineProperty(this, "torusIframe", void 0);
		this._state = _objectSpread2({}, TorusCommunicationProvider._defaultState);
		this.torusUrl = "";
		this.dappStorageKey = "";
		this.embedTranslations = configuration.translations[getUserLanguage()].embed;
		this.windowRefs = {};
		this.on("connect", () => {
			this._state.isConnected = true;
		});
		const notificationHandler = (payload) => {
			const { method, params } = payload;
			if (method === COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {
				const { isFullScreen, rid } = params;
				this._displayIframe({
					isFull: isFullScreen,
					rid
				});
			} else if (method === "create_window") {
				const { windowId, url: url$1 } = params;
				this._createPopupBlockAlert(windowId, url$1);
			} else if (method === COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) this._handleCloseWindow(params);
			else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {
				const { currentLoginProvider } = params;
				this._state.isLoggedIn = true;
				this._state.currentLoginProvider = currentLoginProvider;
			} else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {
				this._state.isLoggedIn = false;
				this._state.currentLoginProvider = null;
				this._displayIframe();
			}
		};
		this.jsonRpcConnectionEvents.on("notification", notificationHandler);
	}
	get isLoggedIn() {
		return this._state.isLoggedIn;
	}
	get isIFrameFullScreen() {
		return this._state.isIFrameFullScreen;
	}
	/**
	* Returns whether the inPage provider is connected to Torus.
	*/
	isConnected() {
		return this._state.isConnected;
	}
	async _initializeState(params) {
		try {
			const { torusUrl, dappStorageKey, torusAlertContainer, torusIframe } = params;
			this.torusUrl = torusUrl;
			this.dappStorageKey = dappStorageKey;
			this.torusAlertContainer = torusAlertContainer;
			this.torusIframe = torusIframe;
			this.torusIframe.addEventListener("load", () => {
				if (!this._state.isIFrameFullScreen) this._displayIframe();
			});
			const { currentLoginProvider, isLoggedIn } = await this.request({
				method: COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,
				params: []
			});
			this._handleConnect(currentLoginProvider, isLoggedIn);
		} catch (error$1) {
			log.error("Torus: Failed to get initial state. Please report this bug.", error$1);
		} finally {
			log.info("initialized communication state");
			this._state.initialized = true;
			this.emit("_initialized");
		}
	}
	_handleWindow(windowId) {
		let { url: url$1, target, features } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
		const finalUrl = new URL(url$1 || `${this.torusUrl}/redirect?windowId=${windowId}`);
		if (this.dappStorageKey) if (finalUrl.hash) finalUrl.hash += `&dappStorageKey=${this.dappStorageKey}`;
		else finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;
		const handledWindow = new PopupHandler({
			url: finalUrl,
			target,
			features
		});
		handledWindow.open();
		if (!handledWindow.window) {
			this._createPopupBlockAlert(windowId, finalUrl.href);
			return;
		}
		this.windowRefs[windowId] = handledWindow;
		this.request({
			method: "opened_window",
			params: { windowId }
		});
		handledWindow.once("close", () => {
			delete this.windowRefs[windowId];
			this.request({
				method: COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,
				params: { windowId }
			});
		});
	}
	_displayIframe() {
		let { isFull = false, rid = "" } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		const style = {};
		if (!isFull) {
			style.display = this._state.torusWidgetVisibility ? "block" : "none";
			style.height = "70px";
			style.width = "70px";
			switch (this._state.buttonPosition) {
				case BUTTON_POSITION.TOP_LEFT:
					style.top = "0px";
					style.left = "0px";
					style.right = "auto";
					style.bottom = "auto";
					break;
				case BUTTON_POSITION.TOP_RIGHT:
					style.top = "0px";
					style.right = "0px";
					style.left = "auto";
					style.bottom = "auto";
					break;
				case BUTTON_POSITION.BOTTOM_RIGHT:
					style.bottom = "0px";
					style.right = "0px";
					style.top = "auto";
					style.left = "auto";
					break;
				case BUTTON_POSITION.BOTTOM_LEFT:
				default:
					style.bottom = "0px";
					style.left = "0px";
					style.top = "auto";
					style.right = "auto";
					break;
			}
		} else {
			style.display = "block";
			style.width = "100%";
			style.height = "100%";
			style.top = "0px";
			style.right = "0px";
			style.left = "0px";
			style.bottom = "0px";
		}
		Object.assign(this.torusIframe.style, style);
		this._state.isIFrameFullScreen = isFull;
		this.request({
			method: COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,
			params: {
				isIFrameFullScreen: isFull,
				rid
			}
		});
	}
	hideTorusButton() {
		this._state.torusWidgetVisibility = false;
		this._displayIframe();
	}
	showTorusButton() {
		this._state.torusWidgetVisibility = true;
		this._displayIframe();
	}
	/**
	* Internal RPC method. Forwards requests to background via the RPC engine.
	* Also remap ids inbound and outbound
	*/
	_rpcRequest(payload, callback) {
		const cb = callback;
		const _payload = payload;
		if (!Array.isArray(_payload)) {
			if (!_payload.jsonrpc) _payload.jsonrpc = "2.0";
		}
		this.tryWindowHandle(_payload, cb);
	}
	/**
	* When the provider becomes connected, updates internal state and emits
	* required events. Idempotent.
	*
	* @param currentLoginProvider - The login Provider
	* emits TorusInpageProvider#connect
	*/
	_handleConnect(currentLoginProvider, isLoggedIn) {
		if (!this._state.isConnected) {
			this._state.isConnected = true;
			this.emit("connect", {
				currentLoginProvider,
				isLoggedIn
			});
			log.debug(messages.info.connected(currentLoginProvider));
		}
	}
	/**
	* When the provider becomes disconnected, updates internal state and emits
	* required events. Idempotent with respect to the isRecoverable parameter.
	*
	* Error codes per the CloseEvent status codes as required by EIP-1193:
	* https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
	*
	* @param isRecoverable - Whether the disconnection is recoverable.
	* @param errorMessage - A custom error message.
	* emits TorusInpageProvider#disconnect
	*/
	_handleDisconnect(isRecoverable, errorMessage) {
		if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {
			this._state.isConnected = false;
			let error$1;
			if (isRecoverable) {
				error$1 = new import_dist.EthereumRpcError(1013, errorMessage || messages.errors.disconnected());
				log.debug(error$1);
			} else {
				error$1 = new import_dist.EthereumRpcError(1011, errorMessage || messages.errors.permanentlyDisconnected());
				log.error(error$1);
				this._state.currentLoginProvider = null;
				this._state.isLoggedIn = false;
				this._state.torusWidgetVisibility = false;
				this._state.isIFrameFullScreen = false;
				this._state.isPermanentlyDisconnected = true;
			}
			this.emit("disconnect", error$1);
		}
	}
	_handleCloseWindow(params) {
		const { windowId } = params;
		if (this.windowRefs[windowId]) {
			this.windowRefs[windowId].close();
			delete this.windowRefs[windowId];
		}
	}
	async _createPopupBlockAlert(windowId, url$1) {
		const torusAlert = htmlToElement(`<div id="torusAlert" class="torus-alert--v2"><div id="torusAlert__logo"><img src="${this.getLogoUrl()}" /></div><div><h1 id="torusAlert__title">${this.embedTranslations.actionRequired}</h1><p id="torusAlert__desc">${this.embedTranslations.pendingAction}</p></div></div>`);
		const successAlert = htmlToElement(`<div><a id="torusAlert__btn">${this.embedTranslations.continue}</a></div>`);
		const btnContainer = htmlToElement("<div id=\"torusAlert__btn-container\"></div>");
		btnContainer.appendChild(successAlert);
		torusAlert.appendChild(btnContainer);
		const bindOnLoad = () => {
			successAlert.addEventListener("click", () => {
				this._handleWindow(windowId, {
					url: url$1,
					target: "_blank",
					features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)
				});
				torusAlert.remove();
				if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = "none";
			});
		};
		const attachOnLoad = () => {
			this.torusAlertContainer.appendChild(torusAlert);
		};
		attachOnLoad();
		bindOnLoad();
		this.torusAlertContainer.style.display = "block";
	}
	getLogoUrl() {
		return `${this.torusUrl}/images/torus_icon-blue.svg`;
	}
};
_defineProperty(TorusCommunicationProvider, "_defaultState", {
	buttonPosition: "bottom-left",
	currentLoginProvider: null,
	isIFrameFullScreen: false,
	hasEmittedConnection: false,
	torusWidgetVisibility: false,
	initialized: false,
	isLoggedIn: false,
	isPermanentlyDisconnected: false,
	isConnected: false
});
var TorusInPageProvider = class TorusInPageProvider extends BaseProvider {
	constructor(connectionStream, _ref) {
		let { maxEventListeners = 100, jsonRpcStreamName = "provider" } = _ref;
		super(connectionStream, {
			maxEventListeners,
			jsonRpcStreamName
		});
		/**
		* The chain ID of the currently connected Solana chain.
		* See [chainId.network]{@link https://chainid.network} for more information.
		*/
		_defineProperty(this, "chainId", void 0);
		/**
		* The user's currently selected Solana address.
		* If null, Torus is either locked or the user has not permitted any
		* addresses to be viewed.
		*/
		_defineProperty(this, "selectedAddress", void 0);
		_defineProperty(this, "tryWindowHandle", void 0);
		this._state = _objectSpread2({}, TorusInPageProvider._defaultState);
		this.selectedAddress = null;
		this.chainId = null;
		this._handleAccountsChanged = this._handleAccountsChanged.bind(this);
		this._handleChainChanged = this._handleChainChanged.bind(this);
		this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);
		this.on("connect", () => {
			this._state.isConnected = true;
		});
		const jsonRpcNotificationHandler = (payload) => {
			const { method, params } = payload;
			if (method === PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) this._handleAccountsChanged(params);
			else if (method === PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) this._handleUnlockStateChanged(params);
			else if (method === PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) this._handleChainChanged(params);
		};
		this.jsonRpcConnectionEvents.on("notification", jsonRpcNotificationHandler);
	}
	/**
	* Returns whether the inpage provider is connected to Torus.
	*/
	isConnected() {
		return this._state.isConnected;
	}
	/**
	* Constructor helper.
	* Populates initial state by calling 'wallet_getProviderState' and emits
	* necessary events.
	*/
	async _initializeState() {
		try {
			const { accounts, chainId, isUnlocked } = await this.request({
				method: PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,
				params: []
			});
			this.emit("connect", { chainId });
			this._handleChainChanged({ chainId });
			this._handleUnlockStateChanged({
				accounts,
				isUnlocked
			});
			this._handleAccountsChanged(accounts);
		} catch (error$1) {
			log.error("Torus: Failed to get initial state. Please report this bug.", error$1);
		} finally {
			log.info("initialized provider state");
			this._state.initialized = true;
			this.emit("_initialized");
		}
	}
	/**
	* Internal RPC method. Forwards requests to background via the RPC engine.
	* Also remap ids inbound and outbound
	*/
	_rpcRequest(payload, callback) {
		let isInternal = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
		let cb = callback;
		const _payload = payload;
		if (!Array.isArray(_payload)) {
			if (!_payload.jsonrpc) _payload.jsonrpc = "2.0";
			if (_payload.method === "solana_accounts" || _payload.method === "solana_requestAccounts") cb = (err, res) => {
				this._handleAccountsChanged(res.result || [], _payload.method === "solana_accounts", isInternal);
				callback(err, res);
			};
			else if (_payload.method === "wallet_getProviderState") {
				this._rpcEngine.handle(payload, cb);
				return;
			}
		}
		this.tryWindowHandle(_payload, cb);
	}
	/**
	* When the provider becomes connected, updates internal state and emits
	* required events. Idempotent.
	*
	* @param chainId - The ID of the newly connected chain.
	* emits TorusInpageProvider#connect
	*/
	_handleConnect(chainId) {
		if (!this._state.isConnected) {
			this._state.isConnected = true;
			this.emit("connect", { chainId });
			log.debug(messages.info.connected(chainId));
		}
	}
	/**
	* When the provider becomes disconnected, updates internal state and emits
	* required events. Idempotent with respect to the isRecoverable parameter.
	*
	* Error codes per the CloseEvent status codes as required by EIP-1193:
	* https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
	*
	* @param isRecoverable - Whether the disconnection is recoverable.
	* @param errorMessage - A custom error message.
	* emits TorusInpageProvider#disconnect
	*/
	_handleDisconnect(isRecoverable, errorMessage) {
		if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {
			this._state.isConnected = false;
			let error$1;
			if (isRecoverable) {
				error$1 = new import_dist.EthereumRpcError(1013, errorMessage || messages.errors.disconnected());
				log.debug(error$1);
			} else {
				error$1 = new import_dist.EthereumRpcError(1011, errorMessage || messages.errors.permanentlyDisconnected());
				log.error(error$1);
				this.chainId = null;
				this._state.accounts = null;
				this.selectedAddress = null;
				this._state.isUnlocked = false;
				this._state.isPermanentlyDisconnected = true;
			}
			this.emit("disconnect", error$1);
		}
	}
	/**
	* Called when accounts may have changed.
	*/
	_handleAccountsChanged(accounts) {
		let isEthAccounts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
		let isInternal = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
		let finalAccounts = accounts;
		if (!Array.isArray(finalAccounts)) {
			log.error("Torus: Received non-array accounts parameter. Please report this bug.", finalAccounts);
			finalAccounts = [];
		}
		for (const account of accounts) if (typeof account !== "string") {
			log.error("Torus: Received non-string account. Please report this bug.", accounts);
			finalAccounts = [];
			break;
		}
		if (!(0, import_fast_deep_equal.default)(this._state.accounts, finalAccounts)) {
			if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) log.error("Torus: \"solana_accounts\" unexpectedly updated accounts. Please report this bug.", finalAccounts);
			this._state.accounts = finalAccounts;
			this.emit("accountsChanged", finalAccounts);
		}
		if (this.selectedAddress !== finalAccounts[0]) this.selectedAddress = finalAccounts[0] || null;
	}
	/**
	* Upon receipt of a new chainId and networkVersion, emits corresponding
	* events and sets relevant public state.
	* Does nothing if neither the chainId nor the networkVersion are different
	* from existing values.
	*
	* emits TorusInpageProvider#chainChanged
	* @param networkInfo - An object with network info.
	*/
	_handleChainChanged() {
		let { chainId } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		if (!chainId) {
			log.error("Torus: Received invalid network parameters. Please report this bug.", { chainId });
			return;
		}
		if (chainId === "loading") this._handleDisconnect(true);
		else {
			this._handleConnect(chainId);
			if (chainId !== this.chainId) {
				this.chainId = chainId;
				if (this._state.initialized) this.emit("chainChanged", this.chainId);
			}
		}
	}
	/**
	* Upon receipt of a new isUnlocked state, sets relevant public state.
	* Calls the accounts changed handler with the received accounts, or an empty
	* array.
	*
	* Does nothing if the received value is equal to the existing value.
	* There are no lock/unlock events.
	*
	* @param opts - Options bag.
	*/
	_handleUnlockStateChanged() {
		let { accounts, isUnlocked } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		if (typeof isUnlocked !== "boolean") {
			log.error("Torus: Received invalid isUnlocked parameter. Please report this bug.", { isUnlocked });
			return;
		}
		if (isUnlocked !== this._state.isUnlocked) {
			this._state.isUnlocked = isUnlocked;
			this._handleAccountsChanged(accounts || []);
		}
	}
};
_defineProperty(TorusInPageProvider, "_defaultState", {
	accounts: null,
	isConnected: false,
	isUnlocked: false,
	initialized: false,
	isPermanentlyDisconnected: false,
	hasEmittedConnection: false
});
/**
* Returns whether the given image URL exists
*/
function imgExists(url$1) {
	return new Promise((resolve, reject) => {
		try {
			const img = document.createElement("img");
			img.onload = () => resolve(true);
			img.onerror = () => resolve(false);
			img.src = url$1;
		} catch (e) {
			reject(e);
		}
	});
}
/**
* Extracts a name for the site from the DOM
*/
var getSiteName = (window$1) => {
	const { document: document$1 } = window$1;
	const siteName = document$1.querySelector("head > meta[property=\"og:site_name\"]");
	if (siteName) return siteName.content;
	const metaTitle = document$1.querySelector("head > meta[name=\"title\"]");
	if (metaTitle) return metaTitle.content;
	if (document$1.title && document$1.title.length > 0) return document$1.title;
	return window$1.location.hostname;
};
/**
* Extracts an icon for the site from the DOM
*/
async function getSiteIcon(window$1) {
	try {
		const { document: document$1 } = window$1;
		let icon = document$1.querySelector("head > link[rel=\"shortcut icon\"]");
		if (icon && await imgExists(icon.href)) return icon.href;
		icon = Array.from(document$1.querySelectorAll("head > link[rel=\"icon\"]")).find((_icon) => Boolean(_icon.href));
		if (icon && await imgExists(icon.href)) return icon.href;
		return "";
	} catch (error$1) {
		return "";
	}
}
/**
* Gets site metadata and returns it
*
*/
var getSiteMetadata = async () => ({
	name: getSiteName(window),
	icon: await getSiteIcon(window)
});
var PROVIDER_UNSAFE_METHODS = [
	"send_transaction",
	"sign_transaction",
	"sign_all_transactions",
	"sign_message",
	"connect"
];
var COMMUNICATION_UNSAFE_METHODS = [COMMUNICATION_JRPC_METHODS.SET_PROVIDER];
var isLocalStorageAvailable = storageAvailable("localStorage");
(async function preLoadIframe() {
	try {
		if (typeof document === "undefined") return;
		const torusIframeHtml = document.createElement("link");
		const { torusUrl } = await getTorusUrl("production");
		torusIframeHtml.href = `${torusUrl}/frame`;
		torusIframeHtml.crossOrigin = "anonymous";
		torusIframeHtml.type = "text/html";
		torusIframeHtml.rel = "prefetch";
		if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {
			if (torusIframeHtml.relList.supports("prefetch")) document.head.appendChild(torusIframeHtml);
		}
	} catch (error$1) {
		log.warn(error$1);
	}
})();
var Torus = class {
	constructor() {
		let { modalZIndex = 99999 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		_defineProperty(this, "isInitialized", void 0);
		_defineProperty(this, "torusAlert", void 0);
		_defineProperty(this, "modalZIndex", void 0);
		_defineProperty(this, "alertZIndex", void 0);
		_defineProperty(this, "requestedLoginProvider", void 0);
		_defineProperty(this, "provider", void 0);
		_defineProperty(this, "communicationProvider", void 0);
		_defineProperty(this, "dappStorageKey", void 0);
		_defineProperty(this, "isTopupHidden", false);
		_defineProperty(this, "torusAlertContainer", void 0);
		_defineProperty(this, "torusUrl", void 0);
		_defineProperty(this, "torusIframe", void 0);
		_defineProperty(this, "styleLink", void 0);
		this.torusUrl = "";
		this.isInitialized = false;
		this.requestedLoginProvider = null;
		this.modalZIndex = modalZIndex;
		this.alertZIndex = modalZIndex + 1e3;
		this.dappStorageKey = "";
	}
	get isLoggedIn() {
		if (!this.communicationProvider) return false;
		return this.communicationProvider.isLoggedIn;
	}
	async init() {
		let { buildEnv = TORUS_BUILD_ENV.PRODUCTION, enableLogging = false, network, showTorusButton = false, useLocalStorage = false, buttonPosition = BUTTON_POSITION.BOTTOM_LEFT, apiKey: apiKey$1 = "torus-default", extraParams = {}, whiteLabel } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		if (this.isInitialized) throw new Error("Already initialized");
		setAPIKey(apiKey$1);
		const { torusUrl, logLevel: logLevel$1 } = await getTorusUrl(buildEnv);
		log.enableAll();
		log.info(torusUrl, "url loaded");
		log.info(`Solana Embed Version :${version}`);
		this.torusUrl = torusUrl;
		log.setDefaultLevel(logLevel$1);
		if (enableLogging) log.enableAll();
		else log.disableAll();
		const dappStorageKey = this.handleDappStorageKey(useLocalStorage);
		const torusIframeUrl = new URL(torusUrl);
		if (torusIframeUrl.pathname.endsWith("/")) torusIframeUrl.pathname += "frame";
		else torusIframeUrl.pathname += "/frame";
		const hashParams = new URLSearchParams();
		if (dappStorageKey) hashParams.append("dappStorageKey", dappStorageKey);
		hashParams.append("origin", window.location.origin);
		torusIframeUrl.hash = hashParams.toString();
		this.torusIframe = htmlToElement(`<iframe
        id="torusIframe"
        class="torusIframe"
        src="${torusIframeUrl.href}"
        style="display: none; position: fixed; top: 0; right: 0; width: 100%;
        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()}"
      ></iframe>`);
		this.torusAlertContainer = htmlToElement(`<div id="torusAlertContainer" style="display:none; z-index: ${this.alertZIndex.toString()}"></div>`);
		this.styleLink = htmlToElement(`<link href="${torusUrl}/css/widget.css" rel="stylesheet" type="text/css">`);
		return new Promise((resolve, reject) => {
			try {
				this.torusIframe.addEventListener("load", async () => {
					const dappMetadata = await getSiteMetadata();
					this.torusIframe.contentWindow.postMessage({
						buttonPosition,
						apiKey: apiKey$1,
						network,
						dappMetadata,
						extraParams,
						whiteLabel
					}, torusIframeUrl.origin);
					await this._setupWeb3({ torusUrl });
					if (showTorusButton) this.showTorusButton();
					if (whiteLabel?.topupHide) this.isTopupHidden = whiteLabel.topupHide;
					else this.hideTorusButton();
					this.isInitialized = true;
					window.torus = this;
					resolve();
				});
				window.document.head.appendChild(this.styleLink);
				window.document.body.appendChild(this.torusIframe);
				window.document.body.appendChild(this.torusAlertContainer);
			} catch (error$1) {
				reject(error$1);
			}
		});
	}
	async login() {
		let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		if (!this.isInitialized) throw new Error("Call init() first");
		try {
			this.requestedLoginProvider = params.loginProvider || null;
			if (!this.requestedLoginProvider) this.communicationProvider._displayIframe({ isFull: true });
			const res = await new Promise((resolve, reject) => {
				this.provider._rpcRequest({
					method: "solana_requestAccounts",
					params: [this.requestedLoginProvider, params.login_hint]
				}, getRpcPromiseCallback(resolve, reject));
			});
			if (Array.isArray(res) && res.length > 0) return res;
			throw new Error("Login failed");
		} catch (error$1) {
			log.error("login failed", error$1);
			throw error$1;
		} finally {
			if (this.communicationProvider.isIFrameFullScreen) this.communicationProvider._displayIframe();
		}
	}
	async loginWithPrivateKey(loginParams) {
		if (!this.isInitialized) throw new Error("Call init() first");
		const { privateKey, userInfo } = loginParams;
		const { success } = await this.communicationProvider.request({
			method: "login_with_private_key",
			params: {
				privateKey,
				userInfo
			}
		});
		if (!success) throw new Error("Login Failed");
	}
	async logout() {
		if (!this.communicationProvider.isLoggedIn) throw new Error("Not logged in");
		await this.communicationProvider.request({
			method: COMMUNICATION_JRPC_METHODS.LOGOUT,
			params: []
		});
		this.requestedLoginProvider = null;
	}
	async cleanUp() {
		if (this.communicationProvider.isLoggedIn) await this.logout();
		this.clearInit();
	}
	clearInit() {
		function isElement(element) {
			return element instanceof Element || element instanceof Document;
		}
		if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {
			this.styleLink.remove();
			this.styleLink = void 0;
		}
		if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {
			this.torusIframe.remove();
			this.torusIframe = void 0;
		}
		if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {
			this.torusAlert = void 0;
			this.torusAlertContainer.remove();
			this.torusAlertContainer = void 0;
		}
		this.isInitialized = false;
	}
	hideTorusButton() {
		this.communicationProvider.hideTorusButton();
	}
	showTorusButton() {
		this.communicationProvider.showTorusButton();
	}
	async setProvider(params) {
		await this.communicationProvider.request({
			method: COMMUNICATION_JRPC_METHODS.SET_PROVIDER,
			params: _objectSpread2({}, params)
		});
	}
	async showWallet(path) {
		let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
		const instanceId = await this.communicationProvider.request({
			method: COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID,
			params: []
		});
		const finalPath = path ? `/${path}` : "";
		const finalUrl = new URL(`${this.torusUrl}/wallet${finalPath}`);
		finalUrl.searchParams.append("instanceId", instanceId);
		Object.keys(params).forEach((x) => {
			finalUrl.searchParams.append(x, params[x]);
		});
		if (this.dappStorageKey) finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;
		new PopupHandler({
			url: finalUrl,
			features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)
		}).open();
	}
	async getUserInfo() {
		return await this.communicationProvider.request({
			method: COMMUNICATION_JRPC_METHODS.USER_INFO,
			params: []
		});
	}
	async initiateTopup(provider, params) {
		if (!this.isInitialized) throw new Error("Torus is not initialized");
		const windowId = getWindowId();
		this.communicationProvider._handleWindow(windowId);
		return await this.communicationProvider.request({
			method: COMMUNICATION_JRPC_METHODS.TOPUP,
			params: {
				provider,
				params,
				windowId
			}
		});
	}
	async getAccounts() {
		return await this.provider.request({
			method: "getAccounts",
			params: []
		});
	}
	async sendTransaction(transaction) {
		const isLegacyTransaction = isLegacyTransactionInstance(transaction);
		const message = isLegacyTransaction ? transaction.serialize({ requireAllSignatures: false }).toString("hex") : Buffer.from(transaction.serialize()).toString("hex");
		return await this.provider.request({
			method: "send_transaction",
			params: {
				message,
				isLegacyTransaction
			}
		});
	}
	async signAndSendTransaction(transaction, options) {
		const isLegacyTransaction = isLegacyTransactionInstance(transaction);
		const message = isLegacyTransaction ? transaction.serialize({ requireAllSignatures: false }).toString("hex") : Buffer.from(transaction.serialize()).toString("hex");
		return { signature: await this.provider.request({
			method: "send_transaction",
			params: {
				message,
				options,
				isLegacyTransaction
			}
		}) };
	}
	async signTransaction(transaction) {
		const isLegacyTransaction = isLegacyTransactionInstance(transaction);
		const message = isLegacyTransaction ? transaction.serializeMessage().toString("hex") : Buffer.from(transaction.message.serialize()).toString("hex");
		const response = await this.provider.request({
			method: "sign_transaction",
			params: {
				message,
				messageOnly: true,
				isLegacyTransaction
			}
		});
		const parsed = JSON.parse(response);
		const signature = {
			publicKey: new PublicKey(parsed.publicKey),
			signature: Buffer.from(parsed.signature, "hex")
		};
		transaction.addSignature(signature.publicKey, signature.signature);
		return transaction;
	}
	async signAllTransactions(transactions) {
		let isLegacyTransaction;
		const encodedMessage = transactions.map((tx) => {
			isLegacyTransaction = isLegacyTransactionInstance(tx);
			return isLegacyTransaction ? tx.serializeMessage().toString("hex") : Buffer.from(tx.message.serialize()).toString("hex");
		});
		const signatures = (await this.provider.request({
			method: "sign_all_transactions",
			params: {
				message: encodedMessage,
				messageOnly: true,
				isLegacyTransaction
			}
		})).map((item) => {
			const parsed = JSON.parse(item);
			return {
				publicKey: new PublicKey(parsed.publicKey),
				signature: Buffer.from(parsed.signature, "hex")
			};
		});
		transactions.forEach((tx, idx) => {
			tx.addSignature(signatures[idx].publicKey, signatures[idx].signature);
			return tx;
		});
		return transactions;
	}
	async signMessage(data) {
		return await this.provider.request({
			method: "sign_message",
			params: { data }
		});
	}
	async getGaslessPublicKey() {
		return await this.provider.request({
			method: "get_gasless_public_key",
			params: []
		});
	}
	handleDappStorageKey(useLocalStorage) {
		const localStorageKey = `${configuration.localStorageKeyPrefix}${window.location.hostname}`;
		let dappStorageKey = "";
		if (isLocalStorageAvailable && useLocalStorage) {
			const storedKey = window.localStorage.getItem(localStorageKey);
			if (storedKey) dappStorageKey = storedKey;
			else {
				const generatedKey = `torus-app-${getWindowId()}`;
				window.localStorage.setItem(localStorageKey, generatedKey);
				dappStorageKey = generatedKey;
			}
		}
		this.dappStorageKey = dappStorageKey;
		return dappStorageKey;
	}
	async _setupWeb3(providerParams) {
		log.info("setupWeb3 running");
		const providerStream = new BasePostMessageStream({
			name: "embed_torus",
			target: "iframe_torus",
			targetWindow: this.torusIframe.contentWindow
		});
		const communicationStream = new BasePostMessageStream({
			name: "embed_communication",
			target: "iframe_communication",
			targetWindow: this.torusIframe.contentWindow
		});
		const inPageProvider = new TorusInPageProvider(providerStream, {});
		const communicationProvider = new TorusCommunicationProvider(communicationStream, {});
		inPageProvider.tryWindowHandle = (payload, cb) => {
			const _payload = payload;
			if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {
				if (!this.communicationProvider.isLoggedIn) throw new Error("User Not Logged In");
				const windowId = getWindowId();
				communicationProvider._handleWindow(windowId, {
					target: "_blank",
					features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)
				});
				_payload.windowId = windowId;
			}
			inPageProvider._rpcEngine.handle(_payload, cb);
		};
		communicationProvider.tryWindowHandle = (payload, cb) => {
			const _payload = payload;
			if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {
				const windowId = getWindowId();
				communicationProvider._handleWindow(windowId, {
					target: "_blank",
					features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW)
				});
				_payload.params.windowId = windowId;
			}
			communicationProvider._rpcEngine.handle(_payload, cb);
		};
		const detectAccountRequestPrototypeModifier = (m) => {
			const originalMethod = inPageProvider[m];
			const self$1 = this;
			inPageProvider[m] = function providerFunc(request, cb) {
				const { method, params = [] } = request;
				if (method === "solana_requestAccounts") {
					if (!cb) return self$1.login({ loginProvider: params[0] });
					self$1.login({ loginProvider: params[0] }).then((res) => cb(null, res)).catch((err) => cb(err));
				}
				return originalMethod.apply(this, [request, cb]);
			};
		};
		detectAccountRequestPrototypeModifier("request");
		detectAccountRequestPrototypeModifier("sendAsync");
		detectAccountRequestPrototypeModifier("send");
		const proxiedInPageProvider = new Proxy(inPageProvider, { deleteProperty: () => true });
		const proxiedCommunicationProvider = new Proxy(communicationProvider, { deleteProperty: () => true });
		this.provider = proxiedInPageProvider;
		this.communicationProvider = proxiedCommunicationProvider;
		await Promise.all([inPageProvider._initializeState(), communicationProvider._initializeState(_objectSpread2(_objectSpread2({}, providerParams), {}, {
			dappStorageKey: this.dappStorageKey,
			torusAlertContainer: this.torusAlertContainer,
			torusIframe: this.torusIframe
		}))]);
		log.debug("Torus - injected provider");
	}
};

//#endregion
export { Torus as default };
//# sourceMappingURL=solanaEmbed.esm-BD3u8mmh.js.map