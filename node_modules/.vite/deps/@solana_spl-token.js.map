{"version":3,"file":"@solana_spl-token.js","names":["toBigIntLE","toBigIntBE","toBufferLE","toBufferBE","bigInt","bool","publicKey","struct","getInstructionEncoder","getPublicKeyEncoder","publicKey","isNonePubkey","Layout","e","ONE_IN_BASIS_POINTS","error","publicKey"],"sources":["../../@solana/spl-token/lib/esm/constants.js","../../@solana/buffer-layout-utils/lib/esm/base.mjs","../../bigint-buffer/dist/browser.js","../../@solana/buffer-layout-utils/lib/esm/bigint.mjs","../../@solana/buffer-layout-utils/lib/esm/native.mjs","../../@solana/buffer-layout-utils/lib/esm/web3.mjs","../../@solana/spl-token/lib/esm/errors.js","../../@solana/spl-token/lib/esm/instructions/types.js","../../@solana/spl-token/lib/esm/instructions/amountToUiAmount.js","../../@solana/spl-token/lib/esm/extensions/accountType.js","../../@solana/spl-token/lib/esm/state/multisig.js","../../@solana/spl-token/lib/esm/state/account.js","../../@solana/spl-token/lib/esm/actions/internal.js","../../@solana/spl-token/lib/esm/instructions/internal.js","../../@solana/spl-token/lib/esm/extensions/cpiGuard/instructions.js","../../@solana/spl-token/lib/esm/extensions/cpiGuard/actions.js","../../@solana/spl-token/lib/esm/extensions/cpiGuard/state.js","../../@solana/spl-token/lib/esm/extensions/defaultAccountState/instructions.js","../../@solana/spl-token/lib/esm/extensions/defaultAccountState/actions.js","../../@solana/spl-token/lib/esm/extensions/defaultAccountState/state.js","../../@solana/errors/dist/index.browser.mjs","../../@solana/codecs-core/dist/index.browser.mjs","../../@solana/codecs-numbers/dist/index.browser.mjs","../../@solana/codecs-data-structures/dist/index.browser.mjs","../../@solana/codecs-strings/dist/index.browser.mjs","../../@solana/options/dist/index.browser.mjs","../../@solana/spl-token-group/lib/esm/instruction.js","../../@solana/spl-token-group/lib/esm/state/tokenGroup.js","../../@solana/spl-token-group/lib/esm/state/tokenGroupMember.js","../../@solana/spl-token/lib/esm/extensions/tokenGroup/actions.js","../../@solana/spl-token/lib/esm/extensions/tokenGroup/state.js","../../@solana/spl-token/lib/esm/extensions/groupMemberPointer/state.js","../../@solana/spl-token/lib/esm/extensions/groupPointer/state.js","../../@solana/spl-token/lib/esm/extensions/immutableOwner.js","../../@solana/spl-token/lib/esm/extensions/interestBearingMint/state.js","../../@solana/spl-token/lib/esm/extensions/memoTransfer/instructions.js","../../@solana/spl-token/lib/esm/extensions/memoTransfer/actions.js","../../@solana/spl-token/lib/esm/extensions/memoTransfer/state.js","../../@solana/spl-token/lib/esm/extensions/metadataPointer/state.js","../../@solana/spl-token/lib/esm/extensions/mintCloseAuthority.js","../../@solana/spl-token/lib/esm/extensions/nonTransferable.js","../../@solana/spl-token/lib/esm/extensions/pausable/instructions.js","../../@solana/spl-token/lib/esm/extensions/pausable/actions.js","../../@solana/spl-token/lib/esm/extensions/pausable/state.js","../../@solana/spl-token/lib/esm/extensions/permanentDelegate.js","../../@solana/spl-token/lib/esm/extensions/scaledUiAmount/instructions.js","../../@solana/spl-token/lib/esm/extensions/scaledUiAmount/actions.js","../../@solana/spl-token/lib/esm/extensions/scaledUiAmount/state.js","../../@solana/spl-token/lib/esm/serialization.js","../../@solana/spl-token/lib/esm/extensions/transferFee/instructions.js","../../@solana/spl-token/lib/esm/extensions/transferFee/actions.js","../../@solana/spl-token/lib/esm/extensions/transferFee/state.js","../../@solana/spl-token/lib/esm/instructions/transferChecked.js","../../@solana/spl-token/lib/esm/extensions/transferHook/seeds.js","../../@solana/spl-token/lib/esm/extensions/transferHook/pubkeyData.js","../../@solana/spl-token/lib/esm/extensions/transferHook/state.js","../../@solana/spl-token/lib/esm/extensions/transferHook/instructions.js","../../@solana/spl-token/lib/esm/extensions/transferHook/actions.js","../../@solana/spl-token/lib/esm/extensions/extensionType.js","../../@solana/spl-token/lib/esm/state/mint.js","../../@solana/spl-token/lib/esm/actions/amountToUiAmount.js","../../@solana/spl-token/lib/esm/instructions/approve.js","../../@solana/spl-token/lib/esm/actions/approve.js","../../@solana/spl-token/lib/esm/instructions/approveChecked.js","../../@solana/spl-token/lib/esm/actions/approveChecked.js","../../@solana/spl-token/lib/esm/instructions/burn.js","../../@solana/spl-token/lib/esm/actions/burn.js","../../@solana/spl-token/lib/esm/instructions/burnChecked.js","../../@solana/spl-token/lib/esm/actions/burnChecked.js","../../@solana/spl-token/lib/esm/instructions/closeAccount.js","../../@solana/spl-token/lib/esm/actions/closeAccount.js","../../@solana/spl-token/lib/esm/instructions/initializeAccount.js","../../@solana/spl-token/lib/esm/instructions/associatedTokenAccount.js","../../@solana/spl-token/lib/esm/actions/createAssociatedTokenAccount.js","../../@solana/spl-token/lib/esm/actions/createAccount.js","../../@solana/spl-token/lib/esm/actions/createAssociatedTokenAccountIdempotent.js","../../@solana/spl-token/lib/esm/instructions/initializeMint2.js","../../@solana/spl-token/lib/esm/actions/createMint.js","../../@solana/spl-token/lib/esm/instructions/initializeMultisig.js","../../@solana/spl-token/lib/esm/actions/createMultisig.js","../../@solana/spl-token/lib/esm/instructions/createNativeMint.js","../../@solana/spl-token/lib/esm/actions/createNativeMint.js","../../@solana/spl-token/lib/esm/instructions/syncNative.js","../../@solana/spl-token/lib/esm/actions/createWrappedNativeAccount.js","../../@solana/spl-token/lib/esm/instructions/freezeAccount.js","../../@solana/spl-token/lib/esm/actions/freezeAccount.js","../../@solana/spl-token/lib/esm/actions/getOrCreateAssociatedTokenAccount.js","../../@solana/spl-token/lib/esm/instructions/mintTo.js","../../@solana/spl-token/lib/esm/actions/mintTo.js","../../@solana/spl-token/lib/esm/instructions/mintToChecked.js","../../@solana/spl-token/lib/esm/actions/mintToChecked.js","../../@solana/spl-token/lib/esm/actions/recoverNested.js","../../@solana/spl-token/lib/esm/instructions/revoke.js","../../@solana/spl-token/lib/esm/actions/revoke.js","../../@solana/spl-token/lib/esm/instructions/setAuthority.js","../../@solana/spl-token/lib/esm/actions/setAuthority.js","../../@solana/spl-token/lib/esm/actions/syncNative.js","../../@solana/spl-token/lib/esm/instructions/thawAccount.js","../../@solana/spl-token/lib/esm/actions/thawAccount.js","../../@solana/spl-token/lib/esm/instructions/transfer.js","../../@solana/spl-token/lib/esm/actions/transfer.js","../../@solana/spl-token/lib/esm/actions/transferChecked.js","../../@solana/spl-token/lib/esm/instructions/uiAmountToAmount.js","../../@solana/spl-token/lib/esm/actions/uiAmountToAmount.js","../../@solana/spl-token/lib/esm/extensions/groupMemberPointer/instructions.js","../../@solana/spl-token/lib/esm/extensions/groupPointer/instructions.js","../../@solana/spl-token/lib/esm/instructions/initializeMint.js","../../@solana/spl-token/lib/esm/extensions/interestBearingMint/instructions.js","../../@solana/spl-token/lib/esm/extensions/interestBearingMint/actions.js","../../@solana/spl-token/lib/esm/extensions/metadataPointer/instructions.js","../../@solana/spl-token-metadata/lib/esm/field.js","../../@solana/spl-token-metadata/lib/esm/instruction.js","../../@solana/spl-token-metadata/lib/esm/state.js","../../@solana/spl-token/lib/esm/extensions/tokenMetadata/state.js","../../@solana/spl-token/lib/esm/extensions/tokenMetadata/actions.js","../../@solana/spl-token/lib/esm/instructions/initializeAccount2.js","../../@solana/spl-token/lib/esm/instructions/initializeAccount3.js","../../@solana/spl-token/lib/esm/instructions/decode.js","../../@solana/spl-token/lib/esm/instructions/initializeImmutableOwner.js","../../@solana/spl-token/lib/esm/instructions/initializeMintCloseAuthority.js","../../@solana/spl-token/lib/esm/instructions/reallocate.js","../../@solana/spl-token/lib/esm/instructions/initializeNonTransferableMint.js","../../@solana/spl-token/lib/esm/instructions/initializePermanentDelegate.js"],"sourcesContent":["import { PublicKey } from '@solana/web3.js';\n/** Address of the SPL Token program */\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n/** Address of the SPL Token 2022 program */\nexport const TOKEN_2022_PROGRAM_ID = new PublicKey('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb');\n/** Address of the SPL Associated Token Account program */\nexport const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n/** Address of the special mint for wrapped native SOL in spl-token */\nexport const NATIVE_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n/** Address of the special mint for wrapped native SOL in spl-token-2022 */\nexport const NATIVE_MINT_2022 = new PublicKey('9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP');\n/** Check that the token program provided is not `Tokenkeg...`, useful when using extensions */\nexport function programSupportsExtensions(programId) {\n    if (programId.equals(TOKEN_PROGRAM_ID)) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n//# sourceMappingURL=constants.js.map","export const encodeDecode = (layout) => {\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    return { decode, encode };\n};\n//# sourceMappingURL=base.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet converter;\n/**\n * Convert a little-endian buffer into a BigInt.\n * @param buf The little-endian buffer to convert\n * @returns A BigInt with the little-endian representation of buf.\n */\nfunction toBigIntLE(buf) {\n    {\n        const reversed = Buffer.from(buf);\n        reversed.reverse();\n        const hex = reversed.toString('hex');\n        if (hex.length === 0) {\n            return BigInt(0);\n        }\n        return BigInt(`0x${hex}`);\n    }\n    return converter.toBigInt(buf, false);\n}\nexports.toBigIntLE = toBigIntLE;\n/**\n * Convert a big-endian buffer into a BigInt\n * @param buf The big-endian buffer to convert.\n * @returns A BigInt with the big-endian representation of buf.\n */\nfunction toBigIntBE(buf) {\n    {\n        const hex = buf.toString('hex');\n        if (hex.length === 0) {\n            return BigInt(0);\n        }\n        return BigInt(`0x${hex}`);\n    }\n    return converter.toBigInt(buf, true);\n}\nexports.toBigIntBE = toBigIntBE;\n/**\n * Convert a BigInt to a little-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A little-endian buffer representation of num.\n */\nfunction toBufferLE(num, width) {\n    {\n        const hex = num.toString(16);\n        const buffer = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n        buffer.reverse();\n        return buffer;\n    }\n    // Allocation is done here, since it is slower using napi in C\n    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);\n}\nexports.toBufferLE = toBufferLE;\n/**\n * Convert a BigInt to a big-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A big-endian buffer representation of num.\n */\nfunction toBufferBE(num, width) {\n    {\n        const hex = num.toString(16);\n        return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n    }\n    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);\n}\nexports.toBufferBE = toBufferBE;\n","import { blob } from '@solana/buffer-layout';\nimport { toBigIntBE, toBigIntLE, toBufferBE, toBufferLE } from 'bigint-buffer';\nimport { encodeDecode } from './base.mjs';\nexport const bigInt = (length) => (property) => {\n    const layout = blob(length, property);\n    const { encode, decode } = encodeDecode(layout);\n    const bigIntLayout = layout;\n    bigIntLayout.decode = (buffer, offset) => {\n        const src = decode(buffer, offset);\n        return toBigIntLE(Buffer.from(src));\n    };\n    bigIntLayout.encode = (bigInt, buffer, offset) => {\n        const src = toBufferLE(bigInt, length);\n        return encode(src, buffer, offset);\n    };\n    return bigIntLayout;\n};\nexport const bigIntBE = (length) => (property) => {\n    const layout = blob(length, property);\n    const { encode, decode } = encodeDecode(layout);\n    const bigIntLayout = layout;\n    bigIntLayout.decode = (buffer, offset) => {\n        const src = decode(buffer, offset);\n        return toBigIntBE(Buffer.from(src));\n    };\n    bigIntLayout.encode = (bigInt, buffer, offset) => {\n        const src = toBufferBE(bigInt, length);\n        return encode(src, buffer, offset);\n    };\n    return bigIntLayout;\n};\nexport const u64 = bigInt(8);\nexport const u64be = bigIntBE(8);\nexport const u128 = bigInt(16);\nexport const u128be = bigIntBE(16);\nexport const u192 = bigInt(24);\nexport const u192be = bigIntBE(24);\nexport const u256 = bigInt(32);\nexport const u256be = bigIntBE(32);\n//# sourceMappingURL=bigint.js.map","import { u8 } from '@solana/buffer-layout';\nimport { encodeDecode } from './base.mjs';\nexport const bool = (property) => {\n    const layout = u8(property);\n    const { encode, decode } = encodeDecode(layout);\n    const boolLayout = layout;\n    boolLayout.decode = (buffer, offset) => {\n        const src = decode(buffer, offset);\n        return !!src;\n    };\n    boolLayout.encode = (bool, buffer, offset) => {\n        const src = Number(bool);\n        return encode(src, buffer, offset);\n    };\n    return boolLayout;\n};\n//# sourceMappingURL=native.js.map","import { blob } from '@solana/buffer-layout';\nimport { PublicKey } from '@solana/web3.js';\nimport { encodeDecode } from './base.mjs';\nexport const publicKey = (property) => {\n    const layout = blob(32, property);\n    const { encode, decode } = encodeDecode(layout);\n    const publicKeyLayout = layout;\n    publicKeyLayout.decode = (buffer, offset) => {\n        const src = decode(buffer, offset);\n        return new PublicKey(src);\n    };\n    publicKeyLayout.encode = (publicKey, buffer, offset) => {\n        const src = publicKey.toBuffer();\n        return encode(src, buffer, offset);\n    };\n    return publicKeyLayout;\n};\n//# sourceMappingURL=web3.js.map","/** Base class for errors */\nexport class TokenError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\n/** Thrown if an account is not found at the expected address */\nexport class TokenAccountNotFoundError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenAccountNotFoundError';\n    }\n}\n/** Thrown if a program state account is not a valid Account */\nexport class TokenInvalidAccountError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenInvalidAccountError';\n    }\n}\n/** Thrown if a program state account does not contain valid data */\nexport class TokenInvalidAccountDataError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenInvalidAccountDataError';\n    }\n}\n/** Thrown if a program state account is not owned by the expected token program */\nexport class TokenInvalidAccountOwnerError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenInvalidAccountOwnerError';\n    }\n}\n/** Thrown if the byte length of an program state account doesn't match the expected size */\nexport class TokenInvalidAccountSizeError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenInvalidAccountSizeError';\n    }\n}\n/** Thrown if the mint of a token account doesn't match the expected mint */\nexport class TokenInvalidMintError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenInvalidMintError';\n    }\n}\n/** Thrown if the owner of a token account doesn't match the expected owner */\nexport class TokenInvalidOwnerError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenInvalidOwnerError';\n    }\n}\n/** Thrown if the owner of a token account is a PDA (Program Derived Address) */\nexport class TokenOwnerOffCurveError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenOwnerOffCurveError';\n    }\n}\n/** Thrown if an instruction's program is invalid */\nexport class TokenInvalidInstructionProgramError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenInvalidInstructionProgramError';\n    }\n}\n/** Thrown if an instruction's keys are invalid */\nexport class TokenInvalidInstructionKeysError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenInvalidInstructionKeysError';\n    }\n}\n/** Thrown if an instruction's data is invalid */\nexport class TokenInvalidInstructionDataError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenInvalidInstructionDataError';\n    }\n}\n/** Thrown if an instruction's type is invalid */\nexport class TokenInvalidInstructionTypeError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenInvalidInstructionTypeError';\n    }\n}\n/** Thrown if the program does not support the desired instruction */\nexport class TokenUnsupportedInstructionError extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenUnsupportedInstructionError';\n    }\n}\n/** Thrown if the transfer hook extra accounts contains an invalid account index */\nexport class TokenTransferHookAccountNotFound extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenTransferHookAccountNotFound';\n    }\n}\n/** Thrown if the transfer hook extra accounts contains an invalid seed */\nexport class TokenTransferHookInvalidSeed extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenTransferHookInvalidSeed';\n    }\n}\n/** Thrown if account data required by an extra account meta seed config could not be fetched */\nexport class TokenTransferHookAccountDataNotFound extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenTransferHookAccountDataNotFound';\n    }\n}\n/** Thrown if pubkey data extra accounts config is invalid */\nexport class TokenTransferHookInvalidPubkeyData extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenTransferHookInvalidPubkeyData';\n    }\n}\n/** Thrown if pubkey data source is too small for a pubkey */\nexport class TokenTransferHookPubkeyDataTooSmall extends TokenError {\n    constructor() {\n        super(...arguments);\n        this.name = 'TokenTransferHookPubkeyDataTooSmall';\n    }\n}\n//# sourceMappingURL=errors.js.map","/** Instructions defined by the program */\nexport var TokenInstruction;\n(function (TokenInstruction) {\n    TokenInstruction[TokenInstruction[\"InitializeMint\"] = 0] = \"InitializeMint\";\n    TokenInstruction[TokenInstruction[\"InitializeAccount\"] = 1] = \"InitializeAccount\";\n    TokenInstruction[TokenInstruction[\"InitializeMultisig\"] = 2] = \"InitializeMultisig\";\n    TokenInstruction[TokenInstruction[\"Transfer\"] = 3] = \"Transfer\";\n    TokenInstruction[TokenInstruction[\"Approve\"] = 4] = \"Approve\";\n    TokenInstruction[TokenInstruction[\"Revoke\"] = 5] = \"Revoke\";\n    TokenInstruction[TokenInstruction[\"SetAuthority\"] = 6] = \"SetAuthority\";\n    TokenInstruction[TokenInstruction[\"MintTo\"] = 7] = \"MintTo\";\n    TokenInstruction[TokenInstruction[\"Burn\"] = 8] = \"Burn\";\n    TokenInstruction[TokenInstruction[\"CloseAccount\"] = 9] = \"CloseAccount\";\n    TokenInstruction[TokenInstruction[\"FreezeAccount\"] = 10] = \"FreezeAccount\";\n    TokenInstruction[TokenInstruction[\"ThawAccount\"] = 11] = \"ThawAccount\";\n    TokenInstruction[TokenInstruction[\"TransferChecked\"] = 12] = \"TransferChecked\";\n    TokenInstruction[TokenInstruction[\"ApproveChecked\"] = 13] = \"ApproveChecked\";\n    TokenInstruction[TokenInstruction[\"MintToChecked\"] = 14] = \"MintToChecked\";\n    TokenInstruction[TokenInstruction[\"BurnChecked\"] = 15] = \"BurnChecked\";\n    TokenInstruction[TokenInstruction[\"InitializeAccount2\"] = 16] = \"InitializeAccount2\";\n    TokenInstruction[TokenInstruction[\"SyncNative\"] = 17] = \"SyncNative\";\n    TokenInstruction[TokenInstruction[\"InitializeAccount3\"] = 18] = \"InitializeAccount3\";\n    TokenInstruction[TokenInstruction[\"InitializeMultisig2\"] = 19] = \"InitializeMultisig2\";\n    TokenInstruction[TokenInstruction[\"InitializeMint2\"] = 20] = \"InitializeMint2\";\n    TokenInstruction[TokenInstruction[\"GetAccountDataSize\"] = 21] = \"GetAccountDataSize\";\n    TokenInstruction[TokenInstruction[\"InitializeImmutableOwner\"] = 22] = \"InitializeImmutableOwner\";\n    TokenInstruction[TokenInstruction[\"AmountToUiAmount\"] = 23] = \"AmountToUiAmount\";\n    TokenInstruction[TokenInstruction[\"UiAmountToAmount\"] = 24] = \"UiAmountToAmount\";\n    TokenInstruction[TokenInstruction[\"InitializeMintCloseAuthority\"] = 25] = \"InitializeMintCloseAuthority\";\n    TokenInstruction[TokenInstruction[\"TransferFeeExtension\"] = 26] = \"TransferFeeExtension\";\n    TokenInstruction[TokenInstruction[\"ConfidentialTransferExtension\"] = 27] = \"ConfidentialTransferExtension\";\n    TokenInstruction[TokenInstruction[\"DefaultAccountStateExtension\"] = 28] = \"DefaultAccountStateExtension\";\n    TokenInstruction[TokenInstruction[\"Reallocate\"] = 29] = \"Reallocate\";\n    TokenInstruction[TokenInstruction[\"MemoTransferExtension\"] = 30] = \"MemoTransferExtension\";\n    TokenInstruction[TokenInstruction[\"CreateNativeMint\"] = 31] = \"CreateNativeMint\";\n    TokenInstruction[TokenInstruction[\"InitializeNonTransferableMint\"] = 32] = \"InitializeNonTransferableMint\";\n    TokenInstruction[TokenInstruction[\"InterestBearingMintExtension\"] = 33] = \"InterestBearingMintExtension\";\n    TokenInstruction[TokenInstruction[\"CpiGuardExtension\"] = 34] = \"CpiGuardExtension\";\n    TokenInstruction[TokenInstruction[\"InitializePermanentDelegate\"] = 35] = \"InitializePermanentDelegate\";\n    TokenInstruction[TokenInstruction[\"TransferHookExtension\"] = 36] = \"TransferHookExtension\";\n    // ConfidentialTransferFeeExtension = 37,\n    // WithdrawalExcessLamports = 38,\n    TokenInstruction[TokenInstruction[\"MetadataPointerExtension\"] = 39] = \"MetadataPointerExtension\";\n    TokenInstruction[TokenInstruction[\"GroupPointerExtension\"] = 40] = \"GroupPointerExtension\";\n    TokenInstruction[TokenInstruction[\"GroupMemberPointerExtension\"] = 41] = \"GroupMemberPointerExtension\";\n    // ConfidentialMintBurnExtension = 42,\n    TokenInstruction[TokenInstruction[\"ScaledUiAmountExtension\"] = 43] = \"ScaledUiAmountExtension\";\n    TokenInstruction[TokenInstruction[\"PausableExtension\"] = 44] = \"PausableExtension\";\n})(TokenInstruction || (TokenInstruction = {}));\n//# sourceMappingURL=types.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const amountToUiAmountInstructionData = struct([\n    u8('instruction'),\n    u64('amount'),\n]);\n/**\n * Construct a AmountToUiAmount instruction\n *\n * @param mint         Public key of the mint\n * @param amount       Amount of tokens to be converted to UiAmount\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAmountToUiAmountInstruction(mint, amount, programId = TOKEN_PROGRAM_ID) {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];\n    const data = Buffer.alloc(amountToUiAmountInstructionData.span);\n    amountToUiAmountInstructionData.encode({\n        instruction: TokenInstruction.AmountToUiAmount,\n        amount: BigInt(amount),\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a AmountToUiAmount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeAmountToUiAmountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== amountToUiAmountInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint }, data, } = decodeAmountToUiAmountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.AmountToUiAmount)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n/**\n * Decode a AmountToUiAmount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeAmountToUiAmountInstructionUnchecked({ programId, keys: [mint], data, }) {\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: amountToUiAmountInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=amountToUiAmount.js.map","export var AccountType;\n(function (AccountType) {\n    AccountType[AccountType[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    AccountType[AccountType[\"Mint\"] = 1] = \"Mint\";\n    AccountType[AccountType[\"Account\"] = 2] = \"Account\";\n})(AccountType || (AccountType = {}));\nexport const ACCOUNT_TYPE_SIZE = 1;\n//# sourceMappingURL=accountType.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors.js';\n/** Buffer layout for de/serializing a multisig */\nexport const MultisigLayout = struct([\n    u8('m'),\n    u8('n'),\n    bool('isInitialized'),\n    publicKey('signer1'),\n    publicKey('signer2'),\n    publicKey('signer3'),\n    publicKey('signer4'),\n    publicKey('signer5'),\n    publicKey('signer6'),\n    publicKey('signer7'),\n    publicKey('signer8'),\n    publicKey('signer9'),\n    publicKey('signer10'),\n    publicKey('signer11'),\n]);\n/** Byte length of a multisig */\nexport const MULTISIG_SIZE = MultisigLayout.span;\n/**\n * Retrieve information about a multisig\n *\n * @param connection Connection to use\n * @param address    Multisig account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Multisig information\n */\nexport async function getMultisig(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackMultisig(address, info, programId);\n}\n/**\n * Unpack a multisig\n *\n * @param address   Multisig account\n * @param info      Multisig account data\n * @param programId SPL Token program account\n *\n * @return Unpacked multisig\n */\nexport function unpackMultisig(address, info, programId = TOKEN_PROGRAM_ID) {\n    if (!info)\n        throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId))\n        throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != MULTISIG_SIZE)\n        throw new TokenInvalidAccountSizeError();\n    const multisig = MultisigLayout.decode(info.data);\n    return { address, ...multisig };\n}\n/** Get the minimum lamport balance for a multisig to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMultisig(connection, commitment) {\n    return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\n}\n//# sourceMappingURL=multisig.js.map","import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError, } from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport { getAccountLen } from '../extensions/extensionType.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n/** Token account state as stored by the program */\nexport var AccountState;\n(function (AccountState) {\n    AccountState[AccountState[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    AccountState[AccountState[\"Initialized\"] = 1] = \"Initialized\";\n    AccountState[AccountState[\"Frozen\"] = 2] = \"Frozen\";\n})(AccountState || (AccountState = {}));\n/** Buffer layout for de/serializing a token account */\nexport const AccountLayout = struct([\n    publicKey('mint'),\n    publicKey('owner'),\n    u64('amount'),\n    u32('delegateOption'),\n    publicKey('delegate'),\n    u8('state'),\n    u32('isNativeOption'),\n    u64('isNative'),\n    u64('delegatedAmount'),\n    u32('closeAuthorityOption'),\n    publicKey('closeAuthority'),\n]);\n/** Byte length of a token account */\nexport const ACCOUNT_SIZE = AccountLayout.span;\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getAccount(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackAccount(address, info, programId);\n}\n/**\n * Retrieve information about multiple token accounts in a single RPC call\n *\n * @param connection Connection to use\n * @param addresses  Token accounts\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getMultipleAccounts(connection, addresses, commitment, programId = TOKEN_PROGRAM_ID) {\n    const infos = await connection.getMultipleAccountsInfo(addresses, commitment);\n    return addresses.map((address, i) => unpackAccount(address, infos[i], programId));\n}\n/** Get the minimum lamport balance for a base token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccount(connection, commitment) {\n    return await getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);\n}\n/** Get the minimum lamport balance for a rent-exempt token account with extensions\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {\n    const accountLen = getAccountLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(accountLen, commitment);\n}\n/**\n * Unpack a token account\n *\n * @param address   Token account\n * @param info      Token account data\n * @param programId SPL Token program account\n *\n * @return Unpacked token account\n */\nexport function unpackAccount(address, info, programId = TOKEN_PROGRAM_ID) {\n    if (!info)\n        throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId))\n        throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < ACCOUNT_SIZE)\n        throw new TokenInvalidAccountSizeError();\n    const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > ACCOUNT_SIZE) {\n        if (info.data.length === MULTISIG_SIZE)\n            throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Account)\n            throw new TokenInvalidAccountError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n    return {\n        address,\n        mint: rawAccount.mint,\n        owner: rawAccount.owner,\n        amount: rawAccount.amount,\n        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n        delegatedAmount: rawAccount.delegatedAmount,\n        isInitialized: rawAccount.state !== AccountState.Uninitialized,\n        isFrozen: rawAccount.state === AccountState.Frozen,\n        isNative: !!rawAccount.isNativeOption,\n        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n        tlvData,\n    };\n}\n//# sourceMappingURL=account.js.map","import { PublicKey } from '@solana/web3.js';\n/** @internal */\nexport function getSigners(signerOrMultisig, multiSigners) {\n    return signerOrMultisig instanceof PublicKey\n        ? [signerOrMultisig, multiSigners]\n        : [signerOrMultisig.publicKey, [signerOrMultisig]];\n}\n//# sourceMappingURL=internal.js.map","import { PublicKey } from '@solana/web3.js';\n/** @internal */\nexport function addSigners(keys, ownerOrAuthority, multiSigners) {\n    if (multiSigners.length) {\n        keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });\n        for (const signer of multiSigners) {\n            keys.push({\n                pubkey: signer instanceof PublicKey ? signer : signer.publicKey,\n                isSigner: true,\n                isWritable: false,\n            });\n        }\n    }\n    else {\n        keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });\n    }\n    return keys;\n}\n//# sourceMappingURL=internal.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nexport var CpiGuardInstruction;\n(function (CpiGuardInstruction) {\n    CpiGuardInstruction[CpiGuardInstruction[\"Enable\"] = 0] = \"Enable\";\n    CpiGuardInstruction[CpiGuardInstruction[\"Disable\"] = 1] = \"Disable\";\n})(CpiGuardInstruction || (CpiGuardInstruction = {}));\n/** TODO: docs */\nexport const cpiGuardInstructionData = struct([u8('instruction'), u8('cpiGuardInstruction')]);\n/**\n * Construct an EnableCpiGuard instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createEnableCpiGuardInstruction(account, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    return createCpiGuardInstruction(CpiGuardInstruction.Enable, account, authority, multiSigners, programId);\n}\n/**\n * Construct a DisableCpiGuard instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createDisableCpiGuardInstruction(account, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    return createCpiGuardInstruction(CpiGuardInstruction.Disable, account, authority, multiSigners, programId);\n}\nfunction createCpiGuardInstruction(cpiGuardInstruction, account, authority, multiSigners, programId) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(cpiGuardInstructionData.span);\n    cpiGuardInstructionData.encode({\n        instruction: TokenInstruction.CpiGuardExtension,\n        cpiGuardInstruction,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n//# sourceMappingURL=instructions.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createDisableCpiGuardInstruction, createEnableCpiGuardInstruction } from './instructions.js';\n/**\n * Enable CPI Guard on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function enableCpiGuard(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createEnableCpiGuardInstruction(account, ownerPublicKey, signers, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Disable CPI Guard on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function disableCpiGuard(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createDisableCpiGuardInstruction(account, ownerPublicKey, signers, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=actions.js.map","import { struct } from '@solana/buffer-layout';\nimport { bool } from '@solana/buffer-layout-utils';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n/** Buffer layout for de/serializing a CPI Guard extension */\nexport const CpiGuardLayout = struct([bool('lockCpi')]);\nexport const CPI_GUARD_SIZE = CpiGuardLayout.span;\nexport function getCpiGuard(account) {\n    const extensionData = getExtensionData(ExtensionType.CpiGuard, account.tlvData);\n    if (extensionData !== null) {\n        return CpiGuardLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=state.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nexport var DefaultAccountStateInstruction;\n(function (DefaultAccountStateInstruction) {\n    DefaultAccountStateInstruction[DefaultAccountStateInstruction[\"Initialize\"] = 0] = \"Initialize\";\n    DefaultAccountStateInstruction[DefaultAccountStateInstruction[\"Update\"] = 1] = \"Update\";\n})(DefaultAccountStateInstruction || (DefaultAccountStateInstruction = {}));\n/** TODO: docs */\nexport const defaultAccountStateInstructionData = struct([\n    u8('instruction'),\n    u8('defaultAccountStateInstruction'),\n    u8('accountState'),\n]);\n/**\n * Construct an InitializeDefaultAccountState instruction\n *\n * @param mint         Mint to initialize\n * @param accountState Default account state to set on all new accounts\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeDefaultAccountStateInstruction(mint, accountState, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(defaultAccountStateInstructionData.span);\n    defaultAccountStateInstructionData.encode({\n        instruction: TokenInstruction.DefaultAccountStateExtension,\n        defaultAccountStateInstruction: DefaultAccountStateInstruction.Initialize,\n        accountState,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Construct an UpdateDefaultAccountState instruction\n *\n * @param mint         Mint to update\n * @param accountState    Default account state to set on all accounts\n * @param freezeAuthority       The mint's freeze authority\n * @param signers         The signer account(s) for a multisig\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateDefaultAccountStateInstruction(mint, accountState, freezeAuthority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], freezeAuthority, multiSigners);\n    const data = Buffer.alloc(defaultAccountStateInstructionData.span);\n    defaultAccountStateInstructionData.encode({\n        instruction: TokenInstruction.DefaultAccountStateExtension,\n        defaultAccountStateInstruction: DefaultAccountStateInstruction.Update,\n        accountState,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n//# sourceMappingURL=instructions.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createInitializeDefaultAccountStateInstruction, createUpdateDefaultAccountStateInstruction, } from './instructions.js';\n/**\n * Initialize a default account state on a mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint        Mint to initialize with extension\n * @param state        Account state with which to initialize new accounts\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function initializeDefaultAccountState(connection, payer, mint, state, confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const transaction = new Transaction().add(createInitializeDefaultAccountStateInstruction(mint, state, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n/**\n * Update the default account state on a mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint        Mint to modify\n * @param state        New account state to set on created accounts\n * @param freezeAuthority          Freeze authority of the mint\n * @param multiSigners   Signing accounts if `freezeAuthority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateDefaultAccountState(connection, payer, mint, state, freezeAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [freezeAuthorityPublicKey, signers] = getSigners(freezeAuthority, multiSigners);\n    const transaction = new Transaction().add(createUpdateDefaultAccountStateInstruction(mint, state, freezeAuthorityPublicKey, signers, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=actions.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n/** Buffer layout for de/serializing a transfer fee config extension */\nexport const DefaultAccountStateLayout = struct([u8('state')]);\nexport const DEFAULT_ACCOUNT_STATE_SIZE = DefaultAccountStateLayout.span;\nexport function getDefaultAccountState(mint) {\n    const extensionData = getExtensionData(ExtensionType.DefaultAccountState, mint.tlvData);\n    if (extensionData !== null) {\n        return DefaultAccountStateLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=state.js.map","// src/codes.ts\nvar SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nvar SOLANA_ERROR__INVALID_NONCE = 2;\nvar SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nvar SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nvar SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nvar SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nvar SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nvar SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nvar SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nvar SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nvar SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nvar SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nvar SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nvar SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nvar SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;\nvar SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nvar SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nvar SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nvar SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nvar SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nvar SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nvar SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nvar SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nvar SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nvar SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;\nvar SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nvar SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\nvar SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;\nvar SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;\nvar SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nvar SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nvar SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nvar SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nvar SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\nvar SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;\nvar SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nvar SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nvar SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nvar SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nvar SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nvar SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nvar SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nvar SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nvar SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nvar SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nvar SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nvar SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\nvar SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;\nvar SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nvar SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nvar SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nvar SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nvar SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nvar SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nvar SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nvar SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nvar SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nvar SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nvar SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nvar SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nvar SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nvar SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nvar SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nvar SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nvar SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nvar SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nvar SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nvar SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST = 819e4;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED = 8190003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT = 8190004;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING = 99e5;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\n\n// src/context.ts\nfunction encodeValue(value) {\n  if (Array.isArray(value)) {\n    const commaSeparatedValues = value.map(encodeValue).join(\n      \"%2C%20\"\n      /* \", \" */\n    );\n    return \"%5B\" + commaSeparatedValues + /* \"]\" */\n    \"%5D\";\n  } else if (typeof value === \"bigint\") {\n    return `${value}n`;\n  } else {\n    return encodeURIComponent(\n      String(\n        value != null && Object.getPrototypeOf(value) === null ? (\n          // Plain objects with no prototype don't have a `toString` method.\n          // Convert them before stringifying them.\n          { ...value }\n        ) : value\n      )\n    );\n  }\n}\nfunction encodeObjectContextEntry([key, value]) {\n  return `${key}=${encodeValue(value)}`;\n}\nfunction encodeContextObject(context) {\n  const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join(\"&\");\n  return btoa(searchParamsString);\n}\n\n// src/messages.ts\nvar SolanaErrorMessages = {\n  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: \"Account not found at address: $address\",\n  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: \"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.\",\n  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: \"Expected decoded account at address: $address\",\n  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: \"Failed to decode account data at address: $address\",\n  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: \"Accounts not found at addresses: $addresses\",\n  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: \"Unable to find a viable program address bump seed.\",\n  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: \"$putativeAddress is not a base58-encoded address.\",\n  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: \"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.\",\n  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: \"The `CryptoKey` must be an `Ed25519` public key.\",\n  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: \"Invalid seeds; point must fall off the Ed25519 curve.\",\n  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: \"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].\",\n  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: \"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.\",\n  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: \"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.\",\n  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: \"Expected program derived address bump to be in the range [0, 255], got: $bump.\",\n  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: \"Program address cannot end with PDA marker.\",\n  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.\",\n  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.\",\n  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: \"The network has progressed past the last block for which this transaction could have been committed.\",\n  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: \"Codec [$codecDescription] cannot decode empty byte arrays.\",\n  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: \"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.\",\n  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: \"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].\",\n  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: \"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].\",\n  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: \"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].\",\n  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: \"Encoder and decoder must either both be fixed-size or variable-size.\",\n  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: \"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.\",\n  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: \"Expected a fixed-size codec, got a variable-size one.\",\n  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: \"Codec [$codecDescription] expected a positive byte length, got $bytesLength.\",\n  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: \"Expected a variable-size codec, got a fixed-size one.\",\n  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: \"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].\",\n  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: \"Codec [$codecDescription] expected $expected bytes, got $bytesLength.\",\n  [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: \"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].\",\n  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: \"Invalid discriminated union variant. Expected one of [$variants], got $value.\",\n  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: \"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.\",\n  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: \"Invalid literal union variant. Expected one of [$variants], got $value.\",\n  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: \"Expected [$codecDescription] to have $expected items, got $actual.\",\n  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: \"Invalid value $value for base $base with alphabet $alphabet.\",\n  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: \"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.\",\n  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: \"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.\",\n  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: \"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.\",\n  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: \"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].\",\n  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: \"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.\",\n  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: \"No random values implementation could be found.\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: \"instruction requires an uninitialized account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: \"instruction tries to borrow reference for an account which is already borrowed\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"instruction left account with an outstanding borrowed reference\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: \"program other than the account's owner changed the size of the account data\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: \"account data too small for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: \"instruction expected an executable account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: \"An account does not have enough lamports to be rent-exempt\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: \"Program arithmetic overflowed\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: \"Failed to serialize or deserialize account data: $encodedData\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: \"Builtin programs must consume compute units\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: \"Cross-program invocation call depth too deep\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: \"Computational budget exceeded\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: \"custom program error: #$code\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: \"instruction contains duplicate accounts\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: \"instruction modifications of multiply-passed account differ\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: \"executable accounts must be rent exempt\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: \"instruction changed executable accounts data\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: \"instruction changed the balance of an executable account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: \"instruction changed executable bit of an account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: \"instruction modified data of an account it does not own\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: \"instruction spent from the balance of an account it does not own\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: \"generic instruction error\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: \"Provided owner is not allowed\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: \"Account is immutable\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: \"Incorrect authority provided\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: \"incorrect program id for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: \"insufficient funds for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: \"invalid account data for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: \"Invalid account owner\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: \"invalid program argument\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: \"program returned invalid error code\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: \"invalid instruction data\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: \"Failed to reallocate account data\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: \"Provided seeds do not result in a valid address\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: \"Accounts data allocations exceeded the maximum allowed per transaction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: \"Max accounts exceeded\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: \"Max instruction trace length exceeded\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: \"Length of the seed is too long for address generation\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: \"An account required by the instruction is missing\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: \"missing required signature for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: \"instruction illegally modified the program id of an account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: \"insufficient account keys for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: \"Cross-program invocation with unauthorized signer or writable account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: \"Failed to create program execution environment\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: \"Program failed to compile\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: \"Program failed to complete\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: \"instruction modified data of a read-only account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: \"instruction changed the balance of a read-only account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: \"Cross-program invocation reentrancy not allowed for this instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: \"instruction modified rent epoch of an account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: \"sum of account balances before and after instruction do not match\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: \"instruction requires an initialized account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: \"\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: \"Unsupported program id\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: \"Unsupported sysvar\",\n  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: \"The instruction does not have any accounts.\",\n  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: \"The instruction does not have any data.\",\n  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: \"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.\",\n  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: \"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.\",\n  [SOLANA_ERROR__INVALID_NONCE]: \"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: \"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: \"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: \"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING]: \"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: \"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)\",\n  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: \"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)\",\n  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: \"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)\",\n  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: \"JSON-RPC error: The method does not exist / is not available ($__serverMessage)\",\n  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: \"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)\",\n  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: \"Minimum context slot has not been reached\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: \"Node is unhealthy; behind by $numSlotsBehind slots\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: \"No snapshot\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: \"Transaction simulation failed\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: \"Transaction history is not available from this node\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: \"Transaction signature length mismatch\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: \"Transaction signature verification failure\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: \"$__serverMessage\",\n  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: \"Key pair bytes must be of length 64, got $byteLength.\",\n  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: \"Expected private key bytes with length 32. Actual length: $actualLength.\",\n  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: \"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.\",\n  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: \"The provided private key does not match the provided public key.\",\n  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.\",\n  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: \"Lamports value must be in the range [0, 2e64-1]\",\n  [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: \"`$value` cannot be parsed as a `BigInt`\",\n  [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: \"`$value` cannot be parsed as a `Number`\",\n  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: \"No nonce account could be found at address `$nonceAccountAddress`\",\n  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST]: \"Either the notification name must end in 'Notifications' or the API must supply a subscription creator function for the notification '$notificationName' to map between the notification name and the subscribe/unsubscribe method names.\",\n  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: \"Failed to obtain a subscription id from the server\",\n  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED]: \"WebSocket was closed before payload could be added to the send buffer\",\n  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED]: \"WebSocket connection closed\",\n  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT]: \"WebSocket failed to connect\",\n  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: \"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.\",\n  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: \"HTTP error ($statusCode): $message\",\n  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: \"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.\",\n  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: \"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: \"The provided value does not implement the `KeyPairSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: \"The provided value does not implement the `MessageModifyingSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: \"The provided value does not implement the `MessagePartialSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: \"The provided value does not implement any of the `MessageSigner` interfaces\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: \"The provided value does not implement the `TransactionModifyingSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: \"The provided value does not implement the `TransactionPartialSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: \"The provided value does not implement the `TransactionSendingSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: \"The provided value does not implement any of the `TransactionSigner` interfaces\",\n  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: \"More than one `TransactionSendingSigner` was identified.\",\n  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: \"No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.\",\n  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: \"Wallet account signers do not support signing multiple messages/transactions in a single operation\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: \"Cannot export a non-extractable key.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: \"No digest implementation could be found.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: \"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: \"This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\\n\\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: \"No signature verification implementation could be found.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: \"No key generation implementation could be found.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: \"No signing implementation could be found.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: \"No key export implementation could be found.\",\n  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: \"Timestamp value must be in the range [-8.64e15, 8.64e15]. `$value` given\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"Transaction processing left an account with an outstanding borrowed reference\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: \"Account in use\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: \"Account loaded twice\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: \"Attempt to debit an account but found no record of a prior credit.\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: \"Transaction loads an address table account that doesn't exist\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: \"This transaction has already been processed\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: \"Blockhash not found\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: \"Loader call chain is too deep\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: \"Transactions are currently disabled due to cluster maintenance\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: \"Transaction contains a duplicate instruction ($index) that is not allowed\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: \"Insufficient funds for fee\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: \"Transaction results in an account ($accountIndex) with insufficient funds for rent\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: \"This account may not be used to pay transaction fees\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: \"Transaction contains an invalid account reference\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: \"Transaction loads an address table account with invalid data\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: \"Transaction address table lookup uses an invalid index\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: \"Transaction loads an address table account with an invalid owner\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: \"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: \"This program may not be used for executing instructions\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: \"Transaction leaves an account with a lower balance than rent-exempt minimum\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: \"Transaction loads a writable account that cannot be written\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: \"Transaction exceeded max loaded accounts data size cap\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: \"Transaction requires a fee but has no signature present\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: \"Attempt to load a program that does not exist\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: \"Execution of the program referenced by account at index $accountIndex is temporarily restricted.\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: \"ResanitizationNeeded\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: \"Transaction failed to sanitize accounts offsets correctly\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: \"Transaction did not pass signature verification\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: \"Transaction locked too many accounts\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: \"Sum of account balances before and after transaction do not match\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: \"The transaction failed with the error `$errorName`\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: \"Transaction version is unsupported\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: \"Transaction would exceed account data limit within the block\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: \"Transaction would exceed total account data limit\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: \"Transaction would exceed max account limit within the block\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: \"Transaction would exceed max Block Cost Limit\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: \"Transaction would exceed max Vote Cost Limit\",\n  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: \"Attempted to sign a transaction with an address that is not a signer for it\",\n  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: \"Transaction is missing an address at index: $index.\",\n  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: \"Transaction has no expected signers therefore it cannot be encoded\",\n  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: \"Transaction does not have a blockhash lifetime\",\n  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: \"Transaction is not a durable nonce transaction\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: \"Contents of these address lookup tables unknown: $lookupTableAddresses\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: \"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: \"No fee payer set in CompiledTransaction\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: \"Could not find program address at index $index\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: \"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more\",\n  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: \"Transaction is missing a fee payer.\",\n  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: \"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.\",\n  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: \"Transaction first instruction is not advance nonce account instruction.\",\n  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: \"Transaction with no instructions cannot be durable nonce transaction.\",\n  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: \"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees\",\n  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: \"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable\",\n  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: \"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.\",\n  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: \"Transaction is missing signatures for addresses: $addresses.\",\n  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: \"Transaction version must be in the range [0, 127]. `$actualVersion` given\"\n};\n\n// src/message-formatter.ts\nvar START_INDEX = \"i\";\nvar TYPE = \"t\";\nfunction getHumanReadableErrorMessage(code, context = {}) {\n  const messageFormatString = SolanaErrorMessages[code];\n  if (messageFormatString.length === 0) {\n    return \"\";\n  }\n  let state;\n  function commitStateUpTo(endIndex) {\n    if (state[TYPE] === 2 /* Variable */) {\n      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n      fragments.push(\n        variableName in context ? `${context[variableName]}` : `$${variableName}`\n      );\n    } else if (state[TYPE] === 1 /* Text */) {\n      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n    }\n  }\n  const fragments = [];\n  messageFormatString.split(\"\").forEach((char, ii) => {\n    if (ii === 0) {\n      state = {\n        [START_INDEX]: 0,\n        [TYPE]: messageFormatString[0] === \"\\\\\" ? 0 /* EscapeSequence */ : messageFormatString[0] === \"$\" ? 2 /* Variable */ : 1 /* Text */\n      };\n      return;\n    }\n    let nextState;\n    switch (state[TYPE]) {\n      case 0 /* EscapeSequence */:\n        nextState = { [START_INDEX]: ii, [TYPE]: 1 /* Text */ };\n        break;\n      case 1 /* Text */:\n        if (char === \"\\\\\") {\n          nextState = { [START_INDEX]: ii, [TYPE]: 0 /* EscapeSequence */ };\n        } else if (char === \"$\") {\n          nextState = { [START_INDEX]: ii, [TYPE]: 2 /* Variable */ };\n        }\n        break;\n      case 2 /* Variable */:\n        if (char === \"\\\\\") {\n          nextState = { [START_INDEX]: ii, [TYPE]: 0 /* EscapeSequence */ };\n        } else if (char === \"$\") {\n          nextState = { [START_INDEX]: ii, [TYPE]: 2 /* Variable */ };\n        } else if (!char.match(/\\w/)) {\n          nextState = { [START_INDEX]: ii, [TYPE]: 1 /* Text */ };\n        }\n        break;\n    }\n    if (nextState) {\n      if (state !== nextState) {\n        commitStateUpTo(ii);\n      }\n      state = nextState;\n    }\n  });\n  commitStateUpTo();\n  return fragments.join(\"\");\n}\nfunction getErrorMessage(code, context = {}) {\n  if (process.env.NODE_ENV !== \"production\") {\n    return getHumanReadableErrorMessage(code, context);\n  } else {\n    let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n    if (Object.keys(context).length) {\n      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n    }\n    return `${decodingAdviceMessage}\\``;\n  }\n}\n\n// src/error.ts\nfunction isSolanaError(e, code) {\n  const isSolanaError2 = e instanceof Error && e.name === \"SolanaError\";\n  if (isSolanaError2) {\n    if (code !== void 0) {\n      return e.context.__code === code;\n    }\n    return true;\n  }\n  return false;\n}\nvar SolanaError = class extends Error {\n  cause = this.cause;\n  context;\n  constructor(...[code, contextAndErrorOptions]) {\n    let context;\n    let errorOptions;\n    if (contextAndErrorOptions) {\n      const { cause, ...contextRest } = contextAndErrorOptions;\n      if (cause) {\n        errorOptions = { cause };\n      }\n      if (Object.keys(contextRest).length > 0) {\n        context = contextRest;\n      }\n    }\n    const message = getErrorMessage(code, context);\n    super(message, errorOptions);\n    this.context = {\n      __code: code,\n      ...context\n    };\n    this.name = \"SolanaError\";\n  }\n};\n\n// src/stack-trace.ts\nfunction safeCaptureStackTrace(...args) {\n  if (\"captureStackTrace\" in Error && typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(...args);\n  }\n}\n\n// src/rpc-enum-errors.ts\nfunction getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {\n  let rpcErrorName;\n  let rpcErrorContext;\n  if (typeof rpcEnumError === \"string\") {\n    rpcErrorName = rpcEnumError;\n  } else {\n    rpcErrorName = Object.keys(rpcEnumError)[0];\n    rpcErrorContext = rpcEnumError[rpcErrorName];\n  }\n  const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n  const errorCode = errorCodeBaseOffset + codeOffset;\n  const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n  const err = new SolanaError(errorCode, errorContext);\n  safeCaptureStackTrace(err, constructorOpt);\n  return err;\n}\n\n// src/instruction-error.ts\nvar ORDERED_ERROR_NAMES = [\n  // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n  // If this list ever gets too large, consider implementing a compression strategy like this:\n  // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n  \"GenericError\",\n  \"InvalidArgument\",\n  \"InvalidInstructionData\",\n  \"InvalidAccountData\",\n  \"AccountDataTooSmall\",\n  \"InsufficientFunds\",\n  \"IncorrectProgramId\",\n  \"MissingRequiredSignature\",\n  \"AccountAlreadyInitialized\",\n  \"UninitializedAccount\",\n  \"UnbalancedInstruction\",\n  \"ModifiedProgramId\",\n  \"ExternalAccountLamportSpend\",\n  \"ExternalAccountDataModified\",\n  \"ReadonlyLamportChange\",\n  \"ReadonlyDataModified\",\n  \"DuplicateAccountIndex\",\n  \"ExecutableModified\",\n  \"RentEpochModified\",\n  \"NotEnoughAccountKeys\",\n  \"AccountDataSizeChanged\",\n  \"AccountNotExecutable\",\n  \"AccountBorrowFailed\",\n  \"AccountBorrowOutstanding\",\n  \"DuplicateAccountOutOfSync\",\n  \"Custom\",\n  \"InvalidError\",\n  \"ExecutableDataModified\",\n  \"ExecutableLamportChange\",\n  \"ExecutableAccountNotRentExempt\",\n  \"UnsupportedProgramId\",\n  \"CallDepth\",\n  \"MissingAccount\",\n  \"ReentrancyNotAllowed\",\n  \"MaxSeedLengthExceeded\",\n  \"InvalidSeeds\",\n  \"InvalidRealloc\",\n  \"ComputationalBudgetExceeded\",\n  \"PrivilegeEscalation\",\n  \"ProgramEnvironmentSetupFailure\",\n  \"ProgramFailedToComplete\",\n  \"ProgramFailedToCompile\",\n  \"Immutable\",\n  \"IncorrectAuthority\",\n  \"BorshIoError\",\n  \"AccountNotRentExempt\",\n  \"InvalidAccountOwner\",\n  \"ArithmeticOverflow\",\n  \"UnsupportedSysvar\",\n  \"IllegalOwner\",\n  \"MaxAccountsDataAllocationsExceeded\",\n  \"MaxAccountsExceeded\",\n  \"MaxInstructionTraceLengthExceeded\",\n  \"BuiltinProgramsMustConsumeComputeUnits\"\n];\nfunction getSolanaErrorFromInstructionError(index, instructionError) {\n  return getSolanaErrorFromRpcError(\n    {\n      errorCodeBaseOffset: 4615001,\n      getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n        if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n          return {\n            errorName: rpcErrorName,\n            index,\n            ...rpcErrorContext !== void 0 ? { instructionErrorContext: rpcErrorContext } : null\n          };\n        } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n          return {\n            code: rpcErrorContext,\n            index\n          };\n        } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n          return {\n            encodedData: rpcErrorContext,\n            index\n          };\n        }\n        return { index };\n      },\n      orderedErrorNames: ORDERED_ERROR_NAMES,\n      rpcEnumError: instructionError\n    },\n    getSolanaErrorFromInstructionError\n  );\n}\n\n// src/transaction-error.ts\nvar ORDERED_ERROR_NAMES2 = [\n  // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n  // If this list ever gets too large, consider implementing a compression strategy like this:\n  // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n  \"AccountInUse\",\n  \"AccountLoadedTwice\",\n  \"AccountNotFound\",\n  \"ProgramAccountNotFound\",\n  \"InsufficientFundsForFee\",\n  \"InvalidAccountForFee\",\n  \"AlreadyProcessed\",\n  \"BlockhashNotFound\",\n  // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n  \"CallChainTooDeep\",\n  \"MissingSignatureForFee\",\n  \"InvalidAccountIndex\",\n  \"SignatureFailure\",\n  \"InvalidProgramForExecution\",\n  \"SanitizeFailure\",\n  \"ClusterMaintenance\",\n  \"AccountBorrowOutstanding\",\n  \"WouldExceedMaxBlockCostLimit\",\n  \"UnsupportedVersion\",\n  \"InvalidWritableAccount\",\n  \"WouldExceedMaxAccountCostLimit\",\n  \"WouldExceedAccountDataBlockLimit\",\n  \"TooManyAccountLocks\",\n  \"AddressLookupTableNotFound\",\n  \"InvalidAddressLookupTableOwner\",\n  \"InvalidAddressLookupTableData\",\n  \"InvalidAddressLookupTableIndex\",\n  \"InvalidRentPayingAccount\",\n  \"WouldExceedMaxVoteCostLimit\",\n  \"WouldExceedAccountDataTotalLimit\",\n  \"DuplicateInstruction\",\n  \"InsufficientFundsForRent\",\n  \"MaxLoadedAccountsDataSizeExceeded\",\n  \"InvalidLoadedAccountsDataSizeLimit\",\n  \"ResanitizationNeeded\",\n  \"ProgramExecutionTemporarilyRestricted\",\n  \"UnbalancedTransaction\"\n];\nfunction getSolanaErrorFromTransactionError(transactionError) {\n  if (typeof transactionError === \"object\" && \"InstructionError\" in transactionError) {\n    return getSolanaErrorFromInstructionError(\n      ...transactionError.InstructionError\n    );\n  }\n  return getSolanaErrorFromRpcError(\n    {\n      errorCodeBaseOffset: 7050001,\n      getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n        if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n          return {\n            errorName: rpcErrorName,\n            ...rpcErrorContext !== void 0 ? { transactionErrorContext: rpcErrorContext } : null\n          };\n        } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n          return {\n            index: rpcErrorContext\n          };\n        } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {\n          return {\n            accountIndex: rpcErrorContext.account_index\n          };\n        }\n      },\n      orderedErrorNames: ORDERED_ERROR_NAMES2,\n      rpcEnumError: transactionError\n    },\n    getSolanaErrorFromTransactionError\n  );\n}\n\n// src/json-rpc-error.ts\nfunction getSolanaErrorFromJsonRpcError({ code, data, message }) {\n  let out;\n  if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n    const { err, ...preflightErrorContext } = data;\n    const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n    out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n      ...preflightErrorContext,\n      ...causeObject\n    });\n  } else {\n    let errorContext;\n    switch (code) {\n      case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n      case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n      case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n      case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n      case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n      case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n      case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n      case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n      case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n      case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n      case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n      case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n      case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n      case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n        errorContext = { __serverMessage: message };\n        break;\n      default:\n        if (typeof data === \"object\" && !Array.isArray(data)) {\n          errorContext = data;\n        }\n    }\n    out = new SolanaError(code, errorContext);\n  }\n  safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n  return out;\n}\n\nexport { SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED, SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE, SOLANA_ERROR__ADDRESSES__MALFORMED_PDA, SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__INVALID_CONSTANT, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT, SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW, SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS, SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH, SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER, SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE, SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS, SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE, SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED, SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION, SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, SOLANA_ERROR__INVALID_NONCE, SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING, SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE, SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING, SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR, SOLANA_ERROR__JSON_RPC__INVALID_PARAMS, SOLANA_ERROR__JSON_RPC__INVALID_REQUEST, SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND, SOLANA_ERROR__JSON_RPC__PARSE_ERROR, SOLANA_ERROR__JSON_RPC__SCAN_ERROR, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION, SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY, SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SOLANA_ERROR__MALFORMED_BIGINT_STRING, SOLANA_ERROR__MALFORMED_NUMBER_STRING, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST, SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID, SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED, SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED, SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS, SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT, SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP, SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE, SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT, SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED, SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED, SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED, SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE, SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE, SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS, SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT, SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING, SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT, SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError, getSolanaErrorFromInstructionError, getSolanaErrorFromJsonRpcError, getSolanaErrorFromTransactionError, isSolanaError, safeCaptureStackTrace };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { SolanaError, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES } from '@solana/errors';\n\n// src/add-codec-sentinel.ts\n\n// src/bytes.ts\nvar mergeBytes = (byteArrays) => {\n  const nonEmptyByteArrays = byteArrays.filter((arr) => arr.length);\n  if (nonEmptyByteArrays.length === 0) {\n    return byteArrays.length ? byteArrays[0] : new Uint8Array();\n  }\n  if (nonEmptyByteArrays.length === 1) {\n    return nonEmptyByteArrays[0];\n  }\n  const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  nonEmptyByteArrays.forEach((arr) => {\n    result.set(arr, offset);\n    offset += arr.length;\n  });\n  return result;\n};\nvar padBytes = (bytes, length) => {\n  if (bytes.length >= length) return bytes;\n  const paddedBytes = new Uint8Array(length).fill(0);\n  paddedBytes.set(bytes);\n  return paddedBytes;\n};\nvar fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n  const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n  if (slice.length !== bytes.length) return false;\n  return bytes.every((b, i) => b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n  return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n  return Object.freeze({\n    ...encoder,\n    encode: (value) => {\n      const bytes = new Uint8Array(getEncodedSize(value, encoder));\n      encoder.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction createDecoder(decoder) {\n  return Object.freeze({\n    ...decoder,\n    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]\n  });\n}\nfunction createCodec(codec) {\n  return Object.freeze({\n    ...codec,\n    decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n    encode: (value) => {\n      const bytes = new Uint8Array(getEncodedSize(value, codec));\n      codec.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction isFixedSize(codec) {\n  return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n  if (!isFixedSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n  }\n}\nfunction isVariableSize(codec) {\n  return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n  if (!isVariableSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n  }\n}\nfunction combineCodec(encoder, decoder) {\n  if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n  }\n  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n      decoderFixedSize: decoder.fixedSize,\n      encoderFixedSize: encoder.fixedSize\n    });\n  }\n  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n      decoderMaxSize: decoder.maxSize,\n      encoderMaxSize: encoder.maxSize\n    });\n  }\n  return {\n    ...decoder,\n    ...encoder,\n    decode: decoder.decode,\n    encode: encoder.encode,\n    read: decoder.read,\n    write: encoder.write\n  };\n}\n\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n        encodedBytes: encoderBytes,\n        hexEncodedBytes: hexBytes(encoderBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    bytes.set(encoderBytes, offset);\n    offset += encoderBytes.length;\n    bytes.set(sentinel, offset);\n    offset += sentinel.length;\n    return offset;\n  };\n  if (isFixedSize(encoder)) {\n    return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n  }\n  return createEncoder({\n    ...encoder,\n    ...encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {},\n    getSizeFromValue: (value) => encoder.getSizeFromValue(value) + sentinel.length,\n    write\n  });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n  const read = (bytes, offset) => {\n    const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n    const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n    if (sentinelIndex === -1) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n        decodedBytes: candidateBytes,\n        hexDecodedBytes: hexBytes(candidateBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n    return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n  };\n  if (isFixedSize(decoder)) {\n    return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n  }\n  return createDecoder({\n    ...decoder,\n    ...decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {},\n    read\n  });\n}\nfunction addCodecSentinel(codec, sentinel) {\n  return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n  return bytes.findIndex((byte, index, arr) => {\n    if (sentinel.length === 1) return byte === sentinel[0];\n    return containsBytes(arr, sentinel, index);\n  });\n}\nfunction hexBytes(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n  if (bytes.length - offset <= 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n      codecDescription\n    });\n  }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n  const bytesLength = bytes.length - offset;\n  if (bytesLength < expected) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n      bytesLength,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n  if (offset < 0 || offset > bytesLength) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n      bytesLength,\n      codecDescription,\n      offset\n    });\n  }\n}\n\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    offset = prefix.write(encoderBytes.length, bytes, offset);\n    bytes.set(encoderBytes, offset);\n    return offset + encoderBytes.length;\n  };\n  if (isFixedSize(prefix) && isFixedSize(encoder)) {\n    return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n  return createEncoder({\n    ...encoder,\n    ...maxSize !== null ? { maxSize } : {},\n    getSizeFromValue: (value) => {\n      const encoderSize = getEncodedSize(value, encoder);\n      return getEncodedSize(encoderSize, prefix) + encoderSize;\n    },\n    write\n  });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n  const read = (bytes, offset) => {\n    const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n    const size = Number(bigintSize);\n    offset = decoderOffset;\n    if (offset > 0 || bytes.length > size) {\n      bytes = bytes.slice(offset, offset + size);\n    }\n    assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n    return [decoder.decode(bytes), offset + size];\n  };\n  if (isFixedSize(prefix) && isFixedSize(decoder)) {\n    return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n  return createDecoder({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n  return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n  return createEncoder({\n    fixedSize: fixedBytes,\n    write: (value, bytes, offset) => {\n      const variableByteArray = encoder.encode(value);\n      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n      bytes.set(fixedByteArray, offset);\n      return offset + fixedBytes;\n    }\n  });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n  return createDecoder({\n    fixedSize: fixedBytes,\n    read: (bytes, offset) => {\n      assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n      if (offset > 0 || bytes.length > fixedBytes) {\n        bytes = bytes.slice(offset, offset + fixedBytes);\n      }\n      if (isFixedSize(decoder)) {\n        bytes = fixBytes(bytes, decoder.fixedSize);\n      }\n      const [value] = decoder.read(bytes, 0);\n      return [value, offset + fixedBytes];\n    }\n  });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n  return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, preOffset) => {\n      const wrapBytes = (offset) => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n      const postOffset = encoder.write(value, bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n      return newPostOffset;\n    }\n  });\n}\nfunction offsetDecoder(decoder, config) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, preOffset) => {\n      const wrapBytes = (offset) => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n      const [value, postOffset] = decoder.read(bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n      return [value, newPostOffset];\n    }\n  });\n}\nfunction offsetCodec(codec, config) {\n  return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n  if (divisor === 0) return 0;\n  return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n  if (isFixedSize(encoder)) {\n    const fixedSize = resize(encoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeEncoder\"\n      });\n    }\n    return createEncoder({ ...encoder, fixedSize });\n  }\n  return createEncoder({\n    ...encoder,\n    getSizeFromValue: (value) => {\n      const newSize = resize(encoder.getSizeFromValue(value));\n      if (newSize < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n          bytesLength: newSize,\n          codecDescription: \"resizeEncoder\"\n        });\n      }\n      return newSize;\n    }\n  });\n}\nfunction resizeDecoder(decoder, resize) {\n  if (isFixedSize(decoder)) {\n    const fixedSize = resize(decoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeDecoder\"\n      });\n    }\n    return createDecoder({ ...decoder, fixedSize });\n  }\n  return decoder;\n}\nfunction resizeCodec(codec, resize) {\n  return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n  return offsetEncoder(\n    resizeEncoder(encoder, (size) => size + offset),\n    { preOffset: ({ preOffset }) => preOffset + offset }\n  );\n}\nfunction padRightEncoder(encoder, offset) {\n  return offsetEncoder(\n    resizeEncoder(encoder, (size) => size + offset),\n    { postOffset: ({ postOffset }) => postOffset + offset }\n  );\n}\nfunction padLeftDecoder(decoder, offset) {\n  return offsetDecoder(\n    resizeDecoder(decoder, (size) => size + offset),\n    { preOffset: ({ preOffset }) => preOffset + offset }\n  );\n}\nfunction padRightDecoder(decoder, offset) {\n  return offsetDecoder(\n    resizeDecoder(decoder, (size) => size + offset),\n    { postOffset: ({ postOffset }) => postOffset + offset }\n  );\n}\nfunction padLeftCodec(codec, offset) {\n  return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n  return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n  while (sourceOffset < --sourceLength) {\n    const leftValue = source[sourceOffset];\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n    target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n    sourceOffset++;\n  }\n  if (sourceOffset === sourceLength) {\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n  }\n}\nfunction reverseEncoder(encoder) {\n  assertIsFixedSize(encoder);\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, offset) => {\n      const newOffset = encoder.write(value, bytes, offset);\n      copySourceToTargetInReverse(\n        bytes,\n        bytes,\n        offset,\n        offset + encoder.fixedSize\n      );\n      return newOffset;\n    }\n  });\n}\nfunction reverseDecoder(decoder) {\n  assertIsFixedSize(decoder);\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const reversedBytes = bytes.slice();\n      copySourceToTargetInReverse(\n        bytes,\n        reversedBytes,\n        offset,\n        offset + decoder.fixedSize\n      );\n      return decoder.read(reversedBytes, offset);\n    }\n  });\n}\nfunction reverseCodec(codec) {\n  return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n  return createEncoder({\n    ...isVariableSize(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,\n    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)\n  });\n}\nfunction transformDecoder(decoder, map) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const [value, newOffset] = decoder.read(bytes, offset);\n      return [map(value, bytes, offset), newOffset];\n    }\n  });\n}\nfunction transformCodec(codec, unmap, map) {\n  return createCodec({\n    ...transformEncoder(codec, unmap),\n    read: map ? transformDecoder(codec, map).read : codec.read\n  });\n}\n\nexport { addCodecSentinel, addCodecSizePrefix, addDecoderSentinel, addDecoderSizePrefix, addEncoderSentinel, addEncoderSizePrefix, assertByteArrayHasEnoughBytesForCodec, assertByteArrayIsNotEmptyForCodec, assertByteArrayOffsetIsNotOutOfRange, assertIsFixedSize, assertIsVariableSize, combineCodec, containsBytes, createCodec, createDecoder, createEncoder, fixBytes, fixCodecSize, fixDecoderSize, fixEncoderSize, getEncodedSize, isFixedSize, isVariableSize, mergeBytes, offsetCodec, offsetDecoder, offsetEncoder, padBytes, padLeftCodec, padLeftDecoder, padLeftEncoder, padRightCodec, padRightDecoder, padRightEncoder, resizeCodec, resizeDecoder, resizeEncoder, reverseCodec, reverseDecoder, reverseEncoder, transformCodec, transformDecoder, transformEncoder };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { SolanaError, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE } from '@solana/errors';\nimport { combineCodec, createEncoder, createDecoder, assertByteArrayIsNotEmptyForCodec, assertByteArrayHasEnoughBytesForCodec } from '@solana/codecs-core';\n\n// src/assertions.ts\nfunction assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n  if (value < min || value > max) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n      codecDescription,\n      max,\n      min,\n      value\n    });\n  }\n}\n\n// src/common.ts\nvar Endian = /* @__PURE__ */ ((Endian2) => {\n  Endian2[Endian2[\"Little\"] = 0] = \"Little\";\n  Endian2[Endian2[\"Big\"] = 1] = \"Big\";\n  return Endian2;\n})(Endian || {});\nfunction isLittleEndian(config) {\n  return config?.endian === 1 /* Big */ ? false : true;\n}\nfunction numberEncoderFactory(input) {\n  return createEncoder({\n    fixedSize: input.size,\n    write(value, bytes, offset) {\n      if (input.range) {\n        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n      }\n      const arrayBuffer = new ArrayBuffer(input.size);\n      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n      bytes.set(new Uint8Array(arrayBuffer), offset);\n      return offset + input.size;\n    }\n  });\n}\nfunction numberDecoderFactory(input) {\n  return createDecoder({\n    fixedSize: input.size,\n    read(bytes, offset = 0) {\n      assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n      const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n      return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n    }\n  });\n}\nfunction toArrayBuffer(bytes, offset, length) {\n  const bytesOffset = bytes.byteOffset + (offset ?? 0);\n  const bytesLength = length ?? bytes.byteLength;\n  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n\n// src/f32.ts\nvar getF32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"f32\",\n  set: (view, value, le) => view.setFloat32(0, Number(value), le),\n  size: 4\n});\nvar getF32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getFloat32(0, le),\n  name: \"f32\",\n  size: 4\n});\nvar getF32Codec = (config = {}) => combineCodec(getF32Encoder(config), getF32Decoder(config));\nvar getF64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"f64\",\n  set: (view, value, le) => view.setFloat64(0, Number(value), le),\n  size: 8\n});\nvar getF64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getFloat64(0, le),\n  name: \"f64\",\n  size: 8\n});\nvar getF64Codec = (config = {}) => combineCodec(getF64Encoder(config), getF64Decoder(config));\nvar getI128Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i128\",\n  range: [-BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n, BigInt(\"0x7fffffffffffffffffffffffffffffff\")],\n  set: (view, value, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const rightMask = 0xffffffffffffffffn;\n    view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n  },\n  size: 16\n});\nvar getI128Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const left = view.getBigInt64(leftOffset, le);\n    const right = view.getBigUint64(rightOffset, le);\n    return (left << 64n) + right;\n  },\n  name: \"i128\",\n  size: 16\n});\nvar getI128Codec = (config = {}) => combineCodec(getI128Encoder(config), getI128Decoder(config));\nvar getI16Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i16\",\n  range: [-Number(\"0x7fff\") - 1, Number(\"0x7fff\")],\n  set: (view, value, le) => view.setInt16(0, Number(value), le),\n  size: 2\n});\nvar getI16Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getInt16(0, le),\n  name: \"i16\",\n  size: 2\n});\nvar getI16Codec = (config = {}) => combineCodec(getI16Encoder(config), getI16Decoder(config));\nvar getI32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i32\",\n  range: [-Number(\"0x7fffffff\") - 1, Number(\"0x7fffffff\")],\n  set: (view, value, le) => view.setInt32(0, Number(value), le),\n  size: 4\n});\nvar getI32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getInt32(0, le),\n  name: \"i32\",\n  size: 4\n});\nvar getI32Codec = (config = {}) => combineCodec(getI32Encoder(config), getI32Decoder(config));\nvar getI64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i64\",\n  range: [-BigInt(\"0x7fffffffffffffff\") - 1n, BigInt(\"0x7fffffffffffffff\")],\n  set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n  size: 8\n});\nvar getI64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getBigInt64(0, le),\n  name: \"i64\",\n  size: 8\n});\nvar getI64Codec = (config = {}) => combineCodec(getI64Encoder(config), getI64Decoder(config));\nvar getI8Encoder = () => numberEncoderFactory({\n  name: \"i8\",\n  range: [-Number(\"0x7f\") - 1, Number(\"0x7f\")],\n  set: (view, value) => view.setInt8(0, Number(value)),\n  size: 1\n});\nvar getI8Decoder = () => numberDecoderFactory({\n  get: (view) => view.getInt8(0),\n  name: \"i8\",\n  size: 1\n});\nvar getI8Codec = () => combineCodec(getI8Encoder(), getI8Decoder());\nvar getShortU16Encoder = () => createEncoder({\n  getSizeFromValue: (value) => {\n    if (value <= 127) return 1;\n    if (value <= 16383) return 2;\n    return 3;\n  },\n  maxSize: 3,\n  write: (value, bytes, offset) => {\n    assertNumberIsBetweenForCodec(\"shortU16\", 0, 65535, value);\n    const shortU16Bytes = [0];\n    for (let ii = 0; ; ii += 1) {\n      const alignedValue = Number(value) >> ii * 7;\n      if (alignedValue === 0) {\n        break;\n      }\n      const nextSevenBits = 127 & alignedValue;\n      shortU16Bytes[ii] = nextSevenBits;\n      if (ii > 0) {\n        shortU16Bytes[ii - 1] |= 128;\n      }\n    }\n    bytes.set(shortU16Bytes, offset);\n    return offset + shortU16Bytes.length;\n  }\n});\nvar getShortU16Decoder = () => createDecoder({\n  maxSize: 3,\n  read: (bytes, offset) => {\n    let value = 0;\n    let byteCount = 0;\n    while (++byteCount) {\n      const byteIndex = byteCount - 1;\n      const currentByte = bytes[offset + byteIndex];\n      const nextSevenBits = 127 & currentByte;\n      value |= nextSevenBits << byteIndex * 7;\n      if ((currentByte & 128) === 0) {\n        break;\n      }\n    }\n    return [value, offset + byteCount];\n  }\n});\nvar getShortU16Codec = () => combineCodec(getShortU16Encoder(), getShortU16Decoder());\nvar getU128Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u128\",\n  range: [0n, BigInt(\"0xffffffffffffffffffffffffffffffff\")],\n  set: (view, value, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const rightMask = 0xffffffffffffffffn;\n    view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n  },\n  size: 16\n});\nvar getU128Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const left = view.getBigUint64(leftOffset, le);\n    const right = view.getBigUint64(rightOffset, le);\n    return (left << 64n) + right;\n  },\n  name: \"u128\",\n  size: 16\n});\nvar getU128Codec = (config = {}) => combineCodec(getU128Encoder(config), getU128Decoder(config));\nvar getU16Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u16\",\n  range: [0, Number(\"0xffff\")],\n  set: (view, value, le) => view.setUint16(0, Number(value), le),\n  size: 2\n});\nvar getU16Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getUint16(0, le),\n  name: \"u16\",\n  size: 2\n});\nvar getU16Codec = (config = {}) => combineCodec(getU16Encoder(config), getU16Decoder(config));\nvar getU32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u32\",\n  range: [0, Number(\"0xffffffff\")],\n  set: (view, value, le) => view.setUint32(0, Number(value), le),\n  size: 4\n});\nvar getU32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getUint32(0, le),\n  name: \"u32\",\n  size: 4\n});\nvar getU32Codec = (config = {}) => combineCodec(getU32Encoder(config), getU32Decoder(config));\nvar getU64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u64\",\n  range: [0n, BigInt(\"0xffffffffffffffff\")],\n  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n  size: 8\n});\nvar getU64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getBigUint64(0, le),\n  name: \"u64\",\n  size: 8\n});\nvar getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));\nvar getU8Encoder = () => numberEncoderFactory({\n  name: \"u8\",\n  range: [0, Number(\"0xff\")],\n  set: (view, value) => view.setUint8(0, Number(value)),\n  size: 1\n});\nvar getU8Decoder = () => numberDecoderFactory({\n  get: (view) => view.getUint8(0),\n  name: \"u8\",\n  size: 1\n});\nvar getU8Codec = () => combineCodec(getU8Encoder(), getU8Decoder());\n\nexport { Endian, assertNumberIsBetweenForCodec, getF32Codec, getF32Decoder, getF32Encoder, getF64Codec, getF64Decoder, getF64Encoder, getI128Codec, getI128Decoder, getI128Encoder, getI16Codec, getI16Decoder, getI16Encoder, getI32Codec, getI32Decoder, getI32Encoder, getI64Codec, getI64Decoder, getI64Encoder, getI8Codec, getI8Decoder, getI8Encoder, getShortU16Codec, getShortU16Decoder, getShortU16Encoder, getU128Codec, getU128Decoder, getU128Encoder, getU16Codec, getU16Decoder, getU16Encoder, getU32Codec, getU32Decoder, getU32Encoder, getU64Codec, getU64Decoder, getU64Encoder, getU8Codec, getU8Decoder, getU8Encoder };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { createEncoder, getEncodedSize, createDecoder, combineCodec, assertByteArrayHasEnoughBytesForCodec, transformEncoder, transformDecoder, containsBytes, isFixedSize, assertIsFixedSize, fixEncoderSize, fixDecoderSize } from '@solana/codecs-core';\nimport { getU32Encoder, getU32Decoder, getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SolanaError, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SOLANA_ERROR__CODECS__INVALID_CONSTANT, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE } from '@solana/errors';\n\n// src/array.ts\nfunction assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {\n  if (expected !== actual) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n      actual,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction maxCodecSizes(sizes) {\n  return sizes.reduce(\n    (all, size) => all === null || size === null ? null : Math.max(all, size),\n    0\n  );\n}\nfunction sumCodecSizes(sizes) {\n  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);\n}\nfunction getFixedSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : null;\n}\nfunction getMaxSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n\n// src/array.ts\nfunction getArrayEncoder(item, config = {}) {\n  const size = config.size ?? getU32Encoder();\n  const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n  return createEncoder({\n    ...fixedSize !== null ? { fixedSize } : {\n      getSizeFromValue: (array) => {\n        const prefixSize = typeof size === \"object\" ? getEncodedSize(array.length, size) : 0;\n        return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n      },\n      maxSize\n    },\n    write: (array, bytes, offset) => {\n      if (typeof size === \"number\") {\n        assertValidNumberOfItemsForCodec(\"array\", size, array.length);\n      }\n      if (typeof size === \"object\") {\n        offset = size.write(array.length, bytes, offset);\n      }\n      array.forEach((value) => {\n        offset = item.write(value, bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getArrayDecoder(item, config = {}) {\n  const size = config.size ?? getU32Decoder();\n  const itemSize = getFixedSize(item);\n  const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n  return createDecoder({\n    ...fixedSize !== null ? { fixedSize } : { maxSize },\n    read: (bytes, offset) => {\n      const array = [];\n      if (typeof size === \"object\" && bytes.slice(offset).length === 0) {\n        return [array, offset];\n      }\n      if (size === \"remainder\") {\n        while (offset < bytes.length) {\n          const [value, newOffset2] = item.read(bytes, offset);\n          offset = newOffset2;\n          array.push(value);\n        }\n        return [array, offset];\n      }\n      const [resolvedSize, newOffset] = typeof size === \"number\" ? [size, offset] : size.read(bytes, offset);\n      offset = newOffset;\n      for (let i = 0; i < resolvedSize; i += 1) {\n        const [value, newOffset2] = item.read(bytes, offset);\n        offset = newOffset2;\n        array.push(value);\n      }\n      return [array, offset];\n    }\n  });\n}\nfunction getArrayCodec(item, config = {}) {\n  return combineCodec(getArrayEncoder(item, config), getArrayDecoder(item, config));\n}\nfunction computeArrayLikeCodecSize(size, itemSize) {\n  if (typeof size !== \"number\") return null;\n  if (size === 0) return 0;\n  return itemSize === null ? null : itemSize * size;\n}\nfunction getBitArrayEncoder(size, config = {}) {\n  const parsedConfig = typeof config === \"boolean\" ? { backward: config } : config;\n  const backward = parsedConfig.backward ?? false;\n  return createEncoder({\n    fixedSize: size,\n    write(value, bytes, offset) {\n      const bytesToAdd = [];\n      for (let i = 0; i < size; i += 1) {\n        let byte = 0;\n        for (let j = 0; j < 8; j += 1) {\n          const feature = Number(value[i * 8 + j] ?? 0);\n          byte |= feature << (backward ? j : 7 - j);\n        }\n        if (backward) {\n          bytesToAdd.unshift(byte);\n        } else {\n          bytesToAdd.push(byte);\n        }\n      }\n      bytes.set(bytesToAdd, offset);\n      return size;\n    }\n  });\n}\nfunction getBitArrayDecoder(size, config = {}) {\n  const parsedConfig = typeof config === \"boolean\" ? { backward: config } : config;\n  const backward = parsedConfig.backward ?? false;\n  return createDecoder({\n    fixedSize: size,\n    read(bytes, offset) {\n      assertByteArrayHasEnoughBytesForCodec(\"bitArray\", size, bytes, offset);\n      const booleans = [];\n      let slice = bytes.slice(offset, offset + size);\n      slice = backward ? slice.reverse() : slice;\n      slice.forEach((byte) => {\n        for (let i = 0; i < 8; i += 1) {\n          if (backward) {\n            booleans.push(Boolean(byte & 1));\n            byte >>= 1;\n          } else {\n            booleans.push(Boolean(byte & 128));\n            byte <<= 1;\n          }\n        }\n      });\n      return [booleans, offset + size];\n    }\n  });\n}\nfunction getBitArrayCodec(size, config = {}) {\n  return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\nfunction getBooleanEncoder(config = {}) {\n  return transformEncoder(config.size ?? getU8Encoder(), (value) => value ? 1 : 0);\n}\nfunction getBooleanDecoder(config = {}) {\n  return transformDecoder(config.size ?? getU8Decoder(), (value) => Number(value) === 1);\n}\nfunction getBooleanCodec(config = {}) {\n  return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\nfunction getBytesEncoder() {\n  return createEncoder({\n    getSizeFromValue: (value) => value.length,\n    write: (value, bytes, offset) => {\n      bytes.set(value, offset);\n      return offset + value.length;\n    }\n  });\n}\nfunction getBytesDecoder() {\n  return createDecoder({\n    read: (bytes, offset) => {\n      const slice = bytes.slice(offset);\n      return [slice, offset + slice.length];\n    }\n  });\n}\nfunction getBytesCodec() {\n  return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\nvar getBase16Decoder = () => createDecoder({\n  read(bytes, offset) {\n    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n    return [value, bytes.length];\n  }\n});\nfunction getConstantEncoder(constant) {\n  return createEncoder({\n    fixedSize: constant.length,\n    write: (_, bytes, offset) => {\n      bytes.set(constant, offset);\n      return offset + constant.length;\n    }\n  });\n}\nfunction getConstantDecoder(constant) {\n  return createDecoder({\n    fixedSize: constant.length,\n    read: (bytes, offset) => {\n      const base16 = getBase16Decoder();\n      if (!containsBytes(bytes, constant, offset)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n          constant,\n          data: bytes,\n          hexConstant: base16.decode(constant),\n          hexData: base16.decode(bytes),\n          offset\n        });\n      }\n      return [void 0, offset + constant.length];\n    }\n  });\n}\nfunction getConstantCodec(constant) {\n  return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\nfunction getTupleEncoder(items) {\n  const fixedSize = sumCodecSizes(items.map(getFixedSize));\n  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n  return createEncoder({\n    ...fixedSize === null ? {\n      getSizeFromValue: (value) => items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n      maxSize\n    } : { fixedSize },\n    write: (value, bytes, offset) => {\n      assertValidNumberOfItemsForCodec(\"tuple\", items.length, value.length);\n      items.forEach((item, index) => {\n        offset = item.write(value[index], bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getTupleDecoder(items) {\n  const fixedSize = sumCodecSizes(items.map(getFixedSize));\n  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n  return createDecoder({\n    ...fixedSize === null ? { maxSize } : { fixedSize },\n    read: (bytes, offset) => {\n      const values = [];\n      items.forEach((item) => {\n        const [newValue, newOffset] = item.read(bytes, offset);\n        values.push(newValue);\n        offset = newOffset;\n      });\n      return [values, offset];\n    }\n  });\n}\nfunction getTupleCodec(items) {\n  return combineCodec(\n    getTupleEncoder(items),\n    getTupleDecoder(items)\n  );\n}\nfunction getUnionEncoder(variants, getIndexFromValue) {\n  const fixedSize = getUnionFixedSize(variants);\n  const write = (variant, bytes, offset) => {\n    const index = getIndexFromValue(variant);\n    assertValidVariantIndex(variants, index);\n    return variants[index].write(variant, bytes, offset);\n  };\n  if (fixedSize !== null) {\n    return createEncoder({ fixedSize, write });\n  }\n  const maxSize = getUnionMaxSize(variants);\n  return createEncoder({\n    ...maxSize !== null ? { maxSize } : {},\n    getSizeFromValue: (variant) => {\n      const index = getIndexFromValue(variant);\n      assertValidVariantIndex(variants, index);\n      return getEncodedSize(variant, variants[index]);\n    },\n    write\n  });\n}\nfunction getUnionDecoder(variants, getIndexFromBytes) {\n  const fixedSize = getUnionFixedSize(variants);\n  const read = (bytes, offset) => {\n    const index = getIndexFromBytes(bytes, offset);\n    assertValidVariantIndex(variants, index);\n    return variants[index].read(bytes, offset);\n  };\n  if (fixedSize !== null) {\n    return createDecoder({ fixedSize, read });\n  }\n  const maxSize = getUnionMaxSize(variants);\n  return createDecoder({ ...maxSize !== null ? { maxSize } : {}, read });\n}\nfunction getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {\n  return combineCodec(\n    getUnionEncoder(variants, getIndexFromValue),\n    getUnionDecoder(variants, getIndexFromBytes)\n  );\n}\nfunction assertValidVariantIndex(variants, index) {\n  if (typeof variants[index] === \"undefined\") {\n    throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n      maxRange: variants.length - 1,\n      minRange: 0,\n      variant: index\n    });\n  }\n}\nfunction getUnionFixedSize(variants) {\n  if (variants.length === 0) return 0;\n  if (!isFixedSize(variants[0])) return null;\n  const variantSize = variants[0].fixedSize;\n  const sameSizedVariants = variants.every((variant) => isFixedSize(variant) && variant.fixedSize === variantSize);\n  return sameSizedVariants ? variantSize : null;\n}\nfunction getUnionMaxSize(variants) {\n  return maxCodecSizes(variants.map((variant) => getMaxSize(variant)));\n}\n\n// src/discriminated-union.ts\nfunction getDiscriminatedUnionEncoder(variants, config = {}) {\n  const discriminatorProperty = config.discriminator ?? \"__kind\";\n  const prefix = config.size ?? getU8Encoder();\n  return getUnionEncoder(\n    variants.map(\n      ([, variant], index) => transformEncoder(getTupleEncoder([prefix, variant]), (value) => [index, value])\n    ),\n    (value) => getVariantDiscriminator(variants, value[discriminatorProperty])\n  );\n}\nfunction getDiscriminatedUnionDecoder(variants, config = {}) {\n  const discriminatorProperty = config.discriminator ?? \"__kind\";\n  const prefix = config.size ?? getU8Decoder();\n  return getUnionDecoder(\n    variants.map(\n      ([discriminator, variant]) => transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n        [discriminatorProperty]: discriminator,\n        ...value\n      }))\n    ),\n    (bytes, offset) => Number(prefix.read(bytes, offset)[0])\n  );\n}\nfunction getDiscriminatedUnionCodec(variants, config = {}) {\n  return combineCodec(\n    getDiscriminatedUnionEncoder(variants, config),\n    getDiscriminatedUnionDecoder(variants, config)\n  );\n}\nfunction getVariantDiscriminator(variants, discriminatorValue) {\n  const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n  if (discriminator < 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n      value: discriminatorValue,\n      variants: variants.map(([key]) => key)\n    });\n  }\n  return discriminator;\n}\nvar getDataEnumEncoder = getDiscriminatedUnionEncoder;\nvar getDataEnumDecoder = getDiscriminatedUnionDecoder;\nvar getDataEnumCodec = getDiscriminatedUnionCodec;\n\n// src/enum-helpers.ts\nfunction getEnumStats(constructor) {\n  const numericalValues = [\n    ...new Set(Object.values(constructor).filter((v) => typeof v === \"number\"))\n  ].sort();\n  const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));\n  const enumKeys = Object.keys(enumRecord);\n  const enumValues = Object.values(enumRecord);\n  const stringValues = [\n    .../* @__PURE__ */ new Set([...enumKeys, ...enumValues.filter((v) => typeof v === \"string\")])\n  ];\n  return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\nfunction getEnumIndexFromVariant({\n  enumKeys,\n  enumValues,\n  variant\n}) {\n  const valueIndex = findLastIndex(enumValues, (value) => value === variant);\n  if (valueIndex >= 0) return valueIndex;\n  return enumKeys.findIndex((key) => key === variant);\n}\nfunction getEnumIndexFromDiscriminator({\n  discriminator,\n  enumKeys,\n  enumValues,\n  useValuesAsDiscriminators\n}) {\n  if (!useValuesAsDiscriminators) {\n    return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n  }\n  return findLastIndex(enumValues, (value) => value === discriminator);\n}\nfunction findLastIndex(array, predicate) {\n  let l = array.length;\n  while (l--) {\n    if (predicate(array[l], l, array)) return l;\n  }\n  return -1;\n}\nfunction formatNumericalValues(values) {\n  if (values.length === 0) return \"\";\n  let range = [values[0], values[0]];\n  const ranges = [];\n  for (let index = 1; index < values.length; index++) {\n    const value = values[index];\n    if (range[1] + 1 === value) {\n      range[1] = value;\n    } else {\n      ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n      range = [value, value];\n    }\n  }\n  ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n  return ranges.join(\", \");\n}\n\n// src/enum.ts\nfunction getEnumEncoder(constructor, config = {}) {\n  const prefix = config.size ?? getU8Encoder();\n  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n  const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n  if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === \"string\")) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n      stringValues: enumValues.filter((v) => typeof v === \"string\")\n    });\n  }\n  return transformEncoder(prefix, (variant) => {\n    const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n    if (index < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n        formattedNumericalValues: formatNumericalValues(numericalValues),\n        numericalValues,\n        stringValues,\n        variant\n      });\n    }\n    return useValuesAsDiscriminators ? enumValues[index] : index;\n  });\n}\nfunction getEnumDecoder(constructor, config = {}) {\n  const prefix = config.size ?? getU8Decoder();\n  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n  const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n  if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === \"string\")) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n      stringValues: enumValues.filter((v) => typeof v === \"string\")\n    });\n  }\n  return transformDecoder(prefix, (value) => {\n    const discriminator = Number(value);\n    const index = getEnumIndexFromDiscriminator({\n      discriminator,\n      enumKeys,\n      enumValues,\n      useValuesAsDiscriminators\n    });\n    if (index < 0) {\n      const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [...Array(enumKeys.length).keys()];\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n        discriminator,\n        formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n        validDiscriminators\n      });\n    }\n    return enumValues[index];\n  });\n}\nfunction getEnumCodec(constructor, config = {}) {\n  return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\nvar getScalarEnumEncoder = getEnumEncoder;\nvar getScalarEnumDecoder = getEnumDecoder;\nvar getScalarEnumCodec = getEnumCodec;\nfunction getHiddenPrefixEncoder(encoder, prefixedEncoders) {\n  return transformEncoder(\n    getTupleEncoder([...prefixedEncoders, encoder]),\n    (value) => [...prefixedEncoders.map(() => void 0), value]\n  );\n}\nfunction getHiddenPrefixDecoder(decoder, prefixedDecoders) {\n  return transformDecoder(\n    getTupleDecoder([...prefixedDecoders, decoder]),\n    (tuple) => tuple[tuple.length - 1]\n  );\n}\nfunction getHiddenPrefixCodec(codec, prefixedCodecs) {\n  return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\nfunction getHiddenSuffixEncoder(encoder, suffixedEncoders) {\n  return transformEncoder(\n    getTupleEncoder([encoder, ...suffixedEncoders]),\n    (value) => [value, ...suffixedEncoders.map(() => void 0)]\n  );\n}\nfunction getHiddenSuffixDecoder(decoder, suffixedDecoders) {\n  return transformDecoder(\n    getTupleDecoder([decoder, ...suffixedDecoders]),\n    (tuple) => tuple[0]\n  );\n}\nfunction getHiddenSuffixCodec(codec, suffixedCodecs) {\n  return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\nfunction getMapEncoder(key, value, config = {}) {\n  return transformEncoder(\n    getArrayEncoder(getTupleEncoder([key, value]), config),\n    (map) => [...map.entries()]\n  );\n}\nfunction getMapDecoder(key, value, config = {}) {\n  return transformDecoder(\n    getArrayDecoder(getTupleDecoder([key, value]), config),\n    (entries) => new Map(entries)\n  );\n}\nfunction getMapCodec(key, value, config = {}) {\n  return combineCodec(getMapEncoder(key, value, config), getMapDecoder(key, value, config));\n}\nfunction getUnitEncoder() {\n  return createEncoder({\n    fixedSize: 0,\n    write: (_value, _bytes, offset) => offset\n  });\n}\nfunction getUnitDecoder() {\n  return createDecoder({\n    fixedSize: 0,\n    read: (_bytes, offset) => [void 0, offset]\n  });\n}\nfunction getUnitCodec() {\n  return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n\n// src/nullable.ts\nfunction getNullableEncoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformEncoder(getUnitEncoder(), (_boolean) => void 0);\n    }\n    return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitEncoder();\n    }\n    return getConstantEncoder(config.noneValue);\n  })();\n  return getUnionEncoder(\n    [\n      transformEncoder(getTupleEncoder([prefix, noneValue]), (_value) => [\n        false,\n        void 0\n      ]),\n      transformEncoder(getTupleEncoder([prefix, item]), (value) => [true, value])\n    ],\n    (variant) => Number(variant !== null)\n  );\n}\nfunction getNullableDecoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformDecoder(getUnitDecoder(), () => false);\n    }\n    return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitDecoder();\n    }\n    return getConstantDecoder(config.noneValue);\n  })();\n  return getUnionDecoder(\n    [\n      transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n      transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => value)\n    ],\n    (bytes, offset) => {\n      if (config.prefix === null && !config.noneValue) {\n        return Number(offset < bytes.length);\n      }\n      if (config.prefix === null && config.noneValue != null) {\n        const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n        return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n      }\n      return Number(prefix.read(bytes, offset)[0]);\n    }\n  );\n}\nfunction getNullableCodec(item, config = {}) {\n  return combineCodec(\n    getNullableEncoder(item, config),\n    getNullableDecoder(item, config)\n  );\n}\nfunction getSetEncoder(item, config = {}) {\n  return transformEncoder(getArrayEncoder(item, config), (set) => [...set]);\n}\nfunction getSetDecoder(item, config = {}) {\n  return transformDecoder(getArrayDecoder(item, config), (entries) => new Set(entries));\n}\nfunction getSetCodec(item, config = {}) {\n  return combineCodec(getSetEncoder(item, config), getSetDecoder(item, config));\n}\nfunction getStructEncoder(fields) {\n  const fieldCodecs = fields.map(([, codec]) => codec);\n  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n  return createEncoder({\n    ...fixedSize === null ? {\n      getSizeFromValue: (value) => fields.map(([key, codec]) => getEncodedSize(value[key], codec)).reduce((all, one) => all + one, 0),\n      maxSize\n    } : { fixedSize },\n    write: (struct, bytes, offset) => {\n      fields.forEach(([key, codec]) => {\n        offset = codec.write(struct[key], bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getStructDecoder(fields) {\n  const fieldCodecs = fields.map(([, codec]) => codec);\n  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n  return createDecoder({\n    ...fixedSize === null ? { maxSize } : { fixedSize },\n    read: (bytes, offset) => {\n      const struct = {};\n      fields.forEach(([key, codec]) => {\n        const [value, newOffset] = codec.read(bytes, offset);\n        offset = newOffset;\n        struct[key] = value;\n      });\n      return [struct, offset];\n    }\n  });\n}\nfunction getStructCodec(fields) {\n  return combineCodec(\n    getStructEncoder(fields),\n    getStructDecoder(fields)\n  );\n}\n\nexport { assertValidNumberOfItemsForCodec, getArrayCodec, getArrayDecoder, getArrayEncoder, getBitArrayCodec, getBitArrayDecoder, getBitArrayEncoder, getBooleanCodec, getBooleanDecoder, getBooleanEncoder, getBytesCodec, getBytesDecoder, getBytesEncoder, getConstantCodec, getConstantDecoder, getConstantEncoder, getDataEnumCodec, getDataEnumDecoder, getDataEnumEncoder, getDiscriminatedUnionCodec, getDiscriminatedUnionDecoder, getDiscriminatedUnionEncoder, getEnumCodec, getEnumDecoder, getEnumEncoder, getHiddenPrefixCodec, getHiddenPrefixDecoder, getHiddenPrefixEncoder, getHiddenSuffixCodec, getHiddenSuffixDecoder, getHiddenSuffixEncoder, getMapCodec, getMapDecoder, getMapEncoder, getNullableCodec, getNullableDecoder, getNullableEncoder, getScalarEnumCodec, getScalarEnumDecoder, getScalarEnumEncoder, getSetCodec, getSetDecoder, getSetEncoder, getStructCodec, getStructDecoder, getStructEncoder, getTupleCodec, getTupleDecoder, getTupleEncoder, getUnionCodec, getUnionDecoder, getUnionEncoder, getUnitCodec, getUnitDecoder, getUnitEncoder };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { SolanaError, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE } from '@solana/errors';\nimport { createEncoder, createDecoder, combineCodec } from '@solana/codecs-core';\n\n// src/assertions.ts\nfunction assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n      alphabet: alphabet4,\n      base: alphabet4.length,\n      value: givenValue\n    });\n  }\n}\nvar getBaseXEncoder = (alphabet4) => {\n  return createEncoder({\n    getSizeFromValue: (value) => {\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) return value.length;\n      const base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n    },\n    write(value, bytes, offset) {\n      assertValidBaseString(alphabet4, value);\n      if (value === \"\") return offset;\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) {\n        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n        return offset + leadingZeroes.length;\n      }\n      let base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      const tailBytes = [];\n      while (base10Number > 0n) {\n        tailBytes.unshift(Number(base10Number % 256n));\n        base10Number /= 256n;\n      }\n      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getBaseXDecoder = (alphabet4) => {\n  return createDecoder({\n    read(rawBytes, offset) {\n      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n      if (bytes.length === 0) return [\"\", 0];\n      let trailIndex = bytes.findIndex((n) => n !== 0);\n      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n      const leadingZeroes = alphabet4[0].repeat(trailIndex);\n      if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n      const tailChars = getBaseXFromBigInt(base10Number, alphabet4);\n      return [leadingZeroes + tailChars, rawBytes.length];\n    }\n  });\n};\nvar getBaseXCodec = (alphabet4) => combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));\nfunction partitionLeadingZeroes(value, zeroCharacter) {\n  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n  return [leadingZeros, tailChars];\n}\nfunction getBigIntFromBaseX(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  let sum = 0n;\n  for (const char of value) {\n    sum *= base;\n    sum += BigInt(alphabet4.indexOf(char));\n  }\n  return sum;\n}\nfunction getBaseXFromBigInt(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  const tailChars = [];\n  while (value > 0n) {\n    tailChars.unshift(alphabet4[Number(value % base)]);\n    value /= base;\n  }\n  return tailChars.join(\"\");\n}\n\n// src/base10.ts\nvar alphabet = \"0123456789\";\nvar getBase10Encoder = () => getBaseXEncoder(alphabet);\nvar getBase10Decoder = () => getBaseXDecoder(alphabet);\nvar getBase10Codec = () => getBaseXCodec(alphabet);\nvar INVALID_STRING_ERROR_BASE_CONFIG = {\n  alphabet: \"0123456789abcdef\",\n  base: 16\n};\nfunction charCodeToBase16(char) {\n  if (char >= 48 /* ZERO */ && char <= 57 /* NINE */) return char - 48 /* ZERO */;\n  if (char >= 65 /* A_UP */ && char <= 70 /* F_UP */) return char - (65 /* A_UP */ - 10);\n  if (char >= 97 /* A_LO */ && char <= 102 /* F_LO */) return char - (97 /* A_LO */ - 10);\n}\nvar getBase16Encoder = () => createEncoder({\n  getSizeFromValue: (value) => Math.ceil(value.length / 2),\n  write(value, bytes, offset) {\n    const len = value.length;\n    const al = len / 2;\n    if (len === 1) {\n      const c = value.charCodeAt(0);\n      const n = charCodeToBase16(c);\n      if (n === void 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n          ...INVALID_STRING_ERROR_BASE_CONFIG,\n          value\n        });\n      }\n      bytes.set([n], offset);\n      return 1 + offset;\n    }\n    const hexBytes = new Uint8Array(al);\n    for (let i = 0, j = 0; i < al; i++) {\n      const c1 = value.charCodeAt(j++);\n      const c2 = value.charCodeAt(j++);\n      const n1 = charCodeToBase16(c1);\n      const n2 = charCodeToBase16(c2);\n      if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n          ...INVALID_STRING_ERROR_BASE_CONFIG,\n          value\n        });\n      }\n      hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;\n    }\n    bytes.set(hexBytes, offset);\n    return hexBytes.length + offset;\n  }\n});\nvar getBase16Decoder = () => createDecoder({\n  read(bytes, offset) {\n    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n    return [value, bytes.length];\n  }\n});\nvar getBase16Codec = () => combineCodec(getBase16Encoder(), getBase16Decoder());\n\n// src/base58.ts\nvar alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar getBase58Encoder = () => getBaseXEncoder(alphabet2);\nvar getBase58Decoder = () => getBaseXDecoder(alphabet2);\nvar getBase58Codec = () => getBaseXCodec(alphabet2);\nvar getBaseXResliceEncoder = (alphabet4, bits) => createEncoder({\n  getSizeFromValue: (value) => Math.floor(value.length * bits / 8),\n  write(value, bytes, offset) {\n    assertValidBaseString(alphabet4, value);\n    if (value === \"\") return offset;\n    const charIndices = [...value].map((c) => alphabet4.indexOf(c));\n    const reslicedBytes = reslice(charIndices, bits, 8, false);\n    bytes.set(reslicedBytes, offset);\n    return reslicedBytes.length + offset;\n  }\n});\nvar getBaseXResliceDecoder = (alphabet4, bits) => createDecoder({\n  read(rawBytes, offset = 0) {\n    const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n    if (bytes.length === 0) return [\"\", rawBytes.length];\n    const charIndices = reslice([...bytes], 8, bits, true);\n    return [charIndices.map((i) => alphabet4[i]).join(\"\"), rawBytes.length];\n  }\n});\nvar getBaseXResliceCodec = (alphabet4, bits) => combineCodec(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits));\nfunction reslice(input, inputBits, outputBits, useRemainder) {\n  const output = [];\n  let accumulator = 0;\n  let bitsInAccumulator = 0;\n  const mask = (1 << outputBits) - 1;\n  for (const value of input) {\n    accumulator = accumulator << inputBits | value;\n    bitsInAccumulator += inputBits;\n    while (bitsInAccumulator >= outputBits) {\n      bitsInAccumulator -= outputBits;\n      output.push(accumulator >> bitsInAccumulator & mask);\n    }\n  }\n  if (useRemainder && bitsInAccumulator > 0) {\n    output.push(accumulator << outputBits - bitsInAccumulator & mask);\n  }\n  return output;\n}\n\n// src/base64.ts\nvar alphabet3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar getBase64Encoder = () => {\n  {\n    return createEncoder({\n      getSizeFromValue: (value) => {\n        try {\n          return atob(value).length;\n        } catch (e2) {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      },\n      write(value, bytes, offset) {\n        try {\n          const bytesToAdd = atob(value).split(\"\").map((c) => c.charCodeAt(0));\n          bytes.set(bytesToAdd, offset);\n          return bytesToAdd.length + offset;\n        } catch (e2) {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      }\n    });\n  }\n};\nvar getBase64Decoder = () => {\n  {\n    return createDecoder({\n      read(bytes, offset = 0) {\n        const slice = bytes.slice(offset);\n        const value = btoa(String.fromCharCode(...slice));\n        return [value, bytes.length];\n      }\n    });\n  }\n};\nvar getBase64Codec = () => combineCodec(getBase64Encoder(), getBase64Decoder());\n\n// src/null-characters.ts\nvar removeNullCharacters = (value) => (\n  // eslint-disable-next-line no-control-regex\n  value.replace(/\\u0000/g, \"\")\n);\nvar padNullCharacters = (value, chars) => value.padEnd(chars, \"\\0\");\n\n// ../text-encoding-impl/dist/index.browser.mjs\nvar e = globalThis.TextDecoder;\nvar o = globalThis.TextEncoder;\n\n// src/utf8.ts\nvar getUtf8Encoder = () => {\n  let textEncoder;\n  return createEncoder({\n    getSizeFromValue: (value) => (textEncoder ||= new o()).encode(value).length,\n    write: (value, bytes, offset) => {\n      const bytesToAdd = (textEncoder ||= new o()).encode(value);\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getUtf8Decoder = () => {\n  let textDecoder;\n  return createDecoder({\n    read(bytes, offset) {\n      const value = (textDecoder ||= new e()).decode(bytes.slice(offset));\n      return [removeNullCharacters(value), bytes.length];\n    }\n  });\n};\nvar getUtf8Codec = () => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n\nexport { assertValidBaseString, getBase10Codec, getBase10Decoder, getBase10Encoder, getBase16Codec, getBase16Decoder, getBase16Encoder, getBase58Codec, getBase58Decoder, getBase58Encoder, getBase64Codec, getBase64Decoder, getBase64Encoder, getBaseXCodec, getBaseXDecoder, getBaseXEncoder, getBaseXResliceCodec, getBaseXResliceDecoder, getBaseXResliceEncoder, getUtf8Codec, getUtf8Decoder, getUtf8Encoder, padNullCharacters, removeNullCharacters };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { transformEncoder, assertIsFixedSize, fixEncoderSize, transformDecoder, fixDecoderSize, containsBytes, combineCodec } from '@solana/codecs-core';\nimport { getUnitEncoder, getBooleanEncoder, getConstantEncoder, getUnionEncoder, getTupleEncoder, getUnitDecoder, getBooleanDecoder, getConstantDecoder, getUnionDecoder, getTupleDecoder } from '@solana/codecs-data-structures';\nimport { getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';\n\n// src/option.ts\nvar some = (value) => ({ __option: \"Some\", value });\nvar none = () => ({ __option: \"None\" });\nvar isOption = (input) => !!(input && typeof input === \"object\" && \"__option\" in input && (input.__option === \"Some\" && \"value\" in input || input.__option === \"None\"));\nvar isSome = (option) => option.__option === \"Some\";\nvar isNone = (option) => option.__option === \"None\";\n\n// src/unwrap-option.ts\nfunction unwrapOption(option, fallback) {\n  if (isSome(option)) return option.value;\n  return fallback ? fallback() : null;\n}\nvar wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();\n\n// src/option-codec.ts\nfunction getOptionEncoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformEncoder(getUnitEncoder(), (_boolean) => void 0);\n    }\n    return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitEncoder();\n    }\n    return getConstantEncoder(config.noneValue);\n  })();\n  return getUnionEncoder(\n    [\n      transformEncoder(getTupleEncoder([prefix, noneValue]), (_value) => [\n        false,\n        void 0\n      ]),\n      transformEncoder(getTupleEncoder([prefix, item]), (value) => [\n        true,\n        isOption(value) && isSome(value) ? value.value : value\n      ])\n    ],\n    (variant) => {\n      const option = isOption(variant) ? variant : wrapNullable(variant);\n      return Number(isSome(option));\n    }\n  );\n}\nfunction getOptionDecoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformDecoder(getUnitDecoder(), () => false);\n    }\n    return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitDecoder();\n    }\n    return getConstantDecoder(config.noneValue);\n  })();\n  return getUnionDecoder(\n    [\n      transformDecoder(getTupleDecoder([prefix, noneValue]), () => none()),\n      transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value))\n    ],\n    (bytes, offset) => {\n      if (config.prefix === null && !config.noneValue) {\n        return Number(offset < bytes.length);\n      }\n      if (config.prefix === null && config.noneValue != null) {\n        const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n        return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n      }\n      return Number(prefix.read(bytes, offset)[0]);\n    }\n  );\n}\nfunction getOptionCodec(item, config = {}) {\n  return combineCodec(\n    getOptionEncoder(item, config),\n    getOptionDecoder(item, config)\n  );\n}\n\n// src/unwrap-option-recursively.ts\nfunction unwrapOptionRecursively(input, fallback) {\n  if (!input || ArrayBuffer.isView(input)) {\n    return input;\n  }\n  const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);\n  if (isOption(input)) {\n    if (isSome(input)) return next(input.value);\n    return fallback ? fallback() : null;\n  }\n  if (Array.isArray(input)) {\n    return input.map(next);\n  }\n  if (typeof input === \"object\") {\n    return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));\n  }\n  return input;\n}\n\nexport { getOptionCodec, getOptionDecoder, getOptionEncoder, isNone, isOption, isSome, none, some, unwrapOption, unwrapOptionRecursively, wrapNullable };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { fixEncoderSize, getBytesEncoder, getStructEncoder, getTupleEncoder, getU64Encoder, transformEncoder, } from '@solana/codecs';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nfunction getInstructionEncoder(discriminator, dataEncoder) {\n    return transformEncoder(getTupleEncoder([getBytesEncoder(), dataEncoder]), (data) => [\n        discriminator,\n        data,\n    ]);\n}\nfunction getPublicKeyEncoder() {\n    return transformEncoder(fixEncoderSize(getBytesEncoder(), 32), (publicKey) => publicKey.toBytes());\n}\nexport function createInitializeGroupInstruction(args) {\n    const { programId, group, mint, mintAuthority, updateAuthority, maxSize } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: false, isWritable: false, pubkey: mint },\n            { isSigner: true, isWritable: false, pubkey: mintAuthority },\n        ],\n        data: Buffer.from(getInstructionEncoder(new Uint8Array([\n            /* await splDiscriminate('spl_token_group_interface:initialize_token_group') */\n            121, 113, 108, 39, 54, 51, 0, 4,\n        ]), getStructEncoder([\n            ['updateAuthority', getPublicKeyEncoder()],\n            ['maxSize', getU64Encoder()],\n        ])).encode({ updateAuthority: updateAuthority ?? SystemProgram.programId, maxSize })),\n    });\n}\nexport function createUpdateGroupMaxSizeInstruction(args) {\n    const { programId, group, updateAuthority, maxSize } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: true, isWritable: false, pubkey: updateAuthority },\n        ],\n        data: Buffer.from(getInstructionEncoder(new Uint8Array([\n            /* await splDiscriminate('spl_token_group_interface:update_group_max_size') */\n            108, 37, 171, 143, 248, 30, 18, 110,\n        ]), getStructEncoder([['maxSize', getU64Encoder()]])).encode({ maxSize })),\n    });\n}\nexport function createUpdateGroupAuthorityInstruction(args) {\n    const { programId, group, currentAuthority, newAuthority } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: true, isWritable: false, pubkey: currentAuthority },\n        ],\n        data: Buffer.from(getInstructionEncoder(new Uint8Array([\n            /* await splDiscriminate('spl_token_group_interface:update_authority') */\n            161, 105, 88, 1, 237, 221, 216, 203,\n        ]), getStructEncoder([['newAuthority', getPublicKeyEncoder()]])).encode({ newAuthority: newAuthority ?? SystemProgram.programId })),\n    });\n}\nexport function createInitializeMemberInstruction(args) {\n    const { programId, member, memberMint, memberMintAuthority, group, groupUpdateAuthority } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: member },\n            { isSigner: false, isWritable: false, pubkey: memberMint },\n            { isSigner: true, isWritable: false, pubkey: memberMintAuthority },\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: true, isWritable: false, pubkey: groupUpdateAuthority },\n        ],\n        data: Buffer.from(getInstructionEncoder(new Uint8Array([\n            /* await splDiscriminate('spl_token_group_interface:initialize_member') */\n            152, 32, 222, 176, 223, 237, 116, 134,\n        ]), getStructEncoder([])).encode({})),\n    });\n}\n//# sourceMappingURL=instruction.js.map","import { PublicKey } from '@solana/web3.js';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\nconst tokenGroupCodec = getStructCodec([\n    ['updateAuthority', fixCodecSize(getBytesCodec(), 32)],\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['size', getU64Codec()],\n    ['maxSize', getU64Codec()],\n]);\nexport const TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize;\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer) {\n    for (let i = 0; i < buffer.length; i++) {\n        if (buffer[i] !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n// Pack TokenGroup into byte slab\nexport function packTokenGroup(group) {\n    // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n    const updateAuthority = group.updateAuthority ?? PublicKey.default;\n    return tokenGroupCodec.encode({\n        updateAuthority: updateAuthority.toBuffer(),\n        mint: group.mint.toBuffer(),\n        size: group.size,\n        maxSize: group.maxSize,\n    });\n}\n// unpack byte slab into TokenGroup\nexport function unpackTokenGroup(buffer) {\n    const data = tokenGroupCodec.decode(buffer);\n    return isNonePubkey(data.updateAuthority)\n        ? {\n            mint: new PublicKey(data.mint),\n            size: data.size,\n            maxSize: data.maxSize,\n        }\n        : {\n            updateAuthority: new PublicKey(data.updateAuthority),\n            mint: new PublicKey(data.mint),\n            size: data.size,\n            maxSize: data.maxSize,\n        };\n}\n//# sourceMappingURL=tokenGroup.js.map","import { PublicKey } from '@solana/web3.js';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\nconst tokenGroupMemberCodec = getStructCodec([\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['group', fixCodecSize(getBytesCodec(), 32)],\n    ['memberNumber', getU64Codec()],\n]);\nexport const TOKEN_GROUP_MEMBER_SIZE = tokenGroupMemberCodec.fixedSize;\n// Pack TokenGroupMember into byte slab\nexport function packTokenGroupMember(member) {\n    return tokenGroupMemberCodec.encode({\n        mint: member.mint.toBuffer(),\n        group: member.group.toBuffer(),\n        memberNumber: member.memberNumber,\n    });\n}\n// unpack byte slab into TokenGroupMember\nexport function unpackTokenGroupMember(buffer) {\n    const data = tokenGroupMemberCodec.decode(buffer);\n    return {\n        mint: new PublicKey(data.mint),\n        group: new PublicKey(data.group),\n        memberNumber: data.memberNumber,\n    };\n}\n//# sourceMappingURL=tokenGroupMember.js.map","import { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { createInitializeGroupInstruction, createUpdateGroupMaxSizeInstruction, createUpdateGroupAuthorityInstruction, createInitializeMemberInstruction, TOKEN_GROUP_SIZE, TOKEN_GROUP_MEMBER_SIZE, } from '@solana/spl-token-group';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\n/**\n * Initialize a new `Group`\n *\n * Assumes one has already initialized a mint for the group.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param mintAuthority    Group mint authority\n * @param updateAuthority  Group update authority\n * @param maxSize          Maximum number of members in the group\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupInitializeGroup(connection, payer, mint, mintAuthority, updateAuthority, maxSize, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n    const transaction = new Transaction().add(createInitializeGroupInstruction({\n        programId,\n        group: mint,\n        mint,\n        mintAuthority: mintAuthorityPublicKey,\n        updateAuthority,\n        maxSize,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Initialize a new `Group` with rent transfer.\n *\n * Assumes one has already initialized a mint for the group.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param mintAuthority    Group mint authority\n * @param updateAuthority  Group update authority\n * @param maxSize          Maximum number of members in the group\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupInitializeGroupWithRentTransfer(connection, payer, mint, mintAuthority, updateAuthority, maxSize, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n    const lamports = await connection.getMinimumBalanceForRentExemption(TOKEN_GROUP_SIZE);\n    const transaction = new Transaction().add(SystemProgram.transfer({\n        fromPubkey: payer.publicKey,\n        toPubkey: mint,\n        lamports,\n    }), createInitializeGroupInstruction({\n        programId,\n        group: mint,\n        mint,\n        mintAuthority: mintAuthorityPublicKey,\n        updateAuthority,\n        maxSize,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Update the max size of a `Group`\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param updateAuthority  Group update authority\n * @param maxSize          Maximum number of members in the group\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupUpdateGroupMaxSize(connection, payer, mint, updateAuthority, maxSize, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n    const transaction = new Transaction().add(createUpdateGroupMaxSizeInstruction({\n        programId,\n        group: mint,\n        updateAuthority: updateAuthorityPublicKey,\n        maxSize,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Update the authority of a `Group`\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param updateAuthority  Group update authority\n * @param newAuthority     New authority for the token group, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupUpdateGroupAuthority(connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n    const transaction = new Transaction().add(createUpdateGroupAuthorityInstruction({\n        programId,\n        group: mint,\n        currentAuthority: updateAuthorityPublicKey,\n        newAuthority,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Initialize a new `Member` of a `Group`\n *\n * Assumes the `Group` has already been initialized,\n * as well as the mint for the member.\n *\n * @param connection             Connection to use\n * @param payer                  Payer of the transaction fee\n * @param mint                   Member mint\n * @param mintAuthority          Member mint authority\n * @param group                  Group mint\n * @param groupUpdateAuthority   Group update authority\n * @param multiSigners           Signing accounts if `authority` is a multisig\n * @param confirmOptions         Options for confirming the transaction\n * @param programId              SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupMemberInitialize(connection, payer, mint, mintAuthority, group, groupUpdateAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n    const transaction = new Transaction().add(createInitializeMemberInstruction({\n        programId,\n        member: mint,\n        memberMint: mint,\n        memberMintAuthority: mintAuthorityPublicKey,\n        group,\n        groupUpdateAuthority,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Initialize a new `Member` of a `Group` with rent transfer.\n *\n * Assumes the `Group` has already been initialized,\n * as well as the mint for the member.\n *\n * @param connection             Connection to use\n * @param payer                  Payer of the transaction fee\n * @param mint                   Member mint\n * @param mintAuthority          Member mint authority\n * @param group                  Group mint\n * @param groupUpdateAuthority   Group update authority\n * @param multiSigners           Signing accounts if `authority` is a multisig\n * @param confirmOptions         Options for confirming the transaction\n * @param programId              SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupMemberInitializeWithRentTransfer(connection, payer, mint, mintAuthority, group, groupUpdateAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n    const lamports = await connection.getMinimumBalanceForRentExemption(TOKEN_GROUP_MEMBER_SIZE);\n    const transaction = new Transaction().add(SystemProgram.transfer({\n        fromPubkey: payer.publicKey,\n        toPubkey: mint,\n        lamports,\n    }), createInitializeMemberInstruction({\n        programId,\n        member: mint,\n        memberMint: mint,\n        memberMintAuthority: mintAuthorityPublicKey,\n        group,\n        groupUpdateAuthority,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=actions.js.map","import { PublicKey } from '@solana/web3.js';\nimport { unpackTokenGroup, unpackTokenGroupMember, } from '@solana/spl-token-group';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nexport { TOKEN_GROUP_SIZE, TOKEN_GROUP_MEMBER_SIZE } from '@solana/spl-token-group';\nexport function getTokenGroupState(mint) {\n    const extensionData = getExtensionData(ExtensionType.TokenGroup, mint.tlvData);\n    if (extensionData !== null) {\n        const { updateAuthority, mint, size, maxSize } = unpackTokenGroup(extensionData);\n        // Explicitly set None/Zero keys to null\n        return {\n            updateAuthority: updateAuthority?.equals(PublicKey.default) ? undefined : updateAuthority,\n            mint,\n            size,\n            maxSize,\n        };\n    }\n    else {\n        return null;\n    }\n}\nexport function getTokenGroupMemberState(mint) {\n    const extensionData = getExtensionData(ExtensionType.TokenGroupMember, mint.tlvData);\n    if (extensionData !== null) {\n        const { mint, group, memberNumber } = unpackTokenGroupMember(extensionData);\n        return {\n            mint,\n            group,\n            memberNumber,\n        };\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=state.js.map","import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n/** Buffer layout for de/serializing a Group Pointer extension */\nexport const GroupMemberPointerLayout = struct([\n    publicKey('authority'),\n    publicKey('memberAddress'),\n]);\nexport const GROUP_MEMBER_POINTER_SIZE = GroupMemberPointerLayout.span;\nexport function getGroupMemberPointerState(mint) {\n    const extensionData = getExtensionData(ExtensionType.GroupMemberPointer, mint.tlvData);\n    if (extensionData !== null) {\n        const { authority, memberAddress } = GroupMemberPointerLayout.decode(extensionData);\n        // Explicitly set None/Zero keys to null\n        return {\n            authority: authority.equals(PublicKey.default) ? null : authority,\n            memberAddress: memberAddress.equals(PublicKey.default) ? null : memberAddress,\n        };\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=state.js.map","import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n/** Buffer layout for de/serializing a GroupPointer extension */\nexport const GroupPointerLayout = struct([\n    publicKey('authority'),\n    publicKey('groupAddress'),\n]);\nexport const GROUP_POINTER_SIZE = GroupPointerLayout.span;\nexport function getGroupPointerState(mint) {\n    const extensionData = getExtensionData(ExtensionType.GroupPointer, mint.tlvData);\n    if (extensionData !== null) {\n        const { authority, groupAddress } = GroupPointerLayout.decode(extensionData);\n        // Explicitly set None/Zero keys to null\n        return {\n            authority: authority.equals(PublicKey.default) ? null : authority,\n            groupAddress: groupAddress.equals(PublicKey.default) ? null : groupAddress,\n        };\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=state.js.map","import { struct } from '@solana/buffer-layout';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n/** Buffer layout for de/serializing an account */\nexport const ImmutableOwnerLayout = struct([]);\nexport const IMMUTABLE_OWNER_SIZE = ImmutableOwnerLayout.span;\nexport function getImmutableOwner(account) {\n    const extensionData = getExtensionData(ExtensionType.ImmutableOwner, account.tlvData);\n    if (extensionData !== null) {\n        return ImmutableOwnerLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=immutableOwner.js.map","import { ns64, s16, struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nexport const InterestBearingMintConfigStateLayout = struct([\n    publicKey('rateAuthority'),\n    ns64('initializationTimestamp'),\n    s16('preUpdateAverageRate'),\n    ns64('lastUpdateTimestamp'),\n    s16('currentRate'),\n]);\nexport const INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = InterestBearingMintConfigStateLayout.span;\nexport function getInterestBearingMintConfigState(mint) {\n    const extensionData = getExtensionData(ExtensionType.InterestBearingConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return InterestBearingMintConfigStateLayout.decode(extensionData);\n    }\n    return null;\n}\n//# sourceMappingURL=state.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nexport var MemoTransferInstruction;\n(function (MemoTransferInstruction) {\n    MemoTransferInstruction[MemoTransferInstruction[\"Enable\"] = 0] = \"Enable\";\n    MemoTransferInstruction[MemoTransferInstruction[\"Disable\"] = 1] = \"Disable\";\n})(MemoTransferInstruction || (MemoTransferInstruction = {}));\n/** TODO: docs */\nexport const memoTransferInstructionData = struct([\n    u8('instruction'),\n    u8('memoTransferInstruction'),\n]);\n/**\n * Construct an EnableRequiredMemoTransfers instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createEnableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    return createMemoTransferInstruction(MemoTransferInstruction.Enable, account, authority, multiSigners, programId);\n}\n/**\n * Construct a DisableMemoTransfer instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createDisableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    return createMemoTransferInstruction(MemoTransferInstruction.Disable, account, authority, multiSigners, programId);\n}\nfunction createMemoTransferInstruction(memoTransferInstruction, account, authority, multiSigners, programId) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(memoTransferInstructionData.span);\n    memoTransferInstructionData.encode({\n        instruction: TokenInstruction.MemoTransferExtension,\n        memoTransferInstruction,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n//# sourceMappingURL=instructions.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createDisableRequiredMemoTransfersInstruction, createEnableRequiredMemoTransfersInstruction, } from './instructions.js';\n/**\n * Enable memo transfers on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function enableRequiredMemoTransfers(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createEnableRequiredMemoTransfersInstruction(account, ownerPublicKey, signers, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Disable memo transfers on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function disableRequiredMemoTransfers(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createDisableRequiredMemoTransfersInstruction(account, ownerPublicKey, signers, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=actions.js.map","import { struct } from '@solana/buffer-layout';\nimport { bool } from '@solana/buffer-layout-utils';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n/** Buffer layout for de/serializing a memo transfer extension */\nexport const MemoTransferLayout = struct([bool('requireIncomingTransferMemos')]);\nexport const MEMO_TRANSFER_SIZE = MemoTransferLayout.span;\nexport function getMemoTransfer(account) {\n    const extensionData = getExtensionData(ExtensionType.MemoTransfer, account.tlvData);\n    if (extensionData !== null) {\n        return MemoTransferLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=state.js.map","import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n/** Buffer layout for de/serializing a Metadata Pointer extension */\nexport const MetadataPointerLayout = struct([\n    publicKey('authority'),\n    publicKey('metadataAddress'),\n]);\nexport const METADATA_POINTER_SIZE = MetadataPointerLayout.span;\nexport function getMetadataPointerState(mint) {\n    const extensionData = getExtensionData(ExtensionType.MetadataPointer, mint.tlvData);\n    if (extensionData !== null) {\n        const { authority, metadataAddress } = MetadataPointerLayout.decode(extensionData);\n        // Explicitly set None/Zero keys to null\n        return {\n            authority: authority.equals(PublicKey.default) ? null : authority,\n            metadataAddress: metadataAddress.equals(PublicKey.default) ? null : metadataAddress,\n        };\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=state.js.map","import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n/** Buffer layout for de/serializing a mint */\nexport const MintCloseAuthorityLayout = struct([publicKey('closeAuthority')]);\nexport const MINT_CLOSE_AUTHORITY_SIZE = MintCloseAuthorityLayout.span;\nexport function getMintCloseAuthority(mint) {\n    const extensionData = getExtensionData(ExtensionType.MintCloseAuthority, mint.tlvData);\n    if (extensionData !== null) {\n        return MintCloseAuthorityLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=mintCloseAuthority.js.map","import { struct } from '@solana/buffer-layout';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n/** Buffer layout for de/serializing an account */\nexport const NonTransferableLayout = struct([]);\nexport const NON_TRANSFERABLE_SIZE = NonTransferableLayout.span;\nexport const NON_TRANSFERABLE_ACCOUNT_SIZE = NonTransferableLayout.span;\nexport function getNonTransferable(mint) {\n    const extensionData = getExtensionData(ExtensionType.NonTransferable, mint.tlvData);\n    if (extensionData !== null) {\n        return NonTransferableLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\nexport function getNonTransferableAccount(account) {\n    const extensionData = getExtensionData(ExtensionType.NonTransferableAccount, account.tlvData);\n    if (extensionData !== null) {\n        return NonTransferableLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=nonTransferable.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\nexport var PausableInstruction;\n(function (PausableInstruction) {\n    PausableInstruction[PausableInstruction[\"Initialize\"] = 0] = \"Initialize\";\n    PausableInstruction[PausableInstruction[\"Pause\"] = 1] = \"Pause\";\n    PausableInstruction[PausableInstruction[\"Resume\"] = 2] = \"Resume\";\n})(PausableInstruction || (PausableInstruction = {}));\nexport const initializePausableConfigInstructionData = struct([\n    u8('instruction'),\n    u8('pausableInstruction'),\n    publicKey('authority'),\n]);\n/**\n * Construct a InitializePausableConfig instruction\n *\n * @param mint          Token mint account\n * @param authority     Optional authority that can pause or resume mint\n * @param programId     SPL Token program account\n */\nexport function createInitializePausableConfigInstruction(mint, authority, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(initializePausableConfigInstructionData.span);\n    initializePausableConfigInstructionData.encode({\n        instruction: TokenInstruction.PausableExtension,\n        pausableInstruction: PausableInstruction.Initialize,\n        authority: authority ?? PublicKey.default,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data: data });\n}\nexport const pauseInstructionData = struct([u8('instruction'), u8('pausableInstruction')]);\n/**\n * Construct a Pause instruction\n *\n * @param mint          Token mint account\n * @param authority     The pausable mint's authority\n * @param multiSigners  Signing accounts if authority is a multisig\n * @param programId     SPL Token program account\n */\nexport function createPauseInstruction(mint, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(pauseInstructionData.span);\n    pauseInstructionData.encode({\n        instruction: TokenInstruction.PausableExtension,\n        pausableInstruction: PausableInstruction.Pause,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data: data });\n}\nexport const resumeInstructionData = struct([u8('instruction'), u8('pausableInstruction')]);\n/**\n * Construct a Resume instruction\n *\n * @param mint          Token mint account\n * @param authority     The pausable mint's authority\n * @param multiSigners  Signing accounts if authority is a multisig\n * @param programId     SPL Token program account\n */\nexport function createResumeInstruction(mint, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(resumeInstructionData.span);\n    resumeInstructionData.encode({\n        instruction: TokenInstruction.PausableExtension,\n        pausableInstruction: PausableInstruction.Resume,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n//# sourceMappingURL=instructions.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createPauseInstruction, createResumeInstruction } from './instructions.js';\n/**\n * Pause a pausable mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mint            Public key of the mint\n * @param owner           The pausable config authority\n * @param multiSigners    Signing accounts if `owner` is a multisig\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Public key of the mint\n */\nexport async function pause(connection, payer, mint, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createPauseInstruction(mint, ownerPublicKey, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Resume a pausable mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mint            Public key of the mint\n * @param owner           The pausable config authority\n * @param multiSigners    Signing accounts if `owner` is a multisig\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Public key of the mint\n */\nexport async function resume(connection, payer, mint, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createResumeInstruction(mint, ownerPublicKey, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=actions.js.map","import { struct } from '@solana/buffer-layout';\nimport { publicKey, bool } from '@solana/buffer-layout-utils';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n/** Buffer layout for de/serializing a pausable config */\nexport const PausableConfigLayout = struct([publicKey('authority'), bool('paused')]);\nexport const PAUSABLE_CONFIG_SIZE = PausableConfigLayout.span;\nexport function getPausableConfig(mint) {\n    const extensionData = getExtensionData(ExtensionType.PausableConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return PausableConfigLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n/** Buffer layout for de/serializing a pausable account */\nexport const PausableAccountLayout = struct([]); // esline-disable-line\nexport const PAUSABLE_ACCOUNT_SIZE = PausableAccountLayout.span;\nexport function getPausableAccount(account) {\n    const extensionData = getExtensionData(ExtensionType.PausableAccount, account.tlvData);\n    if (extensionData !== null) {\n        return PausableAccountLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=state.js.map","import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n/** Buffer layout for de/serializing a mint */\nexport const PermanentDelegateLayout = struct([publicKey('delegate')]);\nexport const PERMANENT_DELEGATE_SIZE = PermanentDelegateLayout.span;\nexport function getPermanentDelegate(mint) {\n    const extensionData = getExtensionData(ExtensionType.PermanentDelegate, mint.tlvData);\n    if (extensionData !== null) {\n        return PermanentDelegateLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=permanentDelegate.js.map","import { struct, u8, f64 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { TransactionInstruction, PublicKey } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nexport var ScaledUiAmountInstruction;\n(function (ScaledUiAmountInstruction) {\n    ScaledUiAmountInstruction[ScaledUiAmountInstruction[\"Initialize\"] = 0] = \"Initialize\";\n    ScaledUiAmountInstruction[ScaledUiAmountInstruction[\"UpdateMultiplier\"] = 1] = \"UpdateMultiplier\";\n})(ScaledUiAmountInstruction || (ScaledUiAmountInstruction = {}));\nexport const initializeScaledUiAmountConfigInstructionData = struct([\n    u8('instruction'),\n    u8('scaledUiAmountInstruction'),\n    publicKey('authority'),\n    f64('multiplier'),\n]);\n/**\n * Construct an InitializeScaledUiAmountConfig instruction\n *\n * @param mint         Token mint account\n * @param authority    Optional authority that can update the multipliers\n * @param signers      The signer account(s)\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeScaledUiAmountConfigInstruction(mint, authority, multiplier, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(initializeScaledUiAmountConfigInstructionData.span);\n    initializeScaledUiAmountConfigInstructionData.encode({\n        instruction: TokenInstruction.ScaledUiAmountExtension,\n        scaledUiAmountInstruction: ScaledUiAmountInstruction.Initialize,\n        authority: authority ?? PublicKey.default,\n        multiplier: multiplier,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\nexport const updateMultiplierData = struct([\n    u8('instruction'),\n    u8('scaledUiAmountInstruction'),\n    f64('multiplier'),\n    u64('effectiveTimestamp'),\n]);\n/**\n * Construct an UpdateMultiplierData instruction\n *\n * @param mint                  Token mint account\n * @param authority             Optional authority that can update the multipliers\n * @param multiplier            New multiplier\n * @param effectiveTimestamp    Effective time stamp for the new multiplier\n * @param multiSigners          Signing accounts if `owner` is a multisig\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateMultiplierDataInstruction(mint, authority, multiplier, effectiveTimestamp, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(updateMultiplierData.span);\n    updateMultiplierData.encode({\n        instruction: TokenInstruction.ScaledUiAmountExtension,\n        scaledUiAmountInstruction: ScaledUiAmountInstruction.UpdateMultiplier,\n        multiplier,\n        effectiveTimestamp,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n//# sourceMappingURL=instructions.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createUpdateMultiplierDataInstruction } from './instructions.js';\n/**\n * Update scaled UI amount multiplier\n *\n * @param connection            Connection to use\n * @param payer                 Payer of the transaction fees\n * @param mint                  The token mint\n * @param owner                 Owner of the scaled UI amount mint\n * @param multiplier            New multiplier\n * @param effectiveTimestamp    Effective time stamp for the new multiplier\n * @param multiSigners          Signing accounts if `owner` is a multisig\n * @param confirmOptions        Options for confirming the transaction\n * @param programId             SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateMultiplier(connection, payer, mint, owner, multiplier, effectiveTimestamp, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createUpdateMultiplierDataInstruction(mint, ownerPublicKey, multiplier, effectiveTimestamp, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=actions.js.map","import { f64, struct } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nexport const ScaledUiAmountConfigLayout = struct([\n    publicKey('authority'),\n    f64('multiplier'),\n    u64('newMultiplierEffectiveTimestamp'),\n    f64('newMultiplier'),\n]);\nexport const SCALED_UI_AMOUNT_CONFIG_SIZE = ScaledUiAmountConfigLayout.span;\nexport function getScaledUiAmountConfig(mint) {\n    const extensionData = getExtensionData(ExtensionType.ScaledUiAmountConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return ScaledUiAmountConfigLayout.decode(extensionData);\n    }\n    return null;\n}\n//# sourceMappingURL=state.js.map","import { Layout } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nexport class COptionPublicKeyLayout extends Layout {\n    constructor(property) {\n        super(-1, property);\n        this.publicKeyLayout = publicKey();\n    }\n    decode(buffer, offset = 0) {\n        const option = buffer[offset];\n        if (option === 0) {\n            return null;\n        }\n        return this.publicKeyLayout.decode(buffer, offset + 1);\n    }\n    encode(src, buffer, offset = 0) {\n        if (src === null) {\n            buffer[offset] = 0;\n            return 1;\n        }\n        else {\n            buffer[offset] = 1;\n            this.publicKeyLayout.encode(src, buffer, offset + 1);\n            return 33;\n        }\n    }\n    getSpan(buffer, offset = 0) {\n        if (buffer) {\n            const option = buffer[offset];\n            return option === 0 ? 1 : 1 + this.publicKeyLayout.span;\n        }\n        throw new RangeError('Buffer must be provided');\n    }\n}\n//# sourceMappingURL=serialization.js.map","import { struct, u16, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, TokenUnsupportedInstructionError, } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { COptionPublicKeyLayout } from '../../serialization.js';\nexport var TransferFeeInstruction;\n(function (TransferFeeInstruction) {\n    TransferFeeInstruction[TransferFeeInstruction[\"InitializeTransferFeeConfig\"] = 0] = \"InitializeTransferFeeConfig\";\n    TransferFeeInstruction[TransferFeeInstruction[\"TransferCheckedWithFee\"] = 1] = \"TransferCheckedWithFee\";\n    TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromMint\"] = 2] = \"WithdrawWithheldTokensFromMint\";\n    TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromAccounts\"] = 3] = \"WithdrawWithheldTokensFromAccounts\";\n    TransferFeeInstruction[TransferFeeInstruction[\"HarvestWithheldTokensToMint\"] = 4] = \"HarvestWithheldTokensToMint\";\n    TransferFeeInstruction[TransferFeeInstruction[\"SetTransferFee\"] = 5] = \"SetTransferFee\";\n})(TransferFeeInstruction || (TransferFeeInstruction = {}));\n/** TODO: docs */\nexport const initializeTransferFeeConfigInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    new COptionPublicKeyLayout('transferFeeConfigAuthority'),\n    new COptionPublicKeyLayout('withdrawWithheldAuthority'),\n    u16('transferFeeBasisPoints'),\n    u64('maximumFee'),\n]);\n/**\n * Construct an InitializeTransferFeeConfig instruction\n *\n * @param mint            Token mint account\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee        Maximum fee assessed on transfers\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(78); // worst-case size\n    initializeTransferFeeConfigInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n        transferFeeConfigAuthority: transferFeeConfigAuthority,\n        withdrawWithheldAuthority: withdrawWithheldAuthority,\n        transferFeeBasisPoints: transferFeeBasisPoints,\n        maximumFee: maximumFee,\n    }, data);\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeTransferFeeConfigInstructionData.getSpan(data)),\n    });\n}\n/**\n * Decode an InitializeTransferFeeConfig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeTransferFeeConfigInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeTransferFeeConfigInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint }, data, } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializeTransferFeeConfig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked({ programId, keys: [mint], data, }) {\n    const { instruction, transferFeeInstruction, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee, } = initializeTransferFeeConfigInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            transferFeeConfigAuthority,\n            withdrawWithheldAuthority,\n            transferFeeBasisPoints,\n            maximumFee,\n        },\n    };\n}\nexport const transferCheckedWithFeeInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u64('amount'),\n    u8('decimals'),\n    u64('fee'),\n]);\n/**\n * Construct an TransferCheckedWithFee instruction\n *\n * @param source          The source account\n * @param mint            The token mint\n * @param destination     The destination account\n * @param authority       The source account's owner/delegate\n * @param signers         The signer account(s)\n * @param amount          The amount of tokens to transfer\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\n    transferCheckedWithFeeInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n        amount,\n        decimals,\n        fee,\n    }, data);\n    const keys = addSigners([\n        { pubkey: source, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: destination, isSigner: false, isWritable: true },\n    ], authority, multiSigners);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a TransferCheckedWithFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedWithFeeInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedWithFeeInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { source, mint, destination, authority, signers }, data, } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n/**\n * Decode a TransferCheckedWithFees instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedWithFeeInstructionUnchecked({ programId, keys: [source, mint, destination, authority, ...signers], data, }) {\n    const { instruction, transferFeeInstruction, amount, decimals, fee } = transferCheckedWithFeeInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            amount,\n            decimals,\n            fee,\n        },\n    };\n}\nexport const withdrawWithheldTokensFromMintInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n/**\n * Construct a WithdrawWithheldTokensFromMint instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority, signers = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\n    withdrawWithheldTokensFromMintInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint,\n    }, data);\n    const keys = addSigners([\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: destination, isSigner: false, isWritable: true },\n    ], authority, signers);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint, destination, authority, signers }, data, } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({ programId, keys: [mint, destination, authority, ...signers], data, }) {\n    const { instruction, transferFeeInstruction } = withdrawWithheldTokensFromMintInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\nexport const withdrawWithheldTokensFromAccountsInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u8('numTokenAccounts'),\n]);\n/**\n * Construct a WithdrawWithheldTokensFromAccounts instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\n    withdrawWithheldTokensFromAccountsInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n        numTokenAccounts: sources.length,\n    }, data);\n    const keys = addSigners([\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: destination, isSigner: false, isWritable: true },\n    ], authority, signers);\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint, destination, authority, signers, sources }, data, } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n            sources: sources ? sources : null,\n        },\n        data,\n    };\n}\n/**\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({ programId, keys, data, }) {\n    const { instruction, transferFeeInstruction, numTokenAccounts } = withdrawWithheldTokensFromAccountsInstructionData.decode(data);\n    const [mint, destination, authority, signers, sources] = [\n        keys[0],\n        keys[1],\n        keys[2],\n        keys.slice(3, 3 + numTokenAccounts),\n        keys.slice(-1 * numTokenAccounts),\n    ];\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            numTokenAccounts,\n        },\n    };\n}\nexport const harvestWithheldTokensToMintInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n/**\n * Construct a HarvestWithheldTokensToMint instruction\n *\n * @param mint              The token mint\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createHarvestWithheldTokensToMintInstruction(mint, sources, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\n    harvestWithheldTokensToMintInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint,\n    }, data);\n    const keys = [];\n    keys.push({ pubkey: mint, isSigner: false, isWritable: true });\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a HarvestWithheldTokensToMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint, sources }, data, } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data,\n    };\n}\n/**\n * Decode a HarvestWithheldTokensToMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked({ programId, keys: [mint, ...sources], data, }) {\n    const { instruction, transferFeeInstruction } = harvestWithheldTokensToMintInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\nexport const setTransferFeeInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u16('transferFeeBasisPoints'),\n    u64('maximumFee'),\n]);\n/**\n * Construct a SetTransferFeeInstruction instruction\n *\n * @param mint                      The token mint\n * @param authority                 The authority of the transfer fee\n * @param signers                   The signer account(s)\n * @param transferFeeBasisPoints    Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee                Maximum fee assessed on transfers\n * @param programID                 SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSetTransferFeeInstruction(mint, authority, signers, transferFeeBasisPoints, maximumFee, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(setTransferFeeInstructionData.span);\n    setTransferFeeInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.SetTransferFee,\n        transferFeeBasisPoints: transferFeeBasisPoints,\n        maximumFee: maximumFee,\n    }, data);\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, signers);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode an SetTransferFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSetTransferFeeInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== setTransferFeeInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint, authority, signers }, data, } = decodeSetTransferFeeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.SetTransferFee)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n/**\n * Decode a SetTransferFee instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSetTransferFeeInstructionUnchecked({ programId, keys: [mint, authority, ...signers], data, }) {\n    const { instruction, transferFeeInstruction, transferFeeBasisPoints, maximumFee } = setTransferFeeInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            transferFeeBasisPoints,\n            maximumFee,\n        },\n    };\n}\n//# sourceMappingURL=instructions.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createHarvestWithheldTokensToMintInstruction, createSetTransferFeeInstruction, createTransferCheckedWithFeeInstruction, createWithdrawWithheldTokensFromAccountsInstruction, createWithdrawWithheldTokensFromMintInstruction, } from './instructions.js';\n/**\n * Transfer tokens from one account to another, asserting the transfer fee, token mint, and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferCheckedWithFee(connection, payer, source, mint, destination, owner, amount, decimals, fee, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createTransferCheckedWithFeeInstruction(source, mint, destination, ownerPublicKey, amount, decimals, fee, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Withdraw withheld tokens from mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param destination    The destination account\n * @param authority      The mint's withdraw withheld tokens authority\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function withdrawWithheldTokensFromMint(connection, payer, mint, destination, authority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(createWithdrawWithheldTokensFromMintInstruction(mint, destination, authorityPublicKey, signers, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Withdraw withheld tokens from accounts\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param destination    The destination account\n * @param authority      The mint's withdraw withheld tokens authority\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param sources        Source accounts from which to withdraw withheld fees\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function withdrawWithheldTokensFromAccounts(connection, payer, mint, destination, authority, multiSigners, sources, confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authorityPublicKey, signers, sources, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Harvest withheld tokens from accounts to the mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param sources        Source accounts from which to withdraw withheld fees\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function harvestWithheldTokensToMint(connection, payer, mint, sources, confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const transaction = new Transaction().add(createHarvestWithheldTokensToMintInstruction(mint, sources, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n/**\n * Update transfer fee and maximum fee\n *\n * @param connection                Connection to use\n * @param payer                     Payer of the transaction fees\n * @param mint                      The token mint\n * @param authority                 The authority of the transfer fee\n * @param multiSigners              Signing accounts if `owner` is a multisig\n * @param transferFeeBasisPoints    Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee                Maximum fee assessed on transfers\n * @param confirmOptions            Options for confirming the transaction\n * @param programId                 SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function setTransferFee(connection, payer, mint, authority, multiSigners, transferFeeBasisPoints, maximumFee, confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(createSetTransferFeeInstruction(mint, authorityPublicKey, signers, transferFeeBasisPoints, maximumFee, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=actions.js.map","import { struct, u16 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nexport const MAX_FEE_BASIS_POINTS = 10000;\nexport const ONE_IN_BASIS_POINTS = BigInt(MAX_FEE_BASIS_POINTS);\n/** Buffer layout for de/serializing a transfer fee */\nexport function transferFeeLayout(property) {\n    return struct([u64('epoch'), u64('maximumFee'), u16('transferFeeBasisPoints')], property);\n}\n/** Calculate the transfer fee */\nexport function calculateFee(transferFee, preFeeAmount) {\n    const transferFeeBasisPoints = transferFee.transferFeeBasisPoints;\n    if (transferFeeBasisPoints === 0 || preFeeAmount === BigInt(0)) {\n        return BigInt(0);\n    }\n    else {\n        const numerator = preFeeAmount * BigInt(transferFeeBasisPoints);\n        const rawFee = (numerator + ONE_IN_BASIS_POINTS - BigInt(1)) / ONE_IN_BASIS_POINTS;\n        const fee = rawFee > transferFee.maximumFee ? transferFee.maximumFee : rawFee;\n        return BigInt(fee);\n    }\n}\n/** Buffer layout for de/serializing a transfer fee config extension */\nexport const TransferFeeConfigLayout = struct([\n    publicKey('transferFeeConfigAuthority'),\n    publicKey('withdrawWithheldAuthority'),\n    u64('withheldAmount'),\n    transferFeeLayout('olderTransferFee'),\n    transferFeeLayout('newerTransferFee'),\n]);\nexport const TRANSFER_FEE_CONFIG_SIZE = TransferFeeConfigLayout.span;\n/** Get the fee for given epoch */\nexport function getEpochFee(transferFeeConfig, epoch) {\n    if (epoch >= transferFeeConfig.newerTransferFee.epoch) {\n        return transferFeeConfig.newerTransferFee;\n    }\n    else {\n        return transferFeeConfig.olderTransferFee;\n    }\n}\n/** Calculate the fee for the given epoch and input amount */\nexport function calculateEpochFee(transferFeeConfig, epoch, preFeeAmount) {\n    const transferFee = getEpochFee(transferFeeConfig, epoch);\n    return calculateFee(transferFee, preFeeAmount);\n}\n/** Buffer layout for de/serializing */\nexport const TransferFeeAmountLayout = struct([u64('withheldAmount')]);\nexport const TRANSFER_FEE_AMOUNT_SIZE = TransferFeeAmountLayout.span;\nexport function getTransferFeeConfig(mint) {\n    const extensionData = getExtensionData(ExtensionType.TransferFeeConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return TransferFeeConfigLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\nexport function getTransferFeeAmount(account) {\n    const extensionData = getExtensionData(ExtensionType.TransferFeeAmount, account.tlvData);\n    if (extensionData !== null) {\n        return TransferFeeAmountLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=state.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const transferCheckedInstructionData = struct([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n/**\n * Construct a TransferChecked instruction\n *\n * @param source       Source account\n * @param mint         Mint account\n * @param destination  Destination account\n * @param owner        Owner of the source account\n * @param amount       Number of tokens to transfer\n * @param decimals     Number of decimals in transfer amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: source, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: destination, isSigner: false, isWritable: true },\n    ], owner, multiSigners);\n    const data = Buffer.alloc(transferCheckedInstructionData.span);\n    transferCheckedInstructionData.encode({\n        instruction: TokenInstruction.TransferChecked,\n        amount: BigInt(amount),\n        decimals,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a TransferChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { source, mint, destination, owner, multiSigners }, data, } = decodeTransferCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferChecked)\n        throw new TokenInvalidInstructionTypeError();\n    if (!source || !mint || !destination || !owner)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a TransferChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedInstructionUnchecked({ programId, keys: [source, mint, destination, owner, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data: transferCheckedInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=transferChecked.js.map","import { TokenTransferHookAccountDataNotFound, TokenTransferHookInvalidSeed } from '../../errors.js';\nconst DISCRIMINATOR_SPAN = 1;\nconst LITERAL_LENGTH_SPAN = 1;\nconst INSTRUCTION_ARG_OFFSET_SPAN = 1;\nconst INSTRUCTION_ARG_LENGTH_SPAN = 1;\nconst ACCOUNT_KEY_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_OFFSET_SPAN = 1;\nconst ACCOUNT_DATA_LENGTH_SPAN = 1;\nfunction unpackSeedLiteral(seeds) {\n    if (seeds.length < 1) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [length, ...rest] = seeds;\n    if (rest.length < length) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: Buffer.from(rest.slice(0, length)),\n        packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length,\n    };\n}\nfunction unpackSeedInstructionArg(seeds, instructionData) {\n    if (seeds.length < 2) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [index, length] = seeds;\n    if (instructionData.length < length + index) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: instructionData.subarray(index, index + length),\n        packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN,\n    };\n}\nfunction unpackSeedAccountKey(seeds, previousMetas) {\n    if (seeds.length < 1) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [index] = seeds;\n    if (previousMetas.length <= index) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: previousMetas[index].pubkey.toBuffer(),\n        packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN,\n    };\n}\nasync function unpackSeedAccountData(seeds, previousMetas, connection) {\n    if (seeds.length < 3) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [accountIndex, dataIndex, length] = seeds;\n    if (previousMetas.length <= accountIndex) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);\n    if (accountInfo == null) {\n        throw new TokenTransferHookAccountDataNotFound();\n    }\n    if (accountInfo.data.length < dataIndex + length) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: accountInfo.data.subarray(dataIndex, dataIndex + length),\n        packedLength: DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN,\n    };\n}\nasync function unpackFirstSeed(seeds, previousMetas, instructionData, connection) {\n    const [discriminator, ...rest] = seeds;\n    const remaining = new Uint8Array(rest);\n    switch (discriminator) {\n        case 0:\n            return null;\n        case 1:\n            return unpackSeedLiteral(remaining);\n        case 2:\n            return unpackSeedInstructionArg(remaining, instructionData);\n        case 3:\n            return unpackSeedAccountKey(remaining, previousMetas);\n        case 4:\n            return unpackSeedAccountData(remaining, previousMetas, connection);\n        default:\n            throw new TokenTransferHookInvalidSeed();\n    }\n}\nexport async function unpackSeeds(seeds, previousMetas, instructionData, connection) {\n    const unpackedSeeds = [];\n    let i = 0;\n    while (i < 32) {\n        const seed = await unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);\n        if (seed == null) {\n            break;\n        }\n        unpackedSeeds.push(seed.data);\n        i += seed.packedLength;\n    }\n    return unpackedSeeds;\n}\n//# sourceMappingURL=seeds.js.map","import { PUBLIC_KEY_LENGTH, PublicKey } from '@solana/web3.js';\nimport { TokenTransferHookAccountDataNotFound, TokenTransferHookInvalidPubkeyData, TokenTransferHookPubkeyDataTooSmall, TokenTransferHookAccountNotFound, } from '../../errors.js';\nexport async function unpackPubkeyData(keyDataConfig, previousMetas, instructionData, connection) {\n    const [discriminator, ...rest] = keyDataConfig;\n    const remaining = new Uint8Array(rest);\n    switch (discriminator) {\n        case 1:\n            return unpackPubkeyDataFromInstructionData(remaining, instructionData);\n        case 2:\n            return unpackPubkeyDataFromAccountData(remaining, previousMetas, connection);\n        default:\n            throw new TokenTransferHookInvalidPubkeyData();\n    }\n}\nfunction unpackPubkeyDataFromInstructionData(remaining, instructionData) {\n    if (remaining.length < 1) {\n        throw new TokenTransferHookInvalidPubkeyData();\n    }\n    const dataIndex = remaining[0];\n    if (instructionData.length < dataIndex + PUBLIC_KEY_LENGTH) {\n        throw new TokenTransferHookPubkeyDataTooSmall();\n    }\n    return new PublicKey(instructionData.subarray(dataIndex, dataIndex + PUBLIC_KEY_LENGTH));\n}\nasync function unpackPubkeyDataFromAccountData(remaining, previousMetas, connection) {\n    if (remaining.length < 2) {\n        throw new TokenTransferHookInvalidPubkeyData();\n    }\n    const [accountIndex, dataIndex] = remaining;\n    if (previousMetas.length <= accountIndex) {\n        throw new TokenTransferHookAccountDataNotFound();\n    }\n    const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);\n    if (accountInfo == null) {\n        throw new TokenTransferHookAccountNotFound();\n    }\n    if (accountInfo.data.length < dataIndex + PUBLIC_KEY_LENGTH) {\n        throw new TokenTransferHookPubkeyDataTooSmall();\n    }\n    return new PublicKey(accountInfo.data.subarray(dataIndex, dataIndex + PUBLIC_KEY_LENGTH));\n}\n//# sourceMappingURL=pubkeyData.js.map","import { blob, greedy, seq, struct, u32, u8 } from '@solana/buffer-layout';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TokenTransferHookAccountNotFound } from '../../errors.js';\nimport { unpackSeeds } from './seeds.js';\nimport { unpackPubkeyData } from './pubkeyData.js';\n/** Buffer layout for de/serializing a transfer hook extension */\nexport const TransferHookLayout = struct([publicKey('authority'), publicKey('programId')]);\nexport const TRANSFER_HOOK_SIZE = TransferHookLayout.span;\nexport function getTransferHook(mint) {\n    const extensionData = getExtensionData(ExtensionType.TransferHook, mint.tlvData);\n    if (extensionData !== null) {\n        return TransferHookLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\n/** Buffer layout for de/serializing a transfer hook account extension */\nexport const TransferHookAccountLayout = struct([bool('transferring')]);\nexport const TRANSFER_HOOK_ACCOUNT_SIZE = TransferHookAccountLayout.span;\nexport function getTransferHookAccount(account) {\n    const extensionData = getExtensionData(ExtensionType.TransferHookAccount, account.tlvData);\n    if (extensionData !== null) {\n        return TransferHookAccountLayout.decode(extensionData);\n    }\n    else {\n        return null;\n    }\n}\nexport function getExtraAccountMetaAddress(mint, programId) {\n    const seeds = [Buffer.from('extra-account-metas'), mint.toBuffer()];\n    return PublicKey.findProgramAddressSync(seeds, programId)[0];\n}\n/** Buffer layout for de/serializing an ExtraAccountMeta */\nexport const ExtraAccountMetaLayout = struct([\n    u8('discriminator'),\n    blob(32, 'addressConfig'),\n    bool('isSigner'),\n    bool('isWritable'),\n]);\n/** Buffer layout for de/serializing a list of ExtraAccountMeta prefixed by a u32 length */\nexport const ExtraAccountMetaListLayout = struct([\n    u32('count'),\n    seq(ExtraAccountMetaLayout, greedy(ExtraAccountMetaLayout.span), 'extraAccounts'),\n]);\n/** Buffer layout for de/serializing an ExtraAccountMetaAccountData */\nexport const ExtraAccountMetaAccountDataLayout = struct([\n    u64('instructionDiscriminator'),\n    u32('length'),\n    ExtraAccountMetaListLayout.replicate('extraAccountsList'),\n]);\n/** Unpack an extra account metas account and parse the data into a list of ExtraAccountMetas */\nexport function getExtraAccountMetas(account) {\n    const extraAccountsList = ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;\n    return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);\n}\n/** Take an ExtraAccountMeta and construct that into an actual AccountMeta */\nexport async function resolveExtraAccountMeta(connection, extraMeta, previousMetas, instructionData, transferHookProgramId) {\n    if (extraMeta.discriminator === 0) {\n        return {\n            pubkey: new PublicKey(extraMeta.addressConfig),\n            isSigner: extraMeta.isSigner,\n            isWritable: extraMeta.isWritable,\n        };\n    }\n    else if (extraMeta.discriminator === 2) {\n        const pubkey = await unpackPubkeyData(extraMeta.addressConfig, previousMetas, instructionData, connection);\n        return {\n            pubkey,\n            isSigner: extraMeta.isSigner,\n            isWritable: extraMeta.isWritable,\n        };\n    }\n    let programId = PublicKey.default;\n    if (extraMeta.discriminator === 1) {\n        programId = transferHookProgramId;\n    }\n    else {\n        const accountIndex = extraMeta.discriminator - (1 << 7);\n        if (previousMetas.length <= accountIndex) {\n            throw new TokenTransferHookAccountNotFound();\n        }\n        programId = previousMetas[accountIndex].pubkey;\n    }\n    const seeds = await unpackSeeds(extraMeta.addressConfig, previousMetas, instructionData, connection);\n    const pubkey = PublicKey.findProgramAddressSync(seeds, programId)[0];\n    return { pubkey, isSigner: extraMeta.isSigner, isWritable: extraMeta.isWritable };\n}\n//# sourceMappingURL=state.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { createTransferCheckedInstruction } from '../../instructions/transferChecked.js';\nimport { createTransferCheckedWithFeeInstruction } from '../transferFee/instructions.js';\nimport { getMint } from '../../state/mint.js';\nimport { getExtraAccountMetaAddress, getExtraAccountMetas, getTransferHook, resolveExtraAccountMeta } from './state.js';\nexport var TransferHookInstruction;\n(function (TransferHookInstruction) {\n    TransferHookInstruction[TransferHookInstruction[\"Initialize\"] = 0] = \"Initialize\";\n    TransferHookInstruction[TransferHookInstruction[\"Update\"] = 1] = \"Update\";\n})(TransferHookInstruction || (TransferHookInstruction = {}));\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeTransferHookInstructionData = struct([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('authority'),\n    publicKey('transferHookProgramId'),\n]);\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(initializeTransferHookInstructionData.span);\n    initializeTransferHookInstructionData.encode({\n        instruction: TokenInstruction.TransferHookExtension,\n        transferHookInstruction: TransferHookInstruction.Initialize,\n        authority,\n        transferHookProgramId,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/** The struct that represents the instruction data as it is read by the program */\nexport const updateTransferHookInstructionData = struct([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('transferHookProgramId'),\n]);\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateTransferHookInstruction(mint, authority, transferHookProgramId, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(updateTransferHookInstructionData.span);\n    updateTransferHookInstructionData.encode({\n        instruction: TokenInstruction.TransferHookExtension,\n        transferHookInstruction: TransferHookInstruction.Update,\n        transferHookProgramId,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\nfunction deEscalateAccountMeta(accountMeta, accountMetas) {\n    const maybeHighestPrivileges = accountMetas\n        .filter(x => x.pubkey.equals(accountMeta.pubkey))\n        .reduce((acc, x) => {\n        if (!acc)\n            return { isSigner: x.isSigner, isWritable: x.isWritable };\n        return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };\n    }, undefined);\n    if (maybeHighestPrivileges) {\n        const { isSigner, isWritable } = maybeHighestPrivileges;\n        if (!isSigner && isSigner !== accountMeta.isSigner) {\n            accountMeta.isSigner = false;\n        }\n        if (!isWritable && isWritable !== accountMeta.isWritable) {\n            accountMeta.isWritable = false;\n        }\n    }\n    return accountMeta;\n}\n/**\n * Construct an `ExecuteInstruction` for a transfer hook program, without the\n * additional accounts\n *\n * @param programId             The program ID of the transfer hook program\n * @param source                The source account\n * @param mint                  The mint account\n * @param destination           The destination account\n * @param owner                 Owner of the source account\n * @param validateStatePubkey   The validate state pubkey\n * @param amount                The amount of tokens to transfer\n * @returns Instruction to add to a transaction\n */\nexport function createExecuteInstruction(programId, source, mint, destination, owner, validateStatePubkey, amount) {\n    const keys = [source, mint, destination, owner, validateStatePubkey].map(pubkey => ({\n        pubkey,\n        isSigner: false,\n        isWritable: false,\n    }));\n    const data = Buffer.alloc(16);\n    data.set(Buffer.from([105, 37, 101, 197, 75, 251, 102, 26]), 0); // `ExecuteInstruction` discriminator\n    data.writeBigUInt64LE(BigInt(amount), 8);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Adds all the extra accounts needed for a transfer hook to an instruction.\n *\n * Note this will modify the instruction passed in.\n *\n * @param connection            Connection to use\n * @param instruction           The instruction to add accounts to\n * @param programId             Transfer hook program ID\n * @param source                The source account\n * @param mint                  The mint account\n * @param destination           The destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param commitment            Commitment to use\n */\nexport async function addExtraAccountMetasForExecute(connection, instruction, programId, source, mint, destination, owner, amount, commitment) {\n    const validateStatePubkey = getExtraAccountMetaAddress(mint, programId);\n    const validateStateAccount = await connection.getAccountInfo(validateStatePubkey, commitment);\n    if (validateStateAccount == null) {\n        return instruction;\n    }\n    const validateStateData = getExtraAccountMetas(validateStateAccount);\n    // Check to make sure the provided keys are in the instruction\n    if (![source, mint, destination, owner].every(key => instruction.keys.some(meta => meta.pubkey.equals(key)))) {\n        throw new Error('Missing required account in instruction');\n    }\n    const executeInstruction = createExecuteInstruction(programId, source, mint, destination, owner, validateStatePubkey, BigInt(amount));\n    for (const extraAccountMeta of validateStateData) {\n        executeInstruction.keys.push(deEscalateAccountMeta(await resolveExtraAccountMeta(connection, extraAccountMeta, executeInstruction.keys, executeInstruction.data, executeInstruction.programId), executeInstruction.keys));\n    }\n    // Add only the extra accounts resolved from the validation state\n    instruction.keys.push(...executeInstruction.keys.slice(5));\n    // Add the transfer hook program ID and the validation state account\n    instruction.keys.push({ pubkey: programId, isSigner: false, isWritable: false });\n    instruction.keys.push({ pubkey: validateStatePubkey, isSigner: false, isWritable: false });\n}\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, owner, amount, decimals, multiSigners = [], commitment, programId = TOKEN_PROGRAM_ID) {\n    const instruction = createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners, programId);\n    const mintInfo = await getMint(connection, mint, commitment, programId);\n    const transferHook = getTransferHook(mintInfo);\n    if (transferHook) {\n        await addExtraAccountMetasForExecute(connection, instruction, transferHook.programId, source, mint, destination, owner, amount, commitment);\n    }\n    return instruction;\n}\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, owner, amount, decimals, fee, multiSigners = [], commitment, programId = TOKEN_PROGRAM_ID) {\n    const instruction = createTransferCheckedWithFeeInstruction(source, mint, destination, owner, amount, decimals, fee, multiSigners, programId);\n    const mintInfo = await getMint(connection, mint, commitment, programId);\n    const transferHook = getTransferHook(mintInfo);\n    if (transferHook) {\n        await addExtraAccountMetasForExecute(connection, instruction, transferHook.programId, source, mint, destination, owner, amount, commitment);\n    }\n    return instruction;\n}\n//# sourceMappingURL=instructions.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { createInitializeTransferHookInstruction, createTransferCheckedWithFeeAndTransferHookInstruction, createTransferCheckedWithTransferHookInstruction, createUpdateTransferHookInstruction, } from './instructions.js';\n/**\n * Initialize a transfer hook on a mint\n *\n * @param connection            Connection to use\n * @param payer                 Payer of the transaction fees\n * @param mint                  Mint to initialize with extension\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId The transfer hook program account\n * @param confirmOptions        Options for confirming the transaction\n * @param programId             SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function initializeTransferHook(connection, payer, mint, authority, transferHookProgramId, confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const transaction = new Transaction().add(createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n/**\n * Update the transfer hook program on a mint\n *\n * @param connection            Connection to use\n * @param payer                 Payer of the transaction fees\n * @param mint                  Mint to modify\n * @param transferHookProgramId New transfer hook program account\n * @param authority             Transfer hook update authority\n * @param multiSigners          Signing accounts if `freezeAuthority` is a multisig\n * @param confirmOptions        Options for confirming the transaction\n * @param programId             SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateTransferHook(connection, payer, mint, transferHookProgramId, authority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(createUpdateTransferHookInstruction(mint, authorityPublicKey, transferHookProgramId, signers, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Transfer tokens from one account to another, asserting the token mint, and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param authority      Authority of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferCheckedWithTransferHook(connection, payer, source, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(await createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, authorityPublicKey, amount, decimals, signers, confirmOptions?.commitment, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Transfer tokens from one account to another, asserting the transfer fee, token mint, and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param authority      Authority of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param fee            The calculated fee for the transfer fee extension\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferCheckedWithFeeAndTransferHook(connection, payer, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(await createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, authorityPublicKey, amount, decimals, fee, signers, confirmOptions?.commitment, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=actions.js.map","import { ACCOUNT_SIZE } from '../state/account.js';\nimport { MINT_SIZE, unpackMint } from '../state/mint.js';\nimport { MULTISIG_SIZE } from '../state/multisig.js';\nimport { ACCOUNT_TYPE_SIZE } from './accountType.js';\nimport { CPI_GUARD_SIZE } from './cpiGuard/index.js';\nimport { DEFAULT_ACCOUNT_STATE_SIZE } from './defaultAccountState/index.js';\nimport { TOKEN_GROUP_SIZE, TOKEN_GROUP_MEMBER_SIZE } from './tokenGroup/index.js';\nimport { GROUP_MEMBER_POINTER_SIZE } from './groupMemberPointer/state.js';\nimport { GROUP_POINTER_SIZE } from './groupPointer/state.js';\nimport { IMMUTABLE_OWNER_SIZE } from './immutableOwner.js';\nimport { INTEREST_BEARING_MINT_CONFIG_STATE_SIZE } from './interestBearingMint/state.js';\nimport { MEMO_TRANSFER_SIZE } from './memoTransfer/index.js';\nimport { METADATA_POINTER_SIZE } from './metadataPointer/state.js';\nimport { MINT_CLOSE_AUTHORITY_SIZE } from './mintCloseAuthority.js';\nimport { NON_TRANSFERABLE_SIZE, NON_TRANSFERABLE_ACCOUNT_SIZE } from './nonTransferable.js';\nimport { PAUSABLE_CONFIG_SIZE, PAUSABLE_ACCOUNT_SIZE } from './pausable/index.js';\nimport { PERMANENT_DELEGATE_SIZE } from './permanentDelegate.js';\nimport { SCALED_UI_AMOUNT_CONFIG_SIZE } from './scaledUiAmount/index.js';\nimport { TRANSFER_FEE_AMOUNT_SIZE, TRANSFER_FEE_CONFIG_SIZE } from './transferFee/index.js';\nimport { TRANSFER_HOOK_ACCOUNT_SIZE, TRANSFER_HOOK_SIZE } from './transferHook/index.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../constants.js';\n// Sequence from https://github.com/solana-labs/solana-program-library/blob/master/token/program-2022/src/extension/mod.rs#L903\nexport var ExtensionType;\n(function (ExtensionType) {\n    ExtensionType[ExtensionType[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    ExtensionType[ExtensionType[\"TransferFeeConfig\"] = 1] = \"TransferFeeConfig\";\n    ExtensionType[ExtensionType[\"TransferFeeAmount\"] = 2] = \"TransferFeeAmount\";\n    ExtensionType[ExtensionType[\"MintCloseAuthority\"] = 3] = \"MintCloseAuthority\";\n    ExtensionType[ExtensionType[\"ConfidentialTransferMint\"] = 4] = \"ConfidentialTransferMint\";\n    ExtensionType[ExtensionType[\"ConfidentialTransferAccount\"] = 5] = \"ConfidentialTransferAccount\";\n    ExtensionType[ExtensionType[\"DefaultAccountState\"] = 6] = \"DefaultAccountState\";\n    ExtensionType[ExtensionType[\"ImmutableOwner\"] = 7] = \"ImmutableOwner\";\n    ExtensionType[ExtensionType[\"MemoTransfer\"] = 8] = \"MemoTransfer\";\n    ExtensionType[ExtensionType[\"NonTransferable\"] = 9] = \"NonTransferable\";\n    ExtensionType[ExtensionType[\"InterestBearingConfig\"] = 10] = \"InterestBearingConfig\";\n    ExtensionType[ExtensionType[\"CpiGuard\"] = 11] = \"CpiGuard\";\n    ExtensionType[ExtensionType[\"PermanentDelegate\"] = 12] = \"PermanentDelegate\";\n    ExtensionType[ExtensionType[\"NonTransferableAccount\"] = 13] = \"NonTransferableAccount\";\n    ExtensionType[ExtensionType[\"TransferHook\"] = 14] = \"TransferHook\";\n    ExtensionType[ExtensionType[\"TransferHookAccount\"] = 15] = \"TransferHookAccount\";\n    // ConfidentialTransferFee, // Not implemented yet\n    // ConfidentialTransferFeeAmount, // Not implemented yet\n    ExtensionType[ExtensionType[\"MetadataPointer\"] = 18] = \"MetadataPointer\";\n    ExtensionType[ExtensionType[\"TokenMetadata\"] = 19] = \"TokenMetadata\";\n    ExtensionType[ExtensionType[\"GroupPointer\"] = 20] = \"GroupPointer\";\n    ExtensionType[ExtensionType[\"TokenGroup\"] = 21] = \"TokenGroup\";\n    ExtensionType[ExtensionType[\"GroupMemberPointer\"] = 22] = \"GroupMemberPointer\";\n    ExtensionType[ExtensionType[\"TokenGroupMember\"] = 23] = \"TokenGroupMember\";\n    // ConfidentialMintBurn, // Not implemented yet\n    ExtensionType[ExtensionType[\"ScaledUiAmountConfig\"] = 25] = \"ScaledUiAmountConfig\";\n    ExtensionType[ExtensionType[\"PausableConfig\"] = 26] = \"PausableConfig\";\n    ExtensionType[ExtensionType[\"PausableAccount\"] = 27] = \"PausableAccount\";\n})(ExtensionType || (ExtensionType = {}));\nexport const TYPE_SIZE = 2;\nexport const LENGTH_SIZE = 2;\nfunction addTypeAndLengthToLen(len) {\n    return len + TYPE_SIZE + LENGTH_SIZE;\n}\nfunction isVariableLengthExtension(e) {\n    switch (e) {\n        case ExtensionType.TokenMetadata:\n            return true;\n        default:\n            return false;\n    }\n}\n// NOTE: All of these should eventually use their type's Span instead of these\n// constants.  This is provided for at least creation to work.\nexport function getTypeLen(e) {\n    switch (e) {\n        case ExtensionType.Uninitialized:\n            return 0;\n        case ExtensionType.TransferFeeConfig:\n            return TRANSFER_FEE_CONFIG_SIZE;\n        case ExtensionType.TransferFeeAmount:\n            return TRANSFER_FEE_AMOUNT_SIZE;\n        case ExtensionType.MintCloseAuthority:\n            return MINT_CLOSE_AUTHORITY_SIZE;\n        case ExtensionType.ConfidentialTransferMint:\n            return 65;\n        case ExtensionType.ConfidentialTransferAccount:\n            return 295;\n        case ExtensionType.CpiGuard:\n            return CPI_GUARD_SIZE;\n        case ExtensionType.DefaultAccountState:\n            return DEFAULT_ACCOUNT_STATE_SIZE;\n        case ExtensionType.ImmutableOwner:\n            return IMMUTABLE_OWNER_SIZE;\n        case ExtensionType.MemoTransfer:\n            return MEMO_TRANSFER_SIZE;\n        case ExtensionType.MetadataPointer:\n            return METADATA_POINTER_SIZE;\n        case ExtensionType.NonTransferable:\n            return NON_TRANSFERABLE_SIZE;\n        case ExtensionType.InterestBearingConfig:\n            return INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;\n        case ExtensionType.PermanentDelegate:\n            return PERMANENT_DELEGATE_SIZE;\n        case ExtensionType.NonTransferableAccount:\n            return NON_TRANSFERABLE_ACCOUNT_SIZE;\n        case ExtensionType.TransferHook:\n            return TRANSFER_HOOK_SIZE;\n        case ExtensionType.TransferHookAccount:\n            return TRANSFER_HOOK_ACCOUNT_SIZE;\n        case ExtensionType.GroupPointer:\n            return GROUP_POINTER_SIZE;\n        case ExtensionType.GroupMemberPointer:\n            return GROUP_MEMBER_POINTER_SIZE;\n        case ExtensionType.TokenGroup:\n            return TOKEN_GROUP_SIZE;\n        case ExtensionType.TokenGroupMember:\n            return TOKEN_GROUP_MEMBER_SIZE;\n        case ExtensionType.ScaledUiAmountConfig:\n            return SCALED_UI_AMOUNT_CONFIG_SIZE;\n        case ExtensionType.PausableConfig:\n            return PAUSABLE_CONFIG_SIZE;\n        case ExtensionType.PausableAccount:\n            return PAUSABLE_ACCOUNT_SIZE;\n        case ExtensionType.TokenMetadata:\n            throw Error(`Cannot get type length for variable extension type: ${e}`);\n        default:\n            throw Error(`Unknown extension type: ${e}`);\n    }\n}\nexport function isMintExtension(e) {\n    switch (e) {\n        case ExtensionType.TransferFeeConfig:\n        case ExtensionType.MintCloseAuthority:\n        case ExtensionType.ConfidentialTransferMint:\n        case ExtensionType.DefaultAccountState:\n        case ExtensionType.NonTransferable:\n        case ExtensionType.InterestBearingConfig:\n        case ExtensionType.PermanentDelegate:\n        case ExtensionType.TransferHook:\n        case ExtensionType.MetadataPointer:\n        case ExtensionType.TokenMetadata:\n        case ExtensionType.GroupPointer:\n        case ExtensionType.GroupMemberPointer:\n        case ExtensionType.TokenGroup:\n        case ExtensionType.TokenGroupMember:\n        case ExtensionType.ScaledUiAmountConfig:\n        case ExtensionType.PausableConfig:\n            return true;\n        case ExtensionType.Uninitialized:\n        case ExtensionType.TransferFeeAmount:\n        case ExtensionType.ConfidentialTransferAccount:\n        case ExtensionType.ImmutableOwner:\n        case ExtensionType.MemoTransfer:\n        case ExtensionType.CpiGuard:\n        case ExtensionType.NonTransferableAccount:\n        case ExtensionType.TransferHookAccount:\n        case ExtensionType.PausableAccount:\n            return false;\n        default:\n            throw Error(`Unknown extension type: ${e}`);\n    }\n}\nexport function isAccountExtension(e) {\n    switch (e) {\n        case ExtensionType.TransferFeeAmount:\n        case ExtensionType.ConfidentialTransferAccount:\n        case ExtensionType.ImmutableOwner:\n        case ExtensionType.MemoTransfer:\n        case ExtensionType.CpiGuard:\n        case ExtensionType.NonTransferableAccount:\n        case ExtensionType.TransferHookAccount:\n        case ExtensionType.PausableAccount:\n            return true;\n        case ExtensionType.Uninitialized:\n        case ExtensionType.TransferFeeConfig:\n        case ExtensionType.MintCloseAuthority:\n        case ExtensionType.ConfidentialTransferMint:\n        case ExtensionType.DefaultAccountState:\n        case ExtensionType.NonTransferable:\n        case ExtensionType.InterestBearingConfig:\n        case ExtensionType.PermanentDelegate:\n        case ExtensionType.TransferHook:\n        case ExtensionType.MetadataPointer:\n        case ExtensionType.TokenMetadata:\n        case ExtensionType.GroupPointer:\n        case ExtensionType.GroupMemberPointer:\n        case ExtensionType.TokenGroup:\n        case ExtensionType.TokenGroupMember:\n        case ExtensionType.ScaledUiAmountConfig:\n        case ExtensionType.PausableConfig:\n            return false;\n        default:\n            throw Error(`Unknown extension type: ${e}`);\n    }\n}\nexport function getAccountTypeOfMintType(e) {\n    switch (e) {\n        case ExtensionType.TransferFeeConfig:\n            return ExtensionType.TransferFeeAmount;\n        case ExtensionType.ConfidentialTransferMint:\n            return ExtensionType.ConfidentialTransferAccount;\n        case ExtensionType.NonTransferable:\n            return ExtensionType.NonTransferableAccount;\n        case ExtensionType.TransferHook:\n            return ExtensionType.TransferHookAccount;\n        case ExtensionType.PausableConfig:\n            return ExtensionType.PausableAccount;\n        case ExtensionType.TransferFeeAmount:\n        case ExtensionType.ConfidentialTransferAccount:\n        case ExtensionType.CpiGuard:\n        case ExtensionType.DefaultAccountState:\n        case ExtensionType.ImmutableOwner:\n        case ExtensionType.MemoTransfer:\n        case ExtensionType.MintCloseAuthority:\n        case ExtensionType.MetadataPointer:\n        case ExtensionType.TokenMetadata:\n        case ExtensionType.Uninitialized:\n        case ExtensionType.InterestBearingConfig:\n        case ExtensionType.PermanentDelegate:\n        case ExtensionType.NonTransferableAccount:\n        case ExtensionType.TransferHookAccount:\n        case ExtensionType.GroupPointer:\n        case ExtensionType.GroupMemberPointer:\n        case ExtensionType.TokenGroup:\n        case ExtensionType.TokenGroupMember:\n        case ExtensionType.ScaledUiAmountConfig:\n        case ExtensionType.PausableAccount:\n            return ExtensionType.Uninitialized;\n    }\n}\nfunction getLen(extensionTypes, baseSize, variableLengthExtensions = {}) {\n    if (extensionTypes.length === 0 && Object.keys(variableLengthExtensions).length === 0) {\n        return baseSize;\n    }\n    else {\n        const accountLength = ACCOUNT_SIZE +\n            ACCOUNT_TYPE_SIZE +\n            extensionTypes\n                .filter((element, i) => i === extensionTypes.indexOf(element))\n                .map(element => addTypeAndLengthToLen(getTypeLen(element)))\n                .reduce((a, b) => a + b, 0) +\n            Object.entries(variableLengthExtensions)\n                .map(([extension, len]) => {\n                if (!isVariableLengthExtension(Number(extension))) {\n                    throw Error(`Extension ${extension} is not variable length`);\n                }\n                return addTypeAndLengthToLen(len);\n            })\n                .reduce((a, b) => a + b, 0);\n        if (accountLength === MULTISIG_SIZE) {\n            return accountLength + TYPE_SIZE;\n        }\n        else {\n            return accountLength;\n        }\n    }\n}\nexport function getMintLen(extensionTypes, variableLengthExtensions = {}) {\n    return getLen(extensionTypes, MINT_SIZE, variableLengthExtensions);\n}\nexport function getAccountLen(extensionTypes) {\n    // There are currently no variable length extensions for accounts\n    return getLen(extensionTypes, ACCOUNT_SIZE);\n}\nexport function getExtensionData(extension, tlvData) {\n    let extensionTypeIndex = 0;\n    while (addTypeAndLengthToLen(extensionTypeIndex) <= tlvData.length) {\n        const entryType = tlvData.readUInt16LE(extensionTypeIndex);\n        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + TYPE_SIZE);\n        const typeIndex = addTypeAndLengthToLen(extensionTypeIndex);\n        if (entryType == extension) {\n            return tlvData.slice(typeIndex, typeIndex + entryLength);\n        }\n        extensionTypeIndex = typeIndex + entryLength;\n    }\n    return null;\n}\nexport function getExtensionTypes(tlvData) {\n    const extensionTypes = [];\n    let extensionTypeIndex = 0;\n    while (extensionTypeIndex < tlvData.length) {\n        const entryType = tlvData.readUInt16LE(extensionTypeIndex);\n        extensionTypes.push(entryType);\n        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + TYPE_SIZE);\n        extensionTypeIndex += addTypeAndLengthToLen(entryLength);\n    }\n    return extensionTypes;\n}\nexport function getAccountLenForMint(mint) {\n    const extensionTypes = getExtensionTypes(mint.tlvData);\n    const accountExtensions = extensionTypes.map(getAccountTypeOfMintType);\n    return getAccountLen(accountExtensions);\n}\nexport function getNewAccountLenForExtensionLen(info, address, extensionType, extensionLen, programId = TOKEN_2022_PROGRAM_ID) {\n    const mint = unpackMint(address, info, programId);\n    const extensionData = getExtensionData(extensionType, mint.tlvData);\n    const currentExtensionLen = extensionData ? addTypeAndLengthToLen(extensionData.length) : 0;\n    const newExtensionLen = addTypeAndLengthToLen(extensionLen);\n    return info.data.length + newExtensionLen - currentExtensionLen;\n}\n//# sourceMappingURL=extensionType.js.map","import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError, TokenInvalidMintError, TokenOwnerOffCurveError, } from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport { getMintLen } from '../extensions/extensionType.js';\nimport { ACCOUNT_SIZE } from './account.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n/** Buffer layout for de/serializing a mint */\nexport const MintLayout = struct([\n    u32('mintAuthorityOption'),\n    publicKey('mintAuthority'),\n    u64('supply'),\n    u8('decimals'),\n    bool('isInitialized'),\n    u32('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n/** Byte length of a mint */\nexport const MINT_SIZE = MintLayout.span;\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nexport async function getMint(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackMint(address, info, programId);\n}\n/**\n * Unpack a mint\n *\n * @param address   Mint account\n * @param info      Mint account data\n * @param programId SPL Token program account\n *\n * @return Unpacked mint\n */\nexport function unpackMint(address, info, programId = TOKEN_PROGRAM_ID) {\n    if (!info)\n        throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId))\n        throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < MINT_SIZE)\n        throw new TokenInvalidAccountSizeError();\n    const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > MINT_SIZE) {\n        if (info.data.length <= ACCOUNT_SIZE)\n            throw new TokenInvalidAccountSizeError();\n        if (info.data.length === MULTISIG_SIZE)\n            throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Mint)\n            throw new TokenInvalidMintError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n    return {\n        address,\n        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n        supply: rawMint.supply,\n        decimals: rawMint.decimals,\n        isInitialized: rawMint.isInitialized,\n        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n        tlvData,\n    };\n}\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMint(connection, commitment) {\n    return await getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\n}\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\n *\n * @param connection Connection to use\n * @param extensions Extension types included in the mint\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {\n    const mintLen = getMintLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(mintLen, commitment);\n}\n/**\n * Async version of getAssociatedTokenAddressSync\n * For backwards compatibility\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Promise containing the address of the associated token account\n */\nexport async function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))\n        throw new TokenOwnerOffCurveError();\n    const [address] = await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n    return address;\n}\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nexport function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))\n        throw new TokenOwnerOffCurveError();\n    const [address] = PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n    return address;\n}\n//# sourceMappingURL=mint.js.map","import { PublicKey, Transaction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAmountToUiAmountInstruction } from '../instructions/amountToUiAmount.js';\nimport { unpackMint } from '../state/mint.js';\nimport { getInterestBearingMintConfigState } from '../extensions/interestBearingMint/state.js';\nimport { getScaledUiAmountConfig } from '../extensions/scaledUiAmount/state.js';\n// Constants for interest calculations\nconst ONE_IN_BASIS_POINTS = 10000;\nconst SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\n/**\n * Amount as a string using mint-prescribed decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param amount         Amount of tokens to be converted to Ui Amount\n * @param programId      SPL Token program account\n *\n * @return Ui Amount generated or error\n */\nexport async function amountToUiAmount(connection, payer, mint, amount, programId = TOKEN_PROGRAM_ID) {\n    const transaction = new Transaction().add(createAmountToUiAmountInstruction(mint, amount, programId));\n    const { returnData, err } = (await connection.simulateTransaction(transaction, [payer], false)).value;\n    if (returnData?.data) {\n        return Buffer.from(returnData.data[0], returnData.data[1]).toString('utf-8');\n    }\n    return err;\n}\n/**\n * Calculates the exponent for the interest rate formula.\n * @param t1 - The start time in seconds.\n * @param t2 - The end time in seconds.\n * @param r - The interest rate in basis points.\n * @returns The calculated exponent.\n */\nfunction calculateExponentForTimesAndRate(t1, t2, r) {\n    const timespan = t2 - t1;\n    const numerator = r * timespan;\n    const exponent = numerator / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS);\n    return Math.exp(exponent);\n}\n/**\n * Retrieves the current timestamp from the Solana clock sysvar.\n * @param connection - The Solana connection object.\n * @returns A promise that resolves to the current timestamp in seconds.\n * @throws An error if the sysvar clock cannot be fetched or parsed.\n */\nasync function getSysvarClockTimestamp(connection) {\n    const info = await connection.getParsedAccountInfo(SYSVAR_CLOCK_PUBKEY);\n    if (!info?.value) {\n        throw new Error('Failed to fetch sysvar clock');\n    }\n    if (typeof info.value === 'object' && 'data' in info.value && 'parsed' in info.value.data) {\n        return info.value.data.parsed.info.unixTimestamp;\n    }\n    throw new Error('Failed to parse sysvar clock');\n}\n/**\n * Calculates the decimal factor for a given number of decimals\n * @param decimals - Number of decimals\n * @returns The decimal factor (e.g., 100 for 2 decimals)\n */\nfunction getDecimalFactor(decimals) {\n    return Math.pow(10, decimals);\n}\n/**\n * Convert a UI amount to an atomic amount by removing decimal scaling\n * For example, converts \"1.234\" with 3 decimals to 1234 (atomic units)\n *\n * @param uiAmount       UI Amount to be converted to atomic UI amount\n * @param decimals       Number of decimals for the mint\n *\n * @return Atomic UI amount\n */\nfunction uiAmountToAtomicUiAmount(uiAmount, decimals) {\n    const uiAmountNumber = parseFloat(uiAmount);\n    const decimalFactor = getDecimalFactor(decimals);\n    return uiAmountNumber * decimalFactor;\n}\n/**\n * Convert amount to UiAmount for a mint with interest bearing extension without simulating a transaction\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n *\n * Formula: A = P * e^(r * t) where\n * A = final amount after interest\n * P = principal amount (initial investment)\n * r = annual interest rate (as a decimal)\n * t = time in years\n * e = mathematical constant (~2.718)\n *\n * In this case, we are calculating the total scale factor for the interest bearing extension which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 and r2 are the interest rates before and after the last update, and t1 and t2 are the times in years between\n * the initialization timestamp and the last update timestamp, and between the last update timestamp and the current timestamp.\n *\n * @param amount                   Amount of tokens to be converted\n * @param decimals                 Number of decimals of the mint\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points (1 basis point = 0.01%) before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @return Amount scaled by accrued interest as a string with appropriate decimal places\n */\nexport function amountToUiAmountForInterestBearingMintWithoutSimulation(amount, decimals, currentTimestamp, // in seconds\nlastUpdateTimestamp, initializationTimestamp, preUpdateAverageRate, currentRate) {\n    // Calculate pre-update exponent (interest accrued from initialization to last update)\n    const preUpdateExp = calculateExponentForTimesAndRate(initializationTimestamp, lastUpdateTimestamp, preUpdateAverageRate);\n    // Calculate post-update exponent (interest accrued from last update to current time)\n    const postUpdateExp = calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);\n    // Calculate total scale factor\n    const totalScale = preUpdateExp * postUpdateExp;\n    // Scale the amount by the total interest factor\n    const scaledAmount = Number(amount) * totalScale;\n    // Calculate the decimal factor (e.g. 100 for 2 decimals)\n    const decimalFactor = getDecimalFactor(decimals);\n    // Convert to UI amount by truncating and dividing by decimal factor\n    return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n/**\n * Convert amount to UiAmount for a mint with scaled UI amount extension\n * @param amount     Amount of tokens to be converted\n * @param decimals   Number of decimals of the mint\n * @param multiplier Multiplier to scale the amount\n * @return Scaled UI amount as a string\n */\nexport function amountToUiAmountForScaledUiAmountMintWithoutSimulation(amount, decimals, multiplier) {\n    const scaledAmount = Number(amount) * multiplier;\n    const decimalFactor = getDecimalFactor(decimals);\n    return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n/**\n * Convert amount to UiAmount for a mint without simulating a transaction\n * This implements the same logic as `process_amount_to_ui_amount` in /token/program-2022/src/processor.rs\n * and `process_amount_to_ui_amount` in /token/program/src/processor.rs\n *\n * @param connection     Connection to use\n * @param mint           Mint to use for calculations\n * @param amount         Amount of tokens to be converted to Ui Amount\n *\n * @return Ui Amount generated\n */\nexport async function amountToUiAmountForMintWithoutSimulation(connection, mint, amount) {\n    const accountInfo = await connection.getAccountInfo(mint);\n    const programId = accountInfo?.owner;\n    if (!programId?.equals(TOKEN_PROGRAM_ID) && !programId?.equals(TOKEN_2022_PROGRAM_ID)) {\n        throw new Error('Invalid program ID');\n    }\n    const mintInfo = unpackMint(mint, accountInfo, programId);\n    // Check for interest bearing mint extension\n    const interestBearingMintConfigState = getInterestBearingMintConfigState(mintInfo);\n    // Check for scaled UI amount extension\n    const scaledUiAmountConfig = getScaledUiAmountConfig(mintInfo);\n    // Standard conversion for regular mints\n    if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n        const decimalFactor = getDecimalFactor(mintInfo.decimals);\n        return (Number(amount) / decimalFactor).toString();\n    }\n    // Get timestamp only if needed for special mint types\n    const timestamp = await getSysvarClockTimestamp(connection);\n    // Handle interest bearing mint\n    if (interestBearingMintConfigState) {\n        return amountToUiAmountForInterestBearingMintWithoutSimulation(amount, mintInfo.decimals, timestamp, Number(interestBearingMintConfigState.lastUpdateTimestamp), Number(interestBearingMintConfigState.initializationTimestamp), interestBearingMintConfigState.preUpdateAverageRate, interestBearingMintConfigState.currentRate);\n    }\n    // At this point, we know it must be a scaled UI amount mint\n    let multiplier = scaledUiAmountConfig.multiplier;\n    if (timestamp >= Number(scaledUiAmountConfig.newMultiplierEffectiveTimestamp)) {\n        multiplier = scaledUiAmountConfig.newMultiplier;\n    }\n    return amountToUiAmountForScaledUiAmountMintWithoutSimulation(amount, mintInfo.decimals, multiplier);\n}\n/**\n * Convert an amount with interest back to the original amount without interest\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n *\n * Formula: P = A / (e^(r * t)) where\n * P = principal\n * A = UI amount\n * r = annual interest rate (as a decimal)\n * t = time in years\n *\n * @param uiAmount                  UI Amount (principal plus continuously compounding interest) to be converted back to original principal\n * @param decimals                  Number of decimals for the mint\n * @param currentTimestamp          Current timestamp in seconds\n * @param lastUpdateTimestamp       Last time the interest rate was updated in seconds\n * @param initializationTimestamp   Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate      Interest rate in basis points (hundredths of a percent) before the last update\n * @param currentRate               Current interest rate in basis points\n *\n * @return Original amount (principal) without interest\n */\nexport function uiAmountToAmountForInterestBearingMintWithoutSimulation(uiAmount, decimals, currentTimestamp, // in seconds\nlastUpdateTimestamp, initializationTimestamp, preUpdateAverageRate, currentRate) {\n    const uiAmountScaled = uiAmountToAtomicUiAmount(uiAmount, decimals);\n    // Calculate pre-update exponent\n    const preUpdateExp = calculateExponentForTimesAndRate(initializationTimestamp, lastUpdateTimestamp, preUpdateAverageRate);\n    // Calculate post-update exponent\n    const postUpdateExp = calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);\n    // Calculate total scale\n    const totalScale = preUpdateExp * postUpdateExp;\n    // Calculate original principal by dividing the UI amount (principal + interest) by the total scale\n    const originalPrincipal = uiAmountScaled / totalScale;\n    return BigInt(Math.trunc(originalPrincipal));\n}\n/**\n * Convert a UI amount back to the raw amount for a mint with a scaled UI amount extension\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/scaled_ui_amount/mod.rs\n *\n * @param uiAmount       UI Amount to be converted back to raw amount\n * @param decimals       Number of decimals for the mint\n * @param multiplier     Multiplier for the scaled UI amount\n *\n * @return Raw amount\n */\nexport function uiAmountToAmountForScaledUiAmountMintWithoutSimulation(uiAmount, decimals, multiplier) {\n    const uiAmountScaled = uiAmountToAtomicUiAmount(uiAmount, decimals);\n    const rawAmount = uiAmountScaled / multiplier;\n    return BigInt(Math.trunc(rawAmount));\n}\n/**\n * Convert a UI amount back to the raw amount\n *\n * @param connection     Connection to use\n * @param mint           Mint to use for calculations\n * @param uiAmount       UI Amount to be converted back to raw amount\n *\n * @return Raw amount\n */\nexport async function uiAmountToAmountForMintWithoutSimulation(connection, mint, uiAmount) {\n    const accountInfo = await connection.getAccountInfo(mint);\n    const programId = accountInfo?.owner;\n    if (!programId?.equals(TOKEN_PROGRAM_ID) && !programId?.equals(TOKEN_2022_PROGRAM_ID)) {\n        throw new Error('Invalid program ID');\n    }\n    const mintInfo = unpackMint(mint, accountInfo, programId);\n    // Check for interest bearing mint extension\n    const interestBearingMintConfigState = getInterestBearingMintConfigState(mintInfo);\n    // Check for scaled UI amount extension\n    const scaledUiAmountConfig = getScaledUiAmountConfig(mintInfo);\n    if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n        // Standard conversion for regular mints\n        return BigInt(Math.trunc(uiAmountToAtomicUiAmount(uiAmount, mintInfo.decimals)));\n    }\n    const timestamp = await getSysvarClockTimestamp(connection);\n    if (interestBearingMintConfigState) {\n        return uiAmountToAmountForInterestBearingMintWithoutSimulation(uiAmount, mintInfo.decimals, timestamp, Number(interestBearingMintConfigState.lastUpdateTimestamp), Number(interestBearingMintConfigState.initializationTimestamp), interestBearingMintConfigState.preUpdateAverageRate, interestBearingMintConfigState.currentRate);\n    }\n    // At this point, we know it must be a scaled UI amount mint\n    let multiplier = scaledUiAmountConfig.multiplier;\n    if (timestamp >= Number(scaledUiAmountConfig.newMultiplierEffectiveTimestamp)) {\n        multiplier = scaledUiAmountConfig.newMultiplier;\n    }\n    return uiAmountToAmountForScaledUiAmountMintWithoutSimulation(uiAmount, mintInfo.decimals, multiplier);\n}\n//# sourceMappingURL=amountToUiAmount.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const approveInstructionData = struct([u8('instruction'), u64('amount')]);\n/**\n * Construct an Approve instruction\n *\n * @param account      Account to set the delegate for\n * @param delegate     Account authorized to transfer tokens from the account\n * @param owner        Owner of the account\n * @param amount       Maximum number of tokens the delegate may transfer\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createApproveInstruction(account, delegate, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: delegate, isSigner: false, isWritable: false },\n    ], owner, multiSigners);\n    const data = Buffer.alloc(approveInstructionData.span);\n    approveInstructionData.encode({\n        instruction: TokenInstruction.Approve,\n        amount: BigInt(amount),\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode an Approve instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeApproveInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== approveInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, delegate, owner, multiSigners }, data, } = decodeApproveInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Approve)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !delegate || !owner)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode an Approve instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeApproveInstructionUnchecked({ programId, keys: [account, delegate, owner, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data: approveInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=approve.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createApproveInstruction } from '../instructions/approve.js';\nimport { getSigners } from './internal.js';\n/**\n * Approve a delegate to transfer up to a maximum number of tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the token account\n * @param delegate       Account authorized to transfer tokens from the account\n * @param owner          Owner of the account\n * @param amount         Maximum number of tokens the delegate may transfer\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approve(connection, payer, account, delegate, owner, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createApproveInstruction(account, delegate, ownerPublicKey, amount, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=approve.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const approveCheckedInstructionData = struct([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n/**\n * Construct an ApproveChecked instruction\n *\n * @param account      Account to set the delegate for\n * @param mint         Mint account\n * @param delegate     Account authorized to transfer of tokens from the account\n * @param owner        Owner of the account\n * @param amount       Maximum number of tokens the delegate may transfer\n * @param decimals     Number of decimals in approve amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createApproveCheckedInstruction(account, mint, delegate, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: delegate, isSigner: false, isWritable: false },\n    ], owner, multiSigners);\n    const data = Buffer.alloc(approveCheckedInstructionData.span);\n    approveCheckedInstructionData.encode({\n        instruction: TokenInstruction.ApproveChecked,\n        amount: BigInt(amount),\n        decimals,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode an ApproveChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeApproveCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== approveCheckedInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, mint, delegate, owner, multiSigners }, data, } = decodeApproveCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.ApproveChecked)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !delegate || !owner)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode an ApproveChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeApproveCheckedInstructionUnchecked({ programId, keys: [account, mint, delegate, owner, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data: approveCheckedInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=approveChecked.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createApproveCheckedInstruction } from '../instructions/approveChecked.js';\nimport { getSigners } from './internal.js';\n/**\n * Approve a delegate to transfer up to a maximum number of tokens from an account, asserting the token mint and\n * decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Address of the mint\n * @param account        Address of the account\n * @param delegate       Account authorized to perform a transfer tokens from the source account\n * @param owner          Owner of the source account\n * @param amount         Maximum number of tokens the delegate may transfer\n * @param decimals       Number of decimals in approve amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approveChecked(connection, payer, mint, account, delegate, owner, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createApproveCheckedInstruction(account, mint, delegate, ownerPublicKey, amount, decimals, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=approveChecked.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const burnInstructionData = struct([u8('instruction'), u64('amount')]);\n/**\n * Construct a Burn instruction\n *\n * @param account      Account to burn tokens from\n * @param mint         Mint for the account\n * @param owner        Owner of the account\n * @param amount       Number of tokens to burn\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createBurnInstruction(account, mint, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: true },\n    ], owner, multiSigners);\n    const data = Buffer.alloc(burnInstructionData.span);\n    burnInstructionData.encode({\n        instruction: TokenInstruction.Burn,\n        amount: BigInt(amount),\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a Burn instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeBurnInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== burnInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, mint, owner, multiSigners }, data, } = decodeBurnInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Burn)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a Burn instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeBurnInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data: burnInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=burn.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createBurnInstruction } from '../instructions/burn.js';\nimport { getSigners } from './internal.js';\n/**\n * Burn tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to burn tokens from\n * @param mint           Mint for the account\n * @param owner          Account owner\n * @param amount         Amount to burn\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function burn(connection, payer, account, mint, owner, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createBurnInstruction(account, mint, ownerPublicKey, amount, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=burn.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const burnCheckedInstructionData = struct([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n/**\n * Construct a BurnChecked instruction\n *\n * @param mint         Mint for the account\n * @param account      Account to burn tokens from\n * @param owner        Owner of the account\n * @param amount       Number of tokens to burn\n * @param decimals     Number of decimals in burn amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createBurnCheckedInstruction(account, mint, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: true },\n    ], owner, multiSigners);\n    const data = Buffer.alloc(burnCheckedInstructionData.span);\n    burnCheckedInstructionData.encode({\n        instruction: TokenInstruction.BurnChecked,\n        amount: BigInt(amount),\n        decimals,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a BurnChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeBurnCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== burnCheckedInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, mint, owner, multiSigners }, data, } = decodeBurnCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.BurnChecked)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a BurnChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeBurnCheckedInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data: burnCheckedInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=burnChecked.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createBurnCheckedInstruction } from '../instructions/burnChecked.js';\nimport { getSigners } from './internal.js';\n/**\n * Burn tokens from an account, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to burn tokens from\n * @param mint           Mint for the account\n * @param owner          Account owner\n * @param amount         Amount to burn\n * @param decimals       Number of decimals in amount to burn\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function burnChecked(connection, payer, account, mint, owner, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createBurnCheckedInstruction(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=burnChecked.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const closeAccountInstructionData = struct([u8('instruction')]);\n/**\n * Construct a CloseAccount instruction\n *\n * @param account      Account to close\n * @param destination  Account to receive the remaining balance of the closed account\n * @param authority    Account close authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createCloseAccountInstruction(account, destination, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: destination, isSigner: false, isWritable: true },\n    ], authority, multiSigners);\n    const data = Buffer.alloc(closeAccountInstructionData.span);\n    closeAccountInstructionData.encode({ instruction: TokenInstruction.CloseAccount }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a CloseAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeCloseAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== closeAccountInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, destination, authority, multiSigners }, data, } = decodeCloseAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.CloseAccount)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !destination || !authority)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a CloseAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeCloseAccountInstructionUnchecked({ programId, keys: [account, destination, authority, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: closeAccountInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=closeAccount.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createCloseAccountInstruction } from '../instructions/closeAccount.js';\nimport { getSigners } from './internal.js';\n/**\n * Close a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to close\n * @param destination    Account to receive the remaining balance of the closed account\n * @param authority      Authority which is allowed to close the account\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function closeAccount(connection, payer, account, destination, authority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(createCloseAccountInstruction(account, destination, authorityPublicKey, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=closeAccount.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const initializeAccountInstructionData = struct([u8('instruction')]);\n/**\n * Construct an InitializeAccount instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     Owner of the new account\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccountInstruction(account, mint, owner, programId = TOKEN_PROGRAM_ID) {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: owner, isSigner: false, isWritable: false },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(initializeAccountInstructionData.span);\n    initializeAccountInstructionData.encode({ instruction: TokenInstruction.InitializeAccount }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode an InitializeAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccountInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, mint, owner, rent }, data, } = decodeInitializeAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner || !rent)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            rent,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializeAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccountInstructionUnchecked({ programId, keys: [account, mint, owner, rent], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            rent,\n        },\n        data: initializeAccountInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=initializeAccount.js.map","import { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n/**\n * Construct a CreateAssociatedTokenAccount instruction\n *\n * @param payer                    Payer of the initialization fees\n * @param associatedToken          New associated token account\n * @param owner                    Owner of the new account\n * @param mint                     Token mint account\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.alloc(0), programId, associatedTokenProgramId);\n}\n/**\n * Construct a CreateAssociatedTokenAccountIdempotent instruction\n *\n * @param payer                    Payer of the initialization fees\n * @param associatedToken          New associated token account\n * @param owner                    Owner of the new account\n * @param mint                     Token mint account\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.from([1]), programId, associatedTokenProgramId);\n}\n/**\n * Derive the associated token account and construct a CreateAssociatedTokenAccountIdempotent instruction\n *\n * @param payer                    Payer of the initialization fees\n * @param owner                    Owner of the new account\n * @param mint                     Token mint account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAssociatedTokenAccountIdempotentInstructionWithDerivation(payer, owner, mint, allowOwnerOffCurve = true, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve);\n    return createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId, associatedTokenProgramId);\n}\nfunction buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, instructionData, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    const keys = [\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: associatedToken, isSigner: false, isWritable: true },\n        { pubkey: owner, isSigner: false, isWritable: false },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n        { pubkey: programId, isSigner: false, isWritable: false },\n    ];\n    return new TransactionInstruction({\n        keys,\n        programId: associatedTokenProgramId,\n        data: instructionData,\n    });\n}\n/**\n * Construct a RecoverNested instruction\n *\n * @param nestedAssociatedToken             Nested associated token account (must be owned by `ownerAssociatedToken`)\n * @param nestedMint                        Token mint for the nested associated token account\n * @param destinationAssociatedToken        Wallet's associated token account\n * @param ownerAssociatedToken              Owner associated token account address (must be owned by `owner`)\n * @param ownerMint                         Token mint for the owner associated token account\n * @param owner                             Wallet address for the owner associated token account\n * @param programId                         SPL Token program account\n * @param associatedTokenProgramId          SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createRecoverNestedInstruction(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, ownerMint, owner, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    const keys = [\n        { pubkey: nestedAssociatedToken, isSigner: false, isWritable: true },\n        { pubkey: nestedMint, isSigner: false, isWritable: false },\n        { pubkey: destinationAssociatedToken, isSigner: false, isWritable: true },\n        { pubkey: ownerAssociatedToken, isSigner: false, isWritable: true },\n        { pubkey: ownerMint, isSigner: false, isWritable: false },\n        { pubkey: owner, isSigner: true, isWritable: true },\n        { pubkey: programId, isSigner: false, isWritable: false },\n    ];\n    return new TransactionInstruction({\n        keys,\n        programId: associatedTokenProgramId,\n        data: Buffer.from([2]),\n    });\n}\n//# sourceMappingURL=associatedTokenAccount.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n/**\n * Create and initialize a new associated token account\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint for the account\n * @param owner                    Owner of the new account\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n *\n * @return Address of the new associated token account\n */\nexport async function createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID, allowOwnerOffCurve = false) {\n    const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);\n    const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n    return associatedToken;\n}\n//# sourceMappingURL=createAssociatedTokenAccount.js.map","import { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { getAccountLenForMint } from '../extensions/extensionType.js';\nimport { createInitializeAccountInstruction } from '../instructions/initializeAccount.js';\nimport { getMint } from '../state/mint.js';\nimport { createAssociatedTokenAccount } from './createAssociatedTokenAccount.js';\n/**\n * Create and initialize a new token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param mint           Mint for the account\n * @param owner          Owner of the new account\n * @param keypair        Optional keypair, defaulting to the associated token account for the `mint` and `owner`\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new token account\n */\nexport async function createAccount(connection, payer, mint, owner, keypair, confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    // If a keypair isn't provided, create the associated token account and return its address\n    if (!keypair)\n        return await createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId);\n    // Otherwise, create the account with the provided keypair and return its public key\n    const mintState = await getMint(connection, mint, confirmOptions?.commitment, programId);\n    const space = getAccountLenForMint(mintState);\n    const lamports = await connection.getMinimumBalanceForRentExemption(space);\n    const transaction = new Transaction().add(SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: keypair.publicKey,\n        space,\n        lamports,\n        programId,\n    }), createInitializeAccountInstruction(keypair.publicKey, mint, owner, programId));\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n    return keypair.publicKey;\n}\n//# sourceMappingURL=createAccount.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountIdempotentInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n/**\n * Create and initialize a new associated token account\n * The instruction will succeed even if the associated token account already exists\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint for the account\n * @param owner                    Owner of the new account\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n *\n * @return Address of the new or existing associated token account\n */\nexport async function createAssociatedTokenAccountIdempotent(connection, payer, mint, owner, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID, allowOwnerOffCurve = false) {\n    const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);\n    const transaction = new Transaction().add(createAssociatedTokenAccountIdempotentInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n    return associatedToken;\n}\n//# sourceMappingURL=createAssociatedTokenAccountIdempotent.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n/** TODO: docs */\nexport const initializeMint2InstructionData = struct([\n    u8('instruction'),\n    u8('decimals'),\n    publicKey('mintAuthority'),\n    new COptionPublicKeyLayout('freezeAuthority'),\n]);\n/**\n * Construct an InitializeMint2 instruction\n *\n * @param mint            Token mint account\n * @param decimals        Number of decimals in token account amounts\n * @param mintAuthority   Minting authority\n * @param freezeAuthority Optional authority that can freeze token accounts\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMint2Instruction(mint, decimals, mintAuthority, freezeAuthority, programId = TOKEN_PROGRAM_ID) {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(67); // worst-case size\n    initializeMint2InstructionData.encode({\n        instruction: TokenInstruction.InitializeMint2,\n        decimals,\n        mintAuthority,\n        freezeAuthority,\n    }, data);\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeMint2InstructionData.getSpan(data)),\n    });\n}\n/**\n * Decode an InitializeMint2 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMint2Instruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMint2InstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint }, data, } = decodeInitializeMint2InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMint2)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializeMint2 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMint2InstructionUnchecked({ programId, keys: [mint], data, }) {\n    const { instruction, decimals, mintAuthority, freezeAuthority } = initializeMint2InstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            decimals,\n            mintAuthority,\n            freezeAuthority,\n        },\n    };\n}\n//# sourceMappingURL=initializeMint2.js.map","import { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createInitializeMint2Instruction } from '../instructions/initializeMint2.js';\nimport { getMinimumBalanceForRentExemptMint, MINT_SIZE } from '../state/mint.js';\n/**\n * Create and initialize a new mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction and initialization fees\n * @param mintAuthority   Account or multisig that will control minting\n * @param freezeAuthority Optional account or multisig that can freeze token accounts\n * @param decimals        Location of the decimal place\n * @param keypair         Optional keypair, defaulting to a new random one\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Address of the new mint\n */\nexport async function createMint(connection, payer, mintAuthority, freezeAuthority, decimals, keypair = Keypair.generate(), confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const lamports = await getMinimumBalanceForRentExemptMint(connection);\n    const transaction = new Transaction().add(SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: keypair.publicKey,\n        space: MINT_SIZE,\n        lamports,\n        programId,\n    }), createInitializeMint2Instruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n    return keypair.publicKey;\n}\n//# sourceMappingURL=createMint.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { PublicKey, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const initializeMultisigInstructionData = struct([\n    u8('instruction'),\n    u8('m'),\n]);\n/**\n * Construct an InitializeMultisig instruction\n *\n * @param account   Multisig account\n * @param signers   Full set of signers\n * @param m         Number of required signatures\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMultisigInstruction(account, signers, m, programId = TOKEN_PROGRAM_ID) {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    for (const signer of signers) {\n        keys.push({\n            pubkey: signer instanceof PublicKey ? signer : signer.publicKey,\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n    const data = Buffer.alloc(initializeMultisigInstructionData.span);\n    initializeMultisigInstructionData.encode({\n        instruction: TokenInstruction.InitializeMultisig,\n        m,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode an InitializeMultisig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMultisigInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMultisigInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, rent, signers }, data, } = decodeInitializeMultisigInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMultisig)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !rent || !signers.length)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            rent,\n            signers,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializeMultisig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMultisigInstructionUnchecked({ programId, keys: [account, rent, ...signers], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            rent,\n            signers,\n        },\n        data: initializeMultisigInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=initializeMultisig.js.map","import { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createInitializeMultisigInstruction } from '../instructions/initializeMultisig.js';\nimport { getMinimumBalanceForRentExemptMultisig, MULTISIG_SIZE } from '../state/multisig.js';\n/**\n * Create and initialize a new multisig\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param signers        Full set of signers\n * @param m              Number of required signatures\n * @param keypair        Optional keypair, defaulting to a new random one\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new multisig\n */\nexport async function createMultisig(connection, payer, signers, m, keypair = Keypair.generate(), confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const lamports = await getMinimumBalanceForRentExemptMultisig(connection);\n    const transaction = new Transaction().add(SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: keypair.publicKey,\n        space: MULTISIG_SIZE,\n        lamports,\n        programId,\n    }), createInitializeMultisigInstruction(keypair.publicKey, signers, m, programId));\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n    return keypair.publicKey;\n}\n//# sourceMappingURL=createMultisig.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { NATIVE_MINT_2022, programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const createNativeMintInstructionData = struct([u8('instruction')]);\n/**\n * Construct a CreateNativeMint instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     Owner of the new account\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createCreateNativeMintInstruction(payer, nativeMintId = NATIVE_MINT_2022, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: nativeMintId, isSigner: false, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(createNativeMintInstructionData.span);\n    createNativeMintInstructionData.encode({ instruction: TokenInstruction.CreateNativeMint }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n//# sourceMappingURL=createNativeMint.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { NATIVE_MINT_2022, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { createCreateNativeMintInstruction } from '../instructions/createNativeMint.js';\n/**\n * Create native mint\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param nativeMint               Native mint id associated with program\n */\nexport async function createNativeMint(connection, payer, confirmOptions, nativeMint = NATIVE_MINT_2022, programId = TOKEN_2022_PROGRAM_ID) {\n    const transaction = new Transaction().add(createCreateNativeMintInstruction(payer.publicKey, nativeMint, programId));\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n//# sourceMappingURL=createNativeMint.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const syncNativeInstructionData = struct([u8('instruction')]);\n/**\n * Construct a SyncNative instruction\n *\n * @param account   Native account to sync lamports from\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSyncNativeInstruction(account, programId = TOKEN_PROGRAM_ID) {\n    const keys = [{ pubkey: account, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(syncNativeInstructionData.span);\n    syncNativeInstructionData.encode({ instruction: TokenInstruction.SyncNative }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a SyncNative instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSyncNativeInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== syncNativeInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account }, data, } = decodeSyncNativeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.SyncNative)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data,\n    };\n}\n/**\n * Decode a SyncNative instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSyncNativeInstructionUnchecked({ programId, keys: [account], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data: syncNativeInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=syncNative.js.map","import { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { createInitializeAccountInstruction } from '../instructions/initializeAccount.js';\nimport { createSyncNativeInstruction } from '../instructions/syncNative.js';\nimport { ACCOUNT_SIZE, getMinimumBalanceForRentExemptAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\nimport { createAccount } from './createAccount.js';\n/**\n * Create, initialize, and fund a new wrapped native SOL account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param owner          Owner of the new token account\n * @param amount         Number of lamports to wrap\n * @param keypair        Optional keypair, defaulting to the associated token account for the native mint and `owner`\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new wrapped native SOL account\n */\nexport async function createWrappedNativeAccount(connection, payer, owner, amount, keypair, confirmOptions, programId = TOKEN_PROGRAM_ID, nativeMint = NATIVE_MINT) {\n    // If the amount provided is explicitly 0 or NaN, just create the account without funding it\n    if (!amount)\n        return await createAccount(connection, payer, nativeMint, owner, keypair, confirmOptions, programId);\n    // If a keypair isn't provided, create the account at the owner's ATA for the native mint and return its address\n    if (!keypair) {\n        const associatedToken = getAssociatedTokenAddressSync(nativeMint, owner, false, programId, ASSOCIATED_TOKEN_PROGRAM_ID);\n        const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, nativeMint, programId, ASSOCIATED_TOKEN_PROGRAM_ID), SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: associatedToken,\n            lamports: amount,\n        }), createSyncNativeInstruction(associatedToken, programId));\n        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n        return associatedToken;\n    }\n    // Otherwise, create the account with the provided keypair and return its public key\n    const lamports = await getMinimumBalanceForRentExemptAccount(connection);\n    const transaction = new Transaction().add(SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: keypair.publicKey,\n        space: ACCOUNT_SIZE,\n        lamports,\n        programId,\n    }), SystemProgram.transfer({\n        fromPubkey: payer.publicKey,\n        toPubkey: keypair.publicKey,\n        lamports: amount,\n    }), createInitializeAccountInstruction(keypair.publicKey, nativeMint, owner, programId));\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n    return keypair.publicKey;\n}\n//# sourceMappingURL=createWrappedNativeAccount.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const freezeAccountInstructionData = struct([u8('instruction')]);\n/**\n * Construct a FreezeAccount instruction\n *\n * @param account      Account to freeze\n * @param mint         Mint account\n * @param authority    Mint freeze authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createFreezeAccountInstruction(account, mint, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n    ], authority, multiSigners);\n    const data = Buffer.alloc(freezeAccountInstructionData.span);\n    freezeAccountInstructionData.encode({ instruction: TokenInstruction.FreezeAccount }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a FreezeAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeFreezeAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== freezeAccountInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, mint, authority, multiSigners }, data, } = decodeFreezeAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.FreezeAccount)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !authority)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a FreezeAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeFreezeAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data: freezeAccountInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=freezeAccount.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createFreezeAccountInstruction } from '../instructions/freezeAccount.js';\nimport { getSigners } from './internal.js';\n/**\n * Freeze a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to freeze\n * @param mint           Mint for the account\n * @param authority      Mint freeze authority\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function freezeAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(createFreezeAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=freezeAccount.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidMintError, TokenInvalidOwnerError, } from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    }\n    catch (error) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            }\n            catch (error) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        }\n        else {\n            throw error;\n        }\n    }\n    if (!account.mint.equals(mint))\n        throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner))\n        throw new TokenInvalidOwnerError();\n    return account;\n}\n//# sourceMappingURL=getOrCreateAssociatedTokenAccount.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const mintToInstructionData = struct([u8('instruction'), u64('amount')]);\n/**\n * Construct a MintTo instruction\n *\n * @param mint         Public key of the mint\n * @param destination  Address of the token account to mint to\n * @param authority    The mint authority\n * @param amount       Amount to mint\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createMintToInstruction(mint, destination, authority, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: destination, isSigner: false, isWritable: true },\n    ], authority, multiSigners);\n    const data = Buffer.alloc(mintToInstructionData.span);\n    mintToInstructionData.encode({\n        instruction: TokenInstruction.MintTo,\n        amount: BigInt(amount),\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a MintTo instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeMintToInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== mintToInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint, destination, authority, multiSigners }, data, } = decodeMintToInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.MintTo)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint || !destination || !authority)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a MintTo instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeMintToInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: mintToInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=mintTo.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createMintToInstruction } from '../instructions/mintTo.js';\nimport { getSigners } from './internal.js';\n/**\n * Mint tokens to an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param destination    Address of the account to mint to\n * @param authority      Minting authority\n * @param amount         Amount to mint\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintTo(connection, payer, mint, destination, authority, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(createMintToInstruction(mint, destination, authorityPublicKey, amount, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=mintTo.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const mintToCheckedInstructionData = struct([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n/**\n * Construct a MintToChecked instruction\n *\n * @param mint         Public key of the mint\n * @param destination  Address of the token account to mint to\n * @param authority    The mint authority\n * @param amount       Amount to mint\n * @param decimals     Number of decimals in amount to mint\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createMintToCheckedInstruction(mint, destination, authority, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: destination, isSigner: false, isWritable: true },\n    ], authority, multiSigners);\n    const data = Buffer.alloc(mintToCheckedInstructionData.span);\n    mintToCheckedInstructionData.encode({\n        instruction: TokenInstruction.MintToChecked,\n        amount: BigInt(amount),\n        decimals,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a MintToChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeMintToCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== mintToCheckedInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint, destination, authority, multiSigners }, data, } = decodeMintToCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.MintToChecked)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint || !destination || !authority)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a MintToChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeMintToCheckedInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: mintToCheckedInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=mintToChecked.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createMintToCheckedInstruction } from '../instructions/mintToChecked.js';\nimport { getSigners } from './internal.js';\n/**\n * Mint tokens to an account, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param destination    Address of the account to mint to\n * @param authority      Minting authority\n * @param amount         Amount to mint\n * @param decimals       Number of decimals in amount to mint\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintToChecked(connection, payer, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(createMintToCheckedInstruction(mint, destination, authorityPublicKey, amount, decimals, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=mintToChecked.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createRecoverNestedInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n/**\n * Recover funds funds in an associated token account which is owned by an associated token account\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param owner                    Owner of original ATA\n * @param mint                     Mint for the original ATA\n * @param nestedMint               Mint for the nested ATA\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function recoverNested(connection, payer, owner, mint, nestedMint, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    const ownerAssociatedToken = getAssociatedTokenAddressSync(mint, owner.publicKey, false, programId, associatedTokenProgramId);\n    const destinationAssociatedToken = getAssociatedTokenAddressSync(nestedMint, owner.publicKey, false, programId, associatedTokenProgramId);\n    const nestedAssociatedToken = getAssociatedTokenAddressSync(nestedMint, ownerAssociatedToken, true, programId, associatedTokenProgramId);\n    const transaction = new Transaction().add(createRecoverNestedInstruction(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, mint, owner.publicKey, programId, associatedTokenProgramId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, owner], confirmOptions);\n}\n//# sourceMappingURL=recoverNested.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const revokeInstructionData = struct([u8('instruction')]);\n/**\n * Construct a Revoke instruction\n *\n * @param account      Address of the token account\n * @param owner        Owner of the account\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createRevokeInstruction(account, owner, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], owner, multiSigners);\n    const data = Buffer.alloc(revokeInstructionData.span);\n    revokeInstructionData.encode({ instruction: TokenInstruction.Revoke }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a Revoke instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeRevokeInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== revokeInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, owner, multiSigners }, data, } = decodeRevokeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Revoke)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !owner)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a Revoke instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeRevokeInstructionUnchecked({ programId, keys: [account, owner, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            owner,\n            multiSigners,\n        },\n        data: revokeInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=revoke.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createRevokeInstruction } from '../instructions/revoke.js';\nimport { getSigners } from './internal.js';\n/**\n * Revoke approval for the transfer of tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the token account\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function revoke(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createRevokeInstruction(account, ownerPublicKey, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=revoke.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n/** Authority types defined by the program */\nexport var AuthorityType;\n(function (AuthorityType) {\n    AuthorityType[AuthorityType[\"MintTokens\"] = 0] = \"MintTokens\";\n    AuthorityType[AuthorityType[\"FreezeAccount\"] = 1] = \"FreezeAccount\";\n    AuthorityType[AuthorityType[\"AccountOwner\"] = 2] = \"AccountOwner\";\n    AuthorityType[AuthorityType[\"CloseAccount\"] = 3] = \"CloseAccount\";\n    AuthorityType[AuthorityType[\"TransferFeeConfig\"] = 4] = \"TransferFeeConfig\";\n    AuthorityType[AuthorityType[\"WithheldWithdraw\"] = 5] = \"WithheldWithdraw\";\n    AuthorityType[AuthorityType[\"CloseMint\"] = 6] = \"CloseMint\";\n    AuthorityType[AuthorityType[\"InterestRate\"] = 7] = \"InterestRate\";\n    AuthorityType[AuthorityType[\"PermanentDelegate\"] = 8] = \"PermanentDelegate\";\n    AuthorityType[AuthorityType[\"ConfidentialTransferMint\"] = 9] = \"ConfidentialTransferMint\";\n    AuthorityType[AuthorityType[\"TransferHookProgramId\"] = 10] = \"TransferHookProgramId\";\n    AuthorityType[AuthorityType[\"ConfidentialTransferFeeConfig\"] = 11] = \"ConfidentialTransferFeeConfig\";\n    AuthorityType[AuthorityType[\"MetadataPointer\"] = 12] = \"MetadataPointer\";\n    AuthorityType[AuthorityType[\"GroupPointer\"] = 13] = \"GroupPointer\";\n    AuthorityType[AuthorityType[\"GroupMemberPointer\"] = 14] = \"GroupMemberPointer\";\n    AuthorityType[AuthorityType[\"ScaledUiAmountConfig\"] = 15] = \"ScaledUiAmountConfig\";\n    AuthorityType[AuthorityType[\"PausableConfig\"] = 16] = \"PausableConfig\";\n})(AuthorityType || (AuthorityType = {}));\n/** TODO: docs */\nexport const setAuthorityInstructionData = struct([\n    u8('instruction'),\n    u8('authorityType'),\n    new COptionPublicKeyLayout('newAuthority'),\n]);\n/**\n * Construct a SetAuthority instruction\n *\n * @param account          Address of the token account\n * @param currentAuthority Current authority of the specified type\n * @param authorityType    Type of authority to set\n * @param newAuthority     New authority of the account\n * @param multiSigners     Signing accounts if `currentAuthority` is a multisig\n * @param programId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSetAuthorityInstruction(account, currentAuthority, authorityType, newAuthority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);\n    const data = Buffer.alloc(35); // worst-case\n    setAuthorityInstructionData.encode({\n        instruction: TokenInstruction.SetAuthority,\n        authorityType,\n        newAuthority,\n    }, data);\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, setAuthorityInstructionData.getSpan(data)),\n    });\n}\n/**\n * Decode a SetAuthority instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSetAuthorityInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== setAuthorityInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, currentAuthority, multiSigners }, data, } = decodeSetAuthorityInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.SetAuthority)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !currentAuthority)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            currentAuthority,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a SetAuthority instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSetAuthorityInstructionUnchecked({ programId, keys: [account, currentAuthority, ...multiSigners], data, }) {\n    const { instruction, authorityType, newAuthority } = setAuthorityInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            account,\n            currentAuthority,\n            multiSigners,\n        },\n        data: {\n            instruction,\n            authorityType,\n            newAuthority,\n        },\n    };\n}\n//# sourceMappingURL=setAuthority.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createSetAuthorityInstruction } from '../instructions/setAuthority.js';\nimport { getSigners } from './internal.js';\n/**\n * Assign a new authority to the account\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param account          Address of the account\n * @param currentAuthority Current authority of the specified type\n * @param authorityType    Type of authority to set\n * @param newAuthority     New authority of the account\n * @param multiSigners     Signing accounts if `currentAuthority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function setAuthority(connection, payer, account, currentAuthority, authorityType, newAuthority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [currentAuthorityPublicKey, signers] = getSigners(currentAuthority, multiSigners);\n    const transaction = new Transaction().add(createSetAuthorityInstruction(account, currentAuthorityPublicKey, authorityType, newAuthority, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=setAuthority.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createSyncNativeInstruction } from '../instructions/syncNative.js';\n/**\n * Sync the balance of a native SPL token account to the underlying system account's lamports\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Native account to sync\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function syncNative(connection, payer, account, confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const transaction = new Transaction().add(createSyncNativeInstruction(account, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n//# sourceMappingURL=syncNative.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const thawAccountInstructionData = struct([u8('instruction')]);\n/**\n * Construct a ThawAccount instruction\n *\n * @param account      Account to thaw\n * @param mint         Mint account\n * @param authority    Mint freeze authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createThawAccountInstruction(account, mint, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n    ], authority, multiSigners);\n    const data = Buffer.alloc(thawAccountInstructionData.span);\n    thawAccountInstructionData.encode({ instruction: TokenInstruction.ThawAccount }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a ThawAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeThawAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== thawAccountInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, mint, authority, multiSigners }, data, } = decodeThawAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.ThawAccount)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !authority)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a ThawAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeThawAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data: thawAccountInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=thawAccount.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createThawAccountInstruction } from '../instructions/thawAccount.js';\nimport { getSigners } from './internal.js';\n/**\n * Thaw (unfreeze) a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to thaw\n * @param mint           Mint for the account\n * @param authority      Mint freeze authority\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function thawAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n    const transaction = new Transaction().add(createThawAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=thawAccount.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const transferInstructionData = struct([u8('instruction'), u64('amount')]);\n/**\n * Construct a Transfer instruction\n *\n * @param source       Source account\n * @param destination  Destination account\n * @param owner        Owner of the source account\n * @param amount       Number of tokens to transfer\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: source, isSigner: false, isWritable: true },\n        { pubkey: destination, isSigner: false, isWritable: true },\n    ], owner, multiSigners);\n    const data = Buffer.alloc(transferInstructionData.span);\n    transferInstructionData.encode({\n        instruction: TokenInstruction.Transfer,\n        amount: BigInt(amount),\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a Transfer instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { source, destination, owner, multiSigners }, data, } = decodeTransferInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Transfer)\n        throw new TokenInvalidInstructionTypeError();\n    if (!source || !destination || !owner)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            source,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n/**\n * Decode a Transfer instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferInstructionUnchecked({ programId, keys: [source, destination, owner, ...multiSigners], data, }) {\n    return {\n        programId,\n        keys: {\n            source,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data: transferInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=transfer.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createTransferInstruction } from '../instructions/transfer.js';\nimport { getSigners } from './internal.js';\n/**\n * Transfer tokens from one account to another\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transfer(connection, payer, source, destination, owner, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createTransferInstruction(source, destination, ownerPublicKey, amount, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=transfer.js.map","import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createTransferCheckedInstruction } from '../instructions/transferChecked.js';\nimport { getSigners } from './internal.js';\n/**\n * Transfer tokens from one account to another, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferChecked(connection, payer, source, mint, destination, owner, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n    const transaction = new Transaction().add(createTransferCheckedInstruction(source, mint, destination, ownerPublicKey, amount, decimals, multiSigners, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=transferChecked.js.map","import { blob, struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\n/**\n * Construct a UiAmountToAmount instruction\n *\n * @param mint         Public key of the mint\n * @param amount       UiAmount of tokens to be converted to Amount\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUiAmountToAmountInstruction(mint, amount, programId = TOKEN_PROGRAM_ID) {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];\n    const buf = Buffer.from(amount, 'utf8');\n    const uiAmountToAmountInstructionData = struct([\n        u8('instruction'),\n        blob(buf.length, 'amount'),\n    ]);\n    const data = Buffer.alloc(uiAmountToAmountInstructionData.span);\n    uiAmountToAmountInstructionData.encode({\n        instruction: TokenInstruction.UiAmountToAmount,\n        amount: buf,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a UiAmountToAmount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeUiAmountToAmountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    const uiAmountToAmountInstructionData = struct([\n        u8('instruction'),\n        blob(instruction.data.length - 1, 'amount'),\n    ]);\n    if (instruction.data.length !== uiAmountToAmountInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint }, data, } = decodeUiAmountToAmountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.UiAmountToAmount)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n/**\n * Decode a UiAmountToAmount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeUiAmountToAmountInstructionUnchecked({ programId, keys: [mint], data, }) {\n    const uiAmountToAmountInstructionData = struct([\n        u8('instruction'),\n        blob(data.length - 1, 'amount'),\n    ]);\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: uiAmountToAmountInstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=uiAmountToAmount.js.map","import { u64 } from '@solana/buffer-layout-utils';\nimport { Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createUiAmountToAmountInstruction } from '../instructions/uiAmountToAmount.js';\n/**\n * Amount as a string using mint-prescribed decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param amount         Ui Amount of tokens to be converted to Amount\n * @param programId      SPL Token program account\n *\n * @return Ui Amount generated\n */\nexport async function uiAmountToAmount(connection, payer, mint, amount, programId = TOKEN_PROGRAM_ID) {\n    const transaction = new Transaction().add(createUiAmountToAmountInstruction(mint, amount, programId));\n    const { returnData, err } = (await connection.simulateTransaction(transaction, [payer], false)).value;\n    if (returnData) {\n        const data = Buffer.from(returnData.data[0], returnData.data[1]);\n        return u64().decode(data);\n    }\n    return err;\n}\n//# sourceMappingURL=uiAmountToAmount.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\nexport var GroupMemberPointerInstruction;\n(function (GroupMemberPointerInstruction) {\n    GroupMemberPointerInstruction[GroupMemberPointerInstruction[\"Initialize\"] = 0] = \"Initialize\";\n    GroupMemberPointerInstruction[GroupMemberPointerInstruction[\"Update\"] = 1] = \"Update\";\n})(GroupMemberPointerInstruction || (GroupMemberPointerInstruction = {}));\nexport const initializeGroupMemberPointerData = struct([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupMemberPointerInstruction'),\n    publicKey('authority'),\n    publicKey('memberAddress'),\n]);\n/**\n * Construct an Initialize GroupMemberPointer instruction\n *\n * @param mint            Token mint account\n * @param authority       Optional Authority that can set the member address\n * @param memberAddress   Optional Account address that holds the member\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeGroupMemberPointerInstruction(mint, authority, memberAddress, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(initializeGroupMemberPointerData.span);\n    initializeGroupMemberPointerData.encode({\n        instruction: TokenInstruction.GroupMemberPointerExtension,\n        groupMemberPointerInstruction: GroupMemberPointerInstruction.Initialize,\n        authority: authority ?? PublicKey.default,\n        memberAddress: memberAddress ?? PublicKey.default,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data: data });\n}\nexport const updateGroupMemberPointerData = struct([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupMemberPointerInstruction'),\n    publicKey('memberAddress'),\n]);\nexport function createUpdateGroupMemberPointerInstruction(mint, authority, memberAddress, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(updateGroupMemberPointerData.span);\n    updateGroupMemberPointerData.encode({\n        instruction: TokenInstruction.GroupMemberPointerExtension,\n        groupMemberPointerInstruction: GroupMemberPointerInstruction.Update,\n        memberAddress: memberAddress ?? PublicKey.default,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n//# sourceMappingURL=instructions.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\nexport var GroupPointerInstruction;\n(function (GroupPointerInstruction) {\n    GroupPointerInstruction[GroupPointerInstruction[\"Initialize\"] = 0] = \"Initialize\";\n    GroupPointerInstruction[GroupPointerInstruction[\"Update\"] = 1] = \"Update\";\n})(GroupPointerInstruction || (GroupPointerInstruction = {}));\nexport const initializeGroupPointerData = struct([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupPointerInstruction'),\n    publicKey('authority'),\n    publicKey('groupAddress'),\n]);\n/**\n * Construct an Initialize GroupPointer instruction\n *\n * @param mint            Token mint account\n * @param authority       Optional Authority that can set the group address\n * @param groupAddress    Optional Account address that holds the group\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeGroupPointerInstruction(mint, authority, groupAddress, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(initializeGroupPointerData.span);\n    initializeGroupPointerData.encode({\n        instruction: TokenInstruction.GroupPointerExtension,\n        groupPointerInstruction: GroupPointerInstruction.Initialize,\n        authority: authority ?? PublicKey.default,\n        groupAddress: groupAddress ?? PublicKey.default,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data: data });\n}\nexport const updateGroupPointerData = struct([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupPointerInstruction'),\n    publicKey('groupAddress'),\n]);\nexport function createUpdateGroupPointerInstruction(mint, authority, groupAddress, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(updateGroupPointerData.span);\n    updateGroupPointerData.encode({\n        instruction: TokenInstruction.GroupPointerExtension,\n        groupPointerInstruction: GroupPointerInstruction.Update,\n        groupAddress: groupAddress ?? PublicKey.default,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n//# sourceMappingURL=instructions.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n/** TODO: docs */\nexport const initializeMintInstructionData = struct([\n    u8('instruction'),\n    u8('decimals'),\n    publicKey('mintAuthority'),\n    new COptionPublicKeyLayout('freezeAuthority'),\n]);\n/**\n * Construct an InitializeMint instruction\n *\n * @param mint            Token mint account\n * @param decimals        Number of decimals in token account amounts\n * @param mintAuthority   Minting authority\n * @param freezeAuthority Optional authority that can freeze token accounts\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId = TOKEN_PROGRAM_ID) {\n    const keys = [\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(67); // worst-case size\n    initializeMintInstructionData.encode({\n        instruction: TokenInstruction.InitializeMint,\n        decimals,\n        mintAuthority,\n        freezeAuthority,\n    }, data);\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeMintInstructionData.getSpan(data)),\n    });\n}\n/**\n * Decode an InitializeMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMintInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMintInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint, rent }, data, } = decodeInitializeMintInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMint)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint || !rent)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            mint,\n            rent,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializeMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMintInstructionUnchecked({ programId, keys: [mint, rent], data, }) {\n    const { instruction, decimals, mintAuthority, freezeAuthority } = initializeMintInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            rent,\n        },\n        data: {\n            instruction,\n            decimals,\n            mintAuthority,\n            freezeAuthority,\n        },\n    };\n}\n//# sourceMappingURL=initializeMint.js.map","import { s16, struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nexport var InterestBearingMintInstruction;\n(function (InterestBearingMintInstruction) {\n    InterestBearingMintInstruction[InterestBearingMintInstruction[\"Initialize\"] = 0] = \"Initialize\";\n    InterestBearingMintInstruction[InterestBearingMintInstruction[\"UpdateRate\"] = 1] = \"UpdateRate\";\n})(InterestBearingMintInstruction || (InterestBearingMintInstruction = {}));\nexport const interestBearingMintInitializeInstructionData = struct([\n    u8('instruction'),\n    u8('interestBearingMintInstruction'),\n    // TODO: Make this an optional public key\n    publicKey('rateAuthority'),\n    s16('rate'),\n]);\nexport const interestBearingMintUpdateRateInstructionData = struct([\n    u8('instruction'),\n    u8('interestBearingMintInstruction'),\n    s16('rate'),\n]);\n/**\n * Construct an InitializeInterestBearingMint instruction\n *\n * @param mint           Mint to initialize\n * @param rateAuthority  The public key for the account that can update the rate\n * @param rate           The initial interest rate\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeInterestBearingMintInstruction(mint, rateAuthority, rate, programId = TOKEN_2022_PROGRAM_ID) {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(interestBearingMintInitializeInstructionData.span);\n    interestBearingMintInitializeInstructionData.encode({\n        instruction: TokenInstruction.InterestBearingMintExtension,\n        interestBearingMintInstruction: InterestBearingMintInstruction.Initialize,\n        rateAuthority,\n        rate,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Construct an UpdateRateInterestBearingMint instruction\n *\n * @param mint           Mint to initialize\n * @param rateAuthority  The public key for the account that can update the rate\n * @param rate           The updated interest rate\n * @param multiSigners   Signing accounts if `rateAuthority` is a multisig\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateRateInterestBearingMintInstruction(mint, rateAuthority, rate, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    const keys = addSigners([\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: rateAuthority, isSigner: !multiSigners.length, isWritable: false },\n    ], rateAuthority, multiSigners);\n    const data = Buffer.alloc(interestBearingMintUpdateRateInstructionData.span);\n    interestBearingMintUpdateRateInstructionData.encode({\n        instruction: TokenInstruction.InterestBearingMintExtension,\n        interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate,\n        rate,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n//# sourceMappingURL=instructions.js.map","import { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createInitializeMintInstruction } from '../../instructions/initializeMint.js';\nimport { ExtensionType, getMintLen } from '../extensionType.js';\nimport { createInitializeInterestBearingMintInstruction, createUpdateRateInterestBearingMintInstruction, } from './instructions.js';\n/**\n * Initialize an interest bearing account on a mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mintAuthority   Account or multisig that will control minting\n * @param freezeAuthority Optional account or multisig that can freeze token accounts\n * @param rateAuthority   The public key for the account that can update the rate\n * @param rate            The initial interest rate\n * @param decimals        Location of the decimal place\n * @param keypair         Optional keypair, defaulting to a new random one\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Public key of the mint\n */\nexport async function createInterestBearingMint(connection, payer, mintAuthority, freezeAuthority, rateAuthority, rate, decimals, keypair = Keypair.generate(), confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const mintLen = getMintLen([ExtensionType.InterestBearingConfig]);\n    const lamports = await connection.getMinimumBalanceForRentExemption(mintLen);\n    const transaction = new Transaction().add(SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: keypair.publicKey,\n        space: mintLen,\n        lamports,\n        programId,\n    }), createInitializeInterestBearingMintInstruction(keypair.publicKey, rateAuthority, rate, programId), createInitializeMintInstruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n    return keypair.publicKey;\n}\n/**\n * Update the interest rate of an interest bearing account\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mint            Public key of the mint\n * @param rateAuthority   The public key for the account that can update the rate\n * @param rate            The initial interest rate\n * @param multiSigners    Signing accounts if `owner` is a multisig\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateRateInterestBearingMint(connection, payer, mint, rateAuthority, rate, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [rateAuthorityPublicKey, signers] = getSigners(rateAuthority, multiSigners);\n    const transaction = new Transaction().add(createUpdateRateInterestBearingMintInstruction(mint, rateAuthorityPublicKey, rate, signers, programId));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, rateAuthority, ...signers], confirmOptions);\n}\n//# sourceMappingURL=actions.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\nexport var MetadataPointerInstruction;\n(function (MetadataPointerInstruction) {\n    MetadataPointerInstruction[MetadataPointerInstruction[\"Initialize\"] = 0] = \"Initialize\";\n    MetadataPointerInstruction[MetadataPointerInstruction[\"Update\"] = 1] = \"Update\";\n})(MetadataPointerInstruction || (MetadataPointerInstruction = {}));\nexport const initializeMetadataPointerData = struct([\n    // prettier-ignore\n    u8('instruction'),\n    u8('metadataPointerInstruction'),\n    publicKey('authority'),\n    publicKey('metadataAddress'),\n]);\n/**\n * Construct an Initialize MetadataPointer instruction\n *\n * @param mint            Token mint account\n * @param authority       Optional Authority that can set the metadata address\n * @param metadataAddress Optional Account address that holds the metadata\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMetadataPointerInstruction(mint, authority, metadataAddress, programId) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(initializeMetadataPointerData.span);\n    initializeMetadataPointerData.encode({\n        instruction: TokenInstruction.MetadataPointerExtension,\n        metadataPointerInstruction: MetadataPointerInstruction.Initialize,\n        authority: authority ?? PublicKey.default,\n        metadataAddress: metadataAddress ?? PublicKey.default,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data: data });\n}\nexport const updateMetadataPointerData = struct([\n    // prettier-ignore\n    u8('instruction'),\n    u8('metadataPointerInstruction'),\n    publicKey('metadataAddress'),\n]);\nexport function createUpdateMetadataPointerInstruction(mint, authority, metadataAddress, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(updateMetadataPointerData.span);\n    updateMetadataPointerData.encode({\n        instruction: TokenInstruction.MetadataPointerExtension,\n        metadataPointerInstruction: MetadataPointerInstruction.Update,\n        metadataAddress: metadataAddress ?? PublicKey.default,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n//# sourceMappingURL=instructions.js.map","import { addCodecSizePrefix, getU32Codec, getUtf8Codec, getStructCodec, getTupleCodec, getUnitCodec, } from '@solana/codecs';\nexport var Field;\n(function (Field) {\n    Field[Field[\"Name\"] = 0] = \"Name\";\n    Field[Field[\"Symbol\"] = 1] = \"Symbol\";\n    Field[Field[\"Uri\"] = 2] = \"Uri\";\n})(Field || (Field = {}));\nexport const getFieldCodec = () => [\n    ['Name', getUnitCodec()],\n    ['Symbol', getUnitCodec()],\n    ['Uri', getUnitCodec()],\n    ['Key', getStructCodec([['value', getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n];\nexport function getFieldConfig(field) {\n    if (field === Field.Name || field === 'Name' || field === 'name') {\n        return { __kind: 'Name' };\n    }\n    else if (field === Field.Symbol || field === 'Symbol' || field === 'symbol') {\n        return { __kind: 'Symbol' };\n    }\n    else if (field === Field.Uri || field === 'Uri' || field === 'uri') {\n        return { __kind: 'Uri' };\n    }\n    else {\n        return { __kind: 'Key', value: [field] };\n    }\n}\n//# sourceMappingURL=field.js.map","import { addEncoderSizePrefix, fixEncoderSize, getBooleanEncoder, getBytesEncoder, getDataEnumCodec, getOptionEncoder, getUtf8Encoder, getStructEncoder, getTupleEncoder, getU32Encoder, getU64Encoder, transformEncoder, } from '@solana/codecs';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { getFieldCodec, getFieldConfig } from './field.js';\nfunction getInstructionEncoder(discriminator, dataEncoder) {\n    return transformEncoder(getTupleEncoder([getBytesEncoder(), dataEncoder]), (data) => [\n        discriminator,\n        data,\n    ]);\n}\nfunction getPublicKeyEncoder() {\n    return transformEncoder(fixEncoderSize(getBytesEncoder(), 32), (publicKey) => publicKey.toBytes());\n}\nfunction getStringEncoder() {\n    return addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n}\nexport function createInitializeInstruction(args) {\n    const { programId, metadata, updateAuthority, mint, mintAuthority, name, symbol, uri } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: metadata },\n            { isSigner: false, isWritable: false, pubkey: updateAuthority },\n            { isSigner: false, isWritable: false, pubkey: mint },\n            { isSigner: true, isWritable: false, pubkey: mintAuthority },\n        ],\n        data: Buffer.from(getInstructionEncoder(new Uint8Array([\n            /* await splDiscriminate('spl_token_metadata_interface:initialize_account') */\n            210, 225, 30, 162, 88, 184, 77, 141,\n        ]), getStructEncoder([\n            ['name', getStringEncoder()],\n            ['symbol', getStringEncoder()],\n            ['uri', getStringEncoder()],\n        ])).encode({ name, symbol, uri })),\n    });\n}\nexport function createUpdateFieldInstruction(args) {\n    const { programId, metadata, updateAuthority, field, value } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: metadata },\n            { isSigner: true, isWritable: false, pubkey: updateAuthority },\n        ],\n        data: Buffer.from(getInstructionEncoder(new Uint8Array([\n            /* await splDiscriminate('spl_token_metadata_interface:updating_field') */\n            221, 233, 49, 45, 181, 202, 220, 200,\n        ]), getStructEncoder([\n            ['field', getDataEnumCodec(getFieldCodec())],\n            ['value', getStringEncoder()],\n        ])).encode({ field: getFieldConfig(field), value })),\n    });\n}\nexport function createRemoveKeyInstruction(args) {\n    const { programId, metadata, updateAuthority, key, idempotent } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: metadata },\n            { isSigner: true, isWritable: false, pubkey: updateAuthority },\n        ],\n        data: Buffer.from(getInstructionEncoder(new Uint8Array([\n            /* await splDiscriminate('spl_token_metadata_interface:remove_key_ix') */\n            234, 18, 32, 56, 89, 141, 37, 181,\n        ]), getStructEncoder([\n            ['idempotent', getBooleanEncoder()],\n            ['key', getStringEncoder()],\n        ])).encode({ idempotent, key })),\n    });\n}\nexport function createUpdateAuthorityInstruction(args) {\n    const { programId, metadata, oldAuthority, newAuthority } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: metadata },\n            { isSigner: true, isWritable: false, pubkey: oldAuthority },\n        ],\n        data: Buffer.from(getInstructionEncoder(new Uint8Array([\n            /* await splDiscriminate('spl_token_metadata_interface:update_the_authority') */\n            215, 228, 166, 228, 84, 100, 86, 123,\n        ]), getStructEncoder([['newAuthority', getPublicKeyEncoder()]])).encode({ newAuthority: newAuthority ?? SystemProgram.programId })),\n    });\n}\nexport function createEmitInstruction(args) {\n    const { programId, metadata, start, end } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [{ isSigner: false, isWritable: false, pubkey: metadata }],\n        data: Buffer.from(getInstructionEncoder(new Uint8Array([\n            /* await splDiscriminate('spl_token_metadata_interface:emitter') */\n            250, 166, 180, 250, 13, 12, 184, 70,\n        ]), getStructEncoder([\n            ['start', getOptionEncoder(getU64Encoder())],\n            ['end', getOptionEncoder(getU64Encoder())],\n        ])).encode({ start: start ?? null, end: end ?? null })),\n    });\n}\n//# sourceMappingURL=instruction.js.map","import { PublicKey } from '@solana/web3.js';\nimport { addCodecSizePrefix, fixCodecSize, getArrayCodec, getBytesCodec, getUtf8Codec, getU32Codec, getStructCodec, getTupleCodec, } from '@solana/codecs';\nexport const TOKEN_METADATA_DISCRIMINATOR = Buffer.from([112, 132, 90, 90, 11, 88, 157, 87]);\nfunction getStringCodec() {\n    return addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n}\nconst tokenMetadataCodec = getStructCodec([\n    ['updateAuthority', fixCodecSize(getBytesCodec(), 32)],\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['name', getStringCodec()],\n    ['symbol', getStringCodec()],\n    ['uri', getStringCodec()],\n    ['additionalMetadata', getArrayCodec(getTupleCodec([getStringCodec(), getStringCodec()]))],\n]);\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer) {\n    for (let i = 0; i < buffer.length; i++) {\n        if (buffer[i] !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n// Pack TokenMetadata into byte slab\nexport function pack(meta) {\n    // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n    const updateAuthority = meta.updateAuthority ?? PublicKey.default;\n    return tokenMetadataCodec.encode({\n        ...meta,\n        updateAuthority: updateAuthority.toBuffer(),\n        mint: meta.mint.toBuffer(),\n    });\n}\n// unpack byte slab into TokenMetadata\nexport function unpack(buffer) {\n    const data = tokenMetadataCodec.decode(buffer);\n    return isNonePubkey(data.updateAuthority)\n        ? {\n            mint: new PublicKey(data.mint),\n            name: data.name,\n            symbol: data.symbol,\n            uri: data.uri,\n            additionalMetadata: data.additionalMetadata,\n        }\n        : {\n            updateAuthority: new PublicKey(data.updateAuthority),\n            mint: new PublicKey(data.mint),\n            name: data.name,\n            symbol: data.symbol,\n            uri: data.uri,\n            additionalMetadata: data.additionalMetadata,\n        };\n}\n//# sourceMappingURL=state.js.map","import { Field, unpack } from '@solana/spl-token-metadata';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nimport { getMint } from '../../state/mint.js';\nconst getNormalizedTokenMetadataField = (field) => {\n    if (field === Field.Name || field === 'Name' || field === 'name') {\n        return 'name';\n    }\n    if (field === Field.Symbol || field === 'Symbol' || field === 'symbol') {\n        return 'symbol';\n    }\n    if (field === Field.Uri || field === 'Uri' || field === 'uri') {\n        return 'uri';\n    }\n    return field;\n};\nexport function updateTokenMetadata(current, key, value) {\n    const field = getNormalizedTokenMetadataField(key);\n    if (field === 'mint' || field === 'updateAuthority') {\n        throw new Error(`Cannot update ${field} via this instruction`);\n    }\n    // Handle updates to default keys\n    if (['name', 'symbol', 'uri'].includes(field)) {\n        return {\n            ...current,\n            [field]: value,\n        };\n    }\n    // Avoid mutating input, make a shallow copy\n    const additionalMetadata = [...current.additionalMetadata];\n    const i = current.additionalMetadata.findIndex(x => x[0] === field);\n    if (i === -1) {\n        // Key was not found, add it\n        additionalMetadata.push([field, value]);\n    }\n    else {\n        // Key was found, change value\n        additionalMetadata[i] = [field, value];\n    }\n    return {\n        ...current,\n        additionalMetadata,\n    };\n}\n/**\n * Retrieve Token Metadata Information\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token Metadata information\n */\nexport async function getTokenMetadata(connection, address, commitment, programId = TOKEN_2022_PROGRAM_ID) {\n    const mintInfo = await getMint(connection, address, commitment, programId);\n    const data = getExtensionData(ExtensionType.TokenMetadata, mintInfo.tlvData);\n    if (data === null) {\n        return null;\n    }\n    return unpack(data);\n}\n//# sourceMappingURL=state.js.map","import { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { createInitializeInstruction, createRemoveKeyInstruction, createUpdateAuthorityInstruction, createUpdateFieldInstruction, pack, unpack, } from '@solana/spl-token-metadata';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { ExtensionType, getExtensionData, getNewAccountLenForExtensionLen } from '../extensionType.js';\nimport { updateTokenMetadata } from './state.js';\nimport { TokenAccountNotFoundError } from '../../errors.js';\nimport { unpackMint } from '../../state/index.js';\nasync function getAdditionalRentForNewMetadata(connection, address, tokenMetadata, programId = TOKEN_2022_PROGRAM_ID) {\n    const info = await connection.getAccountInfo(address);\n    if (!info) {\n        throw new TokenAccountNotFoundError();\n    }\n    const extensionLen = pack(tokenMetadata).length;\n    const newAccountLen = getNewAccountLenForExtensionLen(info, address, ExtensionType.TokenMetadata, extensionLen, programId);\n    if (newAccountLen <= info.data.length) {\n        return 0;\n    }\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n    return newRentExemptMinimum - info.lamports;\n}\nasync function getAdditionalRentForUpdatedMetadata(connection, address, field, value, programId = TOKEN_2022_PROGRAM_ID) {\n    const info = await connection.getAccountInfo(address);\n    if (!info) {\n        throw new TokenAccountNotFoundError();\n    }\n    const mint = unpackMint(address, info, programId);\n    const extensionData = getExtensionData(ExtensionType.TokenMetadata, mint.tlvData);\n    if (extensionData === null) {\n        throw new Error('TokenMetadata extension not initialized');\n    }\n    const updatedTokenMetadata = updateTokenMetadata(unpack(extensionData), field, value);\n    const extensionLen = pack(updatedTokenMetadata).length;\n    const newAccountLen = getNewAccountLenForExtensionLen(info, address, ExtensionType.TokenMetadata, extensionLen, programId);\n    if (newAccountLen <= info.data.length) {\n        return 0;\n    }\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n    return newRentExemptMinimum - info.lamports;\n}\n/**\n * Initializes a TLV entry with the basic token-metadata fields.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitialize(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n    const transaction = new Transaction().add(createInitializeInstruction({\n        programId,\n        metadata: mint,\n        updateAuthority,\n        mint,\n        mintAuthority: mintAuthorityPublicKey,\n        name,\n        symbol,\n        uri,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Initializes a TLV entry with the basic token-metadata fields,\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitializeWithRentTransfer(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n    const transaction = new Transaction();\n    const lamports = await getAdditionalRentForNewMetadata(connection, mint, {\n        updateAuthority,\n        mint,\n        name,\n        symbol,\n        uri,\n        additionalMetadata: [],\n    }, programId);\n    if (lamports > 0) {\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\n    }\n    transaction.add(createInitializeInstruction({\n        programId,\n        metadata: mint,\n        updateAuthority,\n        mint,\n        mintAuthority: mintAuthorityPublicKey,\n        name,\n        symbol,\n        uri,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateField(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n    const transaction = new Transaction().add(createUpdateFieldInstruction({\n        programId,\n        metadata: mint,\n        updateAuthority: updateAuthorityPublicKey,\n        field,\n        value,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateFieldWithRentTransfer(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n    const transaction = new Transaction();\n    const lamports = await getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);\n    if (lamports > 0) {\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\n    }\n    transaction.add(createUpdateFieldInstruction({\n        programId,\n        metadata: mint,\n        updateAuthority: updateAuthorityPublicKey,\n        field,\n        value,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Remove a field in a token-metadata account.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param key              Key to remove in the additional metadata portion\n * @param idempotent       When true, instruction will not error if the key does not exist\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataRemoveKey(connection, payer, mint, updateAuthority, key, idempotent, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n    const transaction = new Transaction().add(createRemoveKeyInstruction({\n        programId,\n        metadata: mint,\n        updateAuthority: updateAuthorityPublicKey,\n        key,\n        idempotent,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n *  Update authority\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param newAuthority     New authority for the token metadata, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateAuthority(connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n    const transaction = new Transaction().add(createUpdateAuthorityInstruction({\n        programId,\n        metadata: mint,\n        oldAuthority: updateAuthorityPublicKey,\n        newAuthority,\n    }));\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n//# sourceMappingURL=actions.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\nexport const initializeAccount2InstructionData = struct([\n    u8('instruction'),\n    publicKey('owner'),\n]);\n/**\n * Construct an InitializeAccount2 instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     New account's owner/multisignature\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccount2Instruction(account, mint, owner, programId = TOKEN_PROGRAM_ID) {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(initializeAccount2InstructionData.span);\n    initializeAccount2InstructionData.encode({ instruction: TokenInstruction.InitializeAccount2, owner }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode an InitializeAccount2 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccount2Instruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccount2InstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, mint, rent }, data, } = decodeInitializeAccount2InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount2)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !rent)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            rent,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializeAccount2 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccount2InstructionUnchecked({ programId, keys: [account, mint, rent], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            rent,\n        },\n        data: initializeAccount2InstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=initializeAccount2.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\nexport const initializeAccount3InstructionData = struct([\n    u8('instruction'),\n    publicKey('owner'),\n]);\n/**\n * Construct an InitializeAccount3 instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     New account's owner/multisignature\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccount3Instruction(account, mint, owner, programId = TOKEN_PROGRAM_ID) {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(initializeAccount3InstructionData.span);\n    initializeAccount3InstructionData.encode({ instruction: TokenInstruction.InitializeAccount3, owner }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode an InitializeAccount3 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccount3Instruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccount3InstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account, mint }, data, } = decodeInitializeAccount3InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount3)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint)\n        throw new TokenInvalidInstructionKeysError();\n    // TODO: key checks?\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializeAccount3 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccount3InstructionUnchecked({ programId, keys: [account, mint], data, }) {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n        },\n        data: initializeAccount3InstructionData.decode(data),\n    };\n}\n//# sourceMappingURL=initializeAccount3.js.map","import { u8 } from '@solana/buffer-layout';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionTypeError } from '../errors.js';\nimport { decodeAmountToUiAmountInstruction } from './amountToUiAmount.js';\nimport { decodeApproveInstruction } from './approve.js';\nimport { decodeApproveCheckedInstruction } from './approveChecked.js';\nimport { decodeBurnInstruction } from './burn.js';\nimport { decodeBurnCheckedInstruction } from './burnChecked.js';\nimport { decodeCloseAccountInstruction } from './closeAccount.js';\nimport { decodeFreezeAccountInstruction } from './freezeAccount.js';\nimport { decodeInitializeAccountInstruction } from './initializeAccount.js';\nimport { decodeInitializeAccount2Instruction } from './initializeAccount2.js';\nimport { decodeInitializeAccount3Instruction } from './initializeAccount3.js';\nimport { decodeInitializeMintInstruction } from './initializeMint.js';\nimport { decodeInitializeMint2Instruction } from './initializeMint2.js';\nimport { decodeInitializeMultisigInstruction } from './initializeMultisig.js';\nimport { decodeMintToInstruction } from './mintTo.js';\nimport { decodeMintToCheckedInstruction } from './mintToChecked.js';\nimport { decodeRevokeInstruction } from './revoke.js';\nimport { decodeSetAuthorityInstruction } from './setAuthority.js';\nimport { decodeSyncNativeInstruction } from './syncNative.js';\nimport { decodeThawAccountInstruction } from './thawAccount.js';\nimport { decodeTransferInstruction } from './transfer.js';\nimport { decodeTransferCheckedInstruction } from './transferChecked.js';\nimport { TokenInstruction } from './types.js';\nimport { decodeUiAmountToAmountInstruction } from './uiAmountToAmount.js';\n/** TODO: docs */\nexport function decodeInstruction(instruction, programId = TOKEN_PROGRAM_ID) {\n    if (!instruction.data.length)\n        throw new TokenInvalidInstructionDataError();\n    const type = u8().decode(instruction.data);\n    if (type === TokenInstruction.InitializeMint)\n        return decodeInitializeMintInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount)\n        return decodeInitializeAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeMultisig)\n        return decodeInitializeMultisigInstruction(instruction, programId);\n    if (type === TokenInstruction.Transfer)\n        return decodeTransferInstruction(instruction, programId);\n    if (type === TokenInstruction.Approve)\n        return decodeApproveInstruction(instruction, programId);\n    if (type === TokenInstruction.Revoke)\n        return decodeRevokeInstruction(instruction, programId);\n    if (type === TokenInstruction.SetAuthority)\n        return decodeSetAuthorityInstruction(instruction, programId);\n    if (type === TokenInstruction.MintTo)\n        return decodeMintToInstruction(instruction, programId);\n    if (type === TokenInstruction.Burn)\n        return decodeBurnInstruction(instruction, programId);\n    if (type === TokenInstruction.CloseAccount)\n        return decodeCloseAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.FreezeAccount)\n        return decodeFreezeAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.ThawAccount)\n        return decodeThawAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.TransferChecked)\n        return decodeTransferCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.ApproveChecked)\n        return decodeApproveCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.MintToChecked)\n        return decodeMintToCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.BurnChecked)\n        return decodeBurnCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount2)\n        return decodeInitializeAccount2Instruction(instruction, programId);\n    if (type === TokenInstruction.SyncNative)\n        return decodeSyncNativeInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount3)\n        return decodeInitializeAccount3Instruction(instruction, programId);\n    if (type === TokenInstruction.InitializeMint2)\n        return decodeInitializeMint2Instruction(instruction, programId);\n    if (type === TokenInstruction.AmountToUiAmount)\n        return decodeAmountToUiAmountInstruction(instruction, programId);\n    if (type === TokenInstruction.UiAmountToAmount)\n        return decodeUiAmountToAmountInstruction(instruction, programId);\n    // TODO: implement\n    if (type === TokenInstruction.InitializeMultisig2)\n        throw new TokenInvalidInstructionTypeError();\n    throw new TokenInvalidInstructionTypeError();\n}\n/** TODO: docs */\nexport function isInitializeMintInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.InitializeMint;\n}\n/** TODO: docs */\nexport function isInitializeAccountInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount;\n}\n/** TODO: docs */\nexport function isInitializeMultisigInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.InitializeMultisig;\n}\n/** TODO: docs */\nexport function isTransferInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.Transfer;\n}\n/** TODO: docs */\nexport function isApproveInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.Approve;\n}\n/** TODO: docs */\nexport function isRevokeInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.Revoke;\n}\n/** TODO: docs */\nexport function isSetAuthorityInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.SetAuthority;\n}\n/** TODO: docs */\nexport function isMintToInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.MintTo;\n}\n/** TODO: docs */\nexport function isBurnInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.Burn;\n}\n/** TODO: docs */\nexport function isCloseAccountInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.CloseAccount;\n}\n/** TODO: docs */\nexport function isFreezeAccountInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.FreezeAccount;\n}\n/** TODO: docs */\nexport function isThawAccountInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.ThawAccount;\n}\n/** TODO: docs */\nexport function isTransferCheckedInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.TransferChecked;\n}\n/** TODO: docs */\nexport function isApproveCheckedInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.ApproveChecked;\n}\n/** TODO: docs */\nexport function isMintToCheckedInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.MintToChecked;\n}\n/** TODO: docs */\nexport function isBurnCheckedInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.BurnChecked;\n}\n/** TODO: docs */\nexport function isInitializeAccount2Instruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount2;\n}\n/** TODO: docs */\nexport function isSyncNativeInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.SyncNative;\n}\n/** TODO: docs */\nexport function isInitializeAccount3Instruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount3;\n}\n/** TODO: docs, implement */\n// export function isInitializeMultisig2Instruction(\n//     decoded: DecodedInstruction\n// ): decoded is DecodedInitializeMultisig2Instruction {\n//     return decoded.data.instruction === TokenInstruction.InitializeMultisig2;\n// }\n/** TODO: docs */\nexport function isInitializeMint2Instruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.InitializeMint2;\n}\n/** TODO: docs */\nexport function isAmountToUiAmountInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.AmountToUiAmount;\n}\n/** TODO: docs */\nexport function isUiamountToAmountInstruction(decoded) {\n    return decoded.data.instruction === TokenInstruction.UiAmountToAmount;\n}\n//# sourceMappingURL=decode.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeImmutableOwnerInstructionData = struct([\n    u8('instruction'),\n]);\n/**\n * Construct an InitializeImmutableOwner instruction\n *\n * @param account           Immutable Owner Account\n * @param programId         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeImmutableOwnerInstruction(account, programId) {\n    const keys = [{ pubkey: account, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(initializeImmutableOwnerInstructionData.span);\n    initializeImmutableOwnerInstructionData.encode({\n        instruction: TokenInstruction.InitializeImmutableOwner,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode an InitializeImmutableOwner instruction and validate it\n *\n * @param instruction InitializeImmutableOwner instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeImmutableOwnerInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeImmutableOwnerInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { account }, data, } = decodeInitializeImmutableOwnerInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeImmutableOwner)\n        throw new TokenInvalidInstructionTypeError();\n    if (!account)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializeImmutableOwner instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeImmutableOwnerInstructionUnchecked({ programId, keys: [account], data, }) {\n    const { instruction } = initializeImmutableOwnerInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            account: account,\n        },\n        data: {\n            instruction,\n        },\n    };\n}\n//# sourceMappingURL=initializeImmutableOwner.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, TokenUnsupportedInstructionError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n/** TODO: docs */\nexport const initializeMintCloseAuthorityInstructionData = struct([\n    u8('instruction'),\n    new COptionPublicKeyLayout('closeAuthority'),\n]);\n/**\n * Construct an InitializeMintCloseAuthority instruction\n *\n * @param mint            Token mint account\n * @param closeAuthority  Optional authority that can close the mint\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMintCloseAuthorityInstruction(mint, closeAuthority, programId) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(34); // worst-case size\n    initializeMintCloseAuthorityInstructionData.encode({\n        instruction: TokenInstruction.InitializeMintCloseAuthority,\n        closeAuthority,\n    }, data);\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeMintCloseAuthorityInstructionData.getSpan(data)),\n    });\n}\n/**\n * Decode an InitializeMintCloseAuthority instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMintCloseAuthorityInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMintCloseAuthorityInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint }, data, } = decodeInitializeMintCloseAuthorityInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMintCloseAuthority)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializeMintCloseAuthority instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMintCloseAuthorityInstructionUnchecked({ programId, keys: [mint], data, }) {\n    const { instruction, closeAuthority } = initializeMintCloseAuthorityInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            closeAuthority,\n        },\n    };\n}\n//# sourceMappingURL=initializeMintCloseAuthority.js.map","import { seq, struct, u16, u8 } from '@solana/buffer-layout';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n/**\n * Construct a Reallocate instruction\n *\n * @param account        Address of the token account\n * @param payer          Address paying for the reallocation\n * @param extensionTypes Extensions to reallocate for\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createReallocateInstruction(account, payer, extensionTypes, owner, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const baseKeys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ];\n    const keys = addSigners(baseKeys, owner, multiSigners);\n    const reallocateInstructionData = struct([\n        u8('instruction'),\n        seq(u16(), extensionTypes.length, 'extensionTypes'),\n    ]);\n    const data = Buffer.alloc(reallocateInstructionData.span);\n    reallocateInstructionData.encode({ instruction: TokenInstruction.Reallocate, extensionTypes }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n//# sourceMappingURL=reallocate.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeNonTransferableMintInstructionData = struct([\n    u8('instruction'),\n]);\n/**\n * Construct an InitializeNonTransferableMint instruction\n *\n * @param mint           Mint Account to make non-transferable\n * @param programId         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeNonTransferableMintInstruction(mint, programId) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(initializeNonTransferableMintInstructionData.span);\n    initializeNonTransferableMintInstructionData.encode({\n        instruction: TokenInstruction.InitializeNonTransferableMint,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n//# sourceMappingURL=initializeNonTransferableMint.js.map","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, TokenUnsupportedInstructionError, } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n/** TODO: docs */\nexport const initializePermanentDelegateInstructionData = struct([\n    u8('instruction'),\n    publicKey('delegate'),\n]);\n/**\n * Construct an InitializePermanentDelegate instruction\n *\n * @param mint               Token mint account\n * @param permanentDelegate  Authority that may sign for `Transfer`s and `Burn`s on any account\n * @param programId          SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializePermanentDelegateInstruction(mint, permanentDelegate, programId) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(initializePermanentDelegateInstructionData.span);\n    initializePermanentDelegateInstructionData.encode({\n        instruction: TokenInstruction.InitializePermanentDelegate,\n        delegate: permanentDelegate || new PublicKey(0),\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode an InitializePermanentDelegate instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializePermanentDelegateInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializePermanentDelegateInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint }, data, } = decodeInitializePermanentDelegateInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializePermanentDelegate)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializePermanentDelegate instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializePermanentDelegateInstructionUnchecked({ programId, keys: [mint], data, }) {\n    const { instruction, delegate } = initializePermanentDelegateInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            delegate,\n        },\n    };\n}\n//# sourceMappingURL=initializePermanentDelegate.js.map"],"mappings":"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"}