import { c as __toESM, s as __toDynamicImportESM, t as __commonJS } from "./chunk-CBgdiQcn.js";
import "./buffer-B-cPJC5o.js";
import { Mt as ed25519, Nt as init_ed25519, St as init_index_browser_esm, j as PublicKey, mt as VersionedTransaction, nt as Transaction, v as Keypair } from "./index.browser.esm-CCXoTR2h.js";
import "./browser-external_buffer-X3Ug0HYL.js";
import { a as WalletDisconnectionError, c as WalletNotConnectedError, d as WalletSendTransactionError, h as WalletWindowClosedError, i as WalletDisconnectedError, l as WalletNotReadyError, m as WalletSignTransactionError, n as WalletConfigError, o as WalletError, p as WalletSignMessageError, r as WalletConnectionError, s as WalletLoadError, t as WalletAccountError, u as WalletPublicKeyError } from "./errors-DB0nNAUq.js";
import { _ as scopePollingDetectionStrategy, a as SOLANA_MAINNET_CHAIN, c as StandardDisconnect, d as BaseSignInMessageSignerWalletAdapter, f as BaseSignerWalletAdapter, g as isIosAndRedirectable, h as WalletReadyState, l as StandardConnect, o as SOLANA_TESTNET_CHAIN, p as isVersionedTransaction, r as SOLANA_DEVNET_CHAIN, s as StandardEvents, t as createSignInMessage, u as BaseMessageSignerWalletAdapter } from "./signIn-B6eZQ8-6.js";
import { n as SolanaSignMessage, r as SolanaSignAndSendTransaction, t as SolanaSignTransaction } from "./signTransaction-BhZsvcdP.js";
import { t as require_events } from "./events-yU-zBpk5.js";
import { a as StatusCodes, c as TransportStatusError } from "./Transport-B5tZgenk.js";
import { $ as isJsonRpcError, A as m, At as require_cjs, C as P$1, Ct as y$1, D as d$1, Dt as i, E as V$1, Et as safeJsonStringify, G as proxy, H as StorageUtil, I as EventsController, J as ConstantsUtil, K as ref, L as AlertController, M as ConnectorController, N as ThemeController, O as f$1, Ot as r, P as RouterController, Q as o, R as OptionsController, S as O$1, St as k, T as S$1, Tt as safeJsonParse, U as ConstantsUtil$2, V as CoreHelperUtil, W as subscribeKey, X as f, Y as NetworkUtil, Z as f$2, _ as SIWXUtil, _t as Qo$1, at as formatJsonRpcResult, b as J$1, bt as E$1, c as setThemeVariables, ct as C$3, d as AccountController, dt as concat, et as isJsonRpcRequest, f as BlockchainApiController, ft as require_cjs$2, g as ConnectionController, gt as Qe$5, h as PublicStateController, ht as Po$4, it as formatJsonRpcRequest, j as y$2, k as h$1, kt as IEvents, lt as toString, m as formatUnits, mt as detect, nt as isJsonRpcResult, ot as getBigIntRpcId, p as ChainController, pt as require_cjs$1, q as subscribe, rt as formatJsonRpcError, s as setColorTheme, st as payloadId, tt as isJsonRpcResponse, u as ModalController, ut as fromString, v as SnackController, vt as sn, w as R, wt as h, x as M, xt as import_browser, y as I$1, yt as A, z as AssetUtil } from "./exports-CDGmcewz.js";
import { a as isLE$1, c as toBytes$3, d as wrapXOFConstructorWithOpts$1, f as abytes$1, g as aoutput$1, h as anumber$1, l as u32$1, n as byteSwap32$1, p as aexists$1, t as Hash$2, u as wrapConstructor$1 } from "./utils-BP6TE3-m.js";
import { t as require_elliptic } from "./elliptic-DiSash_k.js";
import "./browser-external_crypto-CwrtXUOq.js";
import "./inherits_browser-COIPrfC8.js";
import { a as isLE, c as toBytes$1, d as wrapXOFConstructorWithOpts, f as abytes, g as aoutput, h as anumber, l as u32, n as byteSwap32, p as aexists, t as Hash, u as wrapConstructor } from "./utils-qCmSRCGt.js";
import { i as ConstantsUtil$1, n as WalletUtil, r as HelpersUtil } from "./ConnectorUtil-DWi4HGTv.js";
import "./lit-CeBuIx8X.js";

//#region node_modules/@solana/wallet-adapter-base/lib/esm/types.js
var WalletAdapterNetwork;
(function(WalletAdapterNetwork$1) {
	WalletAdapterNetwork$1["Mainnet"] = "mainnet-beta";
	WalletAdapterNetwork$1["Testnet"] = "testnet";
	WalletAdapterNetwork$1["Devnet"] = "devnet";
})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));

//#endregion
//#region node_modules/@wallet-standard/wallet/lib/esm/register.js
var __classPrivateFieldGet$1 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state$2, kind, f$7) {
	if (kind === "a" && !f$7) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state$2 === "function" ? receiver !== state$2 || !f$7 : !state$2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f$7 : kind === "a" ? f$7.call(receiver) : f$7 ? f$7.value : state$2.get(receiver);
};
var __classPrivateFieldSet$1 = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state$2, value, kind, f$7) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f$7) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state$2 === "function" ? receiver !== state$2 || !f$7 : !state$2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f$7.call(receiver, value) : f$7 ? f$7.value = value : state$2.set(receiver, value), value;
};
var _RegisterWalletEvent_detail;
/**
* Register a {@link "@wallet-standard/base".Wallet} as a Standard Wallet with the app.
*
* This dispatches a {@link "@wallet-standard/base".WindowRegisterWalletEvent} to notify the app that the Wallet is
* ready to be registered.
*
* This also adds a listener for {@link "@wallet-standard/base".WindowAppReadyEvent} to listen for a notification from
* the app that the app is ready to register the Wallet.
*
* This combination of event dispatch and listener guarantees that the Wallet will be registered synchronously as soon
* as the app is ready whether the Wallet loads before or after the app.
*
* @param wallet Wallet to register.
*
* @group Wallet
*/
function registerWallet(wallet) {
	const callback = ({ register: register$1 }) => register$1(wallet);
	try {
		window.dispatchEvent(new RegisterWalletEvent(callback));
	} catch (error) {
		console.error("wallet-standard:register-wallet event could not be dispatched\n", error);
	}
	try {
		window.addEventListener("wallet-standard:app-ready", ({ detail: api }) => callback(api));
	} catch (error) {
		console.error("wallet-standard:app-ready event listener could not be added\n", error);
	}
}
var RegisterWalletEvent = class extends Event {
	get detail() {
		return __classPrivateFieldGet$1(this, _RegisterWalletEvent_detail, "f");
	}
	get type() {
		return "wallet-standard:register-wallet";
	}
	constructor(callback) {
		super("wallet-standard:register-wallet", {
			bubbles: false,
			cancelable: false,
			composed: false
		});
		_RegisterWalletEvent_detail.set(this, void 0);
		__classPrivateFieldSet$1(this, _RegisterWalletEvent_detail, callback, "f");
	}
	/** @deprecated */
	preventDefault() {
		throw new Error("preventDefault cannot be called");
	}
	/** @deprecated */
	stopImmediatePropagation() {
		throw new Error("stopImmediatePropagation cannot be called");
	}
	/** @deprecated */
	stopPropagation() {
		throw new Error("stopPropagation cannot be called");
	}
};
_RegisterWalletEvent_detail = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/@solana/wallet-adapter-alpha/lib/esm/adapter.js
init_index_browser_esm();
const AlphaWalletName = "Alpha";
var AlphaWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = AlphaWalletName;
		this.url = "https://github.com/alphabatem/alpha-wallet";
		this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAxMDgwIDEwODAiPjxkZWZzPjxzdHlsZT4ua3tmaWxsOiNmZmY7fS5se2ZpbGw6dXJsKCNjKTt9Lm17aXNvbGF0aW9uOmlzb2xhdGU7fS5ue2ZpbGw6dXJsKCNqKTtvcGFjaXR5Oi42Nzt9Lm4sLm97bWl4LWJsZW5kLW1vZGU6bXVsdGlwbHk7fS5ve2ZpbGw6dXJsKCNpKTtvcGFjaXR5Oi40MTt9LnB7ZmlsbDp1cmwoI2YpO30ucXtmaWxsOiMwMGNlN2M7fS5ye2ZpbGw6IzJhN2RlMTt9LnN7ZmlsbDp1cmwoI2cpO30udHtmaWxsOnVybCgjYik7fS51e2ZpbGw6dXJsKCNoKTt9LnZ7ZmlsbDp1cmwoI2QpO30ud3tmaWxsOnVybCgjZSk7fTwvc3R5bGU+PGxpbmVhckdyYWRpZW50IGlkPSJiIiB4MT0iNjYzLjIyIiB5MT0iMTAuNTIyIiB4Mj0iMzIzLjIwMiIgeTI9IjM1OS4zNzIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiMyNGNlN2IiLz48c3RvcCBvZmZzZXQ9Ii44MjgiIHN0b3AtY29sb3I9IiMyNTdjZTEiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYyIgeDE9IjMzNi4zNjgiIHkxPSItOTguMjg5IiB4Mj0iODQzLjk1OSIgeTI9IjI4MC41OCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iLjQ3NiIgc3RvcC1jb2xvcj0iIzI0Y2U3YiIvPjxzdG9wIG9mZnNldD0iLjgyOCIgc3RvcC1jb2xvcj0iIzI1N2NlMSIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJkIiB4MT0iMTk2LjU2NCIgeTE9IjIzMS44OTQiIHgyPSI5MzIuODIyIiB5Mj0iMjMxLjg5NCIgeGxpbms6aHJlZj0iI2MiLz48bGluZWFyR3JhZGllbnQgaWQ9ImUiIHgxPSIyMTQuODczIiB5MT0iMjk5LjIwNyIgeDI9IjgwMy44OCIgeTI9IjI5OS4yMDciIHhsaW5rOmhyZWY9IiNjIi8+PGxpbmVhckdyYWRpZW50IGlkPSJmIiB4MT0iMjA2LjM4NiIgeTE9IjkzNi4yMDIiIHgyPSI3ODUuNjY0IiB5Mj0iNjMzLjA3IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMzY3IiBzdG9wLWNvbG9yPSIjMjU3Y2UxIi8+PHN0b3Agb2Zmc2V0PSIuODUiIHN0b3AtY29sb3I9IiMyNGNlN2IiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iZyIgeDE9IjIwNC42MTEiIHkxPSI5NTcuMDQzIiB4Mj0iODEyLjQzNiIgeTI9IjYzOC45NzMiIHhsaW5rOmhyZWY9IiNjIi8+PGxpbmVhckdyYWRpZW50IGlkPSJoIiB4MT0iNTc0LjY4NCIgeTE9IjY3NS43MjMiIHgyPSI1NzkuMDU1IiB5Mj0iNjczLjQzNSIgeGxpbms6aHJlZj0iI2MiLz48bGluZWFyR3JhZGllbnQgaWQ9ImkiIHgxPSIxMDQyLjA3IiB5MT0iMTMwOC4zMyIgeDI9IjgzOC43NzciIHkyPSIxNzQ1LjYzIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKC01NDAuMTUxIC02MzEuNDg1KSByb3RhdGUoLjM5KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2ZmZiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAwMCIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJqIiB4MT0iMjEzOTcuNjU1IiB5MT0iMTE2MC4zOTIiIHgyPSIyMTE5MS4xNjMiIHkyPSIxNjA0LjU3MyIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgyMTk3My43NjggLTYzMS40ODUpIHJvdGF0ZSgxNzkuNjEpIHNjYWxlKDEgLTEpIiB4bGluazpocmVmPSIjaSIvPjwvZGVmcz48ZyBjbGFzcz0ibSI+PGcgaWQ9ImEiPjxnPjxnPjxwYXRoIGNsYXNzPSJxIiBkPSJNNTY5LjYyMSw1NDAuMTMxYzQ3LjkzNiwxMDQuNTE0LDk1Ljg3MywyMDkuMDI4LDE0My44MDksMzEzLjU0M2wtMjAyLjcxOSwuMjU4YzE1LjExNCwzNC4xNzUsMzAuMjI5LDY4LjM1LDQ1LjM0MywxMDIuNTI0bDMxNS4zNzIsLjM5OWMtNjYuNDg4LTE0Ni40NTMtMTMyLjk3NS0yOTIuOTA2LTE5OS40NjMtNDM5LjM2LS4wMjEtNjUuOTI5LS4wNDMtMTMxLjg1Ny0uMDY0LTE5Ny43ODYtMzQuMTM2LDE0LjQ0NS02OC4yNzIsMjguODkxLTEwMi40MDgsNDMuMzM2LC4wNDMsNTkuMDI4LC4wODYsMTE4LjA1NywuMTI5LDE3Ny4wODVaIi8+PHBhdGggY2xhc3M9ImsiIGQ9Ik0zNTQuODc0LDg1My41NDVjNDIuMTMyLTEwNC44NTgsODQuMjY1LTIwOS43MTYsMTI2LjM5Ny0zMTQuNTc0LS4wODYtNTguNjQyLS4xNzItMTE3LjI4My0uMjU4LTE3NS45MjQtMzQuMTc5LTE0LjY4Mi02OC4zNTgtMjkuMzY0LTEwMi41MzctNDQuMDQ2LC40Myw2Ni4wNTgsLjg2LDEzMi4xMTUsMS4yOSwxOTguMTczbC0xNzkuNDA3LDQzOS42ODJjMTE4LjU3My0uMTI5LDIzNy4xNDUtLjI1OCwzNTUuNzE4LS4zODctMTUuMDQ3LTM0LjE3OS0zMC4wOTUtNjguMzU4LTQ1LjE0Mi0xMDIuNTM3LTUyLjAyMS0uMTI5LTEwNC4wNDEtLjI1OC0xNTYuMDYyLS4zODdaIi8+PGNpcmNsZSBjbGFzcz0idCIgY3g9IjUyMS40NTgiIGN5PSIxNTUuOTY2IiByPSIzOC43NzIiLz48Y2lyY2xlIGNsYXNzPSJsIiBjeD0iNjU1LjM2NCIgY3k9IjEzOS44MTEiIHI9IjYxLjkyNyIvPjxjaXJjbGUgY2xhc3M9InYiIGN4PSI1ODEuNTkiIGN5PSIyMzEuODk0IiByPSIyOS42MTciLz48Y2lyY2xlIGNsYXNzPSJ3IiBjeD0iNTIyLjg5NCIgY3k9IjI5OS4yMDciIHI9IjIzLjY5NCIvPjxwYXRoIGNsYXNzPSJwIiBkPSJNNTc2LjYxOSw3MzcuNzgxYy0uMzM2LS41OTktMy4zNTctNi4wOS04LjEyNy0xMy4yMTQtMS40MzEtMi4xMzctMy4wNDktNC40NDItNC45MjEtNi45NTItOC43OC0xMS43NjgtNDAuOTY4LTU0LjkxNC02OS45ODctNTEuMDA3LTIuNzY2LC4zNzItNC43MjksLjk3LTYuMzMzLDEuNDgxLTIzLjc1MSw3LjU3Mi0zNC4yNCwzNC41MTUtNDEuMDYsNTEuNTc0LTExLjg0MSwyOS42MTYtMjUuNTM5LDYxLjczMy00Mi4xMzYsMTAwLjMwNSw4NS4zMjcsLjIyOCwxNzAuNjUzLC40NTYsMjU1Ljk4LC42ODQtNTkuOTkzLTU1Ljk4MS04MC4xNTktNzcuMDY1LTgzLjQxNS04Mi44NzFaIi8+PHBhdGggY2xhc3M9InMiIGQ9Ik01MDUuNzc3LDcxNC4zNzljLTEzLjc0Nyw3Ljk5Mi0yNi44OTEsMTEuODU4LTMzLjcwMiwxMy42ODktMTIuNDM0LDMuMzQyLTIzLjIzNCw0LjQ5NC0zMS4wNDUsNC44ODRsLTM2Ljc5Niw4Ny4yNTJjODUuMjY2LC4wNjUsMTcwLjUzMiwuMTI5LDI1NS43OTksLjE5NC0xNC42Ni0zNS45ODQtMjkuMzIxLTcxLjk2OS00My45ODEtMTA3Ljk1NC0xMC41OTgtMjAuNzAyLTIwLjE4NC0zMi4zMTgtMjguNDg4LTM4LjU4NS02LjI4MS00Ljc0LTExLjgyOC02LjQyLTE2LjUyNi02LjY1Ni0uMzQ4LS4wMTgtLjY5Mi0uMDI3LTEuMDMtLjAzLTIwLjc4MS0uMTQ1LTI5LjUwNiwyNy4wMTgtNjQuMjMsNDcuMjA1WiIvPjxwYXRoIGNsYXNzPSJyIiBkPSJNNTM4LjkyNCw5NjguMTgxYzEuNDYzLDAsMS40NjUtMi4yNzMsMC0yLjI3M3MtMS40NjUsMi4yNzMsMCwyLjI3M2gwWiIvPjxsaW5lIGNsYXNzPSJ1IiB4MT0iNTc4LjAwNCIgeTE9IjY3NC42NTQiIHgyPSI1NzUuOTQxIiB5Mj0iNjc0LjM5NiIvPjwvZz48cGF0aCBjbGFzcz0ibyIgZD0iTTM3OS44MzEsNTE3LjEwOWMzMy44MzUsNy4yODcsNjcuNjcsMTQuNTc0LDEwMS41MDUsMjEuODYybC0xMjYuNDUsMzE0LjU2MiwxNTYuMDY2LC4zOTljMTUuMDQ2LDM0LjE3OSwzMC4wOTIsNjguMzU4LDQ1LjEzOCwxMDIuNTM3LTExOC41NzcsLjE1LTIzNy4xNTMsLjMwMS0zNTUuNzMsLjQ1MSw1OS44MjQtMTQ2LjYwNCwxMTkuNjQ4LTI5My4yMDcsMTc5LjQ3MS00MzkuODExWiIvPjxwYXRoIGNsYXNzPSJuIiBkPSJNNjcxLjkyOCw1MTcuNTMyYy0zNC4xMTQsNy41MjktNjguMjI5LDE1LjA1OC0xMDIuMzQzLDIyLjU4Nyw0Ny45NDcsMTA0LjUxNiw5NS44OTQsMjA5LjAzMSwxNDMuODQxLDMxMy41NDctNjcuNDk2LC4wODktMTM0Ljk5MSwuMTc3LTIwMi40ODcsLjI2NiwxNS4wNDksMzQuMTgzLDMwLjA5OSw2OC4zNjcsNDUuMTQ4LDEwMi41NSwxMDUuMTE1LC4xMjYsMjEwLjIzLC4yNTMsMzE1LjM0NSwuMzc5LTY2LjUwMi0xNDYuNDQzLTEzMy4wMDMtMjkyLjg4Ni0xOTkuNTA1LTQzOS4zMjlaIi8+PC9nPjwvZz48L2c+PC9zdmc+";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.alpha?.isAlpha) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.alpha;
			if (!wallet.isConnected) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				transaction = await this.prepareTransaction(transaction, connection, sendOptions);
				signers?.length && transaction.partialSign(...signers);
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-avana/lib/esm/adapter.js
init_index_browser_esm();
const AvanaWalletName = "Avana";
var AvanaWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = AvanaWalletName;
		this.url = "https://www.avanawallet.com";
		this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyNi4yLjEsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCAyODkuNzg3ODEgMjg5Ljc4NzgxIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCAyODkuNzg3ODEgMjg5Ljc4NzgxIiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxwYXRoIGZpbGw9IiMxQzFDMUMiIGQ9Ik0yMTguNDM5MDEsMjg5Ljc4NzgxSDcxLjM0ODhDMzEuOTQzOTUsMjg5Ljc4NzgxLDAsMjU3Ljg0Mzg3LDAsMjE4LjQzOTAxVjcxLjM0ODgNCglDMCwzMS45NDM5NSwzMS45NDM5NSwwLDcxLjM0ODgsMGgxNDcuMDkwMjFjMzkuNDA0ODYsMCw3MS4zNDg4LDMxLjk0Mzk1LDcxLjM0ODgsNzEuMzQ4OHYxNDcuMDkwMjENCglDMjg5Ljc4NzgxLDI1Ny44NDM4NywyNTcuODQzODcsMjg5Ljc4NzgxLDIxOC40MzkwMSwyODkuNzg3ODF6Ii8+DQo8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjczLjU4NTUzIiB5MT0iMjE3Ljk4MDgzIiB4Mj0iMjA4LjY0NzQ5IiB5Mj0iLTY0LjU5NzU2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMjkwLjc5MzAzKSI+DQoJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzE2RkVBOCIvPg0KCTxzdG9wICBvZmZzZXQ9IjAuNCIgc3R5bGU9InN0b3AtY29sb3I6IzAwREFGRiIvPg0KCTxzdG9wICBvZmZzZXQ9IjAuOTIiIHN0eWxlPSJzdG9wLWNvbG9yOiNEQzFGRkYiLz4NCgk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojREMxRkZGIi8+DQo8L2xpbmVhckdyYWRpZW50Pg0KPHBhdGggZmlsbD0idXJsKCNTVkdJRF8xXykiIGQ9Ik0yMzUuNzgxMjIsMjE3LjA0NTMzTDE1Ny43MjQ0Myw0OC40NTUyMmMtNS4wMzU4MS0xMC45MjA1NC0yMC41Mzk3Ni0xMC45MjA1NC0yNS41NzU1OSwwDQoJbC0zOS4xODM4OSw4NC41OTIxNGMtMS4xMDM0MiwyLjQwNDcyLTEuNjQwOTcsNC45NzkzNy0xLjY0MDk3LDcuNDY5MDZjMCw3LjEwMTA3LDQuMjQzNzUsMTMuODkxMTMsMTEuNDAxNDQsMTYuNjYzNjQNCgljOC44ODM2NCwzLjQ1MTY4LDE4LjkyNzEzLTEuMTAzMjMsMjIuOTQ0NjYtOS43NjA0OGw5Ljc4ODgyLTIxLjEzMzk2YzMuNzM0NTEtOC4wOTEzOCwxNS4yMjA5Mi04LjA5MTM4LDE4Ljk1NTQ2LDANCglsMTYuNDQ4MiwzNS41NTM0M2MyLjQxMjAyLDUuMjEzNjctMS43MDg5MiwxMS4wMjA4My03LjQzNzA5LDEwLjU4NzAxYy02Ny42NzI1LTUuMTI0OTQtMTA1LjA3MzAzLDM4LjcwMzA5LTEwNi4xNjQ3Niw0MC4wMDc3NA0KCWMtMC4wMjgxNCwwLjAyODMxLTAuMDI4MTQsMC4wMjgzMS0wLjAyODE0LDAuMDI4MzFjLTMuMDI3MjMsMy4xOTY5OS00Ljg5NDU4LDcuNDY5MDYtNC44OTQ1OCwxMi4yNTAxOA0KCWMwLDkuODE3MzEsNy45NDk5NCwxNy43NjcyNiwxNy43Mzg5MywxNy43NjcyNmM1LjE3NzQzLDAsOS44NDU0NS0yLjIzNDk5LDEzLjA5OTA1LTUuNzcxNDRjMCwwLDAuMDg0NzktMC4xMTMzLDAuMjU0NTMtMC4zMTEzNg0KCWMwLjExMzI4LTAuMTEzMTEsMC4yNTQ3MS0wLjI1NDUzLDAuMzk2MTMtMC40MjQyNmM0Ljk0NjEtNS4zMDEyNSwzNy42MTI0LTM3LjM5MDI3LDkyLjA2NjE1LTI2LjM1OTA3DQoJYzEyLjAxNzc4LDIuNDM0NTQsMjIuMDQ5NjgsMTAuNjgxNywyNy4yMTE2MiwyMS44MDQxNGwwLDBjMy4wMjcyMiw2LjUzNTM3LDkuNTA1OTcsMTEuMDYxOTgsMTYuNzIwMjksMTAuOTc3MDENCglDMjMyLjcyNTY2LDI0Mi4yMjQ4MiwyNDEuMjEzMTcsMjI4Ljc4NjI1LDIzNS43ODEyMiwyMTcuMDQ1MzN6Ii8+DQo8L3N2Zz4NCg==";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.avana?.solana?.isAvana) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.avana.solana;
			if (!wallet.isConnected) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				transaction = await this.prepareTransaction(transaction, connection, sendOptions);
				signers?.length && transaction.partialSign(...signers);
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-bitkeep/lib/esm/adapter.js
init_index_browser_esm();
const BitgetWalletName = "Bitget";
var BitgetWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = BitgetWalletName;
		this.url = "https://web3.bitget.com";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjMDAxRjI5Ii8+CjxwYXRoIGQ9Ik0yMTkuOTQ4IDk1LjcwMjJDMjAxLjYyMyA5NS42OTI5IDE4My4zMyA5NS42ODM1IDE2NC45NDEgOTUuNzExNkMxNTMuODIyIDk1LjcxMTYgMTQ5LjY1MSAxMDkuNjcxIDE1Ny45MjEgMTE3LjkzOUwyODMuMDk4IDI0My4xMTdDMjg3LjAwNCAyNDYuNjkgMjg5LjQ0MSAyNTAuNTc0IDI4OS41MyAyNTUuNjkzQzI4OS40NDEgMjYwLjgxMiAyODcuMDA0IDI2NC42OTYgMjgzLjA5OCAyNjguMjY5TDE1Ny45MjEgMzkzLjQ0NkMxNDkuNjUxIDQwMS43MTUgMTUzLjgyMiA0MTUuNjc0IDE2NC45NDEgNDE1LjY3NEMxODMuMzMgNDE1LjcwMiAyMDEuNjIzIDQxNS42OTMgMjE5Ljk0OCA0MTUuNjgzQzIyOS4xMjIgNDE1LjY3OSAyMzguMzA1IDQxNS42NzQgMjQ3LjUxMSA0MTUuNjc0QzI1OS41NTUgNDE1LjY3NCAyNjYuNzIgNDA5LjI0IDI3My4xNTQgNDAyLjgwNUwzODYuMDQ3IDI4OS45MTJDMzk1LjA1NyAyODAuOTAyIDQwMy4xMTkgMjY4LjkzOSA0MDMuMDA5IDI1NS42OTNDNDAzLjExOSAyNDIuNDQ3IDM5NS4wNTcgMjMwLjQ4NCAzODYuMDQ3IDIyMS40NzRMMjczLjE1NCAxMDguNThDMjY2LjcyIDEwMi4xNDYgMjU5LjU1NSA5NS43MTE2IDI0Ny41MTEgOTUuNzExNkMyMzguMzA1IDk1LjcxMTYgMjI5LjEyMiA5NS43MDY5IDIxOS45NDggOTUuNzAyMloiIGZpbGw9IiMwMEYwRkYiLz4KPC9zdmc+Cg==";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.bitkeep?.solana?.isBitKeep) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.bitkeep.solana;
			let account;
			try {
				account = await wallet.getAccount();
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};
/**
* @deprecated Use 'BitgetWalletName' instead."
*/
const BitKeepWalletName = BitgetWalletName;
/**
* @deprecated Use 'BitgetWalletAdapter' instead."
*/
const BitKeepWalletAdapter = BitgetWalletAdapter;

//#endregion
//#region node_modules/@solana/wallet-adapter-bitpie/lib/esm/adapter.js
init_index_browser_esm();
const BitpieWalletName = "Bitpie";
var BitpieWalletAdapter = class extends BaseSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = BitpieWalletName;
		this.url = "https://bitpiecn.com";
		this.icon = `data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjY0IiB2aWV3Qm94PSIwIDAgNjQgNjQiIHdpZHRoPSI2NCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiMxZTNkYTAiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMzNzUwZGUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9IjUyLjU0NTc1JSIgeDI9IjUyLjU0NTc1JSIgeGxpbms6aHJlZj0iI2EiIHkxPSIxMDAlIiB5Mj0iMCUiLz48bGluZWFyR3JhZGllbnQgaWQ9ImMiIHgxPSI1MCUiIHgyPSI1MCUiIHkxPSIwJSIgeTI9IjEwMCUiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzFkM2JhMyIgc3RvcC1vcGFjaXR5PSIwIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMTczNzkzIiBzdG9wLW9wYWNpdHk9Ii42NTI5MzgiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iZCIgeDE9IjUwJSIgeDI9IjUwJSIgeGxpbms6aHJlZj0iI2EiIHkxPSIxMDAlIiB5Mj0iMCUiLz48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Im0xOCAwaDI4YzkuOTQxMTI1NSAwIDE4IDguMDU4ODc0NSAxOCAxOHYyOGMwIDkuOTQxMTI1NS04LjA1ODg3NDUgMTgtMTggMThoLTI4Yy05Ljk0MTEyNTUgMC0xOC04LjA1ODg3NDUtMTgtMTh2LTI4YzAtOS45NDExMjU1IDguMDU4ODc0NS0xOCAxOC0xOHoiIGZpbGw9InVybCgjYikiLz48Y2lyY2xlIGN4PSIzMi4yODU3MTQiIGN5PSIzMi4yODU3MTQiIGZpbGw9IiNmZmYiIHI9IjI0LjI4NTcxNCIvPjxwYXRoIGQ9Im0zMiAwYzE3LjY3MzExMiAwIDMyIDE0LjMyNjg4OCAzMiAzMnMtMTQuMzI2ODg4IDMyLTMyIDMyLTMyLTE0LjMyNjg4OC0zMi0zMiAxNC4zMjY4ODgtMzIgMzItMzJ6bS0uMTQzNDk3OCA3LjYwNTM4MTE3Yy0xMy40NzI3NzU5IDAtMjQuMzk0NjE4NzkgMTAuOTIxODQyODMtMjQuMzk0NjE4NzkgMjQuMzk0NjE4ODNzMTAuOTIxODQyODkgMjQuMzk0NjE4OCAyNC4zOTQ2MTg3OSAyNC4zOTQ2MTg4YzEzLjQ3Mjc3NiAwIDI0LjM5NDYxODktMTAuOTIxODQyOCAyNC4zOTQ2MTg5LTI0LjM5NDYxODhzLTEwLjkyMTg0MjktMjQuMzk0NjE4ODMtMjQuMzk0NjE4OS0yNC4zOTQ2MTg4M3oiIGZpbGw9InVybCgjYykiLz48cGF0aCBkPSJtMjkuMDkwOTA5MSA0NC4zNjM2MzY0YzAgMi4wMDgzMDgxLTEuNjI4MDU1NSAzLjYzNjM2MzYtMy42MzYzNjM2IDMuNjM2MzYzNi0yLjAwODMwODIgMC0zLjYzNjM2MzctMS42MjgwNTU1LTMuNjM2MzYzNy0zLjYzNjM2MzZsLS4wMDAxODE4LTIuMTgyNjM2NC0yLjE4MTYzNjQuMDAwODE4MmMtMi4wMDgzMDgxIDAtMy42MzYzNjM2LTEuNjI4MDU1NS0zLjYzNjM2MzYtMy42MzYzNjM3IDAtMi4wMDgzMDgxIDEuNjI4MDU1NS0zLjYzNjM2MzYgMy42MzYzNjM2LTMuNjM2MzYzNmwyLjE4MTYzNjQtLjAwMDA5MDl2LTUuODE5bC0yLjE4MTYzNjQuMDAwOTA5MWMtMi4wMDgzMDgxIDAtMy42MzYzNjM2LTEuNjI4MDU1NS0zLjYzNjM2MzYtMy42MzYzNjM2IDAtMi4wMDgzMDgyIDEuNjI4MDU1NS0zLjYzNjM2MzcgMy42MzYzNjM2LTMuNjM2MzYzN2wyLjE4MTYzNjQtLjAwMDE4MTguMDAwMTgxOC0yLjE4MTYzNjRjMC0yLjAwODMwODEgMS42MjgwNTU1LTMuNjM2MzYzNiAzLjYzNjM2MzctMy42MzYzNjM2IDIuMDA4MzA4MSAwIDMuNjM2MzYzNiAxLjYyODA1NTUgMy42MzYzNjM2IDMuNjM2MzYzNmwtLjAwMDkwOTEgMi4xODE2MzY0aDUuODE5bC4wMDAwOTA5LTIuMTgxNjM2NGMwLTIuMDA4MzA4MSAxLjYyODA1NTUtMy42MzYzNjM2IDMuNjM2MzYzNi0zLjYzNjM2MzYgMi4wMDgzMDgyIDAgMy42MzYzNjM3IDEuNjI4MDU1NSAzLjYzNjM2MzcgMy42MzYzNjM2bC0uMDAwODE4MiAyLjE4MTYzNjQgMi4xODI2MzY0LjAwMDE4MThjMi4wMDgzMDgxIDAgMy42MzYzNjM2IDEuNjI4MDU1NSAzLjYzNjM2MzYgMy42MzYzNjM3IDAgMi4wMDgzMDgxLTEuNjI4MDU1NSAzLjYzNjM2MzYtMy42MzYzNjM2IDMuNjM2MzYzNmwtMi4xODI2MzY0LS4wMDA5MDkxdjUuODE5bDIuMTgyNjM2NC4wMDAwOTA5YzIuMDA4MzA4MSAwIDMuNjM2MzYzNiAxLjYyODA1NTUgMy42MzYzNjM2IDMuNjM2MzYzNiAwIDIuMDA4MzA4Mi0xLjYyODA1NTUgMy42MzYzNjM3LTMuNjM2MzYzNiAzLjYzNjM2MzdsLTIuMTgyNjM2NC0uMDAwODE4Mi4wMDA4MTgyIDIuMTgyNjM2NGMwIDIuMDA4MzA4MS0xLjYyODA1NTUgMy42MzYzNjM2LTMuNjM2MzYzNyAzLjYzNjM2MzYtMi4wMDgzMDgxIDAtMy42MzYzNjM2LTEuNjI4MDU1NS0zLjYzNjM2MzYtMy42MzYzNjM2bC0uMDAwMDkwOS0yLjE4MjYzNjRoLTUuODE5em0tLjAwMDkwOTEtOS40NTQ2MzY0aDUuODE5di01LjgxOWgtNS44MTl6IiBmaWxsPSJ1cmwoI2QpIiB0cmFuc2Zvcm09Im1hdHJpeCguODY2MDI1NCAtLjUgLjUgLjg2NjAyNTQgLTExLjcxMjgxMyAyMC4yODcxODcpIi8+PC9nPjwvc3ZnPg==`;
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.bitpie) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.bitpie;
			let account;
			try {
				account = await wallet.getAccount();
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		if (this._wallet) {
			this._wallet = null;
			this._publicKey = null;
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-clover/lib/esm/adapter.js
init_index_browser_esm();
const CloverWalletName = "Clover";
var CloverWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = CloverWalletName;
		this.url = "https://clv.org";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTM2LjQ4IDBIMTEuNTJDNS4xNTc2OCAwIDAgNS4xNTc2OCAwIDExLjUyVjM2LjQ4QzAgNDIuODQyMyA1LjE1NzY4IDQ4IDExLjUyIDQ4SDM2LjQ4QzQyLjg0MjMgNDggNDggNDIuODQyMyA0OCAzNi40OFYxMS41MkM0OCA1LjE1NzY4IDQyLjg0MjMgMCAzNi40OCAwWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzc5MTBfMTYzMzUxKSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTI0LjAwMDYgMzkuMzYwNkMzMi40ODM3IDM5LjM2MDYgMzkuMzYwNiAzMi40ODM3IDM5LjM2MDYgMjQuMDAwNkMzOS4zNjA2IDE1LjUxNzUgMzIuNDgzNyA4LjY0MDYyIDI0LjAwMDYgOC42NDA2MkMxNS41MTc1IDguNjQwNjIgOC42NDA2MiAxNS41MTc1IDguNjQwNjIgMjQuMDAwNkM4LjY0MDYyIDMyLjQ4MzcgMTUuNTE3NSAzOS4zNjA2IDI0LjAwMDYgMzkuMzYwNlpNMjEuMjg5OSAxNS44Njg4SDI2LjcxMVYyMS4zNDdIMjEuMjkwNFYyNi42NTRIMjYuNzExVjMyLjEzMjJIMjEuMjg5OVYyNi44MjUySDE1Ljg2OTNWMjEuMzQ3SDIxLjI4OTlWMTUuODY4OFpNMjYuNzEyIDIxLjM0N0gzMi4xMzMxVjI2LjgyNTJIMjYuNzEyVjIxLjM0N1oiIGZpbGw9ImJsYWNrIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNzkxMF8xNjMzNTEiIHgxPSI0OCIgeTE9Ii0xLjQzMDUxZS0wNiIgeDI9IjEuNDMwNTFlLTA2IiB5Mj0iNDgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0E5RkZFMCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM4NkQ1RkYiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.clover_solana?.isCloverWallet) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.clover_solana;
			let account;
			try {
				account = await wallet.getAccount();
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		if (this._wallet) {
			this._wallet = null;
			this._publicKey = null;
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return Uint8Array.from(signature);
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-coin98/node_modules/base-x/src/esm/index.js
function base$2(ALPHABET$3) {
	if (ALPHABET$3.length >= 255) throw new TypeError("Alphabet too long");
	const BASE_MAP = new Uint8Array(256);
	for (let j$2 = 0; j$2 < BASE_MAP.length; j$2++) BASE_MAP[j$2] = 255;
	for (let i$2 = 0; i$2 < ALPHABET$3.length; i$2++) {
		const x$6 = ALPHABET$3.charAt(i$2);
		const xc$1 = x$6.charCodeAt(0);
		if (BASE_MAP[xc$1] !== 255) throw new TypeError(x$6 + " is ambiguous");
		BASE_MAP[xc$1] = i$2;
	}
	const BASE = ALPHABET$3.length;
	const LEADER = ALPHABET$3.charAt(0);
	const FACTOR = Math.log(BASE) / Math.log(256);
	const iFACTOR = Math.log(256) / Math.log(BASE);
	function encode(source) {
		if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
		else if (Array.isArray(source)) source = Uint8Array.from(source);
		if (!(source instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
		if (source.length === 0) return "";
		let zeroes = 0;
		let length = 0;
		let pbegin = 0;
		const pend = source.length;
		while (pbegin !== pend && source[pbegin] === 0) {
			pbegin++;
			zeroes++;
		}
		const size$4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
		const b58 = new Uint8Array(size$4);
		while (pbegin !== pend) {
			let carry = source[pbegin];
			let i$2 = 0;
			for (let it1 = size$4 - 1; (carry !== 0 || i$2 < length) && it1 !== -1; it1--, i$2++) {
				carry += 256 * b58[it1] >>> 0;
				b58[it1] = carry % BASE >>> 0;
				carry = carry / BASE >>> 0;
			}
			if (carry !== 0) throw new Error("Non-zero carry");
			length = i$2;
			pbegin++;
		}
		let it2 = size$4 - length;
		while (it2 !== size$4 && b58[it2] === 0) it2++;
		let str = LEADER.repeat(zeroes);
		for (; it2 < size$4; ++it2) str += ALPHABET$3.charAt(b58[it2]);
		return str;
	}
	function decodeUnsafe(source) {
		if (typeof source !== "string") throw new TypeError("Expected String");
		if (source.length === 0) return new Uint8Array();
		let psz = 0;
		let zeroes = 0;
		let length = 0;
		while (source[psz] === LEADER) {
			zeroes++;
			psz++;
		}
		const size$4 = (source.length - psz) * FACTOR + 1 >>> 0;
		const b256 = new Uint8Array(size$4);
		while (psz < source.length) {
			const charCode = source.charCodeAt(psz);
			if (charCode > 255) return;
			let carry = BASE_MAP[charCode];
			if (carry === 255) return;
			let i$2 = 0;
			for (let it3 = size$4 - 1; (carry !== 0 || i$2 < length) && it3 !== -1; it3--, i$2++) {
				carry += BASE * b256[it3] >>> 0;
				b256[it3] = carry % 256 >>> 0;
				carry = carry / 256 >>> 0;
			}
			if (carry !== 0) throw new Error("Non-zero carry");
			length = i$2;
			psz++;
		}
		let it4 = size$4 - length;
		while (it4 !== size$4 && b256[it4] === 0) it4++;
		const vch = new Uint8Array(zeroes + (size$4 - it4));
		let j$2 = zeroes;
		while (it4 !== size$4) vch[j$2++] = b256[it4++];
		return vch;
	}
	function decode(string) {
		const buffer$1 = decodeUnsafe(string);
		if (buffer$1) return buffer$1;
		throw new Error("Non-base" + BASE + " character");
	}
	return {
		encode,
		decodeUnsafe,
		decode
	};
}
var esm_default$5 = base$2;

//#endregion
//#region node_modules/@solana/wallet-adapter-coin98/node_modules/bs58/src/esm/index.js
var ALPHABET$2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default$4 = esm_default$5(ALPHABET$2);

//#endregion
//#region node_modules/@solana/wallet-adapter-coin98/lib/esm/adapter.js
init_index_browser_esm();
const Coin98WalletName = "Coin98";
var Coin98WalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = Coin98WalletName;
		this.url = "https://coin98.com";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA3NiA3NSI+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9ImEiIHgxPSIxMDEuNjgxJSIgeDI9Ii0xLjU1NyUiIHkxPSIxNS4yNjglIiB5Mj0iODQuOTE3JSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiNGMUQ5NjEiLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjQ0RBMTQ2Ii8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KICA8ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgPHJlY3Qgd2lkdGg9Ijc1IiBoZWlnaHQ9Ijc1IiBmaWxsPSIjMDAwIiByeD0iMTYiLz4KICAgIDxwYXRoIGZpbGw9InVybCgjYSkiIGZpbGwtcnVsZT0ibm9uemVybyIgZD0iTTYxLjQ0IDBhMTMuNzE0IDEzLjcxNCAwIDAgMSA5LjY4IDQuMDEgMTMuNjYxIDEzLjY2MSAwIDAgMSA0LjAwOCA5LjY2OHY0Ny42NDZhMTMuNjYgMTMuNjYgMCAwIDEtNC4wMDcgOS42NjZBMTMuNzEzIDEzLjcxMyAwIDAgMSA2MS40NCA3NUgxMy42ODZhMTMuNzEzIDEzLjcxMyAwIDAgMS05LjY4LTQuMDFBMTMuNjYgMTMuNjYgMCAwIDEgMCA2MS4zMjRWMTMuNjc4YzAtMy42MjUgMS40NC03LjEwMiA0LjAwNy05LjY2N0ExMy43MTQgMTMuNzE0IDAgMCAxIDEzLjY4NyAwWk0yMC4wNjMgNDYuMjMxaC00LjgyNWExMC4wMzIgMTAuMDMyIDAgMCAwIDIuOTQ2IDcuMDg2IDEwLjA3IDEwLjA3IDAgMCAwIDcuMSAyLjk0MiAxMC4wNjUgMTAuMDY1IDAgMCAwIDcuMTA4LTIuOTM1IDEwLjAzIDEwLjAzIDAgMCAwIDIuOTQ2LTcuMDkzaC00LjgyNGE1LjIwNyA1LjIwNyAwIDAgMS0xLjUzIDMuNjg4IDUuMjI1IDUuMjI1IDAgMCAxLTMuNjk2IDEuNTI4IDUuMjM0IDUuMjM0IDAgMCAxLTMuNjk1LTEuNTI4IDUuMjEzIDUuMjEzIDAgMCAxLTEuNTMtMy42ODhaTTU0LjMzIDMzLjcxNmExMS43NjMgMTEuNzYzIDAgMCAwLTEyLjc5OSAyLjUzOEExMS42OTcgMTEuNjk3IDAgMCAwIDM4Ljk5IDQ5LjAzYTExLjcyMyAxMS43MjMgMCAwIDAgNC4zMjggNS4yNTkgMTEuNzU3IDExLjc1NyAwIDAgMCA2LjUyNiAxLjk3IDExLjc2NiAxMS43NjYgMCAwIDAgOC4yOS0zLjQzNSAxMS43MiAxMS43MiAwIDAgMCAzLjQ0Mi04LjI3NCAxMS43MDIgMTEuNzAyIDAgMCAwLTEuOTc1LTYuNTE0IDExLjczNiAxMS43MzYgMCAwIDAtNS4yNjktNC4zMlptLTQuNDg4IDMuOTJhNi45MzcgNi45MzcgMCAwIDEgNC45IDIuMDI1IDYuOTEgNi45MSAwIDAgMSAyLjAyOCA0Ljg5MiA2Ljg5NyA2Ljg5NyAwIDAgMS0xLjE3IDMuODM0IDYuOTMyIDYuOTMyIDAgMCAxLTEwLjY0MyAxLjA0MiA2LjkwMiA2LjkwMiAwIDAgMS0xLjUtNy41MjIgNi45MDkgNi45MDkgMCAwIDEgMi41NDQtMy4xIDYuOTI4IDYuOTI4IDAgMCAxIDMuODQxLTEuMTY3Wm0uMTcgNC41NTJhMi40MzEgMi40MzEgMCAwIDAtMi4yNDEgMS4xNTQgMi40MTggMi40MTggMCAwIDAtLjM1NiAxLjI1NyAyLjM5NSAyLjM5NSAwIDAgMCAxLjYxOSAyLjI5djEuNzUzaDEuNjE4di0xLjc1NGEyLjQyNyAyLjQyNyAwIDAgMCAxLjU5NC0xLjk1IDIuNDE4IDIuNDE4IDAgMCAwLTEtMi4zMSAyLjQzMSAyLjQzMSAwIDAgMC0xLjIzNC0uNDRabS0yMC4yMi0yMi41NTJhMTEuNzYyIDExLjc2MiAwIDAgMC0xMi43OTYgMi41MzEgMTEuNjk3IDExLjY5NyAwIDAgMC0yLjU1NCAxMi43NjkgMTEuNzIzIDExLjcyMyAwIDAgMCA0LjMyIDUuMjYyIDExLjc1NyAxMS43NTcgMCAwIDAgMTQuODI1LTEuNDQ2IDExLjcxNyAxMS43MTcgMCAwIDAgMy40NDUtOC4yODQgMTEuNzAzIDExLjcwMyAwIDAgMC0xLjk3NC02LjUxMiAxMS43MzYgMTEuNzM2IDAgMCAwLTUuMjY2LTQuMzJabS00LjUxIDMuOTE3YTYuOTQ1IDYuOTQ1IDAgMCAxIDQuODk3IDIuMDI5IDYuOTE4IDYuOTE4IDAgMCAxIDIuMDMyIDQuODg2IDYuOTA2IDYuOTA2IDAgMCAxLTEuMTY4IDMuODQyIDYuOTQgNi45NCAwIDAgMS0xMC42NiAxLjA0OCA2LjkxMSA2LjkxMSAwIDAgMS0xLjUtNy41MzYgNi45MTggNi45MTggMCAwIDEgMi41NS0zLjEwMyA2LjkzNyA2LjkzNyAwIDAgMSAzLjg1LTEuMTY2Wm0yNC41Ni00LjgxYTEwLjA1OSAxMC4wNTkgMCAwIDAtNy4xMDMgMi45NCAxMC4wMiAxMC4wMiAwIDAgMC0yLjk0IDcuMDkgOS45IDkuOSAwIDAgMCAxLjIzIDQuNzk1IDEzLjU3NSAxMy41NzUgMCAwIDEgNC4yMTQtMi4zMjIgNS4wODIgNS4wODIgMCAwIDEtLjYyNS0yLjQ3NyA1LjIwNiA1LjIwNiAwIDAgMSAxLjUwMy0zLjczNiA1LjIyMyA1LjIyMyAwIDAgMSAzLjcyMi0xLjU1NCA1LjIzNCA1LjIzNCAwIDAgMSAzLjcyIDEuNTU0IDUuMjEzIDUuMjEzIDAgMCAxIDEuNTA1IDMuNzM2IDUuMjc5IDUuMjc5IDAgMCAxLS42MjMgMi40NzMgMTMuNTc0IDEzLjU3NCAwIDAgMSA0LjIxMyAyLjMyMiA5LjkwMyA5LjkwMyAwIDAgMCAxLjIzLTQuNzk1IDEwLjAzMiAxMC4wMzIgMCAwIDAtMi45NDYtNy4wODYgMTAuMDcgMTAuMDcgMCAwIDAtNy4xLTIuOTRabS0yMy43NSA3Ljk5aC0xLjYxN3YxLjc1YTIuNDE5IDIuNDE5IDAgMCAwLTEuNTgyIDIuNjg3IDIuNDE0IDIuNDE0IDAgMCAwIDIuMzkgMi4wMDYgMi40NSAyLjQ1IDAgMCAwIDEuNTU1LS41NzQgMi40MTQgMi40MTQgMCAwIDAtLjc0Ni00LjExOXYtMS43NVoiLz4KICA8L2c+Cjwvc3ZnPgo=";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.coin98?.sol) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected();
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.coin98.sol;
			let account;
			try {
				account = (await wallet.connect())[0];
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const response = await wallet.request({
					method: "sol_sign",
					params: [transaction]
				});
				const publicKey = new PublicKey(response.publicKey);
				const signature = esm_default$4.decode(response.signature);
				transaction.addSignature(publicKey, Buffer.from(signature));
				return transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const response = await wallet.request({
					method: "sol_signAllTransactions",
					params: [transactions]
				});
				const publicKey = new PublicKey(response.publicKey);
				const signatures = response.signatures;
				return transactions.map((transaction, index$1) => {
					const signature = esm_default$4.decode(signatures[index$1]);
					transaction.addSignature(publicKey, Buffer.from(signature));
					return transaction;
				});
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const response = await wallet.request({
					method: "sol_signMessage",
					params: [message]
				});
				return esm_default$4.decode(response.signature);
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-coinbase/lib/esm/adapter.js
init_index_browser_esm();
const CoinbaseWalletName = "Coinbase Wallet";
var CoinbaseWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = CoinbaseWalletName;
		this.url = "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSI1MTIiIGN5PSI1MTIiIHI9IjUxMiIgZmlsbD0iIzAwNTJGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MiA1MTJDMTUyIDcxMC44MjMgMzEzLjE3NyA4NzIgNTEyIDg3MkM3MTAuODIzIDg3MiA4NzIgNzEwLjgyMyA4NzIgNTEyQzg3MiAzMTMuMTc3IDcxMC44MjMgMTUyIDUxMiAxNTJDMzEzLjE3NyAxNTIgMTUyIDMxMy4xNzcgMTUyIDUxMlpNNDIwIDM5NkM0MDYuNzQ1IDM5NiAzOTYgNDA2Ljc0NSAzOTYgNDIwVjYwNEMzOTYgNjE3LjI1NSA0MDYuNzQ1IDYyOCA0MjAgNjI4SDYwNEM2MTcuMjU1IDYyOCA2MjggNjE3LjI1NSA2MjggNjA0VjQyMEM2MjggNDA2Ljc0NSA2MTcuMjU1IDM5NiA2MDQgMzk2SDQyMFoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=";
		this.supportedTransactionVersions = new Set(["legacy", 0]);
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window?.coinbaseSolana) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.coinbaseSolana;
			try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				if (isVersionedTransaction(transaction)) signers?.length && transaction.sign(signers);
				else {
					transaction = await this.prepareTransaction(transaction, connection, sendOptions);
					signers?.length && transaction.partialSign(...signers);
				}
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-coinhub/lib/esm/adapter.js
init_index_browser_esm();
const CoinhubWalletName = "Coinhub";
var CoinhubWalletAdapter = class extends BaseSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = CoinhubWalletName;
		this.url = "https://coinhub.org";
		this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTAwcHgiIGhlaWdodD0iMTAwcHgiIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPHRpdGxlPuefqeW9ojwvdGl0bGU+CiAgICA8ZyBpZD0i6aG16Z2iLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSLkuIvovb3pobVpb3MiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMzguMDAwMDAwLCAtOTQuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSJDb2luaHViLSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM4LjAwMDAwMCwgOTQuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0i55+p5b2iIiB4PSIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgICAgICAgICAgPGcgaWQ9Iue8lue7hCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMy4zMzMzMzMsIDMuMzMzMzMzKSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNTcuOTU2MzU0Miw0MC43MDQ2MzE2IEM1Ny45NTYzNTQyLDQwLjcwNDYzMTYgNjIuNzc2ODc1LDU2LjM0NTIxMDUgODEuNjE1OTg5Niw1OC41MTY2ODQyIEM4NC43MzEzNTQyLDU4Ljg3NTUyNjMgODguMjYwNTIwOCw1OS4yNjM4NDIxIDkxLjg2ODQzNzUsNTguMTg4MDUyNiBDOTIuMDIyMjkxNyw1OC4xOTc2MzE2IDkyLjE3MjUsNTguMjQwNzM2OCA5Mi4zMDgxMjUsNTguMzE0MDUyNiBDOTIuNDQ0MTE0Niw1OC4zODczNjg0IDkyLjU2Mjk2ODgsNTguNDg5MDUyNiA5Mi42NTY2NjY3LDU4LjYxMjg0MjEgQzkyLjc1LDU4LjczNjYzMTYgOTIuODE1OTg5Niw1OC44Nzk1Nzg5IDkyLjg1MDI2MDQsNTkuMDMxMzY4NCBDOTIuODg0NTMxMyw1OS4xODMxNTc5IDkyLjg4NTYyNSw1OS4zNDA0NzM3IDkyLjg1NDI3MDgsNTkuNDkzIEM5Mi4zMjM4MDIxLDYzLjE1MTc4OTUgOTEuMTIzNTkzNyw2Ni42Nzg2ODQyIDg5LjMxNTI2MDQsNjkuODkzNTI2MyBDODQuNzQxMTk3OSw3OC4xMTE4OTQ3IDc0LjY5NTQ2ODgsODguOTgwNjg0MiA1Mi4wMTE4MjI5LDkyLjgwNiBDNTAuODA5MDYyNSw5Mi44MDYgNDguNDMzMDcyOSw5MS43NDAxNTc5IDQ3LjMyOTExNDYsOTEuOTI5NTI2MyBDNDcuMzI5MTE0Niw5MS45MDkyNjMyIDE5Ljk3MjUzMTIsNjcuNjUyMDUyNiA1Ny45NTYzNTQyLDQwLjcwNDYzMTYgWiIgaWQ9Iui3r+W+hCIgZmlsbD0iI0NGQkZBMyI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01Mi4wMTE0NTgzLDkyLjgwNiBDNTIuMDExNDU4Myw5Mi44MDYgMzIuMTk2NSw2NC4xNzUyNjMyIDYzLjMwOTE2NjcsNDkuNTExIEw1OS40MzQ3Mzk2LDQ0LjQxMDU3ODkgQzU5LjQzNDczOTYsNDQuNDEwNTc4OSAxOS4xNDQxOTc5LDY1LjE5MTM2ODQgNTIuMDExNDU4Myw5Mi44MDYgWiIgaWQ9Iui3r+W+hCIgZmlsbD0iI0I5QTc5OCI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05Mi44NTQ2MzU0LDU5LjUzMzE1NzkgQzkyLjIzOTU4MzMsNjMuMzYxMDUyNiA5MC45NDAyMDgzLDY3LjA0Mzc4OTUgODkuMDE5OTQ3OSw3MC40MDE1Nzg5IEw4My4yNjI0NDc5LDU4LjY5NjEwNTMgQzg1LjkzMDEwNDIsNTkuMDU0OTQ3NCA4OC42Mzk2ODc1LDU4LjkxNjQyMTEgOTEuMjU3NzYwNCw1OC4yODc4OTQ3IEM5Mi41MDk3Mzk2LDU3Ljk5OTA1MjYgOTMuMDUxODc1LDU4LjQxNzIxMDUgOTIuODU0NjM1NCw1OS41MzMxNTc5IFoiIGlkPSLot6/lvoQiIGZpbGw9IiM4QzY3NDIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNTkuNzk5Njg3NSw2Ny41MzIzMTU4IEM2Mi4wMTU2MjUsNjcuNTMyMzE1OCA2My44MTE5MjcxLDY1LjcxNzEwNTMgNjMuODExOTI3MSw2My40Nzc4NDIxIEM2My44MTE5MjcxLDYxLjIzODU3ODkgNjIuMDE1NjI1LDU5LjQyMzM2ODQgNTkuNzk5Njg3NSw1OS40MjMzNjg0IEM1Ny41ODM3NSw1OS40MjMzNjg0IDU1Ljc4NzQ0NzksNjEuMjM4NTc4OSA1NS43ODc0NDc5LDYzLjQ3Nzg0MjEgQzU1Ljc4NzQ0NzksNjUuNzE3MTA1MyA1Ny41ODM3NSw2Ny41MzIzMTU4IDU5Ljc5OTY4NzUsNjcuNTMyMzE1OCBaIiBpZD0i6Lev5b6EIiBmaWxsPSIjMjIyMjIyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYwLjU1OTExNDYsNi44MTQwMjEwNSBMNjMuODkxMDQxNywxLjI3NTEzNDc0IEM1OC4yNzI4MTI1LDIuMjE4NjEzMTYgNTIuNzc3MDgzMywzLjc5NTg0MjExIDQ3LjUwNjY2NjcsNS45NzcxODk0NyBDNDYuMTIzODAyMSw2LjEwODQ5NDc0IDQ0Ljc0ODU5MzcsNi4zMTEzMTA1MyA0My4zODYxNDU4LDYuNTg0ODYzMTYgTDUwLjA2MDIwODMsMy40NjI0NjIyOWUtMTMgQzQzLjQ2MzA3MjksMS42MzEzMDk0NyAzNy40ODkzNzUsNS4xOTM3NDIxMSAzMi44ODcwNTczLDEwLjI0MDkyNjMgQzMyLjIwNjgxNzcsMTAuNTc5NjUyNiAzMS41MzY0NTgzLDEwLjk0ODI1NzkgMzAuOTE1MzkwNiwxMS4zMzY3NTc5IEwzNi4xNTAxMTQ2LDEuNTkzOTI1NzkgQzI5LjA0OTE5NzksNS40NjMyNDIxMSAyMy40ODAzMzMzLDExLjY4MTYzNjggMjAuMzc2OTYzNSwxOS4yMDY3NDc0IEwyMy42MTA0NTMxLDcuODUwMDU3ODkgQzIzLjYxMDQ1MzEsNy44NTAwNTc4OSAxNS40Mzc5ODk2LDE0LjEwNjIxNTggMTMuOTg4ODQzNywyOS41MzczNDc0IEMxMy44MDE1MjA4LDI5LjkxNTkgMTMuNjE0MTk3OSwzMC4yOTQ0NTI2IDEzLjQzNjc1NTIsMzAuNjgyOTUyNiBMMTIuNTQ5NTQxNywxNi44NTU3MDUzIEMxMi41NDk1NDE3LDE2Ljg1NTcwNTMgNC42MDM4MTI1LDI5LjY1Njg2MzIgOS43MTAzNDg5Niw0NC4xMzE2ODQyIEw0LjE2MDE4NzUsMzAuMTg0ODQ3NCBDNC4xNjAxODc1LDMwLjE4NDg0NzQgMC43MTk2NTEwNDIsNDEuMTQzMDUyNiA5LjA4OTI4MTI1LDU1LjM0OSBMLTIuNzYzMjIxNzVlLTE0LDQ0LjcwOTM2ODQgQy0yLjc2MzIyMTc1ZS0xNCw0NC43MDkzNjg0IDAuODc3MzgwNzI5LDYzLjA2OTI2MzIgMTEuMjY3OTU4Myw3My4wMDE1MjYzIEMxMS4yNjc5NTgzLDczLjAwMTUyNjMgMTUuMDA0MjA4Myw3MS44NzYgMTcuMzAxMTkyNyw3NC41NDU1Nzg5IEMyMC45NjAyMjQsNzkuOTIzNDIxMSAyNS44MDI5NDc5LDg0LjM3MSAzMS40NDkxNzcxLDg3LjUzOTQyMTEgQzM3LjA5NTI2MDQsOTAuNzA3NDczNyA0My4zOTE2MTQ2LDkyLjUxMDUyNjMgNDkuODQzMjgxMiw5Mi44MDYgQzUwLjM4NTQxNjcsOTIuODA2IDUxLjQ2OTY4NzUsOTIuODA2IDUxLjQ2OTY4NzUsOTIuODA2IEM1MS40Njk2ODc1LDkyLjgwNiAzMi4xODcwOTM3LDc1Ljk4MDIxMDUgNTAuNzY5Njg3NSw1MS45NjE3MzY4IEM2OS4zNjIzNDM3LDI5Ljg1NjEwNTMgOTMuMzg2OTI3MSw0NS4yMjczNjg0IDkzLjE2MDE1NjIsNDMuMjQ0ODk0NyBDOTIuMDM3NjA0MiwzNC41NDI2Nzg5IDg4LjMxNTU3MjksMjYuMzkzMjA1MyA4Mi40OTA2MjUsMTkuODgzOTc4OSBDNzYuNjY1Njc3MSwxMy4zNzQ3NTI2IDY5LjAxNDg5NTgsOC44MTUzMjEwNSA2MC41NTkxMTQ2LDYuODE0MDIxMDUgTDYwLjU1OTExNDYsNi44MTQwMjEwNSBaIiBpZD0i6Lev5b6EIiBmaWxsPSIjMjJBMDc5Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQzLjM0NjQwNjMsNzguNTgwMTU3OSBDNDMuMzQ2NDA2Myw3OC41ODAxNTc5IDIyLjA2MjQzMjMsODYuMDgxNTc4OSAyLjI4NjgzNDM4LDU3LjAzMjMxNTggQzQuNDA4MTc3MDgsNjQuNjU0MjEwNSA4LjIwNjE1MTA0LDcxLjY5MzI2MzIgMTMuMzk3MDUyMSw3Ny42MjM3MzY4IEMyMC42MjMxMzAyLDg2LjAyMTg5NDcgMzQuOTc2NzM5Niw5My4zMTQwNTI2IDUyLjAxMTgyMjksOTIuNzg2MTA1MyBDNDkuOTUzNzUsOTEuMTc5NDIxMSA0OC4yMzcyOTE3LDg5LjE3MDQyMTEgNDYuOTY0MTY2Nyw4Ni44Nzg0NzM3IEM0NS40OTM4MDIxLDg0LjIzOCA0NC4yODE5MjcxLDgxLjQ1OSA0My4zNDY0MDYzLDc4LjU4MDE1NzkgTDQzLjM0NjQwNjMsNzguNTgwMTU3OSBaIiBpZD0i6Lev5b6EIiBmaWxsPSIjMUI4MDYxIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.coinhub?.isCoinhubWallet) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.coinhub;
			let account;
			try {
				account = await wallet.getAccount();
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		if (this._wallet) {
			this._wallet = null;
			this._publicKey = null;
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-fractal/lib/esm/adapter.js
init_index_browser_esm();
const FractalWalletName = "Fractal";
var FractalWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = FractalWalletName;
		this.url = "https://developers.fractal.is/wallet-adapters/solana";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiPjxwYXRoIGQ9Ik0zNDIuMjQgNzYzLjkzVjI0My44Mkg3MTV2MTEyLjY5SDQ4MXYxMTUuNThoMTgydjExMi42OUg0ODF2MTc5LjE1WiIgc3R5bGU9ImZpbGw6I2RlMzU5YyIvPjwvc3ZnPg==";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Loadable) throw new WalletNotReadyError();
			this._connecting = true;
			let FractalWalletClass;
			try {
				FractalWalletClass = (await import("./esm-B4lTqOBW.js")).FractalWalletAdapterImpl;
			} catch (error) {
				throw new WalletLoadError(error?.message, error);
			}
			let wallet;
			try {
				wallet = new FractalWalletClass();
			} catch (error) {
				throw new WalletConfigError(error?.message, error);
			}
			if (!wallet.getPublicKey()) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.getPublicKey().toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return wallet.signTransaction(transaction);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return wallet.signAllTransactions(transactions);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return wallet.signMessage(message);
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-huobi/lib/esm/adapter.js
init_index_browser_esm();
const HuobiWalletName = "HuobiWallet";
var HuobiWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = HuobiWalletName;
		this.url = "https://www.huobiwallet.io";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjI0IiBoZWlnaHQ9IjIyNCIgdmlld0JveD0iMCAwIDIyNCAyMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMCAwTDIyNCAwVjIyNEgwTDAgMFoiIGZpbGw9IiMyMTU3RTIiLz4KPHBhdGggZD0iTTEzMS4wNTkgODEuMTc3MUMxMzEuMDU5IDU3Ljc1MzEgMTE5LjQ1OCAzNy42MzE1IDExMC42MjUgMzEuMDcyOEMxMTAuNjI1IDMxLjA3MjggMTA5Ljk1MyAzMC43MDQyIDExMCAzMS42MjU4VjMxLjYyNThDMTA5LjI2NSA3Ni44MzAzIDg1Ljc2NzIgODkuMDg3NSA3Mi44MzggMTA1LjU4NEM0My4wMjQxIDE0My42NzcgNzAuNzU4NyAxODUuNDU2IDk4Ljk5MzUgMTkzLjEzNkMxMTQuNzk5IDE5Ny40NTIgOTUuMzUwOCAxODUuNDU2IDkyLjg0OTQgMTYwLjIzNUM4OS44MDA3IDEyOS43NDUgMTMxLjA1OSAxMDYuNDQ0IDEzMS4wNTkgODEuMTc3MVoiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xMTAxXzEyNSkiLz4KPHBhdGggZD0iTTE0My41OTcgOTYuMzE3NEMxNDMuNDA5IDk2LjE5NDMgMTQzLjE1OCA5Ni4xMDIgMTQyLjk4NiA5Ni4zOTQzQzE0Mi40ODQgMTAyLjEwMiAxMzYuNTYgMTE0LjI4NiAxMjkuMDM3IDEyNS40ODZDMTAzLjU1MiAxNjMuNDU1IDExOC4wNjUgMTgxLjc2MiAxMjYuMjQ3IDE5MS42MzlDMTMwLjk0OSAxOTcuMzQ3IDEyNi4yNDcgMTkxLjYzOSAxMzguMDk2IDE4NS44MDhDMTUyLjczNSAxNzcuMDkyIDE2Mi4yMzQgMTYyLjAyIDE2My42NDMgMTQ1LjI3QzE2NS4yMzMgMTI2Ljc1OCAxNTcuNzk4IDEwOC42IDE0My41OTcgOTYuMzE3NFoiIGZpbGw9InVybCgjcGFpbnQxX2xpbmVhcl8xMTAxXzEyNSkiLz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xMTAxXzEyNSIgeDE9IjEyMi40MDEiIHkxPSIyMDkuMjk1IiB4Mj0iMTc4LjY2MiIgeTI9IjExMC40NDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y3RjZGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQxX2xpbmVhcl8xMTAxXzEyNSIgeDE9IjE1Ny44NjEiIHkxPSIyMDMuMTc3IiB4Mj0iMTg5LjAxNCIgeTI9IjE0MC4wMjIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y3RjZGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIi8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg==";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.huobiWallet?.isHuobiWallet) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.huobiWallet;
			try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			this.emit("disconnect");
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-hyperpay/lib/esm/adapter.js
init_index_browser_esm();
const HyperPayWalletName = "HyperPay";
var HyperPayWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = HyperPayWalletName;
		this.url = "https://hyperpay.io";
		this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNTIwcHgiIGhlaWdodD0iNTIwcHgiIHZpZXdCb3g9IjAgMCA1MjAgNTIwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPHRpdGxlPkh5cGVyUGF5PC90aXRsZT4KICAgIDxnIGlkPSLpobXpnaItMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9Iue8lue7hC0zMyIgZmlsbD0iIzFBNzJGRSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPHBhdGggZD0iTTI2MCwwIEM0MDMuNTIsMCA1MjAsMTE1Ljk0MTI1NSA1MjAsMjU5LjY1Mjg3IEM1MjAsNDAzLjM2NDQ4NiA0MDMuNTIsNTIwIDI2MCw1MjAgQzExNi40OCw1MjAgMCw0MDQuMDU4NzQ1IDAsMjYwLjM0NzEzIEMwLDExNi42MzU1MTQgMTE2LjQ4LDAgMjYwLDAgWiBNMTIzLjQ2Mzk4NSwxMjIuNjQ3NzM3IEwxMjMuNDEzMzMzLDEyMi42NDc1MyBMMTA2LjA4LDE4My42MjQ4MzMgTDIyMS44NjY2NjcsMTgzLjYyNDgzMyBMMjA4LDI0OC43NTk2OCBMMjc5LjQxMzMzMywyNDguNzU5NjggTDI3OS40MTMzMzMsMjQ4Ljc1OTY4IEwyNzkuNDEzODUzLDI0OC43MDU5NzggQzI3OS40MjM3MzMsMjQ4LjAxNDc4NiAyNzkuNjIxMzMzLDI0MC40NDQ1OTMgMjgzLjU3MzMzMywyMTQuMTEzNDg1IEMyODkuODEzMzMzLDE3MC40NTkyNzkgMzY1LjM4NjY2NywxNjcuNjg3NTgzIDM2NC42OTMzMzMsMjE2Ljg4NTE4IEMzNjQsMjUyLjkxNzIyMyAzMzYuMjY2NjY3LDI1Ny4wNzQ3NjYgMzE4LjI0LDI1Ny43Njc2OSBDMzEyLjQ3MTQ2NywyNTcuOTg5NDI2IDI4Ni4xODQ3MDQsMjU4LjA2OTI1MSAyNTMuMTAyMDc3LDI1OC4wNzUyODIgTDI0My42Mjk3MDcsMjU4LjA3NTA4OSBDMTc0LjA4NzMzMywyNTguMDYwNDUxIDgxLjgxMzMzMzMsMjU3Ljc2NzY5IDgxLjgxMzMzMzMsMjU3Ljc2NzY5IEw4MS44MTMzMzMzLDI1Ny43Njc2OSBMNjEuNzA2NjY2NywzMTguMDUyMDY5IEwxODcuMiwzMTguMDUyMDY5IEwxNjguNDgsMzkxLjUwMjAwMyBMMjQ4LjkwNjY2NywzOTEuNTAyMDAzIEwyNjguMzIsMzE2LjY2NjIyMiBDMjY4LjMyLDMxNi42NjYyMjIgMjgzLjc5NTIsMzE2LjQxNjc2OSAyOTkuOTE5MzYsMzE2LjIxNzIwNyBMMzAyLjM0MDk5OCwzMTYuMTg3Njg0IEMzMTIuMzAxMzkyLDMxNi4wNjgxNTkgMzIyLjIyNjY2NywzMTUuOTczMjk4IDMyOC42NCwzMTUuOTczMjk4IEMzNTkuODQsMzE1Ljk3MzI5OCA0NDIuMzQ2NjY3LDI5NS44Nzg1MDUgNDQyLjM0NjY2NywyMDkuOTU1OTQxIEM0NDIuMzQ2NjY3LDEzMS42NTU1NDEgMzU3LjA2NjY2NywxMjMuMzQwNDU0IDMyNS4xNzMzMzMsMTIzLjM0MDQ1NCBDMjkzLjI4LDEyMy4zNDA0NTQgMTIzLjQxMzMzMywxMjIuNjQ3NTMgMTIzLjQxMzMzMywxMjIuNjQ3NTMgWiIgaWQ9IuW9oueKtue7k+WQiCI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.hyperPay?.solana?.isHyperPay) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.hyperPay.solana;
			try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			this.emit("disconnect");
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-keystone/lib/esm/adapter.js
init_index_browser_esm();
const KeystoneWalletName = "Keystone";
var KeystoneWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	constructor(config = {}) {
		super();
		this.name = KeystoneWalletName;
		this.url = "https://keyst.one";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxjaXJjbGUgY3g9IjE2IiBjeT0iMTYiIHI9IjE2IiBmaWxsPSJ3aGl0ZSIvPgogICAgPHJlY3QgeD0iNSIgeT0iNSIgd2lkdGg9IjIyIiBoZWlnaHQ9IjIyIiBmaWxsPSJ3aGl0ZSIgZmlsbC1vcGFjaXR5PSIxIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0LjY5NjUgNS40MzQ4N0MxNS4wOTEgNC43NTMxNiAxNi4wNzQ5IDQuNzUyMTEgMTYuNDcwOCA1LjQzMjk5TDE3LjMzOTggNi45MjcxOUMxNy42NDkgNy40NTg5NiAxNy42NDg3IDguMTE1ODggMTcuMzM4OSA4LjY0NzM0TDkuNjMxMjEgMjEuODcxQzkuMjE4NTEgMjIuNTc5MSA4LjE5NjIzIDIyLjU4MTEgNy43ODA3NiAyMS44NzQ2QzcuNzMxMzIgMjEuNzkwNiA3LjY5MzU4IDIxLjcwMDEgNy42Njg1OCAyMS42MDU4TDcuMzcwODggMjAuNDgyOUM3LjA5MjY2IDE5LjQzMzQgNy4yNDE4IDE4LjMxNjQgNy43ODU2MyAxNy4zNzY3TDE0LjY5NjUgNS40MzQ4N1pNMTIuNjYzNiAxOS4yODU4QzEzLjA2MzUgMTguNTk5NyAxNC4wMDM1IDE4LjQ3NTcgMTQuNTY3NyAxOS4wMzQ1TDE3LjQyODggMjEuODY4NkMxOC44NjA1IDIzLjI4NjcgMTguODU2NSAyNS42MDE2IDE3LjQyIDI3LjAxNDlDMTcuMjA0NSAyNy4yMjY5IDE2Ljg3OTggMjcuMjgyNSAxNi42MDYgMjcuMTU0MkwxMS42MDAyIDI0LjgwODFDMTAuNjkwNyAyNC4zODE5IDEwLjM0MyAyMy4yNjcxIDEwLjg0ODcgMjIuMzk5NEwxMi42NjM2IDE5LjI4NThaTTIwLjQzNSAxNi4zMzcyQzIxLjQ4OTcgMTYuMzM3MiAyMi4xNDc0IDE1LjE5MzkgMjEuNjE3MiAxNC4yODIyTDE5Ljc4MjggMTEuMTI4QzE5LjI1NTggMTAuMjIxOCAxNy45NDcxIDEwLjIyMTIgMTcuNDE5MiAxMS4xMjY5TDE1LjQzMDkgMTQuNTM4MUMxNC45NjYgMTUuMzM1OCAxNS41NDE0IDE2LjMzNzIgMTYuNDY0NyAxNi4zMzcyTDIwLjQzNSAxNi4zMzcyWiIgZmlsbD0iYmxhY2siLz4KICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjEuNzMwMyAxNy42NDU5QzIyLjg3MTMgMTcuNjQ1OSAyMy45MjYxIDE4LjI1MjcgMjQuNDk5OCAxOS4yMzlWMTkuMjM5QzI0LjY3NjMgMTkuNTQyNyAyNC42MjQ3IDE5LjkyNzQgMjQuMzc0MyAyMC4xNzM3TDIyLjA1MTEgMjIuNDU5QzIxLjQ1MDkgMjMuMDQ5NCAyMC40ODc3IDIzLjA0NzggMTkuODg5NSAyMi40NTUzTDE2LjUxMDEgMTkuMTA3OEMxNS45Njc3IDE4LjU3MDYgMTYuMzQ4MSAxNy42NDU5IDE3LjExMTYgMTcuNjQ1OUwyMS43MzAzIDE3LjY0NTlaIiBmaWxsPSIjMjE2MUZGIi8+Cjwvc3ZnPgo=";
		this.supportedTransactionVersions = new Set(["legacy", 0]);
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
		this._keyring = null;
		this._publicKey = null;
		this._connecting = false;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Loadable) throw new WalletNotReadyError();
			this._connecting = true;
			let keyring;
			try {
				const { DefaultKeyring } = await import("./dist-B2dV-GzL.js").then(__toDynamicImportESM(1));
				keyring = DefaultKeyring.getEmptyKeyring();
			} catch (error) {
				throw new WalletLoadError(error?.message, error);
			}
			let account;
			try {
				await keyring.readKeyring();
				account = keyring.getAccounts()[0].pubKey;
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._keyring = keyring;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		if (this._keyring) {
			this._keyring = null;
			this._publicKey = null;
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const keyring = this._keyring;
			const publicKey = this._publicKey;
			if (!keyring || !publicKey) throw new WalletNotConnectedError();
			try {
				if (isVersionedTransaction(transaction)) {
					const txHex = transaction.serialize();
					const signature = await keyring.signTransaction(publicKey.toString(), txHex);
					transaction.addSignature(publicKey, signature);
				} else {
					const txHex = transaction.serializeMessage();
					const signature = await keyring.signTransaction(publicKey.toString(), txHex);
					transaction.addSignature(publicKey, Buffer.from(signature));
				}
				return transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const keyring = this._keyring;
			const publicKey = this._publicKey?.toString();
			if (!keyring || !publicKey) throw new WalletNotConnectedError();
			try {
				return keyring.signMessage(publicKey, message);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-krystal/lib/esm/adapter.js
init_index_browser_esm();
const KrystalWalletName = "Krystal";
var KrystalWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = KrystalWalletName;
		this.url = "https://krystal.app";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjMDEwMTAxIi8+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiByeD0iMTAwIiBmaWxsPSIjMDEwMTAxIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjkxLjg4NyA4MC44NDA3QzI5MS44ODcgNzUuMDgyNiAyOTcuNTg1IDcxLjA1NzYgMzAzLjAxMiA3Mi45ODJMMzc3LjYxOCA5OS40Mzc2QzM4My4wMyAxMDEuMzU3IDM4NC45MjggMTA4LjA0MyAzODEuMzMxIDExMi41MTlMMzA2LjcyNSAyMDUuMzcyQzMwMS43OTQgMjExLjUxIDI5MS44ODcgMjA4LjAyMyAyOTEuODg3IDIwMC4xNVY4MC44NDA3Wk0xNTIuMzUzIDE3Mi4zM0MxNDYuMjg1IDE3NS44NDYgMTQ3LjAwNiAxODQuODI4IDE1My41NTcgMTg3LjMzM0wyNjYuMTEyIDIzMC4zNTNDMjcxLjU3MSAyMzIuNDQgMjc3LjQyNyAyMjguNDA5IDI3Ny40MjcgMjIyLjU2NVYxMTQuMzE5QzI3Ny40MjcgMTA3Ljg5NSAyNzAuNDY3IDEwMy44ODQgMjY0LjkwOCAxMDcuMTA1TDE1Mi4zNTMgMTcyLjMzWk03Mi41MjcyIDI5MC40NzJDNzIuMDY0MSAyOTYuMTg5IDc3LjM3NzUgMzAwLjY1NSA4Mi45Mjk3IDI5OS4yMTdMMjQ5LjkwNyAyNTUuOTQ1QzI1Ny43NjkgMjUzLjkwOCAyNTguMzc1IDI0Mi45NzcgMjUwLjc4NyAyNDAuMDgzTDkyLjIxMiAxNzkuNjEzQzg3LjAxOTEgMTc3LjYzMyA4MS4zNzg5IDE4MS4xOTEgODAuOTMwMiAxODYuNzNMNzIuNTI3MiAyOTAuNDcyWk0yNDkuOTA4IDI4Ni45M0MyNTIuMTQ2IDI4MC42MjcgMjQ2LjQyNCAyNzQuMzg3IDIzOS45NSAyNzYuMDcyTDEyNy42NDkgMzA1LjMwMkMxMjEuMzU3IDMwNi45MzkgMTE5LjI3NyAzMTQuODI5IDEyMy45NDQgMzE5LjM1NkwxOTkuNzYgMzkyLjkwNEMyMDQuMTE5IDM5Ny4xMzIgMjExLjM5MiAzOTUuNDMyIDIxMy40MjQgMzg5LjcwOEwyNDkuOTA4IDI4Ni45M1pNMzExLjk0MyAyNDQuMTQ3QzMwNS44MzEgMjQyLjg5NiAzMDMuMjA4IDIzNS42MjMgMzA3LjExNCAyMzAuNzU4TDM4NS43MDMgMTMyLjg4MkMzOTAuMTMyIDEyNy4zNjUgMzk4Ljk4NyAxMjkuNTI1IDQwMC4zNzkgMTM2LjQ2MUw0MjQuMjI5IDI1NS4zMTJDNDI1LjQwMyAyNjEuMTY0IDQyMC4yMjggMjY2LjMxOCA0MTQuMzgxIDI2NS4xMjFMMzExLjk0MyAyNDQuMTQ3Wk0zMjEuMjA0IDI2NC4wNjhDMzEzLjI5MSAyNjIuNDQyIDMwNy45MjEgMjcxLjg5MiAzMTMuMzY4IDI3Ny44NThMNDE1Ljc3OSAzOTAuMDMxQzQyMC41NDMgMzk1LjI0OSA0MjkuMjMxIDM5Mi41NDggNDMwLjE5NyAzODUuNTQ5TDQ0Mi40MjIgMjk2LjkzMkM0NDMuMDIyIDI5Mi41OCA0NDAuMTQzIDI4OC41MDkgNDM1Ljg0IDI4Ny42MjVMMzIxLjIwNCAyNjQuMDY4Wk0yNzYuMjQ3IDMwMi44MDhDMjc2LjA3NSAyOTMuNTM3IDI2My4xNzEgMjkxLjQyOCAyNjAuMDU2IDMwMC4xNjFMMjE1LjA1MiA0MjYuMzYyQzIxMi44NzUgNDMyLjQ2NSAyMTguMTg4IDQzOC42MTEgMjI0LjU0MyA0MzcuMzM4TDI3MS43MDcgNDI3Ljg5M0MyNzUuNjYgNDI3LjEwMiAyNzguNDgxIDQyMy41OTUgMjc4LjQwNiA0MTkuNTYzTDI3Ni4yNDcgMzAyLjgwOFpNMjkyLjI5NiAzMDQuMDM2QzI5Mi4xNTMgMjk2LjM2OSAzMDEuNTYzIDI5Mi41OTEgMzA2Ljc2MiAyOTguMjI4TDM4MS43NjUgMzc5LjU2QzM4Ni4yMTggMzg0LjM4OCAzODMuNTk5IDM5Mi4yMyAzNzcuMTM5IDM5My40MTRMMzAzLjkgNDA2LjgzM0MyOTguODQxIDQwNy43NiAyOTQuMTU3IDQwMy45MyAyOTQuMDYxIDM5OC43ODdMMjkyLjI5NiAzMDQuMDM2WiIgZmlsbD0iIzFERTlCNiIvPgo8L3N2Zz4K";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.krystal?.solana) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected();
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.krystal.solana;
			let account;
			try {
				account = (await wallet.connect())[0];
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-ledger/lib/esm/util.js
init_index_browser_esm();
function getDerivationPath(account, change) {
	const length = account !== void 0 ? change === void 0 ? 3 : 4 : 2;
	const derivationPath = Buffer.alloc(1 + length * 4);
	let offset = derivationPath.writeUInt8(length, 0);
	offset = derivationPath.writeUInt32BE(harden(44), offset);
	offset = derivationPath.writeUInt32BE(harden(501), offset);
	if (account !== void 0) {
		offset = derivationPath.writeUInt32BE(harden(account), offset);
		if (change !== void 0) derivationPath.writeUInt32BE(harden(change), offset);
	}
	return derivationPath;
}
var BIP32_HARDENED_BIT = 1 << 31 >>> 0;
function harden(n$2) {
	return (n$2 | BIP32_HARDENED_BIT) >>> 0;
}
var INS_GET_PUBKEY = 5;
var INS_SIGN_MESSAGE = 6;
var P1_NON_CONFIRM = 0;
var P1_CONFIRM = 1;
var P2_EXTEND = 1;
var P2_MORE = 2;
var MAX_PAYLOAD = 255;
var LEDGER_CLA = 224;
/** @internal */
async function getPublicKey(transport, derivationPath) {
	return new PublicKey(await send(transport, INS_GET_PUBKEY, P1_NON_CONFIRM, derivationPath));
}
/** @internal */
async function signTransaction(transport, transaction, derivationPath) {
	const paths = Buffer.alloc(1);
	paths.writeUInt8(1, 0);
	const message = isVersionedTransaction(transaction) ? transaction.message.serialize() : transaction.serializeMessage();
	return await send(transport, INS_SIGN_MESSAGE, P1_CONFIRM, Buffer.concat([
		paths,
		derivationPath,
		message
	]));
}
async function send(transport, instruction, p1, data) {
	let p2 = 0;
	let offset = 0;
	if (data.length > MAX_PAYLOAD) while (data.length - offset > MAX_PAYLOAD) {
		const buffer$2 = data.slice(offset, offset + MAX_PAYLOAD);
		if ((await transport.send(LEDGER_CLA, instruction, p1, p2 | P2_MORE, buffer$2)).length !== 2) throw new TransportStatusError(StatusCodes.INCORRECT_DATA);
		p2 |= P2_EXTEND;
		offset += MAX_PAYLOAD;
	}
	const buffer$1 = data.slice(offset);
	const response = await transport.send(LEDGER_CLA, instruction, p1, p2, buffer$1);
	return response.slice(0, response.length - 2);
}

//#endregion
//#region node_modules/@solana/wallet-adapter-ledger/lib/esm/adapter.js
const LedgerWalletName = "Ledger";
var LedgerWalletAdapter = class extends BaseSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = LedgerWalletName;
		this.url = "https://ledger.com";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzUgMzUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI2ZmZiI+PHBhdGggZD0ibTIzLjU4OCAwaC0xNnYyMS41ODNoMjEuNnYtMTZhNS41ODUgNS41ODUgMCAwIDAgLTUuNi01LjU4M3oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuNzM5KSIvPjxwYXRoIGQ9Im04LjM0MiAwaC0yLjc1N2E1LjU4NSA1LjU4NSAwIDAgMCAtNS41ODUgNS41ODV2Mi43NTdoOC4zNDJ6Ii8+PHBhdGggZD0ibTAgNy41OWg4LjM0MnY4LjM0MmgtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDUuNzM5KSIvPjxwYXRoIGQ9Im0xNS4xOCAyMy40NTFoMi43NTdhNS41ODUgNS41ODUgMCAwIDAgNS41ODUtNS42di0yLjY3MWgtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMS40NzggMTEuNDc4KSIvPjxwYXRoIGQ9Im03LjU5IDE1LjE4aDguMzQydjguMzQyaC04LjM0MnoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuNzM5IDExLjQ3OCkiLz48cGF0aCBkPSJtMCAxNS4xOHYyLjc1N2E1LjU4NSA1LjU4NSAwIDAgMCA1LjU4NSA1LjU4NWgyLjc1N3YtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDExLjQ3OCkiLz48L2c+PC9zdmc+";
		this.supportedTransactionVersions = new Set(["legacy", 0]);
		this._readyState = typeof window === "undefined" || typeof document === "undefined" || typeof navigator === "undefined" || !navigator.hid ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
		this._disconnected = () => {
			const transport = this._transport;
			if (transport) {
				transport.off("disconnect", this._disconnected);
				this._transport = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._derivationPath = config.derivationPath || getDerivationPath(0, 0);
		this._connecting = false;
		this._transport = null;
		this._publicKey = null;
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Loadable) throw new WalletNotReadyError();
			this._connecting = true;
			let TransportWebHIDClass;
			try {
				TransportWebHIDClass = (await import("./TransportWebHID-XgEN_z5w.js")).default;
			} catch (error) {
				throw new WalletLoadError(error?.message, error);
			}
			let transport;
			try {
				transport = await TransportWebHIDClass.create();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = await getPublicKey(transport, this._derivationPath);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			transport.on("disconnect", this._disconnected);
			this._transport = transport;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const transport = this._transport;
		if (transport) {
			transport.off("disconnect", this._disconnected);
			this._transport = null;
			this._publicKey = null;
			try {
				await transport.close();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const transport = this._transport;
			const publicKey = this._publicKey;
			if (!transport || !publicKey) throw new WalletNotConnectedError();
			try {
				const signature = await signTransaction(transport, transaction, this._derivationPath);
				transaction.addSignature(publicKey, signature);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
			return transaction;
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-mathwallet/lib/esm/adapter.js
init_index_browser_esm();
const MathWalletName = "MathWallet";
var MathWalletAdapter = class extends BaseSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = MathWalletName;
		this.url = "https://mathwallet.org";
		this.icon = "data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIHdpZHRoPSIxMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI2ZmZiIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJtMCAwaDEyOHYxMjhoLTEyOHoiIG9wYWNpdHk9IjAiLz48cGF0aCBkPSJtOTAuODQ3MDA4NiA1Ny43NjEwMDIzYy0yLjI3NzAzNjMtMi4yNzcwMzYzLTIuMjc3MDM2My01Ljk2ODg0MTYgMC04LjI0NTg3NzggMi4yNzcwMzYyLTIuMjc3MDM2MyA1Ljk2ODg0MTUtMi4yNzcwMzYzIDguMjQ1ODc3OCAwIDIuMjc3MDM2NiAyLjI3NzAzNjIgMi4yNzcwMzY2IDUuOTY4ODQxNSAwIDguMjQ1ODc3OC0yLjI3NzAzNjMgMi4yNzcwMzYyLTUuOTY4ODQxNiAyLjI3NzAzNjItOC4yNDU4Nzc4IDB6bS0xOS41ODM5NTk4IDE5LjU4Mzk1OTdjLTEuNzA3Nzc3Mi0xLjcwNzc3NzItMS43MDc3NzcyLTQuNDc2NjMxMSAwLTYuMTg0NDA4M3M0LjQ3NjYzMTEtMS43MDc3NzcyIDYuMTg0NDA4MyAwIDEuNzA3Nzc3MiA0LjQ3NjYzMTEgMCA2LjE4NDQwODMtNC40NzY2MzExIDEuNzA3Nzc3Mi02LjE4NDQwODMgMHptMzAuOTIyMDQyMi0xMC4zMDczNDcyYy0xLjcwNzc3OC0xLjcwNzc3NzItMS43MDc3NzgtNC40NzY2MzEyIDAtNi4xODQ0MDg0IDEuNzA3Nzc3LTEuNzA3Nzc3MiA0LjQ3NjYzMS0xLjcwNzc3NzIgNi4xODQ0MDggMHMxLjcwNzc3NyA0LjQ3NjYzMTIgMCA2LjE4NDQwODQtNC40NzY2MzEgMS43MDc3NzcyLTYuMTg0NDA4IDB6bS0xMC4zMDczNDc3IDEwLjMwNzM0NzJjLTEuNzA3Nzc3Mi0xLjcwNzc3NzItMS43MDc3NzcyLTQuNDc2NjMxMSAwLTYuMTg0NDA4M3M0LjQ3NjYzMTEtMS43MDc3NzcyIDYuMTg0NDA4MyAwIDEuNzA3Nzc3MiA0LjQ3NjYzMTEgMCA2LjE4NDQwODMtNC40NzY2MzExIDEuNzA3Nzc3Mi02LjE4NDQwODMgMHptMjEuNjQ1NDI4Ny0xLjAzMDczNDdjLTEuMTM4NTE4LTEuMTM4NTE4MS0xLjEzODUxOC0yLjk4NDQyMDggMC00LjEyMjkzODkgMS4xMzg1MTktMS4xMzg1MTgxIDIuOTg0NDIxLTEuMTM4NTE4MSA0LjEyMjkzOSAwIDEuMTM4NTE5IDEuMTM4NTE4MSAxLjEzODUxOSAyLjk4NDQyMDggMCA0LjEyMjkzODktMS4xMzg1MTggMS4xMzg1MTgxLTIuOTg0NDIgMS4xMzg1MTgxLTQuMTIyOTM5IDB6bS0xMC4zMDczNDcgMTAuMzA3MzQ3MmMtMS4xMzg1MTgtMS4xMzg1MTgxLTEuMTM4NTE4LTIuOTg0NDIwNyAwLTQuMTIyOTM4OSAxLjEzODUxOC0xLjEzODUxODEgMi45ODQ0MjEtMS4xMzg1MTgxIDQuMTIyOTM5IDAgMS4xMzg1MTggMS4xMzg1MTgyIDEuMTM4NTE4IDIuOTg0NDIwOCAwIDQuMTIyOTM4OS0xLjEzODUxOCAxLjEzODUxODItMi45ODQ0MjEgMS4xMzg1MTgyLTQuMTIyOTM5IDB6bS0yMi42NzYxNjM3LTE4LjU1MzIyNWMtMi4yNzcwMzYzLTIuMjc3MDM2My0yLjI3NzAzNjMtNS45Njg4NDE1IDAtOC4yNDU4Nzc4czUuOTY4ODQxNS0yLjI3NzAzNjMgOC4yNDU4Nzc4IDAgMi4yNzcwMzYzIDUuOTY4ODQxNSAwIDguMjQ1ODc3OC01Ljk2ODg0MTUgMi4yNzcwMzYzLTguMjQ1ODc3OCAwem0wLTIwLjYxNDY5NDVjLTIuMjc3MDM2My0yLjI3NzAzNjMtMi4yNzcwMzYzLTUuOTY4ODQxNSAwLTguMjQ1ODc3OHM1Ljk2ODg0MTUtMi4yNzcwMzYzIDguMjQ1ODc3OCAwIDIuMjc3MDM2MyA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtNS45Njg4NDE1IDIuMjc3MDM2My04LjI0NTg3NzggMHptLTEwLjMwNzM0NzIgMTAuMzA3MzQ3M2MtMi4yNzcwMzYzLTIuMjc3MDM2My0yLjI3NzAzNjMtNS45Njg4NDE2IDAtOC4yNDU4Nzc4IDIuMjc3MDM2Mi0yLjI3NzAzNjMgNS45Njg4NDE1LTIuMjc3MDM2MyA4LjI0NTg3NzggMCAyLjI3NzAzNjIgMi4yNzcwMzYyIDIuMjc3MDM2MiA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtMi4yNzcwMzYzIDIuMjc3MDM2Mi01Ljk2ODg0MTYgMi4yNzcwMzYyLTguMjQ1ODc3OCAwem0tMjAuNzEwNTA2IDBjLTIuMjc3MDM2Mi0yLjI3NzAzNjMtMi4yNzcwMzYyLTUuOTY4ODQxNiAwLTguMjQ1ODc3OCAyLjI3NzAzNjMtMi4yNzcwMzYzIDUuOTY4ODQxNi0yLjI3NzAzNjMgOC4yNDU4Nzc4IDAgMi4yNzcwMzYzIDIuMjc3MDM2MiAyLjI3NzAzNjMgNS45Njg4NDE1IDAgOC4yNDU4Nzc4LTIuMjc3MDM2MiAyLjI3NzAzNjItNS45Njg4NDE1IDIuMjc3MDM2Mi04LjI0NTg3NzggMHptLTE5LjU4Mzk1OTcgMTkuNTgzOTU5N2MtMS43MDc3NzcyLTEuNzA3Nzc3Mi0xLjcwNzc3NzItNC40NzY2MzExIDAtNi4xODQ0MDgzczQuNDc2NjMxMS0xLjcwNzc3NzIgNi4xODQ0MDgzIDAgMS43MDc3NzcyIDQuNDc2NjMxMSAwIDYuMTg0NDA4My00LjQ3NjYzMTEgMS43MDc3NzcyLTYuMTg0NDA4MyAwem0zMC45MjIwNDE3LTEwLjMwNzM0NzJjLTEuNzA3Nzc3Mi0xLjcwNzc3NzItMS43MDc3NzcyLTQuNDc2NjMxMiAwLTYuMTg0NDA4NHM0LjQ3NjYzMTItMS43MDc3NzcyIDYuMTg0NDA4NCAwIDEuNzA3Nzc3MiA0LjQ3NjYzMTIgMCA2LjE4NDQwODQtNC40NzY2MzEyIDEuNzA3Nzc3Mi02LjE4NDQwODQgMHptLTEwLjMwNzM0NzIgMTAuMzA3MzQ3MmMtMS43MDc3NzcyLTEuNzA3Nzc3Mi0xLjcwNzc3NzItNC40NzY2MzExIDAtNi4xODQ0MDgzczQuNDc2NjMxMS0xLjcwNzc3NzIgNi4xODQ0MDgzIDAgMS43MDc3NzcyIDQuNDc2NjMxMSAwIDYuMTg0NDA4My00LjQ3NjYzMTEgMS43MDc3NzcyLTYuMTg0NDA4MyAwem0tNDAuMTk4NjU0My0xLjAzMDczNDdjLTEuMTM4NTE4MTMtMS4xMzg1MTgxLTEuMTM4NTE4MTMtMi45ODQ0MjA4IDAtNC4xMjI5Mzg5IDEuMTM4NTE4MS0xLjEzODUxODEgMi45ODQ0MjA4LTEuMTM4NTE4MSA0LjEyMjkzODkgMHMxLjEzODUxODEgMi45ODQ0MjA4IDAgNC4xMjI5Mzg5LTIuOTg0NDIwOCAxLjEzODUxODEtNC4xMjI5Mzg5IDB6bTEwLjMwNzM0NzMgMTAuMzA3MzQ3MmMtMS4xMzg1MTgyLTEuMTM4NTE4MS0xLjEzODUxODItMi45ODQ0MjA3IDAtNC4xMjI5Mzg5IDEuMTM4NTE4MS0xLjEzODUxODEgMi45ODQ0MjA3LTEuMTM4NTE4MSA0LjEyMjkzODggMCAxLjEzODUxODIgMS4xMzg1MTgyIDEuMTM4NTE4MiAyLjk4NDQyMDggMCA0LjEyMjkzODktMS4xMzg1MTgxIDEuMTM4NTE4Mi0yLjk4NDQyMDcgMS4xMzg1MTgyLTQuMTIyOTM4OCAwem00MS4yMjkzODg5IDBjLTEuMTM4NTE4MS0xLjEzODUxODEtMS4xMzg1MTgxLTIuOTg0NDIwNyAwLTQuMTIyOTM4OSAxLjEzODUxODItMS4xMzg1MTgxIDIuOTg0NDIwOC0xLjEzODUxODEgNC4xMjI5Mzg5IDAgMS4xMzg1MTgyIDEuMTM4NTE4MiAxLjEzODUxODIgMi45ODQ0MjA4IDAgNC4xMjI5Mzg5LTEuMTM4NTE4MSAxLjEzODUxODItMi45ODQ0MjA3IDEuMTM4NTE4Mi00LjEyMjkzODkgMHptLTQyLjI2MDEyMzctMTkuNTgzOTU5N2MtMS43MDc3NzcyLTEuNzA3Nzc3Mi0xLjcwNzc3NzItNC40NzY2MzEyIDAtNi4xODQ0MDg0czQuNDc2NjMxMi0xLjcwNzc3NzIgNi4xODQ0MDg0IDAgMS43MDc3NzcyIDQuNDc2NjMxMiAwIDYuMTg0NDA4NC00LjQ3NjYzMTIgMS43MDc3NzcyLTYuMTg0NDA4NCAwem0xOS41ODM5NTk4IDEuMDMwNzM0N2MtMi4yNzcwMzYzLTIuMjc3MDM2My0yLjI3NzAzNjMtNS45Njg4NDE1IDAtOC4yNDU4Nzc4czUuOTY4ODQxNS0yLjI3NzAzNjMgOC4yNDU4Nzc4IDAgMi4yNzcwMzYzIDUuOTY4ODQxNSAwIDguMjQ1ODc3OC01Ljk2ODg0MTUgMi4yNzcwMzYzLTguMjQ1ODc3OCAwem0wLTIwLjYxNDY5NDVjLTIuMjc3MDM2My0yLjI3NzAzNjMtMi4yNzcwMzYzLTUuOTY4ODQxNSAwLTguMjQ1ODc3OHM1Ljk2ODg0MTUtMi4yNzcwMzYzIDguMjQ1ODc3OCAwIDIuMjc3MDM2MyA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtNS45Njg4NDE1IDIuMjc3MDM2My04LjI0NTg3NzggMHptLTEwLjMwNzM0NzMgMTAuMzA3MzQ3M2MtMi4yNzcwMzYyLTIuMjc3MDM2My0yLjI3NzAzNjItNS45Njg4NDE2IDAtOC4yNDU4Nzc4IDIuMjc3MDM2My0yLjI3NzAzNjMgNS45Njg4NDE2LTIuMjc3MDM2MyA4LjI0NTg3NzggMCAyLjI3NzAzNjMgMi4yNzcwMzYyIDIuMjc3MDM2MyA1Ljk2ODg0MTUgMCA4LjI0NTg3NzgtMi4yNzcwMzYyIDIuMjc3MDM2Mi01Ljk2ODg0MTUgMi4yNzcwMzYyLTguMjQ1ODc3OCAweiIvPjwvZz48L3N2Zz4=";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._messaged = (event) => {
			const data = event.data;
			if (data && data.origin === "mathwallet_internal" && data.type === "lockStatusChanged" && !data.payload) this._disconnected();
		};
		this._disconnected = () => {
			if (this._wallet) {
				window.removeEventListener("message", this._messaged);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.solana?.isMathWallet) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.solana;
			let account;
			try {
				account = await wallet.getAccount();
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			window.addEventListener("message", this._messaged);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		if (this._wallet) {
			window.removeEventListener("message", this._messaged);
			this._wallet = null;
			this._publicKey = null;
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-neko/lib/esm/adapter.js
init_index_browser_esm();
const NekoWalletName = "Neko";
var NekoWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = NekoWalletName;
		this.url = "https://nekowallet.com";
		this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIyNDRweCIgaGVpZ2h0PSIyNjBweCIgdmlld0JveD0iMCAwIDI0NCAyNjAiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI0NCAyNjAiIHhtbDpzcGFjZT0icHJlc2VydmUiPiAgPGltYWdlIGlkPSJpbWFnZTAiIHdpZHRoPSIyNDQiIGhlaWdodD0iMjYwIiB4PSIwIiB5PSIwIgogICAgaHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFQUUFBQUVFQ0FNQUFBQW9GT2xoQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUNCalNGSk4KQUFCNkpnQUFnSVFBQVBvQUFBQ0E2QUFBZFRBQUFPcGdBQUE2bUFBQUYzQ2N1bEU4QUFBQjQxQk1WRVVBQUFEL2Z5RC9jQ0QvZ0NyLwpmeXIvZ0VEL2dBRC9iU1QvY0JEM2JCajViUnI0YlJuNGJScjViaHI0YmhuNWJCbjRiaG40YlJyNmJodjNiQmo0YlJyM2NCajRiUm41CmJoci9jUno0Ynh2NWJocjNhQmovY3huNWJocjFhaHYzYkJyL2JSdjNiUnIyYkJ2M2JSdjRiQnI0YmhydmNDRDRiUm40YlJyM2NCajQKYmhmM2JSdjRieG4zYkJyM2JCbjRiQm41YlJyNWJScjRiQm4vZGgzNGJocjZhaHY0YXhuL2RTRDNiaHIzYlJqL2JCMzNhQmowYWh2MwpiUnIvYnhINGJCbjRiUnYvYnhENGJSbjZhaFg0YlJyMWJCbjRiUnI2YmhqNGJScjRiUm40YkJuNGJCcjNiUmo0YmhuNGJCcjRiUnI0CmJodjRiUnY5MnNiN3Y1cjVkaWo2bW1INnJYNzh5S245MGJqOHY1djd0b3o1aUVYKzQ5VCs3T1ArOXZILy8vLzVrVlA1ZGluN28zRDcKdG8zNnBIRDVpRWI1ZnpiKzdlTDdyWC81ZnpmLzl2SCs3ZVA3djV2KzdlSC8vLzcrNU5UN3BIRCs0OVA4dG8zOTJzWDZtMkw1ZnpqLwo5dkQ1Z0RqN3JYNzZwSEg4eUtqKzdPSC8vdjc4djVuNGRpbi85ZkQ4djVyNmlFYjd0b3Y5NDlQOHRveis1TlA5MExmNmtWUDRkeW42CmtWVDZtbUQ0ZGlqOTBiZis3T0Q3dFl2KzlmRDdtbUQ4dnBuOHRZdjgwYmo2bzNEOTVOVDZtbUw3bzNIKzl2RDZpRVg4ckgvNm0ySDcKcllEOTI4WDdtbUg4ckg3N3JIN1dKTE5MQUFBQVQzUlNUbE1BQUFBQUFBQUFBQkJBbjkvdno1QlFiOTlmUWQ0Z3YzOEJqODRnQVlBeApnQUh1a0dIUHpoQncvaUZQWUkrZ29JK2VyNzRCenpCd0FZQmdBU0V3N3hDUWp4QytNTEJRcjErdTNyK3VYNC9Pd0xqT0dBQUFBQUZpClMwZEVYM1BSVVMwQUFBQUpjRWhaY3dBQUN4TUFBQXNUQVFDYW5CZ0FBQUFIZEVsTlJRZm1CaHdHRkNaaGFHR2lBQUFPMTBsRVFWUjQKMnUyZCsyTVVWeFhIbDFacU5vWGF0QW1VaDRhdEJiYUNiVVNMSWxTMFZTeDlPTTAweXo2U3pTNGh6UVBMMGhwVEVaWUVBelZxMGFxawppbS8rVkdkMlp2WTVNK2Q3WnM2ZG05MzAreVBNenIyZm5Edm5mdStkZSsra1Vnd05wWWVmM0dQczJUdWM1dnhLb1hhbG43SXFaT3dkCi9vcXlJcDYyN3U5cTVCbmR2RGJ5c3lQTkNvMnFxZERZUHFOZCszVWpwNTQ3MEZHaGc0Y1VNSThZblJyV3pIeDR1S3RDbytMVVE5M00KdW1QOTJGZDdLalE2SkZ6R0FhTlhPdFBaNDEvenFkQzRiQmxqUGtVWSt6UkNIeG54cVZCR050VFArMEZyRFBXWHZ1NWJJZGxRditCYgp4b2cyYU45QUc4WlJ5VEtPR2Y0NnJvazVJTkJHVnJKOXB3T2c5MGpuUzB5N1h4d0pnSmJzdFlLZ3BmTWxLSi91eW9YK2htQXBKNEtnCnRZUjY5NHRCMWNtZUVDeG1QS2dVNDZRRzZNUGZES3lPWk10N0tiQVVRNEhqSlJRY2FNTjRXYkNjZmNIRkpPOVFRZ0p0VENRRG5iaEQKMmZWc1NHVWtPK3FSa0hLU0R2V1JzTXFNQ2haa2hDblpVQWY1RWtkWnVZTEdRcUgzSmdvZEdtaEpTNVlPaFRhU25Eb0tEN1NrSlNPZwpFM1FvZ1FiVWc1YXpaQ2ZDb1JNMG80RUcxSU9XczJUakJIUmlvUTd6SmRKLy8rZVRLeXBjWWI3RWtad2wreFpWVkVKbWxBNjBvQ1hiClI1YVZ6SHd3SFdqamxGaGhJMlJaaVRnVTN4blFMc2xaTXJxc1JNem90NzlEMXlNalZkZ3h1cXdrUWszNEVrZGlsdXdWQkZwOXFJOEEKVDVtY0pVc0RoYWszbzFDZ2pheFVpNk1NbWFNUnhRNEZDclNjSlJ1SG9CVTdGTXFBZXRDbmhjb2pEWmtqcFdhVUdtazBKV1hKYUVPbQpQdFNBTDNFMElWUWdiY2pjVUtzem80QUJkU1ZseWNDR3BkS013b0VXczJSb2Vlb2NDaDVvS1VzR0dUSkhxaHpLZDlFblRNeVNRWVpNCmFhZ3hYK0pDeXlRV3pKQ3BERFhtUzF4b21iODdac2hjcVRDam5FQkxXYkp4RHJRS004b0p0SlFsQXcyWkszbUhBaHBRVHpLV0REVmsKanNUTktHeEFYVTJJbElwM0YwcENqZnNTUnpLV2pQZUhsamFqREYvaVNNYVNNUXNWTnFQY1FCdVpKd1JLWlJneVY1SU9oUjFvR1V2RwpNV1NPSkIwS3c0QjYwQktQRjhlUWlZZWE1VXRjYUluU1dZWk1PdFFzWCtKQ1MxaXljVDYwOGIwelFqckFMMXZFa3ZFTTJUYVFoQ1hqCkdiSnRvQWtCYUhiNjFDMEpTOFpQSlpvbFljbDBNN0FsWU1uNGhreTNCQ3daMzVEcGxvQWxpMkRJZEVQSHQyUVJESmx1NlBpV2JGdzMKQXg4NnZpWHJPME1tWWNuNnpwQkpXTEsrTTJTV0pkc1Zrem5kZDRiTWNpZnB4Mkl4NzljTkVFblovZC9mSFJsNXFBL2J0cU9EWjZOUwpuK3ZEcHUxcDlPeVhJekUvc3lkKzJmcjA2dkVvRDNaL1BzNHRaZmZ6cWZ1ZDJhWitic2N4V3pwNW1NVThITC9FN2FCaERuV0VtZGZ0CnFXRzhoUTlFMjNaMEVzMW1BOFJzWlRPc3YzNWFkMFZscVk4anc0LytteDhpcU5PMEl4M3JZKy9wcjh4WmFrNTRhT0NZZ2RPckJxYXoKYXRkd2VESWJyQ1RtS1hzODdMRWU2K3VCVmJBeVowT2dCL0NCZG5RdzJLTU1raXZwMG5oUUF4K0xmMjlWZXJkZGs1T1Q3QnNFdnVBaQo5bSthb041ci9XUXFkeWxmc1A0cFh5emxwcm4xdEg4OFU1NnRkR3UyYkJaSzFjdE04SDMrR1p4NmExVUJOZWRWK29yWldkbkMvQlJjCngycHhoaWhtcHZnK2h6dDczTStpa0xZRWhWNXdrV2Q5L2krL0FNWFk5N2U5V3B5L2pGTm5maEFsaTRITVp1UGlwYUJxMDlqTGVReTUKZ1gxbEdhWWU3dzAxbmNYQWV0aXRlOG9NL3YrclMrRlJMc0xFYnJUUlJ1NXp3T1pMNUkvQVdsaVJYUDU1NkJVZmhEemFTM2lVUFYxRApnMzF5Tnp2UUlMUkpNbHM1S0lqNnNnbVYwYVhhRWwxNVd6M2RGaDFvRUhxT1pnNmtmcC8rcGI4K3dKcjQrU2U0Z1FhaEY0enJ3RlY1CnZ3SSs1RGR0VHg5QmFid3JnZjlRQ3JwZy9BSzZ6cWRGWWo4TUVQWmdkeVp3WktRQkZUNVh4U3A1dGFmbmlzVU14anJ6STRZWnc2R24KME1mU2xHV3VWRllBaEk0MU9OQjdhS1RrQWw3M2FzZk5meG1YMmNwbUFNTnJqek9IVjBqQkpieU9IYUZlalo3RG1rSjZydXpyVFdocwoyUlJRN3RVOG81SnR3NjdKcUgxVmh6NEdqUDA0SzQxQjBOVElxRU9sMXExalA5Q09nTWM2NDAzOWc5UDdNaFZyYWJGNTUxOEozUkZvCjRNMkZvK0NpUUdub1p2dVdhZHkyUHFZSDdPZGQ2QmZJSzlWQTMzQnYvR3U1VzVaSWl0SGRyS2t4Y2VpYnJFRFhrSXZvVUx1akRuUngKc3pqMExVNmdiODFEbDVHaGR2MEp1dVJWSExyZUNNc2tOcHk4dlFaZHRrNWkvTGdCamI3VmtJZHU5S3RZNnE3bHNLZWdWcVV3TXZaRApEVy9TRUlldTVlemIzc0d1clU0V29BdnpGRWJqb2Y2SlB1aDVBMDVqOWFsSnpPMlI3YnV4MndGZXVpOFBiZmRadjhHdXJSc0c1dXZyCnBCYzlqNDZ3bEVCWE5xeTdMbUdYV3BuK2hoRDBhNHc4aGtNWDBlazlDeHA4VWl0M0RRUHJzOGptYldjeWZJY2RERDEvandIOUNYYnAKQ2pyay9pM0pZV1V5ZkRFUkRyMkpRLzhPdk5TQy9qMXlYZTBQTlBUcmpNMW1NSFQxVXh3YXpHT1YreUQwSDJrT0szMlBLNEEyd0dIVApCa2hTYWZoMHhNWFFhY3l3SnhLQVdYNCtORGlCc29HUHNERG8rcDhRa0FuR3Zpc0dOSlpvYldpd3g4S2dNV2JqZ2dyb0JXTVpoa1puCkVoRm9rTms0eWxoUXhJQTJzTWxOV2VqUC9neUNqQ3FDeHV5SlpQT3Uvd1ZlMnpIS09QSUFocmF1eGV3Skk1RVZER00xK0g5cm4vMFYKV3RmaEtLc0lHck1uRzR3M0d5Vmo3VUhBUXpPYnorRXJlQlJDWS9hRVlVNHNlMkxGY25xdWFKYmIvN0g4b0xqRlhxdWxDaHF6Snd3YgphdW1xTi8rMU1MM1owSUovazZibkJoVkFOeWJ4SVh1eXdaenpYbHdpbjl5RlMrWXRiZENRUGJHaE9XKy9MSm56d2R6VFczbTc3ZC9YCkJnM1pFOFlrUXB0bThwZXFuZVJUMC9hS1NqZk4xVzVRSUNxZ1AyOWNqZGdUR3hyUFpKMHFtNlpaeU9kTmM2YmMrUjgxTXJHcGdIWmUKUENQMnhJYVdlNUhsaW55a0ZVSWo5bVFEdlpDam14cWhFWHZTZ0VaSDFLRG8xcTBFdXRDNEdyRW5EV2p3dFE0cXVuVXJnWGJmTVFEUAphZ1BhK0pza2MyMk9CbEVJRFhUQURyUm9LZ01DclFUNmpuTTVZRThjYU9QdmNzeElvSlZBdXhZWnNDY3V0T0JUalFSYUpUUmdUMXhvCnVRUU9wRzdGMEhUOFBHandkUzJ0MnhDSUNtalArOUt1b3dtOXhscUFGcWhiMkZ5Q0N1aDU5M3JhbmpTaFJaWkpWaDZDVTBZcW9XbDcKMG9LVzZLeHJINElnS3FCejNnL0kvcmNOV3NDQ2I2QWdLcUNiUzExSWU5SlJ6YmpVTUxOYWFITHBRR2M5NDFIanpHcWgvOEdzNkQragpJOVBUSllxaFd3YUJTc25kMFltOFJlbmhKb05aQ1hTcjQ2RHNTVStUWEgwUWlYbUY4WHBET1RSbHRIeWV3emwrc0djNVRWczk5TC80CjBNWXljMDY0Y3BQMVNrY1ZkT3NYbEQzeHo3Z3M3QUw3cFk1cWFNcWVCSFV6eTNtc2tjL2VZMGM1QVdnaVppRjk2MmFlR29PVWk2eVUKblJ3MFlVL0NEY1Z5cnZUQUxQdjhyRHlUTC9KZXprYUhIaGg5QWIxVDlBWDBUaEVIdXN5Ui95Mm10MHI1d2t6WlRzbmw4b3haS0FWYgppNm5wcldMZTlMbXo5YlBpcFdxTTVLMW16VW1sZDB1NEJWRXRtajJqcnFDNStlb1ZreHFoelJUSmZUbEpRM2VOQWFhMi9DRjhOeFJOClhTbGpoU3plNUkydVZFTjNOTnRxTVNoczlkNVdXbVVOT0ZhaWhGc1I5R0xiejZvaG8rcTczV1h3QjlUTXNiUkM2TmFPc09WUWlxNkYKUU9qcFZKMWlOM0pGME0zOFJCeEYxR20rbzg0V1hadkhJUlJDdTMvN1pXSytxSlpydi8rL295SGJvcmROcTRkMkZsVVpWYXF4dHI5awp2TXlkTWVuUVI1d21yZ2JhZVMxUEw0dGJiMk8rSG9mWmF1SzZsejQ3TTkvQWlSYXQweXBXWXpLenFOVkFnOHl0MThtWEJaYWQ0TlJLCm9HMFBpaXo1Ykw2V21Md2VuNWxCclFUYVlwbEdydk5NNkNUeldNRWdJVWMyS1lPZVJnNmZxN1JNYUl5K3FsUHZZU0NLbGo1ank0WGMKcFVBaXF4QWFvZzlFVUFhZFJ6ZmdPYzFSY3UwY3R1aEVCZlFjMXJnOUV5cld1RzFCRFZ6SnV5elFXemttZEZWMHZUZlV3QlZBZnc1dQp0SFJNS0hjUEJ5WG8wRDE1NkRzb1J0MitLWG9xMXl6WUlKQlFLNENHYy9GZFRxRHo2UDVFSU5TcXBvc1EyVE1JYU9xdTVkQW1VYWNUCnVFYm9oZ2xGNDFlYmZoZHRRZlF5STUzUVZjYWk1enJlbmE5dloyaTdIY0k3TFcvQnA4QUFxVXdqdEIwUmVDUHhDcU52STl1M1J1Z1YKVGllOWdoOGtRT2R2amRDMzhUTjhHanZNWUdneWYrdUR0bDlqNFp1bmJ6TE9uQ1QzTkdpRXJuTDJiakJPVDNET2R0dWUwTFlKeFk5Ngo1a0NUT3puMFFkc21GRDhqbW5IS0ViM0ZWQiswYlVMeFRUb3NhQ3A5NjRObUhRMWdQNlk0OUYwQ1JCOTBUaDAwdFExUEUvVHN6SU9GCkhRTnRMM0RjeWkyNDdtSEFvV2ZOZk1tQzdicWhLdWh0a3NnS3ZqZGtRTi9vUTJqN0tUYUxwYTNxZEljdlZ0UlBVNmU3SkovSUxQcTgKVFcvZkVUZFpuUE9zdHE4ajQ1d0RYR0Y2YjJvamkxNUhwbWlVUlUyZDZJTmVOeml2c1FabFBGM2xwTy83REdqS2hlcWNPV0VkVWNXWgpJeVBQOGRFN1I3Ynpaa1B0UncrZTkxN25YTHFOb1J0dmF0SDJYVitBMzNEb09hVUtsZTBoMWtDVVdnNTlFb0RYbGpxaDdjRVFuSjVLCnFDSFRja3JWOWYrZzBJMnp1RkZIdlhnZHUwN1BLVlVsZENHQ1l4ZUZUeVBUZEVwVkNWeFBWWEdIZ0ZJZkNIUC9rSHBPcVNxQjM4dW8KZUoyTDFMbEZEWkZuaHFxQy9oVHRYSnhFdXlhNHZBZzZzbDhKdElGNkovZWxxdURKaXRoaEowcWcwYzl3ZVBNNllnMGNYQkdyQkJvOAp2TDQ1Q0p5VU9aZ0xYdnVzQmhvOWtNZDd2eWl6YWhBOW1Vc1JOTnkrUFo4c1FWMkRqMGhRQXcxMzFldmV2ZU5UdzZlUktZTkd1K3BXCkZ4T1grdUYvY1JCRjBPZ1hoZG9tTHVOUlgrT2M4WklWL3c2SHN4a09iZDl0bmN4YWpQWEFuN0MyVzJiRW9aMk5hR2dxVzIrZnVmeGYKMUgwTjJNbVpUUjJGUCtXSlFqc2JhbEVyMmpua1g0VzlYRWVZdVNmYm5NSS9kc2lDaGwxV1Y1RDRKM094RCtZeWpKZkZ2NHptUXFQdAp1MmVTbW9jZDVjaW03RS94RDVqeW9OR1BvL204anBpRGQ4dWJqNkljZ21GL1YxNzRFNDhlTkdoRmZWZTZMYytSaDE5WXhQZWlIUU5oCkplOFUvajA0SGpUYVZRZk4yRzQrS3BvQnAyQ1VaL0tQTnFNZmRETEIrUHkwSGkzMEtNNnhMcmFzUnpxVk9nYTM3OEZRcHZIOWFielQKR2doTk5LRHhiNWdPZ3R4dnlqTStlRGdBdXVBdzc2aFFlNEZPcFM3b3JrcHltdkNZVTJNN0pvRm5tb0ZPcFU3cnJreEN5cDVPdFdtSAo1TEkzMnBsVHg1N1VYWjhrZFBGUUIzVHEzQTU0ckROZHpEdWgzOHFlUy9Yb2pPNUtxV1kra2ZKUmVxQmJlQ2FkOHRYWUFHZXppK2RTCkFSb2JXR3QyYWlnVnJOTUQyY1F6cDFPaEdvTm5qL3BIYnh4S1VYcmxUZDJWbE5XYmFSTFppZmJBTlBKWG44S1FiUTJkZVN1VHplcXUKY1R4bHM1bUp0NGRnWkVmbnpyeHo2bWNXZWovcTRzVzMzbms3c0pOSy9SOXZRRFNYcURYRjdRQUFBQ1YwUlZoMFpHRjBaVHBqY21WaApkR1VBTWpBeU1pMHdOaTB5T0ZRd05Eb3lNRG96T0Nzd01qb3dNSmVEK2JFQUFBQWxkRVZZZEdSaGRHVTZiVzlrYVdaNUFESXdNakl0Ck1EWXRNamhVTURRNk1qQTZNemdyTURJNk1ERG0za0VOQUFBQUFFbEZUa1N1UW1DQyIgLz4KPC9zdmc+Cg==";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.neko?.isNeko) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.neko;
			if (!wallet.isConnected) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-nightly/lib/esm/adapter.js
init_index_browser_esm();
const NightlyWalletName = "Nightly";
var NightlyWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor() {
		super();
		this.name = NightlyWalletName;
		this.url = "https://nightly.app";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTYiIGhlaWdodD0iOTYiIHZpZXdCb3g9IjAgMCA5NiA5NiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTQ4IDk2Qzc0LjUwOTcgOTYgOTYgNzQuNTA5NyA5NiA0OEM5NiAyMS40OTAzIDc0LjUwOTcgMCA0OCAwQzIxLjQ5MDMgMCAwIDIxLjQ5MDMgMCA0OEMwIDc0LjUwOTcgMjEuNDkwMyA5NiA0OCA5NloiIGZpbGw9IiM2RDczRjgiLz4KPHBhdGggZD0iTTQ4IDg1LjYzNTZDNDggODUuNjM1NiA1Mi40NTMzIDg1LjYzNTYgNTUuNDQgODIuNTg2N0M1OC45MTU1IDc5LjI4MDEgNTcuMzUxMSA3NS40MzEyIDYyLjI3NTUgNzEuNDMxMkM2Ni45ODY2IDY3LjY0NDUgNzIuOTI0NCA3MC4zMzc5IDcyLjkyNDQgNzAuMzM3OUM3Ny4wMjIyIDYyLjEyNDUgNzQuNzkxMSA1Mi41NjkgNzQuNzkxMSA1Mi41NjlDODEuNzY4OCAzNC4yNTc5IDc1Ljk2NDQgMjEuMTU1NyA3NC40NDQ0IDE3LjM2MDFDNjkuNDQ4OCAyNC4zMzc5IDYzLjE5MTEgMjkuMTczNCA1NS43OTU1IDMyLjQwOUM1My4yMjY2IDMxLjcwNjggNTAuNTk1NSAzMS4zMzM0IDQ4IDMxLjM2MDFDNDUuNDEzMyAzMS4zMzM0IDQyLjc3MzMgMzEuNzA2OCA0MC4yMDQ0IDMyLjQwOUMzMi44MTc3IDI5LjE2NDUgMjYuNTUxMSAyNC4zMzc5IDIxLjU1NTUgMTcuMzYwMUMyMC4wMzU1IDIxLjE1NTcgMTQuMjMxMSAzNC4yNTc5IDIxLjIwODkgNTIuNTY5QzIxLjIwODkgNTIuNTY5IDE4Ljk3NzggNjIuMTI0NSAyMy4wNzU1IDcwLjMzNzlDMjMuMDc1NSA3MC4zMzc5IDI5LjAxMzMgNjcuNjQ0NSAzMy43MjQ0IDcxLjQzMTJDMzguNjU3NyA3NS40MzEyIDM3LjA4NDQgNzkuMjgwMSA0MC41NiA4Mi41ODY3QzQzLjU0NjYgODUuNjM1NiA0OCA4NS42MzU2IDQ4IDg1LjYzNTZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNDIuNDc5OSA2NS4yOThDNDIuMjkzMyA1OS4yMTggMzYuMzAyMSA1Ny4yNjI0IDMyLjIxMzMgNTkuODIyNEMzMi4yMTMzIDU5LjgyMjQgMzIuODUzMyA2Mi40MzU4IDM1LjgzOTkgNjMuNzUxM0MzOC4yNzU1IDY0LjgyNjkgMzkuMzI0NCA2My4zODY5IDQyLjQ3OTkgNjUuMjk4WiIgZmlsbD0iIzdCODFGOSIvPgo8cGF0aCBkPSJNMjIuNDk3NyAyMy4wOTM1QzIwLjA4ODggMzEuNTQ2OCAyMS4xMjg4IDQyLjI0MDIgMjQuOTMzMyA1MC4wMjY5QzI4LjgyNjYgNDcuMjcxMyAzMi45MTU1IDQzLjAxMzUgMzUuMDkzMyAzOC41MDY5QzI5Ljk2NDQgMzQuNzExMyAyNS42NjIyIDMxLjEwMjQgMjIuNDk3NyAyMy4wOTM1WiIgZmlsbD0iIzdCODFGOSIvPgo8cGF0aCBkPSJNNTMuNTE5OSA2NS4yOThDNTMuNzA2NiA1OS4yMTggNTkuNjk3NyA1Ny4yNjI0IDYzLjc4NjYgNTkuODIyNEM2My43ODY2IDU5LjgyMjQgNjMuMTQ2NiA2Mi40MzU4IDYwLjE1OTkgNjMuNzUxM0M1Ny43MjQzIDY0LjgyNjkgNTYuNjc1NSA2My4zODY5IDUzLjUxOTkgNjUuMjk4WiIgZmlsbD0iIzdCODFGOSIvPgo8cGF0aCBkPSJNNzMuNTAyMiAyMy4wOTM1Qzc1LjkxMTEgMzEuNTQ2OCA3NC44NzExIDQyLjI0MDIgNzEuMDY2NiA1MC4wMjY5QzY3LjE3MzMgNDcuMjcxMyA2My4wODQ0IDQzLjAxMzUgNjAuOTA2NiAzOC41MDY5QzY2LjAzNTUgMzQuNzExMyA3MC4zMzc3IDMxLjEwMjQgNzMuNTAyMiAyMy4wOTM1WiIgZmlsbD0iIzdCODFGOSIvPgo8cGF0aCBkPSJNNDcuOTk5OSA4NS4zMDY5QzUwLjE0MDQgODUuMzA2OSA1MS44NzU1IDgzLjc3ODcgNTEuODc1NSA4MS44OTM2QzUxLjg3NTUgODAuMDA4NCA1MC4xNDA0IDc4LjQ4MDIgNDcuOTk5OSA3OC40ODAyQzQ1Ljg1OTUgNzguNDgwMiA0NC4xMjQ0IDgwLjAwODQgNDQuMTI0NCA4MS44OTM2QzQ0LjEyNDQgODMuNzc4NyA0NS44NTk1IDg1LjMwNjkgNDcuOTk5OSA4NS4zMDY5WiIgZmlsbD0iIzdCODFGOSIvPgo8L3N2Zz4K";
		this.supportedTransactionVersions = new Set(["legacy", 0]);
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._connecting = false;
		this._publicKey = null;
		this._wallet = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window?.nightly?.solana) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	get publicKey() {
		return this._publicKey;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.nightly.solana;
			try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (wallet.publicKey.toString() === "11111111111111111111111111111111") throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectedError());
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return wallet.signMessage(new TextDecoder().decode(message));
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-nufi/lib/esm/adapter.js
init_index_browser_esm();
const NufiWalletName = "NuFi";
var NufiWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = NufiWalletName;
		this.url = "https://nu.fi";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjMiIHZpZXdCb3g9IjAgMCAyMiAyMyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iIzIxMjEyMSIgLz4KPHBhdGggZD0iTTQuMzA5OTkgOS4wMDAwOEM1LjMwODc3IDYuMjA0MDEgNy45ODA2OSA0LjIwMzA4IDExLjEyIDQuMjAzMDhDMTQuMjU5MiA0LjIwMzA4IDE2LjkzMTEgNi4yMDQwMSAxNy45Mjk5IDkuMDAwMDhDMTcuOTc5IDkuMTM3NDcgMTguMTA3NCA5LjIzMjE4IDE4LjI1MzMgOS4yMzIxOEgyMS4wNTk0QzIxLjI3MjUgOS4yMzIxOCAyMS40MzE3IDkuMDM1NzYgMjEuMzc5NCA4LjgyOTE5QzIwLjIxOTUgNC4yNDM2MiAxNi4wNjYgMC44NTAzNDIgMTEuMTIgMC44NTAzNDJDNi4xNzM5MSAwLjg1MDM0MiAyLjAyMDQyIDQuMjQzNjIgMC44NjA0NjggOC44MjkxOEMwLjgwODIxMyA5LjAzNTc2IDAuOTY3NDM0IDkuMjMyMTggMS4xODA1MiA5LjIzMjE4SDMuOTg2NTlDNC4xMzI0OSA5LjIzMjE4IDQuMjYwOTEgOS4xMzc0NyA0LjMwOTk5IDkuMDAwMDhaIiBmaWxsPSIjQzZGRjAwIi8+CjxwYXRoIGQ9Ik0zLjk4NjU5IDEzLjYzMjdDNC4xMzI0OSAxMy42MzI3IDQuMjYwOTEgMTMuNzI3NCA0LjMwOTk5IDEzLjg2NDhDNS4zMDg3NyAxNi42NjA4IDcuOTgwNjkgMTguNjYxOCAxMS4xMiAxOC42NjE4QzE0LjI1OTIgMTguNjYxOCAxNi45MzExIDE2LjY2MDggMTcuOTI5OSAxMy44NjQ4QzE3Ljk3OSAxMy43Mjc0IDE4LjEwNzQgMTMuNjMyNyAxOC4yNTMzIDEzLjYzMjdIMjEuMDU5NEMyMS4yNzI1IDEzLjYzMjcgMjEuNDMxNyAxMy44MjkxIDIxLjM3OTQgMTQuMDM1N0MyMC4yMTk1IDE4LjYyMTIgMTYuMDY2IDIyLjAxNDUgMTEuMTIgMjIuMDE0NUM2LjE3MzkxIDIyLjAxNDUgMi4wMjA0MiAxOC42MjEyIDAuODYwNDY4IDE0LjAzNTdDMC44MDgyMTMgMTMuODI5MSAwLjk2NzQzNCAxMy42MzI3IDEuMTgwNTIgMTMuNjMyN0gzLjk4NjU5WiIgZmlsbD0iI0M2RkYwMCIvPgo8cGF0aCBkPSJNOS4yNTQ5OSA5LjIzMjE4QzkuMDY5ODMgOS4yMzIxOCA4LjkxOTcyIDkuMzgyMjkgOC45MTk3MiA5LjU2NzQ2VjEzLjI5NzRDOC45MTk3MiAxMy40ODI1IDkuMDY5ODMgMTMuNjMyNyA5LjI1NDk5IDEzLjYzMjdIMTIuOTg0OUMxMy4xNzAxIDEzLjYzMjcgMTMuMzIwMiAxMy40ODI1IDEzLjMyMDIgMTMuMjk3NFY5LjU2NzQ2QzEzLjMyMDIgOS4zODIyOSAxMy4xNzAxIDkuMjMyMTggMTIuOTg0OSA5LjIzMjE4SDkuMjU0OTlaIiBmaWxsPSIjQzZGRjAwIi8+Cjwvc3ZnPgo=";
		this.supportedTransactionVersions = new Set(["legacy", 0]);
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.nufiSolana?.isNufi) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.nufiSolana;
			if (!wallet.isConnected) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				if (isVersionedTransaction(transaction)) signers?.length && transaction.sign(signers);
				else {
					transaction = await this.prepareTransaction(transaction, connection, sendOptions);
					signers?.length && transaction.partialSign(...signers);
				}
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-onto/lib/esm/adapter.js
init_index_browser_esm();
const OntoWalletName = "ONTO";
var OntoWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = OntoWalletName;
		this.url = "https://onto.app";
		this.icon = "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyODggMjg4Ij4KICA8dGl0bGU+T05UTyBMT0dPXzI4OHgyODg8L3RpdGxlPgogIDxnIGlkPSJMT0dPIj4KICAgIDxwYXRoIGlkPSLlvaLnirbnu5PlkIgiIGQ9Ik0zMCwxMS4xNSw3MS4xOSw1Mi4zMkExMTUsMTE1LDAsMCwxLDI1OCwxMzguNjdMMjU4LDE0MlYyNzYuODVsLTQxLjE5LTQxLjE2QTExNSwxMTUsMCwwLDEsMzAuMDUsMTQ5LjM0TDMwLDE0NlptMjguMTcsNjhWMTQ2YTg2Ljc5LDg2Ljc5LDAsMCwwLDEzNS4xNSw3MmwyLjIzLTEuNTVMNjMuNjcsODQuNjVaTTk0LjY4LDcwbC0yLjIzLDEuNTVMMjI0LjMzLDIwMy4zNmw1LjUsNS41VjE0MkE4Ni43OSw4Ni43OSwwLDAsMCw5NC42OCw3MFoiLz4KICA8L2c+Cjwvc3ZnPg==";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.onto?.solana?.isONTO) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.onto.solana;
			let account;
			try {
				account = await wallet.getAccount();
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-particle/lib/esm/adapter.js
init_index_browser_esm();
const ParticleName = "Particle";
var ParticleAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = ParticleName;
		this.url = "https://particle.network";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTQwIiBoZWlnaHQ9IjE0MCIgdmlld0JveD0iMCAwIDE0MCAxNDAiPjxkZWZzPjxmaWx0ZXIgaWQ9ImEiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNDAiIGhlaWdodD0iMTQwIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiPjxmZUltYWdlIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHdpZHRoPSIxNDAiIGhlaWdodD0iMTQwIiByZXN1bHQ9ImltYWdlIiB4bGluazpocmVmPSJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGh0Ykc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQjNhV1IwYUQwaU1UUXdJaUJvWldsbmFIUTlJakUwTUNJZ2RtbGxkMEp2ZUQwaU1DQXdJREUwTUNBeE5EQWlQZ29nSUR4a1pXWnpQZ29nSUNBZ1BITjBlV3hsUGdvZ0lDQWdJQ0F1WTJ4ekxURWdld29nSUNBZ0lDQWdJR1pwYkd3NklIVnliQ2dqYkdsdVpXRnlMV2R5WVdScFpXNTBLVHNLSUNBZ0lDQWdmUW9nSUNBZ1BDOXpkSGxzWlQ0S0lDQWdJRHhzYVc1bFlYSkhjbUZrYVdWdWRDQnBaRDBpYkdsdVpXRnlMV2R5WVdScFpXNTBJaUI0TVQwaU1UUXdJaUI1TVQwaU1UUXdJaUI0TWowaU1DSWdaM0poWkdsbGJuUlZibWwwY3owaWRYTmxjbE53WVdObFQyNVZjMlVpUGdvZ0lDQWdJQ0E4YzNSdmNDQnZabVp6WlhROUlqQWlJSE4wYjNBdFkyOXNiM0k5SWlObE1EUXdaRGNpTHo0S0lDQWdJQ0FnUEhOMGIzQWdiMlptYzJWMFBTSXhJaUJ6ZEc5d0xXTnZiRzl5UFNJak5qSXlOMlUySWk4K0NpQWdJQ0E4TDJ4cGJtVmhja2R5WVdScFpXNTBQZ29nSUR3dlpHVm1jejRLSUNBOGNtVmpkQ0JqYkdGemN6MGlZMnh6TFRFaUlIZHBaSFJvUFNJeE5EQWlJR2hsYVdkb2REMGlNVFF3SWk4K0Nqd3ZjM1puUGdvPSIvPjxmZUNvbXBvc2l0ZSByZXN1bHQ9ImNvbXBvc2l0ZSIgb3BlcmF0b3I9ImluIiBpbjI9IlNvdXJjZUdyYXBoaWMiLz48ZmVCbGVuZCByZXN1bHQ9ImJsZW5kIiBpbjI9IlNvdXJjZUdyYXBoaWMiLz48L2ZpbHRlcj48L2RlZnM+PHJlY3QgZGF0YS1uYW1lPSLlnIbop5Lnn6nlvaIgMSIgd2lkdGg9IjE0MCIgaGVpZ2h0PSIxNDAiIHJ4PSI0MCIgcnk9IjQwIiBmaWx0ZXI9InVybCgjYSkiLz48cGF0aCBkYXRhLW5hbWU9IuakreWchiAzIOaLt+i0nSIgZD0iTTM0LjkxIDMwLjhhNi42MTQgNi42MTQgMCAxIDAgNi41NTMgNi42MTRBNi41ODQgNi41ODQgMCAwIDAgMzQuOTEgMzAuOHptMTMuNjE1LTcuODJhNi41NTIgNi41NTIgMCAwIDAtOC4yNzIgNC4yNTQgNi42MzkgNi42MzkgMCAwIDAgNC4yMTUgOC4zNDkgNi41NTIgNi41NTIgMCAwIDAgOC4yNzItNC4yNTQgNi42MzkgNi42MzkgMCAwIDAtNC4yMTUtOC4zNDl6bTE1LjMxMS0zLjI0OGE2LjUyNSA2LjUyNSAwIDAgMC05LjE3IDEuNDY4IDYuNjY2IDYuNjY2IDAgMCAwIDEuNDUyIDkuMjU1IDYuNTI1IDYuNTI1IDAgMCAwIDkuMTY5LTEuNDY2IDYuNjY2IDYuNjY2IDAgMCAwLTEuNDUxLTkuMjU3em0xNS41NTYgMS42ODdhNi41MjUgNi41MjUgMCAwIDAtOS4xNjktMS40NjYgNi42NjYgNi42NjYgMCAwIDAtMS40NTIgOS4yNTUgNi41MjUgNi41MjUgMCAwIDAgOS4xNjkgMS40NjYgNi42NjYgNi42NjYgMCAwIDAgMS40NTEtOS4yNTZ6bTE0LjI3OCA2LjQ1NWE2LjU1MiA2LjU1MiAwIDAgMC04LjI3LTQuMjU0IDYuNjM5IDYuNjM5IDAgMCAwLTQuMjE1IDguMzQ5IDYuNTUyIDYuNTUyIDAgMCAwIDguMjcyIDQuMjU0IDYuNjM5IDYuNjM5IDAgMCAwIDQuMjEzLTguMzQ5em0xMS42IDEwLjU5NGE2LjU2NCA2LjU2NCAwIDEgMC02LjU2NCA2LjYyNiA2LjYgNi42IDAgMCAwIDYuNTY2LTYuNjI2em03Ljc5MiAxMy42OTRhNi42MzkgNi42MzkgMCAwIDAtNC4yMTQtOC4zNDkgNi41NTIgNi41NTIgMCAwIDAtOC4yNzIgNC4yNTQgNi42MzkgNi42MzkgMCAwIDAgNC4yMTUgOC4zNDkgNi41NTEgNi41NTEgMCAwIDAgOC4yNzMtNC4yNTN6bTMuMjE4IDE1LjQ1NWE2LjY2NiA2LjY2NiAwIDAgMC0xLjQ1Mi05LjI1NSA2LjUyNSA2LjUyNSAwIDAgMC05LjE2OSAxLjQ2NiA2LjY2NiA2LjY2NiAwIDAgMCAxLjQ1MiA5LjI1NSA2LjUyNSA2LjUyNSAwIDAgMCA5LjE3MS0xLjQ2NnptLTEuNjcxIDE1LjdhNi42NjYgNi42NjYgMCAwIDAgMS40NTItOS4yNTUgNi41MjUgNi41MjUgMCAwIDAtOS4xNjktMS40NjYgNi42NjYgNi42NjYgMCAwIDAtMS40NTIgOS4yNTUgNi41MjUgNi41MjUgMCAwIDAgOS4xNzEgMS40Njh6bS02LjQgMTQuNDEyYTYuNjM4IDYuNjM4IDAgMCAwIDQuMjE0LTguMzQ5IDYuNTUxIDYuNTUxIDAgMCAwLTguMjcxLTQuMjU0IDYuNjM5IDYuNjM5IDAgMCAwLTQuMjE1IDguMzQ5IDYuNTUyIDYuNTUyIDAgMCAwIDguMjc4IDQuMjU2em0tMTAuNSAxMS43MTFhNi42MjYgNi42MjYgMCAxIDAtNi41NjQtNi42MjYgNi42IDYuNiAwIDAgMCA2LjU3NSA2LjYyOHptLTEzLjU2NyA3Ljg2NWE2LjU1MiA2LjU1MiAwIDAgMCA4LjI3Mi00LjI1NCA2LjYzOSA2LjYzOSAwIDAgMC00LjIxNS04LjM0OSA2LjU1MiA2LjU1MiAwIDAgMC04LjI3MiA0LjI1NCA2LjYzOSA2LjYzOSAwIDAgMCA0LjIyNSA4LjM1MXptLTE1LjMxMSAzLjI0OEE2LjUyNSA2LjUyNSAwIDAgMCA3OCAxMTkuMDg3YTYuNjY2IDYuNjY2IDAgMCAwLTEuNDUyLTkuMjU1IDYuNTI1IDYuNTI1IDAgMCAwLTkuMTY5IDEuNDY2IDYuNjY2IDYuNjY2IDAgMCAwIDEuNDYyIDkuMjU3em0tMTUuNTU2LTEuNjg2YTYuNTI1IDYuNTI1IDAgMCAwIDkuMTY5IDEuNDY1IDYuNjY2IDYuNjY2IDAgMCAwIDEuNDUyLTkuMjU1IDYuNTI1IDYuNTI1IDAgMCAwLTkuMTY5LTEuNDY2IDYuNjY3IDYuNjY3IDAgMCAwLTEuNDQxIDkuMjU4em0tMTQuMjc4LTYuNDU3YTYuNTUyIDYuNTUyIDAgMCAwIDguMjcyIDQuMjU1IDYuNjQgNi42NCAwIDAgMCA0LjIxNS04LjM1IDYuNTUyIDYuNTUyIDAgMCAwLTguMjcyLTQuMjU0IDYuNjM5IDYuNjM5IDAgMCAwLTQuMjA1IDguMzUxek0yNy40IDEwMS44MTlhNi41NjUgNi41NjUgMCAxIDAgNi41NjQtNi42MjYgNi42IDYuNiAwIDAgMC02LjU2NCA2LjYyNnptMTguNzgtNTYuNDY2YTMuOTY5IDMuOTY5IDAgMSAwIDMuOTMyIDMuOTY4IDMuOTUgMy45NSAwIDAgMC0zLjkzMi0zLjk2OHptOC40NTUtNS4wMjlhMy45MzEgMy45MzEgMCAwIDAtNC45NjMgMi41NTIgMy45ODMgMy45ODMgMCAwIDAgMi41MjkgNS4wMSAzLjkzMSAzLjkzMSAwIDAgMCA0Ljk2My0yLjU1MiAzLjk4NCAzLjk4NCAwIDAgMC0yLjUyOS01LjAxem05LjUzNy0yLjIzMmEzLjkxNSAzLjkxNSAwIDAgMC01LjUuODggNCA0IDAgMCAwIC44NzEgNS41NTMgMy45MTUgMy45MTUgMCAwIDAgNS41LS44OCA0IDQgMCAwIDAtLjg3MS01LjU1M3ptOS43NTMuODUyYTMuOTE1IDMuOTE1IDAgMCAwLTUuNS0uODggNCA0IDAgMCAwLS44NzEgNS41NTMgMy45MTUgMy45MTUgMCAwIDAgNS41Ljg4IDQgNCAwIDAgMCAuODcxLTUuNTUzem05LjAxNiAzLjg1NmEzLjkzMSAzLjkzMSAwIDAgMC00Ljk2My0yLjU1MyAzLjk4NCAzLjk4NCAwIDAgMC0yLjUyOSA1LjAxIDMuOTMxIDMuOTMxIDAgMCAwIDQuOTYzIDIuNTUzIDMuOTg0IDMuOTg0IDAgMCAwIDIuNTI5LTUuMDF6bTcuMzk1IDYuNDc2YTMuOTM5IDMuOTM5IDAgMSAwLTMuOTM2IDMuOTcyIDMuOTU3IDMuOTU3IDAgMCAwIDMuOTM1LTMuOTc2em01LjA1IDguNDY1YTMuOTgzIDMuOTgzIDAgMCAwLTIuNTI5LTUuMDEgMy45MzEgMy45MzEgMCAwIDAtNC45NjMgMi41NTIgMy45ODQgMy45ODQgMCAwIDAgMi41MjkgNS4wMSAzLjkzMSAzLjkzMSAwIDAgMCA0Ljk2Mi0yLjU1NnptMi4yMTQgOS42MjNhNCA0IDAgMCAwLS44NzEtNS41NTMgMy45MTUgMy45MTUgMCAwIDAtNS41Ljg4IDQgNCAwIDAgMCAuODcxIDUuNTUzIDMuOTE1IDMuOTE1IDAgMCAwIDUuNS0uODh6bS0uODQ0IDkuODQ1YTQgNCAwIDAgMCAuODcxLTUuNTUzIDMuOTE1IDMuOTE1IDAgMCAwLTUuNS0uODggNCA0IDAgMCAwLS44NzEgNS41NTMgMy45MTUgMy45MTUgMCAwIDAgNS40OTcuODh6bS0zLjgxNyA5LjFhMy45ODMgMy45ODMgMCAwIDAgMi41MjktNS4wMSAzLjkzMSAzLjkzMSAwIDAgMC00Ljk2OC0yLjU1MyAzLjk4MyAzLjk4MyAwIDAgMC0yLjUyOSA1LjAwOSAzLjkzMSAzLjkzMSAwIDAgMCA0Ljk2NSAyLjU1M3ptLTYuNDE5IDcuNDYzYTMuOTc2IDMuOTc2IDAgMSAwLTMuOTM4LTMuOTcyIDMuOTU3IDMuOTU3IDAgMCAwIDMuOTM4IDMuOTcyem0tOC4zODcgNS4xYTMuOTMxIDMuOTMxIDAgMCAwIDQuOTY3LTIuNTU1IDMuOTgzIDMuOTgzIDAgMCAwLTIuNTI5LTUuMDFBMy45MzEgMy45MzEgMCAwIDAgNzUuNiA5My44NmEzLjk4MyAzLjk4MyAwIDAgMCAyLjUzNCA1LjAxek02OC42IDEwMS4xYTMuOTE1IDMuOTE1IDAgMCAwIDUuNS0uODggNCA0IDAgMCAwLS44NzEtNS41NTMgMy45MTUgMy45MTUgMCAwIDAtNS41Ljg4IDQgNCAwIDAgMCAuODcxIDUuNTUzem0tOS43NTMtLjg1MmEzLjkxNiAzLjkxNiAwIDAgMCA1LjUuODggNCA0IDAgMCAwIC44NzEtNS41NTQgMy45MTUgMy45MTUgMCAwIDAtNS41LS44OCA0IDQgMCAwIDAtLjg3NSA1LjU1NnpNNDkuODI4IDk2LjRhMy45MzEgMy45MzEgMCAwIDAgNC45NjMgMi41NTMgMy45ODQgMy45ODQgMCAwIDAgMi41MjktNS4wMSAzLjkzMSAzLjkzMSAwIDAgMC00Ljk2My0yLjU1MyAzLjk4MyAzLjk4MyAwIDAgMC0yLjUyOSA1LjAxem0tNy4zOTUtNi40NzZhMy45MzkgMy45MzkgMCAxIDAgMy45MzktMy45NzYgMy45NTcgMy45NTcgMCAwIDAtMy45MzggMy45NzR6TTUzLjUxOSA1Ni4yYTIuMTE3IDIuMTE3IDAgMSAwIDIuMSAyLjExNyAyLjEwNyAyLjEwNyAwIDAgMC0yLjEtMi4xMTd6bTQuNjM5LTIuNzIzYTIuMSAyLjEgMCAwIDAtMi42NDcgMS4zNjEgMi4xMjUgMi4xMjUgMCAwIDAgMS4zNDkgMi42NzIgMi4xIDIuMSAwIDAgMCAyLjY0Ny0xLjM2MSAyLjEyNCAyLjEyNCAwIDAgMC0xLjM0OS0yLjY3MnptNS4yLTEuMjUyYTIuMDg4IDIuMDg4IDAgMCAwLTIuOTM0LjQ2OSAyLjEzMyAyLjEzMyAwIDAgMCAuNDY1IDIuOTYyIDIuMDg4IDIuMDg4IDAgMCAwIDIuOTM0LS40NjkgMi4xMzMgMi4xMzMgMCAwIDAtLjQ3LTIuOTYxem01LjMyNC40M2EyLjA4OCAyLjA4OCAwIDAgMC0yLjkzNC0uNDY5IDIuMTMzIDIuMTMzIDAgMCAwLS40NjUgMi45NjIgMi4wODggMi4wODggMCAwIDAgMi45MzQuNDY5IDIuMTMzIDIuMTMzIDAgMCAwIC40Ni0yLjk2MXptNC45MzIgMi4wN2EyLjEgMi4xIDAgMCAwLTIuNjQ3LTEuMzYxIDIuMTI0IDIuMTI0IDAgMCAwLTEuMzQ5IDIuNjcyQTIuMSAyLjEgMCAwIDAgNzIuMjYgNTcuNGEyLjEyNCAyLjEyNCAwIDAgMCAxLjM0OS0yLjY3NHptNC4wNTcgMy41MDdhMi4xIDIuMSAwIDEgMC0yLjEgMi4xMiAyLjExMSAyLjExMSAwIDAgMCAyLjA5NS0yLjEyem0yLjc4NSA0LjZhMi4xMjUgMi4xMjUgMCAwIDAtMS4zNTYtMi42NzEgMi4xIDIuMSAwIDAgMC0yLjY0NyAxLjM2MSAyLjEyNSAyLjEyNSAwIDAgMCAxLjM0NyAyLjY3MiAyLjEgMi4xIDAgMCAwIDIuNjUxLTEuMzYxem0xLjI0IDUuMjQ0YTIuMTMzIDIuMTMzIDAgMCAwLS40NjUtMi45NjIgMi4wODggMi4wODggMCAwIDAtMi45MzQuNDY5IDIuMTMzIDIuMTMzIDAgMCAwIC40NjUgMi45NjIgMi4wODggMi4wODggMCAwIDAgMi45MjktLjQ2OHptLS40MjYgNS4zNzRhMi4xMzMgMi4xMzMgMCAwIDAgLjQ2NS0yLjk2MiAyLjA4OCAyLjA4OCAwIDAgMC0yLjkzNS0uNDY4IDIuMTMzIDIuMTMzIDAgMCAwLS40NjUgMi45NjIgMi4wODggMi4wODggMCAwIDAgMi45MjkuNDY5em0tMi4wNSA0Ljk3OGEyLjEyNSAyLjEyNSAwIDAgMCAxLjM0OS0yLjY3MiAyLjEgMi4xIDAgMCAwLTIuNjUzLTEuMzU2IDIuMTI0IDIuMTI0IDAgMCAwLTEuMzQ5IDIuNjcyIDIuMSAyLjEgMCAwIDAgMi42NDcgMS4zNTd6bS0zLjQ4IDQuMDk1YTIuMTIgMi4xMiAwIDEgMC0yLjEtMi4xMiAyLjExMSAyLjExMSAwIDAgMCAyLjEgMi4xMnptLTQuNTU4IDIuODExYTIuMSAyLjEgMCAwIDAgMi42NDctMS4zNjFBMi4xMjUgMi4xMjUgMCAwIDAgNzIuNDggODEuM2EyLjEgMi4xIDAgMCAwLTIuNjQ3IDEuMzYxIDIuMTI1IDIuMTI1IDAgMCAwIDEuMzQ5IDIuNjczem0tNS4yIDEuMjUyYTIuMDg4IDIuMDg4IDAgMCAwIDIuOTM0LS40NjkgMi4xMzMgMi4xMzMgMCAwIDAtLjQ2NS0yLjk2MiAyLjA4OCAyLjA4OCAwIDAgMC0yLjkzNC40NjkgMi4xMzMgMi4xMzMgMCAwIDAgLjQ3IDIuOTYyem0tNS4zMjQtLjQzYTIuMDg4IDIuMDg4IDAgMCAwIDIuOTM0LjQ2OSAyLjEzMyAyLjEzMyAwIDAgMCAuNDY1LTIuOTYyIDIuMDg4IDIuMDg4IDAgMCAwLTIuOTM0LS40NjkgMi4xMzMgMi4xMzMgMCAwIDAtLjQ2IDIuOTYyem0tNC45MzItMi4wN2EyLjEgMi4xIDAgMCAwIDIuNjQ3IDEuMzYxIDIuMTI1IDIuMTI1IDAgMCAwIDEuMzQ5LTIuNjcyIDIuMSAyLjEgMCAwIDAtMi42NDctMS4zNjEgMi4xMjQgMi4xMjQgMCAwIDAtMS4zNDQgMi42NzJ6bS00LjA1Ny0zLjUwN2EyLjEgMi4xIDAgMSAwIDIuMS0yLjEyIDIuMTExIDIuMTExIDAgMCAwLTIuMDk1IDIuMTJ6IiBmaWxsPSIjZmZmIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
		this._particle = null;
		this._connecting = false;
		this._publicKey = null;
		this._wallet = null;
		this._config = {
			config: {
				projectId: "",
				clientKey: "",
				appId: "",
				...config.config,
				chainId: config.config?.chainId ?? 101,
				chainName: config.config?.chainName ?? "solana"
			},
			login: config.login
		};
	}
	get particle() {
		return this._particle;
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Loadable) throw new WalletNotReadyError();
			this._connecting = true;
			let ParticleClass;
			let WalletClass;
			try {
				({ParticleNetwork: ParticleClass, SolanaWallet: WalletClass} = await import("./es-OJjR8yMk.js"));
			} catch (error) {
				throw new WalletLoadError(error?.message, error);
			}
			let particle;
			try {
				particle = new ParticleClass(this._config.config);
				if (!particle.auth.isLogin()) await particle.auth.login(this._config.login);
			} catch (error) {
				throw new WalletConfigError(error?.message, error);
			}
			let wallet;
			try {
				wallet = new WalletClass(particle.auth);
			} catch (error) {
				throw new WalletConfigError(error?.message, error);
			}
			const account = wallet.publicKey;
			if (!account) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(account.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._particle = particle;
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signMessage(message);
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-phantom/lib/esm/adapter.js
init_index_browser_esm();
const PhantomWalletName = "Phantom";
var PhantomWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = PhantomWalletName;
		this.url = "https://phantom.app";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==";
		this.supportedTransactionVersions = new Set(["legacy", 0]);
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				wallet.off("accountChanged", this._accountChanged);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._accountChanged = (newPublicKey) => {
			const publicKey = this._publicKey;
			if (!publicKey) return;
			try {
				newPublicKey = new PublicKey(newPublicKey.toBytes());
			} catch (error) {
				this.emit("error", new WalletPublicKeyError(error?.message, error));
				return;
			}
			if (publicKey.equals(newPublicKey)) return;
			this._publicKey = newPublicKey;
			this.emit("connect", newPublicKey);
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) if (isIosAndRedirectable()) {
			this._readyState = WalletReadyState.Loadable;
			this.emit("readyStateChange", this._readyState);
		} else scopePollingDetectionStrategy(() => {
			if (window.phantom?.solana?.isPhantom || window.solana?.isPhantom) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async autoConnect() {
		if (this.readyState === WalletReadyState.Installed) await this.connect();
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this.readyState === WalletReadyState.Loadable) {
				const url = encodeURIComponent(window.location.href);
				const ref$1 = encodeURIComponent(window.location.origin);
				window.location.href = `https://phantom.app/ul/browse/${url}?ref=${ref$1}`;
				return;
			}
			if (this.readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.phantom?.solana || window.solana;
			if (!wallet.isConnected) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			wallet.on("accountChanged", this._accountChanged);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			wallet.off("accountChanged", this._accountChanged);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				if (isVersionedTransaction(transaction)) signers?.length && transaction.sign(signers);
				else {
					transaction = await this.prepareTransaction(transaction, connection, sendOptions);
					signers?.length && transaction.partialSign(...signers);
				}
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-safepal/lib/esm/adapter.js
init_index_browser_esm();
const SafePalWalletName = "SafePal";
var SafePalWalletAdapter = class extends BaseSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = SafePalWalletName;
		this.url = "https://safepal.io";
		this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAP1BMVEUAAABKIe9MIO9LIO9KIe5KIO9KIe9KIO5JIO1KIu1KIO1KIe////+kkPfo4/1hPfFgPfGZgvaOdPWDZvRVL/CpQHckAAAAC3RSTlMA7yC/oDDfgJCQkAOmnXUAAADnSURBVEjHlZbtjoJAEAR7BwTvmvUO9f2f1USNk81MRrp+VxFY9gsvbJ0aC9r0Y3Bs5gHmT3JqPMRy0nyyPQtbeJhmAGYKzIBRwvBLiRUTJSY0SjQw4X7tI//8kAV/l22k04HoE6JPiD4h+oToE8HfWYLwfNZg9EOQvpL7Mag+et+SoBrWWxaUP64nQT01ehLUk6/nwXYLgRdpsIfAiyy4VAuoc8B9D0rcPxbs7sfAB8oJPiH6hOgTok+IPiH4YQH1keudCfJmrG/3KyXO8pGlH4ow4bMX0w/2Z7EIvnY5cez87fqzvvUH/qNgaUlN588AAAAASUVORK5CYII=";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.safepal?.isSafePalWallet) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.safepal;
			let account;
			try {
				account = await wallet.getAccount();
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		if (this._wallet) {
			this._wallet = null;
			this._publicKey = null;
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-saifu/lib/esm/adapter.js
init_index_browser_esm();
const SaifuWalletName = "Saifu";
var SaifuWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = SaifuWalletName;
		this.url = "https://saifuwallet.com";
		this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNTQxcHgiIGhlaWdodD0iNTQxcHgiIHZpZXdCb3g9IjAgMCA1NDEgNTQxIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPHRpdGxlPkFydGJvYXJkIENvcHkgOTwvdGl0bGU+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgeDE9IjEuNzk5ODcyMTYlIiB5MT0iMCUiIHgyPSI5OC4zOTcxMDUxJSIgeTI9Ijk3Ljk5MDI5MSUiIGlkPSJsaW5lYXJHcmFkaWVudC0xIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0ZCOTIzQyIgb2Zmc2V0PSIwJSI+PC9zdG9wPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRUM0ODk5IiBvZmZzZXQ9IjEwMCUiPjwvc3RvcD4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPC9kZWZzPgogICAgPGcgaWQ9IkFydGJvYXJkLUNvcHktOSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTIzMi4yNzAwNDQsLTcuODU2NzI5NzFlLTE1IEwzMDcuNzI5OTU2LDcuODU2NzI5NzFlLTE1IEMzNzkuNDY1Mzc2LC01LjMyMDg1MzMyZS0xNSA0MTIuMzM3Mzc5LDguODE4NDMzMDYgNDQzLjMwMDM0MiwyNS4zNzc2MDY5IEM0NzQuMjYzMzA1LDQxLjkzNjc4MDcgNDk4LjU2MzIxOSw2Ni4yMzY2OTUyIDUxNS4xMjIzOTMsOTcuMTk5NjU4MiBDNTMxLjY4MTU2NywxMjguMTYyNjIxIDU0MC41LDE2MS4wMzQ2MjQgNTQwLjUsMjMyLjc3MDA0NCBMNTQwLjUsMzA4LjIyOTk1NiBDNTQwLjUsMzc5Ljk2NTM3NiA1MzEuNjgxNTY3LDQxMi44MzczNzkgNTE1LjEyMjM5Myw0NDMuODAwMzQyIEM0OTguNTYzMjE5LDQ3NC43NjMzMDUgNDc0LjI2MzMwNSw0OTkuMDYzMjE5IDQ0My4zMDAzNDIsNTE1LjYyMjM5MyBDNDEyLjMzNzM3OSw1MzIuMTgxNTY3IDM3OS40NjUzNzYsNTQxIDMwNy43Mjk5NTYsNTQxIEwyMzIuMjcwMDQ0LDU0MSBDMTYwLjUzNDYyNCw1NDEgMTI3LjY2MjYyMSw1MzIuMTgxNTY3IDk2LjY5OTY1ODIsNTE1LjYyMjM5MyBDNjUuNzM2Njk1Miw0OTkuMDYzMjE5IDQxLjQzNjc4MDcsNDc0Ljc2MzMwNSAyNC44Nzc2MDY5LDQ0My44MDAzNDIgQzguMzE4NDMzMDYsNDEyLjgzNzM3OSAtMC41LDM3OS45NjUzNzYgLTAuNSwzMDguMjI5OTU2IEwtMC41LDIzMi43NzAwNDQgQy0wLjUsMTYxLjAzNDYyNCA4LjMxODQzMzA2LDEyOC4xNjI2MjEgMjQuODc3NjA2OSw5Ny4xOTk2NTgyIEM0MS40MzY3ODA3LDY2LjIzNjY5NTIgNjUuNzM2Njk1Miw0MS45MzY3ODA3IDk2LjY5OTY1ODIsMjUuMzc3NjA2OSBDMTI3LjY2MjYyMSw4LjgxODQzMzA2IDE2MC41MzQ2MjQsNS4zMjA4NTMzMmUtMTUgMjMyLjI3MDA0NCwtNy44NTY3Mjk3MWUtMTUgWiIgaWQ9IlJlY3RhbmdsZSIgZmlsbD0idXJsKCNsaW5lYXJHcmFkaWVudC0xKSI+PC9wYXRoPgogICAgICAgIDxnIGlkPSJMYXllciIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA3LjUwMjc2NCwgODcuMDIxNTg5KSIgZmlsbD0iI0ZGRkZGRiI+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNjEuMzI1MTQ3LDMyMy44NjM0MjEgQzE0Mi44Mjk2OTQsMzIzLjc5NzY1NSAxMjMuMjczNDA1LDMyMy4xODE2MjggMTE1LjYyMDA1NCwzMjIuNDIzNjkzIEMxMDguMjYyNjAyLDMyMS42OTUwNTUgOTYuMTg1MjU1MywzMTkuOTI1MzEgODguNzgxNTA3MywzMTguNDkwODYyIEM4MS4zNzc3NjAzLDMxNy4wNTY0NDQgNzAuNTIyNDg5MywzMTQuMzEyMjczIDY0LjY1ODY4OTMsMzEyLjM5MjcxOCBDNTguNzk0ODg5MywzMTAuNDczMTMxIDUwLjMxNDQ1MTMsMzA3LjEyMTE3MiA0NS44MTMyNzYzLDMwNC45NDM4NjUgQzQxLjMxMjA5MzMsMzAyLjc2NjU4OCAzMy45ODIzODIzLDI5OC4yMzcxMzkgMjkuNTI1MDMwMywyOTQuODc4NDM1IEMyNS4wNjc2NzEzLDI5MS41MTk3MDEgMTkuMTY5NTMxMywyODYuMDA1Njk0IDE2LjQxODA0MzMsMjgyLjYyNTAxNyBDMTMuNjY2NTU1MywyNzkuMjQ0NDAyIDkuNjgzMDk2MjksMjczLjAzNzM3MSA3LjU2NTkwMTI5LDI2OC44MzE2MjEgQzUuNDQ4NzEzMjksMjY0LjYyNTg3MiAyLjg3OTY0NDI5LDI1Ny42NTA4OTYgMS44NTY4NTUyOSwyNTMuMzMxNjIxIEMwLjU0MDkzNzI4NywyNDcuNzc0NDkzIDAsMjQxLjY3NzU2OSAwLDIzMi40Nzg0MTEgQzAsMjIzLjk1Mzc1MyAwLjYyMzY5MzI4NywyMTYuMzgwMDgzIDEuODA2NDE3MjksMjEwLjQ3ODQxMSBDMi43OTg0MjkyOSwyMDUuNTI4Mzk5IDQuOTYyNzg5MjksMTk3LjQyODQyMyA2LjYxNjExNzI5LDE5Mi40Nzg0MTEgQzguMjY5NDQ1MjksMTg3LjUyODM5OSAxMS4zNzA1MjczLDE3OS41MzcwOTYgMTMuNTA3NDIxMywxNzQuNzE5OTI3IEMxNy4zOTI2NjgzLDE2NS45NjE0NDMgMTcuMzkyNjY4MywxNjUuOTYxNDQzIDE0Ljg0OTI0MTMsMTYxLjA1OTA5OSBDMTMuMjU3MzY4MywxNTcuOTkwODMyIDEyLjI0ODA5MDMsMTU0LjMwNjUwNSAxMi4xNTE1MjUzLDE1MS4yMTExODQgQzEyLjA2NjY2MzMsMTQ4LjQ5MTEyMiAxMi42MjU5NTkzLDE0NC41MTM1MDYgMTMuMzk0Mzk5MywxNDIuMzcyMDI3IEMxNC4xNjI4NDAzLDE0MC4yMzA1NDcgMTcuOTQ4MTk0MywxMzQuMjE2NDc5IDIxLjgwNjMwMzMsMTI5LjAwNzQzMyBDMjUuNjY0NDExMywxMjMuNzk4Mzg4IDMzLjEzNTY4NzMsMTE1LjA3NTYwOSAzOC40MDkxMzkzLDEwOS42MjM0OTIgQzQzLjY4MjU5MjMsMTA0LjE3MTM3NCA1MS41OTcyNDIzLDk2LjY3NTczODQgNTUuOTk3MjM2Myw5Mi45NjY0Nzk0IEM2MC4zOTcyMzAzLDg5LjI1NzI1MDQgNjcuODIyMjMzMyw4My42Nzk5MTk0IDcyLjQ5NzIzNjMsODAuNTcyNDM2NCBDNzcuMTcyMjM5Myw3Ny40NjQ5MjI0IDg1LjQwNTkyNzMsNzIuNjU0Mzc1NCA5MC43OTQzMjUzLDY5Ljg4MjMxMTQgQzk2LjE4MjcyMjMsNjcuMTEwMjQ3NCAxMDQuNTg1OTgxLDYzLjM1NzEwNDQgMTA5LjQ2ODIxNCw2MS41NDE5NDk0IEMxMTQuMzUwNDYyLDU5LjcyNjgyNDQgMTIxLjQxNjc2MSw1Ny40MzYzMjc0IDEyNS4xNzExMjUsNTYuNDUxOTgzNCBDMTI4LjkyNTQ4OSw1NS40Njc2MDg0IDEzMi4zNzk0MzgsNTQuMzI4NjYxNCAxMzIuODQ2NTcxLDUzLjkyMDk3NzQgQzEzMy4zMTM3MDMsNTMuNTEzMjkzNCAxMzMuMzkzNDkxLDUyLjIyNjg4NTQgMTMzLjAyMzg2Myw1MS4wNjIzMDQ0IEMxMzIuNjU0MjM0LDQ5Ljg5NzcyMzQgMTMwLjY1NDQzMiw0OC4wNzg5MzY0IDEyOC41Nzk4NDcsNDcuMDIwNTU2NCBDMTI2LjUwNTI2Miw0NS45NjIxNzY0IDEyMy4zMzE2OTMsNDMuNDE0OTY1NCAxMjEuNTI3NDY0LDQxLjM2MDA2NDQgQzExOS43MjMyMzQsMzkuMzA1MTYzNCAxMTcuNjI4MzQsMzYuMTQzMDg0NCAxMTYuODcyMTQ0LDM0LjMzMzI2OTQgQzExNi4xMTU5NDksMzIuNTIzNDI0NCAxMTUuNDk3MjM2LDI4LjMxMzczODQgMTE1LjQ5NzIzNiwyNC45Nzg0MTE0IEMxMTUuNDk3MjM2LDIxLjY0MzA4NDQgMTE2LjE4NjE1NSwxNy4yNjUzMzc0IDExNy4wMjgxODEsMTUuMjUwMTA5NCBDMTE3Ljg3MDE5MSwxMy4yMzQ4ODE0IDExOS42OTgxMDMsMTAuMDkyNzkxNCAxMjEuMDkwMTkzLDguMjY3NjU3NDMgQzEyMi40ODIyNjcsNi40NDI1NTM0MyAxMjUuODI4Mzk3LDMuODMwODI4NDMgMTI4LjUyNTk5OSwyLjQ2MzgyNDQzIEMxMzIuMzM4NDIzLDAuNTMxOTM5NDI1IDEzNC45NDE0MTksLTAuMDE2NzA1NTc0NiAxNDAuMjEzOTg3LDAgQzE0NC42MTc5NDgsMC4wMTQ2MzU0MjU0IDE0OC40MTM4NDcsMC42NjU4MTk0MjUgMTUxLjAzNTk0OCwxLjg1Njg5MDQzIEMxNTMuMjU3MjMxLDIuODY1ODkzNDMgMTU2Ljk2OTc0LDUuODQ0MzQ3NDMgMTU5LjI4NTk0OCw4LjQ3NTcyNTQzIEMxNjMuNDk3MjM2LDEzLjI1OTk5NzQgMTYzLjQ5NzIzNiwxMy4yNTk5OTc0IDE2Ny43MDg1MjQsOC40NzU3MjU0MyBDMTcwLjAyNDczMiw1Ljg0NDM0NzQzIDE3My43MzcyNDEsMi44NjU4OTM0MyAxNzUuOTU4NTI0LDEuODU2ODkwNDMgQzE3OC41ODA2MjUsMC42NjU4MTk0MjUgMTgyLjM3NjUzOSwwLjAxNDYzNTQyNTQgMTg2Ljc4MDQ3LDAgQzE5Mi4wNTMwNTMsLTAuMDE2NzA1NTc0NiAxOTQuNjU2MDQ5LDAuNTMxOTM5NDI1IDE5OC40Njg0NTgsMi40NjM4MjQ0MyBDMjAxLjE2NjA5LDMuODMwODI4NDMgMjA0LjQ3MzAwNSw2LjQxODMyMjQzIDIwNS44MTcxODIsOC4yMTM4MjQ0MyBDMjA3LjE2MTM2LDEwLjAwOTM1NjQgMjA4Ljk4OTI0LDEyLjkxODU2NjQgMjA5Ljg3OTE5NCwxNC42Nzg3NTk0IEMyMTAuODgxODgsMTYuNjYxOTQ0NCAyMTEuNDk3MjM2LDIwLjM4MjIyMDQgMjExLjQ5NzIzNiwyNC40NjA4NjM0IEMyMTEuNDk3MjM2LDI4LjA4MDg1OTQgMjEwLjg3ODUyMywzMi41MjM0MjQ0IDIxMC4xMjIzMjgsMzQuMzMzMjY5NCBDMjA5LjM2NjEzMiwzNi4xNDMwODQ0IDIwNy4yNzEyNTMsMzkuMzA1MTYzNCAyMDUuNDY3MDI0LDQxLjM2MDA2NDQgQzIwMy42NjI3OTQsNDMuNDE0OTY1NCAyMDAuNDg5MjEsNDUuOTYyMTc2NCAxOTguNDE0NjI1LDQ3LjAyMDU1NjQgQzE5Ni4zNDAwNCw0OC4wNzg5MzY0IDE5NC4zNDAyMjMsNDkuODk3NzIzNCAxOTMuOTcwNjI1LDUxLjA2MjMwNDQgQzE5My42MDA5OTYsNTIuMjI2ODg1NCAxOTMuNjgwNzY5LDUzLjUwODI4ODQgMTk0LjE0NzkwMSw1My45MDk4Mzg0IEMxOTQuNjE1MDM0LDU0LjMxMTM4ODQgMTk3LjY5NzI0OCw1NS4zNzA1MzE0IDIwMC45OTcyMzYsNTYuMjYzNDQ1NCBDMjA0LjI5NzIyNCw1Ny4xNTYzNTk0IDIxMC4xNTMwODksNTguOTY5NDM5NCAyMTQuMDEwMjA2LDYwLjI5MjQ5ODQgQzIxNy44NjczNTMsNjEuNjE1NTI2NCAyMjQuMzY0NzI5LDY0LjE2NDYyOTQgMjI4LjQ0ODgzNSw2NS45NTcxNzE0IEMyMzIuNTMyOTQyLDY3Ljc0OTcxMjQgMjQwLjI5MjA2Niw3MS44MzkzNzM0IDI0NS42OTEyOTcsNzUuMDQ1MzM2NCBDMjUxLjA5MDUyOCw3OC4yNTEyOTk0IDI1OC45OTMxNDcsODMuNDY0MjgxNCAyNjMuMjUyNjY4LDg2LjYyOTcxNzQgQzI2Ny41MTIxOSw4OS43OTUxODM0IDI3Ny4xMTY2ODIsOTguNDgxMDk3NCAyODQuNTk2MDIxLDEwNS45MzE3NSBDMjkyLjA3NTM2MSwxMTMuMzgyNDAzIDMwMS40MTI0MjgsMTIzLjgzNTQ2NyAzMDUuMzQ1MDc1LDEyOS4xNjA3ODQgQzMwOS4yNzc2OTMsMTM0LjQ4NjA3MSAzMTIuOTQ1NzUzLDE0MC4wMjc4OCAzMTMuNDk2MjU5LDE0MS40NzU4NzggQzMxNC4wNDY3OTcsMTQyLjkyMzg3NiAzMTQuNDk3MjM2LDE0Ni45MzcyODkgMzE0LjQ5NzIzNiwxNTAuMzk0NTY0IEMzMTQuNDk3MjM2LDE1NS4xMzAxMjkgMzEzLjg5ODExNSwxNTcuODA3Mjk5IDMxMi4wNjgxODksMTYxLjI0ODkxOSBDMzA5LjYzOTE3MywxNjUuODE3MzI0IDMwOS42MzkxNzMsMTY1LjgxNzMyNCAzMTQuNjI4MjE3LDE3Ny41ODk4MzEgQzMxNy4zNzIxNzUsMTg0LjA2NDcxNSAzMjAuNzM4NzUyLDE5My4yMTM0NTcgMzIyLjEwOTQ0OSwxOTcuOTIwMzY3IEMzMjMuNDgwMTc3LDIwMi42MjcyNzYgMzI1LjI5ODAxNywyMTAuOTc4NDExIDMyNi4xNDkwOTEsMjE2LjQ3ODQxMSBDMzI3LjIxNTAwOSwyMjMuMzY2Njg2IDMyNy41MTg4NDIsMjI5LjkwMTMyNCAzMjcuMTI1NTAxLDIzNy40Nzg0MTEgQzMyNi43OTc0MzcsMjQzLjc5NzY4NiAzMjUuNjgwNDY0LDI1MS41OTY4OCAzMjQuNTAwNTYyLDI1NS44MDcwMjQgQzMyMy4zNzA4OTMsMjU5LjgzNzc4NiAzMjEuMTU2ODEyLDI2NS42OTA3ODMgMzE5LjU4MDM5NiwyNjguODEzNjc3IEMzMTguMDAzOTUsMjcxLjkzNjYwMiAzMTQuNTU1NzA4LDI3Ny4zNjMwNTUgMzExLjkxNzY0NiwyODAuODcyNDU0IEMzMDkuMjc5NTU0LDI4NC4zODE4ODQgMzAzLjgyNDc4MSwyODkuODcyNjk4IDI5OS43OTU5NDIsMjkzLjA3NDI5NyBDMjk1Ljc2NzA3MiwyOTYuMjc1ODY2IDI4OS42NjQxOTgsMzAwLjQ2Mzg4NSAyODYuMjMzOTkxLDMwMi4zODA5NjggQzI4Mi44MDM3ODUsMzA0LjI5ODA4MyAyNzUuODc1MDEzLDMwNy40NTc3NTEgMjcwLjgzNjc0NCwzMDkuNDAyNDgzIEMyNjUuNzk4NDc1LDMxMS4zNDcyNDYgMjU3LjI0ODQ1NywzMTQuMDkwNTk0IDI1MS44MzY3NDQsMzE1LjQ5ODgyNyBDMjQ2LjQyNTAwMSwzMTYuOTA3MDYxIDIzNi41OTcyNDIsMzE4LjkxNDY5IDIyOS45OTcyMzYsMzE5Ljk2MDI4NCBDMjIzLjM5NzIzLDMyMS4wMDU4NDYgMjEyLjUxOTc4OCwzMjIuMzM3NjY0IDIwNS44MjUxNDcsMzIyLjkxOTg0OCBDMTk5LjEzMDUwNiwzMjMuNTAyMDYyIDE3OS4xMDU0OTcsMzIzLjkyNjY4NCAxNjEuMzI1MTQ3LDMyMy44NjM0MjEgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.saifu) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.saifu;
			if (!wallet.isConnected) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			if (wallet.signAndSendTransaction) try {
				const { signers, ...sendOptions } = options;
				transaction = await this.prepareTransaction(transaction, connection, sendOptions);
				signers?.length && transaction.partialSign(...signers);
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
		return await super.sendTransaction(transaction, connection, options);
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-salmon/lib/esm/adapter.js
init_index_browser_esm();
const SalmonWalletName = "Salmon";
var SalmonWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor({ network = WalletAdapterNetwork.Mainnet } = {}) {
		super();
		this.name = SalmonWalletName;
		this.url = "https://salmonwallet.io";
		this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iODgiIGhlaWdodD0iODgiIHZpZXdCb3g9IjAgMCA4OCA4OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9Ijg4IiBoZWlnaHQ9Ijg4IiByeD0iMzAiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl84NTVfNTgwKSIvPgo8cGF0aCBkPSJNNTkuODA1NSAyNy42M0M1Ni43OTU1IDI1LjgyMzkgNTMuNjIyMiAyNC41Mzg4IDUwLjM1OTcgMjMuODE0NEw0Ni45MDQyIDE2LjEyODdDNDYuNDkzMyAxNC44NTg1IDQ1LjMwMDIgMTQuMDAwMSA0My45NTM3IDE0LjAwMDFINDMuODE1QzQyLjQ2ODUgMTQuMDAwMSA0MS4yNzU0IDE0Ljg2MzUgNDAuODY0NSAxNi4xMjg3TDM3LjQwOSAyMy44MDk1QzM0LjE0MTYgMjQuNTM4OCAzMC45NTgzIDI1LjgyODkgMjcuOTQzNCAyNy42MzQ5QzIxLjk1MzIgMzkuMjYwMyAyMC4zMjk0IDUwLjU5MjggMjEuMTQxMyA2MS43NjY2QzI0LjY1MTMgNjUuMTY1NCAzMi40MzM2IDY5LjM2OCAzNi42MDcgNzEuMDMwMkMzOS4wNTI2IDcyLjAwMjcgMzkuODAwMSA3Mi40OTM5IDQyLjI1MDYgNzIuOTAwN0M0NC40Mjg5IDczLjUxNiA0NS4wODczIDczLjI3NzggNDYuNzU1NyA3My4xMDQyQzQ5LjMyNTEgNzIuNDE5NSA1MC4zOTQ0IDcxLjcyNDggNTEuNDM0IDcxLjE2NDFDNTUuODQ5OSA2OC44NzY4IDYzLjExNzQgNjUuMTcwNCA2Ni42Mjc0IDYxLjc3MTZDNjcuNTc3OSA0OC44MTE2IDY0Ljk5ODYgMzcuNTgzMiA1OS44MDU1IDI3LjYyNVYyNy42M1pNMzcuNTI3OCA1MS4xNDg1QzM1LjY0MTYgNTEuMTQ4NSAzNC4wODIyIDQ4LjkwMDkgMzQuMDgyMiA0Ni4xMzIyQzM0LjA4MjIgNDMuMzYzNiAzNS41ODcxIDQxLjA5NjEgMzcuNTE3OSA0MS4wOTYxQzM5LjQ0ODYgNDEuMDk2MSA0MC45OTgxIDQzLjM2MzYgNDAuOTYzNSA0Ni4xMzIyQzQwLjkyODggNDguOTAwOSAzOS40NDM3IDUxLjE0ODUgMzcuNTIyOCA1MS4xNDg1SDM3LjUyNzhaTTUwLjIzMSA1MS4xNDg1QzQ4LjMzOTkgNTEuMTQ4NSA0Ni43OTAzIDQ4LjkwMDkgNDYuNzkwMyA0Ni4xMzIyQzQ2Ljc5MDMgNDMuMzYzNiA0OC4yOTUzIDQxLjA5NjEgNTAuMjMxIDQxLjA5NjFDNTIuMTY2NyA0MS4wOTYxIDUzLjcwMTQgNDMuMzYzNiA1My42NjY3IDQ2LjEzMjJDNTMuNjMyMSA0OC45MDA5IDUyLjE1MTggNTEuMTQ4NSA1MC4yMzEgNTEuMTQ4NVoiIGZpbGw9IiNGQ0ZDRkMiLz4KPHBhdGggZD0iTTc1LjQwNTEgNTYuMTIwM0w3MC45NzkzIDQyLjE3MjlDNzAuNDM0NyA0MC40NjYxIDY4Ljg1NTUgMzkuMzA1MSA2Ny4wNjMzIDM5LjMwNTFDNjYuNTI4NyAzOS4zMDUxIDY2LjAwODkgMzkuNDA5MiA2NS41Mjg3IDM5LjYwMjhDNjcuNTQ4NSA0Ni4zMjU5IDY4LjM2MDQgNTMuNTc5OSA2Ny43MjY3IDYxLjQ4NEg3MS40ODQyQzc0LjI2NjUgNjEuNDg0IDc2LjI0MTcgNTguNzc0OSA3NS40MDAxIDU2LjEyMDNINzUuNDA1MVoiIGZpbGw9IiNGQ0ZDRkMiLz4KPHBhdGggZD0iTTEyLjE5MDggNTYuMzgzNUwxNi42MTY2IDQyLjQzNjFDMTcuMTYxMiA0MC43MjkyIDE4Ljc0MDUgMzkuNTY4MiAyMC41MzI2IDM5LjU2ODJDMjEuMDY3MiAzOS41NjgyIDIxLjU4NyAzOS42NzI0IDIyLjA2NzMgMzkuODY1OUMyMC4wNDc0IDQ2LjU4OSAxOS4yMzU1IDUzLjg0MzEgMTkuODY5MiA2MS43NDcxSDE2LjExMTdDMTMuMzI5NSA2MS43NDcxIDExLjM1NDIgNTkuMDM4IDEyLjE5NTggNTYuMzgzNUgxMi4xOTA4WiIgZmlsbD0iI0ZDRkNGQyIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzg1NV81ODAiIHgxPSI0NCIgeTE9IjAiIHgyPSI0NCIgeTI9Ijg4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGRjgxNzAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY1QzQ1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._network = network;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.salmon) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.connected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			let SalmonClass;
			try {
				SalmonClass = (await import("./esm-CvV9kSnn.js")).default;
			} catch (error) {
				throw new WalletLoadError(error?.message, error);
			}
			let wallet;
			try {
				wallet = new SalmonClass({ network: this._network });
			} catch (error) {
				throw new WalletConfigError(error?.message, error);
			}
			if (!wallet.connected) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signMessage(message, "utf8");
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-sky/lib/esm/adapter.js
init_index_browser_esm();
const SkyWalletName = "SKY Wallet";
var SkyWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = SkyWalletName;
		this.url = "https://getsky.app";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDY2IDY2IiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxpbWFnZSAgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBpZD0iaW1nMSIgaHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUJBQ0FZQUFBQ3FhWEhlQUFBQUFYTlNSMElCMmNrc2Z3QUFFWGhKUkVGVWVKekZXd2x3RlZVVy9ZRUVRaEx5MTdCbGcwaEVrYzJFZ0d5akFoWUtLb2lvaUN3aUlpaWlvcWdnaTRBb0lBNmhCQUVabGtFREptSGZ3aFlNUzFCUjJVVUUwUUZucG5TbVpzWlNTNjJwS2JsenprdS84TkxwL2dSSndxODYxZjI3KzNmM3ZlOHU1OTczdnNkVGhaOTkrL1pGQXgwT0hEZ3c4cU9QUGxyd3lTZWZGSHo2NmFkSGdYOGRQbnhZamg0OVdvcGp4NDc5RXpnQ2JENSsvUGc4NEZFZ0M2aFZsZTlZcVorZE8zZDZkdTNhbGZEKysrL2ZzM2Z2M29VUS9PakJnd2QvZ09BWERoMDZKT0ZBaFJ3NWNrUXJReUQ0aFJNblRuei8yV2VmSFFMZUJPNEVBamgzdGNVcy95a29LUEJzMjdZdEZRcDR1YWlvNkFRRXZ3REJCU1A5dTZHVlFvVkFFUUxoTDV3OGVmSVFNQTVvaU85WFcyeVBaOU9tVFJHYk4yOU9nL0J6Q3dzTC93dkJCYU45UllLSFV3Z3RBNExMNTU5Ly9pdndHcEFFUkZ3VjRkZXRXeGNMQlV5RThQL1p2MzkvbFFudXBBaGFCYXhBVHAwNjlSMHdHcWhkYllMbjUrZEhyRm16cHQzR2pSdFB3OWZsNDQ4L3JoYkIzU3dDRmtCRkhBTmFBbFVyZkY1ZUhoVXdDV2IvWTNGeGNZVkgvWU1QUHBCbHk1YkpDeSs4SUE4OTlKRGNmZmZkMHFWTEY3bnBwcHNVdU4rN2QyOFpPSENnakI4L1hsYXNXQ0hJR2hXNk4rTUUzZUtMTDc3NEhuaXF5b1IvNzczM1FsREFTcGg4aFY0T0FWR21UWnNtUFh2MmxFYU5Hb25mNzVkQUlGQUtyOWNyb1ZCSWdmczhGZ3dHMVhWRWNuS3kzSFhYWFRKanhnelp2WHYzSlo5SGE0QUNMZ0NMQUc5bEM1K0lrVis5ZmZ2MnNOR2RGckZod3dZWk9YS2t0R3paVWhJU0VrcUZwWEJPd2pvcGhlZjBiK3JWcXlkdDJyU1IwYU5IQ3l3dnJOVXhOc0FOZmp0OSt2UnlLQ0ZRV2NMSDVPYm03dURJaC9OM3BEOTU4c2tuSlRVMVZiMDRFUjhmcjdZVXp1ZnpsUkdZNTdRRmNGOGY1M1dFcVJSOXY3UzBOSG51dWVlRTd1ZjJIdVFTbGhKeW9JU29LeFUrRHNJWFVIaTNrYWM3dlBIR0c1S1NrbEw2b3RxTTlVZzdtWHNnakFYbzY4cmR6L3JldEdsVG1UOS92dXVBV0VvUUtDRVhpUDVkd3E5Y3VaSUtXQWF6Y3pWNzBGd1Z1TFNnNWN5WUx3MFREalpzS0w0R0RjU1BXQkJNVEpRQTRNWDNFUHc4bEp5RS9mbzRobk5KU2VMRHRYNUFYWWZyZVYwd0tWR2Q4OWF2TDBIZWcxdTQxL0RISGhOeUR6Y2x3QUpvQ2JOL3o4aEhBSThqMTdzR3ZLMWJ0MHFuVHAxS0JlY0lxWDBDTHhob25Dcis2NitUbEU0ZHBYblBPNlJ0djN1bDNmMzlKS1B2UFdxLzdYMzNTdWE5ZlNXVCt4WXk4SjNYWk4zSDYvcXFiVnNnczE5ZkJWNlRpZDhuZGV3Z2dmU21Fb1RpdW5YdkpxRGZyakVCQ3JnQTNBOWxYSllDTWhEeGZ5VEJjYnJ4amgwN1ZHRFNKc3l0TWxtTXRpOGxXZnh0V3N2OVk1Nld4ZSt0a2kzSUJqdDNGOHB1Y0liM0t3Rzh6MVlJUEdMeVpBbEF3ZjU2Q1dvZzNONFZOWVdjT1hQbTMxQkNzNG9LVDc4L3pEVG1OdkkzM25oanFYOXFmdzQwYkNEZTY1cEpuMUZQeU5xdFcxVHFBbE5VV2FHeUFSSW1LTFprTUhoRjRKbzBDWVNDMHFGREIxZExJRm1DRW9xZ2hQQ01FY0xYQUo3bFE1ejhuZy90MkxGamFkRFNaay8vam9Qd1kxK2ZoZEd1T3NIdFNzaUJpeVpsdFZWeGh1L1RyVnMzeHd4aHhRTzZ3eU9BZSswQTRhL0Y2SDlEUVoyaVBWbWNFaGhwU2xrQW96VlFCNlB3L096WDFhaFh0ZUFtQ3ZjVVNhdmJlMGdBQTZEZmFjU0lFWTdaZ1JVbHJPQVVGSkRrSmp5UnpkRnpNaU9tT2pPWGN4c0h2NDlxMUVENlAvZXM4cy9xRkY0QjZia0pncXlmbWNZYUdMN2JnZ1VMeXIwL2F3ZkxDbDZHSXB4SEg0SHY3MDZqejVGbDBDdERYUERBNkdCQWtycDBrbUp3Zlpwa2RRcFBiakp4YnJZa0lCQUdrQkpORHNINndpa29NaUJDQVY4Q0RaMFVNSk9qNzBRMVNXMDFPZEYrejlHdjBhaWh2RFJuam16WnN1V1Mva29heSt1dUZBekNaSjEveXN1VnhQYnR3QTNxbGZJUXpTSkp3Y2VPSGV0b0JTQklUSXZqbklMZjF6UmpwOEJIZXF0OVRDc2lLaTVPNWVOdGhZVmhoZWM5VitPbFIwMmZKbzlPbmlURHJ4QkR4bytUTGdNZWxIcXRXNVVRSzd5UG5UTHpYZFBUMHgwNWpCVUxqdGdWMEd2dDJyV09QeGcyYkZnWm5xNGZGZ0hjK2Rod1Y5L25xQmZDZFI1QWZJaEt2MFpxZ2h4RkltZlh4T2h3V3dPcGk5dElqS0RlVitjU1NyWVhyd3VWWEFjLzV6WVdqTkVMcGhpdytiMm15MllkTVdiTUdNZU1ZSkdqVEZNQkt3b0tDc3FaLzU0OWUrVDY2Njh2SXp3ZldpY21Sang0NmFlbnZ5TDhuYU9QYnQ4dTB4Y3VFQjk4MUVlQ0ZNQUw4ajcra3EyWDk3T1lZenlEcTNWT3cydGN4NjM1Rzc4bHNGbEhhQXNOR09jWXQreHBrVzVBWGdBRlpHdmhvNEZUOUN1N3R1YkF2ODJINkJ0SDE2a2pIdERRYWZQbktkOTJVc0FPa0pMdVF4K1dJSmloejRvYjloR3ozN2VVVGhzQzJhOXpPdWEwSmVpdVM1WXNjUXVHbnlJcjFLUUNya1B1LzlYSi9HKysrZWFMMVp0aEJiVnExeFlQbU4rckM5NXlKVDFiUVpmYjN0TUhETEZoR2VzeDcyY1h3aHhGOHpwdDNsb0Jaay9CTkhtN0FuaU9UUlVYTi9nQkNraW1BZ2JULzUwcVBVWlQrNGdRVWJWcWlRZStPM0hPSDEwendDNEV4MzVQajVaZ2s4WXFVSm5sY1VVNlF1WjFadkMxbDhqNnV6MEk2dnV4RzJWbnRSWW5ZUGVvaHljbkoyYzV6WmpzeVFSN2VQYVgwemVPam80V0QzejZFVVJrRmtaT0NxQmljdGF2azRZZDJvc1hwV3dJRmhNQ1kvTnlkQmpBRUJUOTdCaFJ5YXdlY2N4TFFlRmFJWHpudmpvSGFKKzNDOHYzTTRYVlFUQmtaUVk5YVBuNStlWGtZelpBTEpqcFdiNTgrWDZhTVVmY3hJUUpFeHlEREtFVUVCY3JIVkNxTWsyNnBVQXFaMEZPanZ3QmFTc1ZqQzI1WFpZa0kzY250MnNuamRwbVN1cE43U1VGNEQ2UHB3Qkp1SWI4bnRjMnVMR04rSzVObDJCYWs1SitnR0ZCZGtzeDM4K3VsRm16WnBXVGowcEF1YnpKczNEaHdxL3BBdHNSdFUwTUdqVEkxUUxJQkNQZ0JyNldMV1RWaHZVcTVibUJXV0l2V0ZudXBvM3lMb3FYZC9Bc2J0OWRwN2NYOXkrZVd5Y3IxcXlSSmJtNU12UHRSVEpzd2t2U3VsZFBWZjRHazVOVmhqQ3R3VzRCZGpkanE4NHVINE0rNHQ1aER5TDlqeXRYcmhRcXdjU3R0OTVhSnFDWVprY0YxSXlNRkErK0QzeCtyTklveStlcUF0TXgyOTl6VjZ5UXJINTlKUUNyOElFVDJHT0YyVkExQjYxUG56N2w1S1BiNDc3ZmVkaDJYcnAwcVNBV2xFRldWcGFqQmVpSHhzVEdpZ2V1VUFkbDhPNERKWE1FZGorcmJEQjRuVGg1VWg2Wk9FRVNZSDBoVUhGdm1CaWdsZEsrZmZ0eThpSHpLVXZ3VEpreVJlQUdLbCthMEIwZmU0b3lGUkVaRlNXZStMcHl3NTI5NUlzdnY1U3paODlXQzg2ZlB5K3ZMbjViUWkxYXFGTFlMUWJvV0VGWjdQSng4b1V1NnBrOGViTHFzQzVldkxnTStDTTdjZEg3ZWh1SGVxQUdsWkFRa3B1SERKTHozM3lqWHZCTEtLT3FjZTdjT1hucXRWZkZEODdQYkdGeUJmdWdzWU5sbDQ5WmJ2MzY5ZUtaT25XcUxGcTBTQjB3a1pHUlVZNVkyQ2MwVkU4QVNtQkFKRFhPNm5ldjdFQTg0Q3hOVmJzRTczOEloT2EyaDRkSUlEV2xITGt5MzcwZHNvNWR2bmZlZWFmRUFwQWlma0lxRkJDaU1tQVFkTHFaMlJIUzU2aUVtbVNIZnAvVVIvcDZjZlpzMlZxNFM0b1BIRkRGVWlGSUVmdDFsNHRMQlVmMktSYkNuK3UxYVMwK3krK2RCbzN6am5iNTFpRExiTnUyN1Z2UHZIbnp6dkVBbzZLSi92Mzd1L0p1T3pmbmZ0MjZkYVUyYW9TSTJCaFZKNUFBOVIvempMenkxbnhabXBjbmVlQWFhMUVXczJHNmh0aFNndFZiTmdONkMrRForWnRMamhYQm1oaW93cVZaOWlDN3dmMDRkK0JtQVd5VDJlVWpSMEVXT09wQlFOaEhYMkJlTk1GWldwTzZta0hHY2RiR2VtZ3Nza01kSUJLSThJSXZnT0Y1OEhJZW1LbW5jV29aUkZpNHVKK2k0Q0dhcEVwMHE1WXlQbnVPS3F6Y09rNVUwTVRzYlBFMkxxSGNUa1NJbWM0dUgyZXM0VW9iU1lXWDhlYmt5eWFZR3UxcDBPd0k2YmtBblh2MVBLRFptVkhYWUJzREYvSHhPQnVvc0pSNEhtZFh5ZWVWdWpoUGhzZGpNYmdIcjRuSDkwaXlUWlRkRWFnbW41ZzZSYm1Fa3dMSVlwZmw1MG13eFEwbHo3QVJJZTdud1FMdDhsbHJrV2F5R0JwQ2Y3RDNBa2h1ekZFMml4Y3RyT2JpNWtQMXBLZVRVa3lYNFRrV1d3VGRSNWV2NXYzcXNPd0dHRmZXdS9RZE9IaWJZQVh4VUFCckRYUFF1TjhBeDV5S0lhNDVRajF3dXlxSGdWOC8vUEREY2hYaExiZmNVcTd3c1BOdiszUjJ5S3I4N01VTGp5ZFl6Y3R3bFIrdk1mdVBOWkJoSXVFZWI2NzRzM3Q3SENZZHpNeFF4Wlc5R0hJcWg2MUZGVDlBQWFvY3JnT2NjZW9Ic29pdzl3THNOYjA5OTVwVDR2WmVnbm1kM2FMY3Jxc0pDNGhERFVBemQ3T0FIUWlFM3RZdDFWeWgrWDY4TjBtZTA1d2hoRDl5L1BqeFNOMFZXc1Z1cTkwTnFCUTJGKzFLY0dwZ3FIMUw4MzZUTjFpV0V3eFpOWDFwSzh5NnhtcHhCYlQvMHFMNEd6NUQ5UVpEMGhuVjVPNGk5OTVqL3VaTjRnYzE5aHZsTWRFQ1ROR3BQVzZ0UTV4djlnVDdyRjY5V3B6Y1lQRGd3ZVVzb0F6VnBBQ3M3Vkd1Qm1HcVhsUnJiSUlFRUpXNXo2MGZ4MzBrSzV3eFRrMVZXeStDbXlwekFmTTZubGZBOXhpY1MrOXhtNm9XM1ZwdjdEdGtMMXNxUHM0V0c2YlA3YWhSb3h6Tm40c3dvWVNPcGdKcUFuOTFXb3RERXBORTRXeWNnQ1BJR1puQU5kZElzKzdkNUo0blI4blFsOGJMTUJRcWJGMC9iTzBQUlNuTDc5d2ZObWtpam8rVFIzRHNVZXp6ZXA1bnU3dmsydkdsN1crZW16QTNXL1pnQk4yRVYvNlA5Mk81SEtCaURjdmphaEtudFFNMGZ5amc1SkVqWlR2amFscU1OM1NhR0JrNmRHZ1p2MVQ3TU9rWWpDSWJuMFg3OTZrMHhkbWFpb0E5Z29vZ25PRGEvTmZCZGROdStZT3lRdE05MlFOd21oaWgrVU1KTHp2TkRMVkFpZmdQcCs0d3lRYjl5UXlDdGJIZnFsZFBLZHE3dDlxbnhUUm9zU05mbnF3V1M1aWQ1OHpNVE5WRGNHcUdRdmh6MktZNktZQ3JRaGFRRlRwWndmVHAweTkyaEtBQUZqL1B2RHBkamVqVkVKNit2eFNaSVJFY3djOWxORVphelFZenRMKy9ObjhJUHdOeG9QemtxTFlDNEZ1bldFRHF5TTRLSTdscWk5ZXZKNitFbVJlb1NqQmpyZCsrVFpyZDFsMkNLU2txZzJnZXdsYWUwOW9Hamo3d0ZZUlBjNWIrWWpDYzREWk5Sc1d3VEs1TkJTQUlqa1N3Y3VzS1Z3VlV6c2Z6MkMvTTZIMjN5alkrbzB6bjRnMHlXQ2ZmcHdJZy9DZ2cvT0pxS01EUG1TSnEyY21NdUhDS0VaWThQYjNyclZKUTZGNm9WS2JnYWxZWThXWWFxa3RPeXZxNUZpbDRjWmtPR3podTcwemhvWVNEUUd4WTRRMGxkQVIrZGdxSUJGOHFDYWJud1lNeit2U1dkWWpZYWdFVExLUXl3WHZ1Z0lKWklsUHd0RzVkeGQrc21YZzVyMkJNcWpEb3VTMm5aZDdIbG4vYWFGVWg0UzBGTUNDK3lBa0Z0M1Y0SkU1TjhUSWVWSFJzakRhN3ZZZTBlK0IrYVUvMHYzTHdYczN2N0NXTk9uV1VXRkRoZUZoZFBGT2ROVnVsQTE3bnpwMWRSNTZtenkxaXduQ1V2cGYzdjRKVnExWlJDV3RZS1RveFJFMlM3dWpaVTZKUjd0WkM3Yy9VV012dlUxc2lDbG1qZHBESC9GSXI0TGZPbDJ5anpPdlV2dDg2VjNLZXEwL3FjbGFaWklzelNKYXBteDJwQVFNR2lOT0tGZ01YRU12ZXhpQmVsdXltSmZpQS9VeU5ia3BnZG1CbnVZSFZuZFZ0YXI5QlNjMjFSZWF4MG1yUnZNNmxBV3ZXOTJTbU0yZk9ETHRxblgzRDR1TGlBZ2hmTWIrL2hCS0t3eW1CWUhUbVlvckV4TVF5ZlFTemQyanVtK1d5S2FUOWV2TTZya2QrL1BISHhhbHl0UWwvQVVYUVJsaEh6QlVKYnlnaERTaWdFdHhpZ3RZNlhFZmw0bWFJRDA2bGRMajFBZmJxVXYrbWVmUG1Tcm1NTzVmNmt3YXNnc0xuUS9qNmxTSzhvWVJHd0JiR2hFdjRuUUpiVmVQR2pWTnJEUFQvQm9KRzJxTFF1cGxpbnpvbitEOEJMbnljTkdtU3Fnc3U5VHdxNWtCSkZ6b1hDRldxOFBwakJjWnMxQXkvc0Q2bzZOOWFhTEt6Wjg5VzNWbitYYVpyMTY1cXNxSlZxMWJTdW5WcnRVOWh5VFJwNHFTeUZWR3lNZXBzZFA2MGMrZk9xWERGS3BHOTlHT2x5QjdBMzBpS0x1ZEY3U05tVG5MOG5udnd0MlIrRVBvcjFDU2RnZXI3QzUzRkdHY0RQNUtwVmVkZjV5ZzRGUStCdjBjdE1nV0ZVVnkxQ1c1VEF0Y1gzZ0Rrd0MxK295SllobGFWSW1qcWRDY0kvRDg4YXpFWWFUcFE0Nm9JYjFORWhLV0lPY0EzREpRTVhGUkdSZU9FMjBnenNKSG1zdnlGeTUzRnZWOUROa2pIOW1xTDdmeXhyS0lQRzYzc05uTUZHcXRMS29TQzBIUXBGRGtGbGFOQlFrVTNZdjNCZVQrVzJSRHlsN3k4dkZOY3h3amNRVVZmYmZrdTYyTzEzRG52TUFSWUFod0F6a0VwUDNPMnhnU08vUVQ4QmVmM0FXOEREd0xwWE1kWWxlLzRmLzRNQmw2a1JRUjRBQUFBQUVsRlRrU3VRbUNDIi8+PC9kZWZzPjxzdHlsZT48L3N0eWxlPjx1c2UgIGhyZWY9IiNpbWcxIiB4PSIxIiB5PSIxIi8+PC9zdmc+";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.skySolana?.isSkyWallet) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.skySolana;
			try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				transaction = await this.prepareTransaction(transaction, connection, sendOptions);
				signers?.length && transaction.partialSign(...signers);
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/icon.js
/** @internal */
const icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMxIiB2aWV3Qm94PSIwIDAgMzEgMzEiIHdpZHRoPSIzMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIwLjI1IiB4Mj0iMjYuNTcxIiB5MT0iMjcuMTczIiB5Mj0iMTkuODU4Ij48c3RvcCBvZmZzZXQ9Ii4wOCIgc3RvcC1jb2xvcj0iIzk5NDVmZiIvPjxzdG9wIG9mZnNldD0iLjMiIHN0b3AtY29sb3I9IiM4NzUyZjMiLz48c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNTQ5N2Q1Ii8+PHN0b3Agb2Zmc2V0PSIuNiIgc3RvcC1jb2xvcj0iIzQzYjRjYSIvPjxzdG9wIG9mZnNldD0iLjcyIiBzdG9wLWNvbG9yPSIjMjhlMGI5Ii8+PHN0b3Agb2Zmc2V0PSIuOTciIHN0b3AtY29sb3I9IiMxOWZiOWIiLz48L2xpbmVhckdyYWRpZW50PjxnIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iLjA5NCI+PHBhdGggZD0ibTI2LjEwOSAzLjY0My05LjM2OSA2Ljk1OSAxLjczMy00LjEwNSA3LjYzNy0yLjg1M3oiIGZpbGw9IiNlMjc2MWIiIHN0cm9rZT0iI2UyNzYxYiIvPjxnIGZpbGw9IiNlNDc2MWIiIHN0cm9rZT0iI2U0NzYxYiI+PHBhdGggZD0ibTQuNDgxIDMuNjQzIDkuMjk0IDcuMDI0LTEuNjQ4LTQuMTcxem0xOC4yNTggMTYuMTMtMi40OTUgMy44MjMgNS4zMzkgMS40NjkgMS41MzUtNS4yMDctNC4zNzgtLjA4NXptLTE5LjI0Ny4wODUgMS41MjUgNS4yMDcgNS4zMzktMS40NjktMi40OTUtMy44MjN6Ii8+PHBhdGggZD0ibTEwLjA1NSAxMy4zMTMtMS40ODggMi4yNTEgNS4zMDEuMjM1LS4xODgtNS42OTd6bTEwLjQ4IDAtMy42NzItMy4yNzctLjEyMiA1Ljc2MyA1LjI5Mi0uMjM1LTEuNDk3LTIuMjUxem0tMTAuMTc4IDEwLjI4MyAzLjE4My0xLjU1NC0yLjc0OS0yLjE0Ny0uNDMzIDMuNzAxem02LjY5NS0xLjU1NCAzLjE5MiAxLjU1NC0uNDQzLTMuNzAxeiIvPjwvZz48cGF0aCBkPSJtMjAuMjQ0IDIzLjU5Ni0zLjE5Mi0xLjU1NC4yNTQgMi4wODEtLjAyOC44NzZ6bS05Ljg4NyAwIDIuOTY2IDEuNDAzLS4wMTktLjg3Ni4yMzUtMi4wODEtMy4xODMgMS41NTR6IiBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiLz48cGF0aCBkPSJtMTMuMzY5IDE4LjUyMS0yLjY1NS0uNzgxIDEuODc0LS44NTd6bTMuODUxIDAgLjc4MS0xLjYzOCAxLjg4My44NTctMi42NjUuNzgxeiIgZmlsbD0iIzIzMzQ0NyIgc3Ryb2tlPSIjMjMzNDQ3Ii8+PHBhdGggZD0ibTEwLjM1NyAyMy41OTYuNDUyLTMuODIzLTIuOTQ3LjA4NXptOS40MzUtMy44MjMuNDUyIDMuODIzIDIuNDk1LTMuNzM4em0yLjI0MS00LjIwOS01LjI5Mi4yMzUuNDkgMi43MjEuNzgyLTEuNjM4IDEuODgzLjg1N3ptLTExLjMxOCAyLjE3NSAxLjg4My0uODU3Ljc3MiAxLjYzOC40OTktMi43MjEtNS4zMDEtLjIzNXoiIGZpbGw9IiNjZDYxMTYiIHN0cm9rZT0iI2NkNjExNiIvPjxwYXRoIGQ9Im04LjU2NyAxNS41NjQgMi4yMjIgNC4zMzEtLjA3NS0yLjE1NnptMTEuMzI4IDIuMTc1LS4wOTQgMi4xNTYgMi4yMzItNC4zMzEtMi4xMzcgMi4xNzV6bS02LjAyNi0xLjk0LS40OTkgMi43MjEuNjIxIDMuMjExLjE0MS00LjIyOC0uMjY0LTEuNzA0em0yLjg3MiAwLS4yNTQgMS42OTUuMTEzIDQuMjM3LjYzMS0zLjIxMXoiIGZpbGw9IiNlNDc1MWYiIHN0cm9rZT0iI2U0NzUxZiIvPjxwYXRoIGQ9Im0xNy4yMyAxOC41Mi0uNjMxIDMuMjExLjQ1Mi4zMTEgMi43NS0yLjE0Ny4wOTQtMi4xNTZ6bS02LjUxNi0uNzgxLjA3NSAyLjE1NiAyLjc1IDIuMTQ3LjQ1Mi0uMzExLS42MjItMy4yMTF6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48cGF0aCBkPSJtMTcuMjc3IDI0Ljk5OS4wMjgtLjg3Ni0uMjM1LS4yMDdoLTMuNTVsLS4yMTcuMjA3LjAxOS44NzYtMi45NjYtMS40MDMgMS4wMzYuODQ4IDIuMSAxLjQ1OWgzLjYwNmwyLjEwOS0xLjQ1OSAxLjAzNi0uODQ4eiIgZmlsbD0iI2MwYWQ5ZSIgc3Ryb2tlPSIjYzBhZDllIi8+PHBhdGggZD0ibTE3LjA1MSAyMi4wNDItLjQ1Mi0uMzExaC0yLjYwOGwtLjQ1Mi4zMTEtLjIzNSAyLjA4MS4yMTctLjIwN2gzLjU1bC4yMzUuMjA3LS4yNTQtMi4wODF6IiBmaWxsPSIjMTYxNjE2IiBzdHJva2U9IiMxNjE2MTYiLz48cGF0aCBkPSJtMjYuNTA1IDExLjA1My44LTMuODQyLTEuMTk2LTMuNTY5LTkuMDU4IDYuNzIzIDMuNDg0IDIuOTQ3IDQuOTI1IDEuNDQxIDEuMDkyLTEuMjcxLS40NzEtLjMzOS43NTMtLjY4Ny0uNTg0LS40NTIuNzUzLS41NzQtLjQ5OS0uMzc3em0tMjMuMjExLTMuODQxLjggMy44NDItLjUwOC4zNzcuNzUzLjU3NC0uNTc0LjQ1Mi43NTMuNjg3LS40NzEuMzM5IDEuMDgzIDEuMjcxIDQuOTI1LTEuNDQxIDMuNDg0LTIuOTQ3LTkuMDU5LTYuNzIzeiIgZmlsbD0iIzc2M2QxNiIgc3Ryb2tlPSIjNzYzZDE2Ii8+PHBhdGggZD0ibTI1LjQ2IDE0Ljc1NC00LjkyNS0xLjQ0MSAxLjQ5NyAyLjI1MS0yLjIzMiA0LjMzMSAyLjkzOC0uMDM4aDQuMzc4bC0xLjY1Ny01LjEwNHptLTE1LjQwNS0xLjQ0MS00LjkyNSAxLjQ0MS0xLjYzOCA1LjEwNGg0LjM2OWwyLjkyOC4wMzgtMi4yMjItNC4zMzEgMS40ODgtMi4yNTF6bTYuNjg1IDIuNDg2LjMxMS01LjQzMyAxLjQzMS0zLjg3aC02LjM1NmwxLjQxMyAzLjg3LjMyOSA1LjQzMy4xMTMgMS43MTQuMDA5IDQuMjE5aDIuNjFsLjAxOS00LjIxOS4xMjItMS43MTR6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48L2c+PGNpcmNsZSBjeD0iMjMuNSIgY3k9IjIzLjUiIGZpbGw9IiMwMDAiIHI9IjYuNSIvPjxwYXRoIGQ9Im0yNy40NzMgMjUuNTQ1LTEuMzEgMS4zNjhjLS4wMjkuMDMtLjA2My4wNTMtLjEwMS4wN2EuMzEuMzEgMCAwIDEgLS4xMjEuMDI0aC02LjIwOWMtLjAzIDAtLjA1OS0uMDA4LS4wODMtLjAyNGEuMTUuMTUgMCAwIDEgLS4wNTYtLjA2NWMtLjAxMi0uMDI2LS4wMTUtLjA1Ni0uMDEtLjA4NHMuMDE4LS4wNTUuMDM5LS4wNzZsMS4zMTEtMS4zNjhjLjAyOC0uMDMuMDYzLS4wNTMuMTAxLS4wNjlhLjMxLjMxIDAgMCAxIC4xMjEtLjAyNWg2LjIwOGMuMDMgMCAuMDU5LjAwOC4wODMuMDI0YS4xNS4xNSAwIDAgMSAuMDU2LjA2NWMuMDEyLjAyNi4wMTUuMDU2LjAxLjA4NHMtLjAxOC4wNTUtLjAzOS4wNzZ6bS0xLjMxLTIuNzU2Yy0uMDI5LS4wMy0uMDYzLS4wNTMtLjEwMS0uMDdhLjMxLjMxIDAgMCAwIC0uMTIxLS4wMjRoLTYuMjA5Yy0uMDMgMC0uMDU5LjAwOC0uMDgzLjAyNHMtLjA0NC4wMzgtLjA1Ni4wNjUtLjAxNS4wNTYtLjAxLjA4NC4wMTguMDU1LjAzOS4wNzZsMS4zMTEgMS4zNjhjLjAyOC4wMy4wNjMuMDUzLjEwMS4wNjlhLjMxLjMxIDAgMCAwIC4xMjEuMDI1aDYuMjA4Yy4wMyAwIC4wNTktLjAwOC4wODMtLjAyNGEuMTUuMTUgMCAwIDAgLjA1Ni0uMDY1Yy4wMTItLjAyNi4wMTUtLjA1Ni4wMS0uMDg0cy0uMDE4LS4wNTUtLjAzOS0uMDc2em0tNi40MzEtLjk4M2g2LjIwOWEuMzEuMzEgMCAwIDAgLjEyMS0uMDI0Yy4wMzgtLjAxNi4wNzMtLjA0LjEwMS0uMDdsMS4zMS0xLjM2OGMuMDItLjAyMS4wMzQtLjA0Ny4wMzktLjA3NnMuMDAxLS4wNTgtLjAxLS4wODRhLjE1LjE1IDAgMCAwIC0uMDU2LS4wNjVjLS4wMjUtLjAxNi0uMDU0LS4wMjQtLjA4My0uMDI0aC02LjIwOGEuMzEuMzEgMCAwIDAgLS4xMjEuMDI1Yy0uMDM4LjAxNi0uMDcyLjA0LS4xMDEuMDY5bC0xLjMxIDEuMzY4Yy0uMDIuMDIxLS4wMzQuMDQ3LS4wMzkuMDc2cy0uMDAxLjA1OC4wMS4wODQuMDMxLjA0OS4wNTYuMDY1LjA1NC4wMjQuMDgzLjAyNHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";

//#endregion
//#region node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/wallet.js
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state$2, kind, f$7) {
	if (kind === "a" && !f$7) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state$2 === "function" ? receiver !== state$2 || !f$7 : !state$2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f$7 : kind === "a" ? f$7.call(receiver) : f$7 ? f$7.value : state$2.get(receiver);
};
var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state$2, value, kind, f$7) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f$7) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state$2 === "function" ? receiver !== state$2 || !f$7 : !state$2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f$7.call(receiver, value) : f$7 ? f$7.value = value : state$2.set(receiver, value), value;
};
var _SolflareMetaMaskWallet_instances, _SolflareMetaMaskWallet_listeners, _SolflareMetaMaskWallet_version, _SolflareMetaMaskWallet_name, _SolflareMetaMaskWallet_icon, _SolflareMetaMaskWallet_solflareMetaMask, _SolflareMetaMaskWallet_on, _SolflareMetaMaskWallet_emit, _SolflareMetaMaskWallet_off, _SolflareMetaMaskWallet_connect, _SolflareMetaMaskWallet_disconnect, _SolflareMetaMaskWallet_signAndSendTransaction, _SolflareMetaMaskWallet_signTransaction, _SolflareMetaMaskWallet_signMessage;
var SolflareMetaMaskWallet = class {
	constructor() {
		_SolflareMetaMaskWallet_instances.add(this);
		_SolflareMetaMaskWallet_listeners.set(this, {});
		_SolflareMetaMaskWallet_version.set(this, "1.0.0");
		_SolflareMetaMaskWallet_name.set(this, "MetaMask");
		_SolflareMetaMaskWallet_icon.set(this, icon);
		_SolflareMetaMaskWallet_solflareMetaMask.set(this, null);
		_SolflareMetaMaskWallet_on.set(this, (event, listener) => {
			__classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[event]?.push(listener) || (__classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[event] = [listener]);
			return () => __classPrivateFieldGet(this, _SolflareMetaMaskWallet_instances, "m", _SolflareMetaMaskWallet_off).call(this, event, listener);
		});
		_SolflareMetaMaskWallet_connect.set(this, async () => {
			if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f")) {
				let SolflareMetaMaskClass;
				try {
					SolflareMetaMaskClass = (await import("./esm-DOhWGRtP.js")).default;
				} catch (error) {
					throw new Error("Unable to load Solflare MetaMask SDK");
				}
				__classPrivateFieldSet(this, _SolflareMetaMaskWallet_solflareMetaMask, new SolflareMetaMaskClass(), "f");
				__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").on("standard_change", (properties) => __classPrivateFieldGet(this, _SolflareMetaMaskWallet_instances, "m", _SolflareMetaMaskWallet_emit).call(this, "change", properties));
			}
			if (!this.accounts.length) await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").connect();
			return { accounts: this.accounts };
		});
		_SolflareMetaMaskWallet_disconnect.set(this, async () => {
			if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f")) return;
			await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").disconnect();
		});
		_SolflareMetaMaskWallet_signAndSendTransaction.set(this, async (...inputs) => {
			if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f")) throw new WalletNotConnectedError();
			return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignAndSendTransaction(...inputs);
		});
		_SolflareMetaMaskWallet_signTransaction.set(this, async (...inputs) => {
			if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f")) throw new WalletNotConnectedError();
			return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignTransaction(...inputs);
		});
		_SolflareMetaMaskWallet_signMessage.set(this, async (...inputs) => {
			if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f")) throw new WalletNotConnectedError();
			return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignMessage(...inputs);
		});
	}
	get version() {
		return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_version, "f");
	}
	get name() {
		return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_name, "f");
	}
	get icon() {
		return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_icon, "f");
	}
	get chains() {
		return [
			SOLANA_MAINNET_CHAIN,
			SOLANA_DEVNET_CHAIN,
			SOLANA_TESTNET_CHAIN
		];
	}
	get features() {
		return {
			[StandardConnect]: {
				version: "1.0.0",
				connect: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_connect, "f")
			},
			[StandardDisconnect]: {
				version: "1.0.0",
				disconnect: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_disconnect, "f")
			},
			[StandardEvents]: {
				version: "1.0.0",
				on: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_on, "f")
			},
			[SolanaSignAndSendTransaction]: {
				version: "1.0.0",
				supportedTransactionVersions: ["legacy", 0],
				signAndSendTransaction: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signAndSendTransaction, "f")
			},
			[SolanaSignTransaction]: {
				version: "1.0.0",
				supportedTransactionVersions: ["legacy", 0],
				signTransaction: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signTransaction, "f")
			},
			[SolanaSignMessage]: {
				version: "1.0.0",
				signMessage: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signMessage, "f")
			}
		};
	}
	get accounts() {
		return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f") ? __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardAccounts : [];
	}
};
_SolflareMetaMaskWallet_listeners = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_version = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_name = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_icon = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_solflareMetaMask = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_on = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_connect = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_disconnect = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_signAndSendTransaction = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_signTransaction = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_signMessage = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_instances = /* @__PURE__ */ new WeakSet(), _SolflareMetaMaskWallet_emit = function _SolflareMetaMaskWallet_emit$1(event, ...args) {
	__classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[event]?.forEach((listener) => listener.apply(null, args));
}, _SolflareMetaMaskWallet_off = function _SolflareMetaMaskWallet_off$1(event, listener) {
	__classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[event] = __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[event]?.filter((existingListener) => listener !== existingListener);
};

//#endregion
//#region node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/detect.js
var registered = false;
function register() {
	if (registered) return;
	registerWallet(new SolflareMetaMaskWallet());
	registered = true;
}
/** @internal */
async function detectAndRegisterSolflareMetaMaskWallet() {
	const id = "solflare-detect-metamask";
	function postMessage() {
		window.postMessage({
			target: "metamask-contentscript",
			data: {
				name: "metamask-provider",
				data: {
					id,
					jsonrpc: "2.0",
					method: "wallet_getSnaps"
				}
			}
		}, window.location.origin);
	}
	function onMessage(event) {
		const message = event.data;
		if (message?.target === "metamask-inpage" && message.data?.name === "metamask-provider") if (message.data.data?.id === id) {
			window.removeEventListener("message", onMessage);
			if (!message.data.data.error) register();
		} else postMessage();
	}
	window.addEventListener("message", onMessage);
	window.setTimeout(() => window.removeEventListener("message", onMessage), 5e3);
	postMessage();
}

//#endregion
//#region node_modules/@solana/wallet-adapter-solflare/lib/esm/adapter.js
init_index_browser_esm();
const SolflareWalletName = "Solflare";
var SolflareWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = SolflareWalletName;
		this.url = "https://solflare.com";
		this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJTIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMjA1MGE7c3Ryb2tlOiNmZmVmNDY7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLXdpZHRoOi41cHg7fS5jbHMtMntmaWxsOiNmZmVmNDY7fTwvc3R5bGU+PC9kZWZzPjxyZWN0IGNsYXNzPSJjbHMtMiIgeD0iMCIgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiByeD0iMTIiIHJ5PSIxMiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTI0LjIzLDI2LjQybDIuNDYtMi4zOCw0LjU5LDEuNWMzLjAxLDEsNC41MSwyLjg0LDQuNTEsNS40MywwLDEuOTYtLjc1LDMuMjYtMi4yNSw0LjkzbC0uNDYuNS4xNy0xLjE3Yy42Ny00LjI2LS41OC02LjA5LTQuNzItNy40M2wtNC4zLTEuMzhoMFpNMTguMDUsMTEuODVsMTIuNTIsNC4xNy0yLjcxLDIuNTktNi41MS0yLjE3Yy0yLjI1LS43NS0zLjAxLTEuOTYtMy4zLTQuNTF2LS4wOGgwWk0xNy4zLDMzLjA2bDIuODQtMi43MSw1LjM0LDEuNzVjMi44LjkyLDMuNzYsMi4xMywzLjQ2LDUuMThsLTExLjY1LTQuMjJoMFpNMTMuNzEsMjAuOTVjMC0uNzkuNDItMS41NCwxLjEzLTIuMTcuNzUsMS4wOSwyLjA1LDIuMDUsNC4wOSwyLjcxbDQuNDIsMS40Ni0yLjQ2LDIuMzgtNC4zNC0xLjQyYy0yLS42Ny0yLjg0LTEuNjctMi44NC0yLjk2TTI2LjgyLDQyLjg3YzkuMTgtNi4wOSwxNC4xMS0xMC4yMywxNC4xMS0xNS4zMiwwLTMuMzgtMi01LjI2LTYuNDMtNi43MmwtMy4zNC0xLjEzLDkuMTQtOC43Ny0xLjg0LTEuOTYtMi43MSwyLjM4LTEyLjgxLTQuMjJjLTMuOTcsMS4yOS04Ljk3LDUuMDktOC45Nyw4Ljg5LDAsLjQyLjA0LjgzLjE3LDEuMjktMy4zLDEuODgtNC42MywzLjYzLTQuNjMsNS44LDAsMi4wNSwxLjA5LDQuMDksNC41NSw1LjIybDIuNzUuOTItOS41Miw5LjE0LDEuODQsMS45NiwyLjk2LTIuNzEsMTQuNzMsNS4yMmgwWiIvPjwvc3ZnPg==";
		this.supportedTransactionVersions = new Set(["legacy", 0]);
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._accountChanged = (newPublicKey) => {
			if (!newPublicKey) return;
			const publicKey = this._publicKey;
			if (!publicKey) return;
			try {
				newPublicKey = new PublicKey(newPublicKey.toBytes());
			} catch (error) {
				this.emit("error", new WalletPublicKeyError(error?.message, error));
				return;
			}
			if (publicKey.equals(newPublicKey)) return;
			this._publicKey = newPublicKey;
			this.emit("connect", newPublicKey);
		};
		this._connecting = false;
		this._publicKey = null;
		this._wallet = null;
		this._config = config;
		if (this._readyState !== WalletReadyState.Unsupported) {
			scopePollingDetectionStrategy(() => {
				if (window.solflare?.isSolflare || window.SolflareApp) {
					this._readyState = WalletReadyState.Installed;
					this.emit("readyStateChange", this._readyState);
					return true;
				}
				return false;
			});
			detectAndRegisterSolflareMetaMaskWallet();
		}
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.connected;
	}
	get readyState() {
		return this._readyState;
	}
	async autoConnect() {
		if (!(this.readyState === WalletReadyState.Loadable && isIosAndRedirectable())) await this.connect();
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			if (this.readyState === WalletReadyState.Loadable && isIosAndRedirectable()) {
				const url = encodeURIComponent(window.location.href);
				const ref$1 = encodeURIComponent(window.location.origin);
				window.location.href = `https://solflare.com/ul/v1/browse/${url}?ref=${ref$1}`;
				return;
			}
			let SolflareClass;
			try {
				SolflareClass = (await import("./esm-DE9kx8Tj.js")).default;
			} catch (error) {
				throw new WalletLoadError(error?.message, error);
			}
			let wallet;
			try {
				wallet = new SolflareClass({ network: this._config.network });
			} catch (error) {
				throw new WalletConfigError(error?.message, error);
			}
			this._connecting = true;
			if (!wallet.connected) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletConnectionError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			wallet.on("accountChanged", this._accountChanged);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			wallet.off("accountChanged", this._accountChanged);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				if (isVersionedTransaction(transaction)) signers?.length && transaction.sign(signers);
				else {
					transaction = await this.prepareTransaction(transaction, connection, sendOptions);
					signers?.length && transaction.partialSign(...signers);
				}
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				return await wallet.signAndSendTransaction(transaction, sendOptions);
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signMessage(message, "utf8");
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-solong/lib/esm/adapter.js
init_index_browser_esm();
const SolongWalletName = "Solong";
var SolongWalletAdapter = class extends BaseSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = SolongWalletName;
		this.url = "https://solongwallet.io";
		this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAGlklEQVR4Ae3bA5DsyhfH8TNr49r2/du2bdu2bdu2zcdNrm3b9toz533rvctUn3Umk9p01WfdvVW/6nROBxJVS1rSkpa0pCUtaUlLWtKSpl4VXos3GJ4sujQFuUKfWl+qT730arzB8Ex9YksKcgXjFOCVeIPhBYydB8mawQ+yiGC8n0EN6zAVcgXhpQjoq1DDdsyDAAB9Pwo1HMC9INk0FIM8Bt1Qh9WohQQCvD+BtEMdtmC8I7y5aIE67MV0SBwDvB3qsE/UHwMJIpC/QB1OYiLEEeCPoQ7nMRcSwwDrao3Zl8aTIEGEUYlL0IAMXuQOr66UvsegDm+ExDJAPNiafSg0AlyIbmjAWX1aQzEkiH6T0QkNaEdpnAN8NNRhPcSF9e9el2ebBhyAuNBvGtLQgIuQOAd4D6jDMRQbM3AmOqEBDfq0xjJIEP3GohkakEFVjAP0y401sAsLnAE+pb6EsC5AA9J4sHsG+kX0PQR1eFJ8AwTWQh0+DjFm4a1Qh2/AOoz/BHX4ZdwD/CDU4aioX2GUMW+AOnB2bqiBBDHe86EOTYw5GRKJwQ/ijUM91OGTxgysxSmowzeNw7j08m5DHX4l7Igg2TY0g9hbLBZ+f7oxC98CdWjDvYzD+MVQh07GfEQsZyDgVWA71OGvorfnQQCAcqaYUFZDHW6j/itAoB70GcergzqsEa0rhGTTEA7mP0koK4xdyeOMmvBBhJU2zsjPMw7lu9O3zShpXheHk4hhcZ4w26AOG4RSxDiUfwZ12KdPqy+FBDHeV6EOZxizIg6HsMGbiQ5jdjzBXRfeefGg3tgbv9BYC0fhZE7sjUMY9Pf9rdcI5XtQh39BjBA/C3VYnM0zcgiDek+GOhzh93mQoMs7kIxze/eMhnxIEOPNM9bcFtTEeAb6I419axu/m2CsgxU4Aw1A/UxIUM/bO/9+cVkDDd5x42x8N1iH8Taow0NhHcZLoQ5Pi/MMzDMW+DTu7g6vIY9AdkAdHmaUMyn6roA6PD22AeLB6DbWplHG7LubfY+kfiIkiH5T0AJ1uFtMA1xUzOc1UIclzvCeXF+o7DygDlvds29RgVVzYj+K4xhgEX4NdcjgecE++rSL+ZdLmIxRB77Ose7l4XPIQB3eF8M60C/n8++ghltE/QLIFfqUiyUE8kOoYSW7jmLIFXeN4X0NaajDDlG/NG6XswrxKdxu+G/weh27j3wCej9uN9zEOjc3sObl4S243XBLhDfWE0mAMQjwZfhxDng7pG/8Sj4/ER/Gd/BdfBhPRGW2A/wxNAfcBOnFCHwZZ6GGs/gqapMAb/QEnIT20Uk8IQkQeB7aof3UihcM9wDvhyboANHXv1+IdWBOB2hsIftto+iSPEif8aGPcjrA50GHyPMiOIT9B/N5apaMgQT8D2poxMdwt8s+hkao4X9ZDxBTIdHwy/h8AeqQxhMhAU9BB9ThPMqHTYCYjU6owy3uPstSfL4Z6uZPC+Mk8gOomz8DEg3vXshAHb4MMXwZarhXGDPwa739w2j48623BPAniOFPUMPsMAL8INTw9AgDrLZOCmjFPEjA3WD1aUJVGAG+CGr4ECRCy6GGg3iyaF0+n/PwFByEGpaJ+qkw1sB7QA3/hUTozdBetFymvXhTWGVMOc7bp36/FhKRamNW9dcxZmpZiI+32ad+vAQSoWejGzpAXXh22Fek3wY1rDD2kVnijR3ExYQMPgkJOUB/nFW0Is3vnw6JhlHX9a4N70Iq/ACBv0MNu7J9WxHw7jaA2deFOtw32zeVHtHLWvMN0dtSkOzwS3spYy7iH1hx2d/wYdyTvnkR3BdeQjjerVBDN14JyZIfQWH5RC7e1rw32npZV54LCc+SPD5/HgqYD3WW5+gTqt6X+rA4v0701hRkKF0+bL+HTM9Hgv/MHH60wyvHWigsafwA1ZAhMguLoL34kbDcQEI1uAH8mcbuxPHImf8i5EMGxqvER9EI7cUqVMTl0Y6HoxHaBzvxNkyC9EEe7oEv4Sy0D/YQ+IS4ver1JNT38z7sWnwbb8TT8Cg8Gs/Gu/Ar7EEXtI/2ud7Ni0GAYCbiJDQiazA57k9nTcdqaJb9UtSvitXbmjavCJ9AMzRkJ/B80boUJBLhDe7Nw1/QCR1i9fgKRg6HByzvjZ/hInQQMjiCT2PSMHxC1a/l8wvwGxyG9kEaW/EtPI4xiiE5JcLrd6PxcLwM78SH8EG8Fc/H/UUXVUByGh8SSYBJgEmASYCJJMAkwBi6A3xCqZhiBz8+AAAAAElFTkSuQmCC";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.solong) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.currentAccount;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.solong;
			let account;
			try {
				account = await wallet.selectAccount();
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(account);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		if (this._wallet) {
			this._wallet = null;
			this._publicKey = null;
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-spot/lib/esm/adapter.js
init_index_browser_esm();
const SpotWalletName = "Spot";
var SpotWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = SpotWalletName;
		this.url = "https://spot-wallet.com";
		this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFYAAABWCAYAAABVVmH3AAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAVqADAAQAAAABAAAAVgAAAAA6XCzdAAAmhUlEQVR4Aa2dC8xmR3nf57yX79tdr9d3e218JQRwguKAcGMVtw0tqtQgimhap4oUxQ1JS6kaqZIVpVJFBVJviKYlEa6KQgIFkcShTiOD6AVCiG3VsY3bdc1N0GKvCWvA1/Xuer/L+779//7PPOfM++77re0kA/PNzDPPzJn5nec8Z86c86678qcIf2exGP+XY+WG2U65sXTltYtSrlE3lyteXBbloNKD3bxMu65MulkZS1bG81I60lnkRzV1ebeUicoj6UzJK1ouGeVxldFmgzxtV9Js4zrVU57MFrUfpeo7jk1+oWMtZpOy2O3mi51JmZ0YL7rny2L21HgxOzYu3WOjbvE1jeeBS99y3pFbbtEsXmboXo7+9NuLm2az8m7xeZvanb9nWykAc6REgCOvMnlPsE4SUBPlDbmCCiADOJepU1wCuwO4kAMs25FyjCivgBXQMbAXgJ0r5WQq1WDHi7lOPDLVqTwqtVwWz467xV2j8eL2X/gPh+/bc84rFS8J7OTbizfP5uV9Ot7NK+3XFwGrMCIFqCdQwSoPCEMGiGKCnSq/CsmAKljqsNi04N5ya30PGrAARJ5WK6gTwHIiBVMWa4gABWxn0JIvQzVgQ7Z8cc+0K+/52Q9f+QVP8Cx/zgr23G8vLjo5Lx/QSbz1LH2srxJAoKbV9nAlM0xNEFBEW64hBDQA2/KUTtMylSZY1yXM2i5PADrT3QAYfSgvGZc/YA3UECMvdyADmAVYDRmII8EmHWO1PeiwYkPuuo8e2hjf9rc+dOVT6ycf815bt3F08boTu+UhHePWtQovUQhfQpv2eZ1W8dXga1DG+SqwXl+ZSstpVpNm5GBcEZ0sImRKax6LTL3ID3VAXI70mfXZzifi1pPbWw/99ru++brl0QwlDOqMMHl88eM783KvKq52ZZI4Q/NFBMygDTkjpQsidVVGmZDyPGSm1GH14uOG5N2ElLNDqsgN0FdJ1bderQMuHYyATGqQ+FLy9Ic8rRSQRMphwekSkMudXD3fWdz7Wz//jR9X0zPCGWCxVN2gfl+ah5a0NaY/TaCZoQEy4SGjM8qKulJdN0eHvKLrSM8WrBiq+HMgurXzQBLkCtLgnEe/wlW6BNgA5ToMM6C6PXo1+mRU+F2ZHRrNZ79/5zu/coblLoHFp+7Mymc0umWoOTkPPAsvklaIaCVQDIuQAIFnGUCr/tJJqHIOu+7QrTVaQUpYb0Ju69NKDai3VgGT3zVodbAMcfC1fT3A7X8TOtY8OzQvi8/c+Y++epEnV/8sgT25U/6t5FfnIFvFPr9uhn3lS8gAkKgj05XWugFVKcCpQ94eps2rypUtNJTdVMD61DKVkSnaBahpWDD6A6R0Cb5xqTOD7AHiJsIVtIB9oqRLW938rh6d3vmAx1b/DGAfXbxZh//ZtpIBrw17ydcqV1AJrQGHddp6kVFPIM1owfKfrEp1ai3jjq98WitpQvTkDQALC1BO7Y+RYZ0BKfKABHCkkTdAQw6rzTpSn6RbP/1z//vNOdoBrNap9cRmXaR7QdxLvtw6Zt3I8tJv3QFk6M6gldpyKdeIVWfAUrOCfIBk0jqUOg8LXU2pB1TAHkBW0Krr/aotNWClpcYJCt3BFXAiKlROgtrpbvG+HGeA/dbiJtXdnEIAL4XVclbuJc/6Bkj6Ts8OuWJaKd2Q73VWymccpvbrblSZsNtywKBOkwcqEatWOay1gjFIoEcZwLZAl0N/pNvrcDJqO8kMVv3Gutfpzf/j5790E9MPsIvybgpt+HOD23Za8y2oHih1CVfZVqc2W0oSJkIDJTVAytkaYFEmHVzCmTLaAI+Quu7PfQVM6lMv3UOckGhLfjbfNUvVL3ii49k/ZsOY6rjWws0xu0H9s07W1tcuU43UUTPoZTXfy5ld6kW2/2uotdTDBKpk4R6wHi57rBUZ5QpHCrZgLLO31rBS5GmxUQfI0HMf5G2p9EU/UbaO6/S0Nl+8bXHHYjwp3yw3qHVsqNTJeMzMkMmSkl1TFzX1b9VfkmWBtrUfiyjTd43kU97LqqhPUkf9kA2AkZJ3bHxsQiVlY4Vo66rugMs4/KrgGVCFmyArKNqHVVbIPdCw0tZyw8Ln59/92ftumKjVjUuTzpkw+gYWgF8SXNonhOyrpkADgOFlnWSUc3WQ4gRM2gfGo2CIZIAlGc//YaFYabVI6iTvLVp3ttDD2gJ2AuutNGFmaqgAjzaG2J+EFbAcV3pY76IsbmQP4rWKy4HJIMuUWuXV1qEHnO3ayaORbck3fSAGVA+XPqss4c7l9XPFsIg7AL30wYdSI8PNVLVRFgTJAq5S9U4XeZNhJysuX2BhgboB9aBC1pdX5ByXzZqEFydF/UuPfJadX8xfO1H/16rNEgCX2z/0CgHPSlkmVPNWa+r6ZikjbUPTV2+V1Lf9kV8pZ3fZVfhNqWGZquxhYjmOQMQFhHX2Mk049lyXIQf8FbjSzZOS4OKERN+dDtyCDsCALtdONNDDYTZ1MkyohZHlTOvMUqUHvDpz9FKJfG3fq3ED1pZf0XagDKeMlD8g2T4pHFDcP1ZeVRtqN1V+U1GzKHPpL7QtuNhWWSltO+25JmD8ZUAfAOcNCCi2WoABnHKVoWOXILlh+iYVAAMmEKmLy90pJ1CyANpa7fwwFnuxhthP3Pl15awAEKESUt+D9SIjpE6Uhr/UA3FLp3Rayht15B8+V2dWp/dygTsHiFLhbBMzv5qy878lwCdOdeX/PbYof3zvonz/cU1MJ8a7W7bYeoevVmsoPYi6BtUk4tJnnZp54PE+KU6QYSvPhNs+EvASVGBYb3FxV76yOKZeD0syAEkwL5Y2bXrLdUdNX5Qr0OkLpbxFWxXvuERgIdcEDnU2mMBtAbd5jPnUC4vyrW8syh/9993yJ0d3y4ZgbMgnsrk9mSsljzUqDStt0/S1wAs/mv40rDSsEpjpU9NSB8DCx9WCTrd4oitfXjyvcR2UJAJp5pG05ZTvlaKeddlWUDtZ6Os3S/nFq0q5Agp7hL3AJtSEuaH2mSdt73ELWc2xb87LXf/phfLMk7vSm5WpJgzUyWJ3CSqwDVJ1aZlhlVhtxrBUuxdB8w3PKXKVdbzBagOsrqgTWOxp1WvaNSQY0nV51F5E3sPVFTSRlf7Dq/X2UZf8iwUA7QWxla/mczht/3NZ6tH7t8tnP3mizE4LMK+LsVYAc6nbctNSB7DIY8EfQMMX5yUOOHQrTEMdrLmH3HVbXfd/dCvopLs6uiyTtnlG35bbfM5MMvzdfkH9Z68q5UbuQi8h0FVaLVZJPq1zNQVu6ii7Z9g5OSuf/ZWnyrHHtnQjBEpADbhhlcjOsFRbMQBDJ60y9AbQZ1qtrXgGWLQiaGYsgZYC5ZS1aZunQaPn5c/pUt77A6X82MuACqiMq1YJZLwIMYGjexbPotoIeoVSHvzN75cv33dCcAVWEddgoL0bqHABKZn9aQM1AKZ11rR1A21eALruSAXbgGE4BpzwELT1KV8js0hLoXe9Qjep82i4d8A7XKhICkgC7RNgLO7DhyKnnIfEGjKv7NmDlBdyDY//t6fL3Xc8WTb0Wji+JBlcAZbYL8V6oAPksNgKvIWYeV0NMR6lOh5PXjFC0sxXEeUecNYzhXZGTRuqdFWVH5EpvWP9yx2r4NCvVTygeFLt79Ya9qunSnlct9GnT2qtqpudv4hRX/vlUja1TiUeVoPrdLKu1pm47lBXLuVq6B268utCHXenQV/91y8qbzq1XR749FO2Wix3WAVgwYAbYuwhhD9NKzZgWTQI0OUhARlPTXETjXKAXTegKqODDL2bqIN1742CXYCg/ONXqUUjz/akWKgWBwb6S8dKueNegRQ8P4pK7m8ABDQ/NdrQZRxRbkJXwsaWIGsNO92aaSmzKO/4K6PyN//yuBzUNlK3CjnH2aTXvO1wee7xk+XokeOGGzenAWb4UMANNy+7AZWXQDPZaq081RHSqpl61z3kWlf4TwLJFKE1Q6W34CgOddLpZHl/VV9u/fI1WbmcXqDitYpHBPLvfb6U7z2nscm6u3MEVr5gLB8w0Rj5oAOwmwK5ub0o+08LpvL7tFbdOKWo8lTp4oTSLX0ktj0vN71mVP7+uzbL5sGwG4xor7jQSfmf/+LL5fknTpapnih6q8VabY3Veis438AyXy00LLdaM9B9MHBEvuu+tAJW43FoYBoswka2DvBY1vrBHyrlNdxVVgKi6xW/Kqh/41N6GtVlvLhcsfrh/DpmU0AnssgNRaDuU5+A3SdLPaD0gODuF8wDp+eSa2kkwDP5k23FiQD/wk9ulje8fb+GqsHqWHvBnT1zuvzBLz8kf7sjy8UvhoXiDtIyfakDiptZAk3ACVApFk0IuOhLhkWzNHJdnmW0yKc805SpTJuM6JK/THNZB5XurlUUk/Izf6DtAcHcfbUOgQmrjf6/FDiMB+CKKOUa0Zcq315pskA4qO+ILtu/U645d6ucLx/xiU+dKHe+/2nfrOz0aK6xLc1PsvH5G+WGn7iEDy9009rVzUZrXR4g6vo2l2Vjye17gUtkuaYO2+gxSeYx1XElbFHWBDPmQOr8esjIs64ZMO3YUHmjHldhsQpKV3oh/pvvl3JMy7DZdSpw61c7msYfMsq2gihIWn1eBcoGRzxJ6e6ux1WAnNPtlKv3n1Z8oTz48AvlI7f9ScCtx1kat+BpJ6dc8teuLBN95RZ9xI0MwPH4C1DWvDxQAF7HcgQqcKkbIm1SHieAiawCkygt2VbpyTLrGlO/SfGvr2uWVy1cDFNXdfn43eJ/TeWoslZA/YmCIceU55RQQQLKHqTyXgpVqxmnlWkyPKYSp3MsbqdcNDldXn3gRHniia3yxV/5jlY16oS1HN2qXZFOxN3S7V+U173jGu2OAWiwWEAmJD9ICFBY6gASfXTsnz0ulm6UpevVBgdcjQks5SrnZU8ag2zSKrtixbem9bJOfVg6L+jOvdDqXuNw7K2otk+4XPYxJsEVfcNV6lcshiorVRowA+qGYGC5U6WHtDnxQ/ueK/c/cLx859O6TLifsdxIqD6wZLq2Dt58WZlqj3JUQSVQ0oAaMG2RaZUAzJOcIAUGvwrYXA8PFssE6ySX4CXgmqYVYwxEt9G4L+WRaE1gufk1uYA5pksbHcPtap4m9qGCx0Ke/gJm+C1/z8qkvEslC5V12lKxUsUNAZvOt8uGNmuJ5A9ob/L6zWfLb33su2Whx1ptFugoSh3ylOu4k1G54scuFwxAcsnLEskDWjGviP6yxwXUpzevgwXYT3FOq0VrAnVtUo8HJGICznRVtqJnwBrzecu9uVNcHNN4VA8ABFt89qsU69U4HTmu+6pw850V68T0e1NN2pYpmABdikX7AYst7SiF/DztAL1q85nyyG98Sx1rFFN8AqMhDHDPf/0VPpH2ocAELgB1LF/qFSSXuG9kGmje0Hp3IP3Y+eJ+AFgmmaDa1AevdeisRk5+tlUKsInGmsPN4QOW8IzWoUDUmMNwlOKXbUS8Aeijrloue31Cji+dyP9NZpqs0qnSqX74kJa5Kevc1KsEYBqo8lGWrES8anKifOmPvlfmz+lgkzzNOboY7eQH9Jgoo5iov7DQcAM89sYNC6CRT8uNfd2Qx6qAExFuAAuOVUECasEiy9jK2zz1AFacIl8JDDuN+IVqlZwA3B1fcYelAlWKmjeykV63dLsaIGCVTpRODTXAbgBWcXMmy9QlT9xX4xLUCnkqwD+48XR57sGn1LlG1DGiABrD1YpXbuLiH71SYxUcrJJIniirteXWNOWsTKI+YdY3FpKHxSaohLiaUp+yvXQl54lpXWAKBPGp4FRIS1U61k16pMdW3nmNlQJzzKfuyk92ZSX6rnSqdGM3gBqqNhNsrfPTSskr4gLaaLewrZvZdrlYVvvIXY8yDA20BZuj68o51x8OiHYDemioPjZWAyy5ADlE7gF5k0In3YBdh8pYrU9gHsIHb/8IGE9Zrt8DHupaRp412HcCtAl+QlHZ76l0+fPefyKoE8GdAlRxY0c3px1BFdhNxX27stBZxLBWyXQJ75O/3RSMWB1wQ6mXribpy/KYll56cuumAquTFmGY9eTwIVssAD1W+0fmrTb9mIFBOdtHfVZ7q6JWxSYM+lm7Rzp03ig0QrJNsVEKOb9WsU+tegw+vwGwexBUllCGWsFubAfYTcHdFFzAbgK1gQvkzXoT26wPC7yOiQU7l2csjS4ZH9fegtauF7Y3MIYZox5fcMD+FP2QBJGEmPNDCkAvCWtz5uKQqQqcoKUQnQ6i1fJQM+R80BexWLS53HMQtlYNBGudANQ3rGqtgFXcBOyWoG7LIok7Ferulqx2q+wHMtZaLXbDFhuXITcdL9l01kaKh3Tw+fHtMrpoFWzMo9P79Q4/qnYmq7EtW6vKhqEK19X5K9+aZfKahNlXpdXEjZaFhihRdpCmnjepZe1BD4C4C1/29KvoDyoMNFYCUzniDQHdkE/dlBvY3N4VTEXB3bctiNsCqrgpsI7cvOwCcANyF/KPLMfyxpILdu5ZY1HZfWarTF7Jw3U/+mG4G2NBZZkVlhYQGecAwUaRlpG9uDp1hn4NduidjpZKg4UtddTopP6K5TcaznK5s2vllQB+SmX/mE3t+ZHbRkYslQhYRcBisQEZq90p++UKsNa4cQmoLDafunADeZPBtxJteVoNzPkYgdBTi6L/ij5LKHayMqRaugOfkJxvr4RAKwvLh7YTJticBKub+2oH2RFp1inFUmV0AazVWcn7XgxYHSx+aqlUDblhGSowZbGGaovFr0YE7n7cQHUFmwK7AVhFL78E1k9fguqnIMMFKksfpg3ckVdblPYKI7mLEZdUzk+6CTfaeDMyslUnegPAcq8T+ulD32EvaQ4iWXZGP02epRY/r2xDHsdAVeFfDmpPlWWkgcqV+WMKWapdgFPeDgAYS424fxeoslSlEQMoKwLghrXKYnUZx0oglkT4VVsrY2WwXr+2Izwz36mNY1+lWdC0LzeZvYTSJ/SrApeqkLzBrSnTn8eJEgclKut1KHXIFTJl+4DnnX26/Kd6+sICOJn8WJgfKA9Q5wKny98xLNf+VUA3HVkRyDIz1t2siXxrQOVRFP/K8qpCZRyeiI6ZA5VsrxAno7U0aXoiOZthXtlHdJ/1FYYqeWrrLRHlOo6llGYpT5i2XsBXuJqPAeYh3EbV+RCJPx0LLFbkfLXQaVpqdQX7lAI4rBPQAqtHWcp+KFCeuz9bhN7dsqVqQV9vPN4Y0WDj8ldaB9RvR2pMa4P0eGJiod836hWjk/bvchUgFPqXgoDVhA2t1tVxWJbyHmpzMt2OziTjcl9okyUh0kdGZNSzwzWRKyCfLsBrVvlY+9XevwosrgDLFUTXsYOVj7Veq+rhQXBjs0R+UYPwpoigBBwuaR1Lg8j5cHOvU9QI9ghcSkzMofrTvlH2RGWbD+1oMsgnPJ870IEiEwckxQSbI2JBb52aUm8dxqIbU+4a0n3GBHuBNhNwBXyewyog44aetLhp7TNYYNZosJHfAKbkpLHLVe/8osX7Kj8EkCqydsVa+xuXB8h4ZLPDvDXCM4NPSn/TqcqeK3kyQxIzRBB6cWVIpx4kwAKobUS5yhKmx5dypViqdZCR181L63y99awnpx6SfolXard7Qy8G8XVsrHiJpct+Q3mvXQHbRlyDQG5w6avjaYWa61Tf/StIQ8RCgKr+e6vVccMSlMT8LXGeOawE37gAazgo1EaePMoq9+2yvhdEfdW1K0hlZG1Ebr118gRLqsi8jgvuZXqLwHCItn6lHPq6g3q3pLerYwnj9TarAcGuMA3YeWCGdfL0NZVVxjup+nSm3niwWPKh6tPjroONOh00J6ZcjgmpA4IMDJDQTtYtmLgUs96ZtidV9HXIs6C5AqTtz8ejHmAcSyn6HnibIgcoMqVsBT4rP8vrmTw0YImsxF6Dxer19EgNuGHFQwGXuNaxtk6sNy955auVYqnsIfg9lw4IVKzebxxINTg2xH0gJaTIcpJwQfesN68cMBMxDDWnj7Rc6h3cmXJKOQShB4+gKmIMAOnHoboeII3qcXysJm8LRRdZjSy3vvusXijqvVYC5TDked65SJlrL9K3q98VWIHCHdhKAah8+NCQBcwAyj5C/pzIT1KA1YB9QtUvx/B0GAdQc8KSO0g/IK1W1PomCU1OVg19Z/Uo7os6aVqJP+SVunv+uEInH4tVxHKJgPZGtEABK2PK8t9jIc06/xMhKh85EjewvGGREvW6S8fuyj/9mWmZ8hWLXtmyH8A/MbKhBwHy6WsDMpd9+GFbquFitdUNCKLnwzyIlDMy+ZRnquqYOJmzBTUQTN7stk37g6QVAdzQU4uzSkSuVGd9lEATqkEntIStMhvSCRCgLiNTJA/4B+9Xx5pYAs2Ucwjc1x/WB8h/aeJPglgN4AISJJvZWKpXAIYqsLoZ9daqfn35e07k1SGx/+2SHIDyRF/C1BEADXQlHQ5+ryCXZCX0rRywDFkHwyvYM9ggWx06VpNWrgPyeNzv7KcFJmSs0pZZAWd9As56Q9bAXhC9hx9XGx1nNQKWhdAv3jIuP3h4ZLiGab8qwIJpFwHUGvMdkm9WGj9YgGtQyhssiWeNQEHVwQYSlCMF+OiC/VZZ+0cnuTaI6oRlK1RH1Vqx5YQcKQehLScCPWUVB4uVPK3Xl326BKBWwMiBmoAHuaxUVruh3ZXfuQMfGGAzNWQdU17A23f/7r37y0+99Rw9ickitTfgF4aCyevt/tLXYt+vPmS18SpcjeUKcuwxF1koswtzMUTKEWOuBi2op6fnl/E1+mJPc1gXZs9ty13pGA5K03Lj7Eha6zwAIFaQS6DRkVyRx+MlcAmVdaktV6ktFNAVcAJdtVw2Y77+9VK+8ugyXG40+VCjvWsNqis/+bc3yq/96iXlLX/xUPXpGozcA98Q8G9g1fEpFaiZVqZK5/rZ4kxxt42zUdlReWc2VtSzmNLdXaU17ig9ObmwHPzgbfqGQCdBc1gXtr+jj3Mru75+tbxOoQctZeX95Y0O0131qzo1TJxO6knIkwEMP4jQhroaE1LUy4okZ1PFcj1dXbCxKB/5wEg/gmOPM/pwqkP0VqwMN1MCA5jp9wo7x+dl59Rc+6bqUP0JqdqTSld5+1hS5E5DbuuqfVnZnUpPLw67Q5ulu3yfVgxSACqRua6Exz98b7ni4d+THpNVZfaHXptfardXRbuOBRoQ6Fd5UoNGXmNfl2Xu0ugSZYkjwdA/V1eeeqaUD//mvPyTn9MeqC5N2gE0oZLSp4PGxophos2EiT712W/vXOv+PJI6D72sjauAPuGBvIbF89vl6fv/uLxC33K18h5o6p7BMSuyp1TQOhYgrTX3QNXGKwRSReslUGSC6jcAtHceyJKp7hztB/7Xz5Xyykt1yf8EW8wD2MznUDwRtVmaEOV1YS85uuvq1smy3wbu0Tu+XK4ayRrQb+RWTVYUXJ+dqqKtc33Wab6CM7MvxeJ0mfRrWuXTEr0yoCwdfDDv/fubmKyUR1Tvr9Z0qhEc3JiX//ix7fKpO3ndwaWr9oqrY2E8a6G44s/4Z+3Bmj5Vf+qB75ajX7yvXDA+FVdRsiHN2DeRoJdlpkk5nqIuwBmrgl1g2TqV+sZkQACM2Mq43AEckGWh1tWNx6nKgo4l75fpnyu4H/3t0+Xff3C7bOmr4z3B9gOvk2nLf9b8WeDOjp0q99z+ufLqze/pKKFoFwUrQjLDbaXMFU1dlp3WBt1iF7A7aaW+tNUJkHrQQESm6H8i1ADRqVB1B6eOZ39/FiTrzCXTOTLlQ4qfv2e7vPMfHC//6/5dLeBXRrhSXBrnyymcBeC6bk7e+0T53C/dWa7UT4kvHfGrVwUv3TR3zae/B1RWAXnlIFkXrdu/O931710cUyeH7UfVIR1kxwBL/+t/naKW7UuBzyVe/SswuYNzclh/+oMJUslniqe2dIfWIvzKS0blnX/3QPmRv6DHW36IsQp2tdwO92x16J2tvtbN9Qr8sU8+Ur5+98PlgunJ8sbNo97UscF6suqHlCCOZ/xjFLD1jcga8QdZw1w34ye6H/7ni28I5Kt8hgSFNgarNC3Vn1NSV+uBiU7AzLRaqtr5QzLB5JHU76EMeFZO7XZlW2vSkQAD/PpXTsrNb9xXrnrFpJx3mVYEh0ZlrLXmSDvmfKjmsXqOLLEUnI+58JdlVxuSR8q4OhZ6CJk/u1VeOPp8+c79j5ZvPfRNbV3Oy1XTZ8pr5ALYg+2hcBBDU78VlI0YH5YBuePysUMWSvKx32B360nN22AZGPAYL5aXgEkDsiyUY6psqMjV2FaLtdpiI/WXLerQj6WCyKuTC+UWOnW0pVGw+vm/j+2Uo4+ekO/V46xftdQ3BHo84ifxU8n9WaXK/hW3FqGctHxpyIcZ+fLQbxE0cL+iMWGNVQP1ulRy1syUL5xslesmT5ZLxic0T+BAiUlFQtbK1EnmrjRPA04dqVjQWi7tCOiU7ik2uo/Zn9KPOki45L04R6bIzhJ1RLb86JP63hUIMDr+WEIg/R5KEHoZ9dLHRZyjHW5ALgRZTex32fVnogEOoAGZN7D5LVa+4naZR15FwPqYau9jKmUtrc5Crsnt00+Ozh2dLpeNny/ndqfNjel7A8dwKjESPeEFBKV0Q1/6v5O8+yInpC7tCMiJo3KMt7SPGSgggVg74fJ3GblkRD4OTtiGWmEmYFsvsNV7As5Jx3M/EIAXEPjB8FTPzlMtO/LzoPj+ijexfIQRcuoiH1+8WBeZwQb4gEy/vGTkFQ3zU1mTw2pjH4BZQ0EpUJgUIocqd6I/nHFAYqo+UUrEgua933VbNxi6oMmiPMYDwtcMs4LlQD1U+nYULKDqYOgGSA1aeayQcr+9BzisxlYLZCyVCYeciXIC3I6JS97HelL4zMePsKoLP6oDEUj6eWTN4GlDS2VR5cZab/K1HUSkke0z7QUcoAqd6E+r31aL1dngjrruqxON4QE/GEh5sFbBq2UAcKYMto7Ll7fyvaUCB1hKgeofYzgPcEBGyiXqevR7qAE3HiICZF5xzC/nE3SqQAACosrKkAcmYNyDiSKNcir5t7a2xAotQZLSHJApo2yrriIlPhCQ9H/cp+G6HZVkCNSPHhy98sZyRLrPAs+Xui0zwNpCWcc2PpW1quV2FQFN/+pvAANivVHZauUn7R6wWoNEv0YNYIAbVluxaIjgGQL5KEeO6RPiNFSZYMIlZFFvk7WydEirCZtfHiHNWvP3UVLP7SRCTsxypmjDrCmj0y26Z8tbbjwy+l39xxPk5u6Km1AFqiO7DFQAqoGtE3mNWGK4gbDUkAuaAaZetWJgVhcQ9ehJp4lYbAs2EQXQYfRDbsCfp8GpFVRnC45eAmj0NMBrYCU4UgJ9ADwP5nyWM7WmoRtwLWoMd3W33KLNTAXtrt2e9A0RoOrUl6dBVsAVcvhHhsilDSDVOwaskAU8dADItAJkppItwYz+0CNkGqUz/+ach5raQhXUqesIaZGpmOWst5y22X6PI7vTrFPatidfT8qoG99OlwZ77691943m3T2GWV2Bb2BAVYOwWuXVQW9lttiAx40q7/SGSp0tV/q2Vtqiq0ifBq28riPbXQu4zVuvnYFGrGJKpFo16CXlmpLhpUyp5mDdbAhEN2gAZQeps1oPrSVZ07bWjWbdPd2vv/8+igZLRq9P3mMfq0HYUu1DAVOhqFPnJQ9LDqgBirt4dQkGmgBXZRywttMo4yTFCiCt2aBVN/iunCmjVHAxtNLGQ0MT5TQlMyvnH4RRn3BcxMqyAaoWKuWmRaeOTR6dpTbZLxUK4/F7ItOA/eKHuy/o1cpHmdCZfhWowAJKWCfvsXroyDSK3udyMlyWvjoM+MiGZRSyAWLkGXUiY1agIGQapZhv5jPlLUS0RlJ7XvKzapewUEmIyDiCU2UBR1gHPGpCN9tbVz3ov+bR/cb7v5AqvcVasH90myZ81Je8/SmWU8FUWGFZyAAdsNLyAjqyqGd6fZ1023J8YxXwKgbpBpIcHDMw1Jz0UOGce1Rd2nxW929t+8nXU5Pltj/yLifcTJHvkedAtKmWrd2No+WcjdsQZ1gC+/kPdU9tTsZv1T7BcUMTjLDCAJQW2ddpSnlpUxcLe6ZZ5V4J8CEw7ZFFP0yTvEH75ESewVKXJ4C8BaR9sNQl86gtEEQvUZ9vatGJKLkyy9BrX7683WX8aYGmW6Cmlbus4S2643rmfmv3oX+lnz4OYQks4s98pHtEl/nbVdHDHaDgBgTHMBIgT1/KK+IOWlgBsroM1Q2A08bQH2Cm5dbpepRcMYEm/lIK9KEVc+VU1jLacgGh5wINFLLXmgK5l6naDVSXDVuIe+R1mONaU729+8gHHvEhmj9ngKXu05+Y/qE+x3yTDnM0rcyXPo+pmmi/2NcoDFUp8NPS3Kb3rcijrgXH9FzmpKh9ljk++ZhhztKCpT/JwVbkGrwsIVrX3qtsgNicp/CneQjS7DRl2Zfr1G/KBVr/O1q6jTd1n/jXf8hRV8NasCj93sc3Hzlvsu8NUvhY+tmcfIKgMfm0TPK2aKWrukN5mHLIEkW24ehtnvJyyPkhHfLtEbIHNJBnyHymyJv80Fk0aMvOS1epoH5MG8dv6D7+L8+w1NUjZXlt+tM//fyb9QXE+wTw5nALuQogxT3ErhVWTZm9SH4z5f1S11V53eLLrb7cGnSb1GfHyvnYEvTea9aRKvI7g9w6ZMOcL7n5bJ7jMT6njIVxVBkLBAwgnUa/wS05BiFfFnMPaxnKcK91+jbhHk3sPd0nh7v/WmA02atinfzWn3rqJp2ydwvg2zT48w2SidbB+zFXeX++XmGkjMnm1l6fao8BecJLef5WCzkAV/doAZvt/O2syj459cTRj68cyQGbvj/g8jsFJq47Vr1e+0+LAEhllQNUxWeV3iXZ7d3vxOJ/HZtV2csCm43v0L/z/8X//OQNi9nOjdpLfa1uXNdq7XtYm7sXa916UFZ1UL54Oul29Tuyuf6bAAE1Jt8AlrWF9VZLlB5vDfItAfr+50nzBPhkDRDjhKCvWK04QHIMrhrkabWCpNlSb/fln8foVyOjbkf8TmhHRa8yFk/KZz8hpUcVv6bGD5T5jx7pfvcWPeS/vPD/AUg2fXs/C6zNAAAAAElFTkSuQmCC";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.spotSolWallet) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.spotSolWallet;
			try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-tokenary/lib/esm/adapter.js
init_index_browser_esm();
const TokenaryWalletName = "Tokenary";
var TokenaryWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = TokenaryWalletName;
		this.url = "https://tokenary.io/get";
		this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMzRweCIgaGVpZ2h0PSIzNHB4IiB2aWV3Qm94PSIwIDAgMzQgMzQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8dGl0bGU+T3ZhbDwvdGl0bGU+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsIiBmaWxsPSIjMkM3Q0Y1IiBjeD0iMTciIGN5PSIxNyIgcj0iMTciPjwvY2lyY2xlPgogICAgPC9nPgo8L3N2Zz4=";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.tokenarySolana?.isTokenary) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.tokenarySolana;
			try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				transaction = await this.prepareTransaction(transaction, connection, sendOptions);
				signers?.length && transaction.partialSign(...signers);
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-tokenpocket/lib/esm/adapter.js
init_index_browser_esm();
const TokenPocketWalletName = "TokenPocket";
var TokenPocketWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = TokenPocketWalletName;
		this.url = "https://tokenpocket.pro";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGc+CjxwYXRoIGQ9Ik0xMDQxLjUyIDBILTI3VjEwMjRIMTA0MS41MlYwWiIgZmlsbD0iIzI5ODBGRSIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNDA4XzIyNSkiPgo8cGF0aCBkPSJNNDA2Ljc5NiA0MzguNjQzSDQwNi45MjdDNDA2Ljc5NiA0MzcuODU3IDQwNi43OTYgNDM2Ljk0IDQwNi43OTYgNDM2LjE1NFY0MzguNjQzWiIgZmlsbD0iIzI5QUVGRiIvPgo8cGF0aCBkPSJNNjY3LjYwMiA0NjMuNTMzSDUyMy4yNDlWNzI0LjA3NkM1MjMuMjQ5IDczNi4zODkgNTMzLjIwNCA3NDYuMzQ1IDU0NS41MTcgNzQ2LjM0NUg2NDUuMzMzQzY1Ny42NDcgNzQ2LjM0NSA2NjcuNjAyIDczNi4zODkgNjY3LjYwMiA3MjQuMDc2VjQ2My41MzNaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNDUzLjU2MyAyNzdINDQ4LjcxNkgxOTAuMjY5QzE3Ny45NTUgMjc3IDE2OCAyODYuOTU1IDE2OCAyOTkuMjY5VjM4OS42NTNDMTY4IDQwMS45NjcgMTc3Ljk1NSA0MTEuOTIyIDE5MC4yNjkgNDExLjkyMkgyNTAuOTE4SDI3NS4wMjFWNDM4LjY0NFY3MjQuNzMxQzI3NS4wMjEgNzM3LjA0NSAyODQuOTc2IDc0NyAyOTcuMjg5IDc0N0gzOTIuMTI4QzQwNC40NDEgNzQ3IDQxNC4zOTYgNzM3LjA0NSA0MTQuMzk2IDcyNC43MzFWNDM4LjY0NFY0MzYuMTU2VjQxMS45MjJINDM4LjQ5OUg0NDguMzIzSDQ1My4xN0M0OTAuMzcyIDQxMS45MjIgNTIwLjYzMSAzODEuNjYzIDUyMC42MzEgMzQ0LjQ2MUM1MjEuMDI0IDMwNy4yNTkgNDkwLjc2NSAyNzcgNDUzLjU2MyAyNzdaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNjY3LjczNSA0NjMuNTMzVjY0NS4zNUM2NzIuNzEzIDY0Ni41MjkgNjc3LjgyMSA2NDcuNDQ2IDY4My4wNjEgNjQ4LjIzMkM2OTAuMzk3IDY0OS4yOCA2OTcuOTk0IDY0OS45MzUgNzA1LjU5MiA2NTAuMDY2QzcwNS45ODUgNjUwLjA2NiA3MDYuMzc4IDY1MC4wNjYgNzA2LjkwMiA2NTAuMDY2VjUwNS40NUM2ODUuMDI2IDUwNC4wMDkgNjY3LjczNSA0ODUuODAxIDY2Ny43MzUgNDYzLjUzM1oiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl80MDhfMjI1KSIvPgo8cGF0aCBkPSJNNzA5Ljc4MSAyNzdDNjA2LjgyMiAyNzcgNTIzLjI0OSAzNjAuNTczIDUyMy4yNDkgNDYzLjUzM0M1MjMuMjQ5IDU1Mi4wODQgNTg0Ljk0NiA2MjYuMjI1IDY2Ny43MzMgNjQ1LjM1VjQ2My41MzNDNjY3LjczMyA0NDAuMzQ3IDY4Ni41OTYgNDIxLjQ4NCA3MDkuNzgxIDQyMS40ODRDNzMyLjk2NyA0MjEuNDg0IDc1MS44MyA0NDAuMzQ3IDc1MS44MyA0NjMuNTMzQzc1MS44MyA0ODMuMDUxIDczOC42IDQ5OS40MjUgNzIwLjUyMyA1MDQuMTRDNzE3LjExNyA1MDUuMDU3IDcxMy40NDkgNTA1LjU4MSA3MDkuNzgxIDUwNS41ODFWNjUwLjA2NkM3MTMuNDQ5IDY1MC4wNjYgNzE2Ljk4NiA2NDkuOTM1IDcyMC41MjMgNjQ5LjgwNEM4MTguNTA1IDY0NC4xNzEgODk2LjMxNCA1NjIuOTU2IDg5Ni4zMTQgNDYzLjUzM0M4OTYuNDQ1IDM2MC41NzMgODEyLjg3MiAyNzcgNzA5Ljc4MSAyNzdaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNzA5Ljc4IDY1MC4wNjZWNTA1LjU4MUM3MDguNzMzIDUwNS41ODEgNzA3LjgxNiA1MDUuNTgxIDcwNi43NjggNTA1LjQ1VjY1MC4wNjZDNzA3LjgxNiA2NTAuMDY2IDcwOC44NjQgNjUwLjA2NiA3MDkuNzggNjUwLjA2NloiIGZpbGw9IndoaXRlIi8+CjwvZz4KPC9nPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzQwOF8yMjUiIHgxPSI3MDkuODQ0IiB5MT0iNTU2LjgyNyIgeDI9IjY2Ny43NTMiIHkyPSI1NTYuODI3IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IndoaXRlIi8+CjxzdG9wIG9mZnNldD0iMC45NjY3IiBzdG9wLWNvbG9yPSJ3aGl0ZSIgc3RvcC1vcGFjaXR5PSIwLjMyMzMiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSJ3aGl0ZSIgc3RvcC1vcGFjaXR5PSIwLjMiLz4KPC9saW5lYXJHcmFkaWVudD4KPGNsaXBQYXRoIGlkPSJjbGlwMF80MDhfMjI1Ij4KPHJlY3Qgd2lkdGg9IjcyOC40NDgiIGhlaWdodD0iNDcwIiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTY4IDI3NykiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.solana?.isTokenPocket) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.solana;
			try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			this.emit("disconnect");
		}
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				if (isVersionedTransaction(transaction)) signers?.length && transaction.sign(signers);
				else {
					transaction = await this.prepareTransaction(transaction, connection, sendOptions);
					signers?.length && transaction.partialSign(...signers);
				}
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-torus/lib/esm/adapter.js
init_index_browser_esm();
const TorusWalletName = "Torus";
var TorusWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor({ params = { showTorusButton: false } } = { params: { showTorusButton: false } }) {
		super();
		this.name = TorusWalletName;
		this.url = "https://tor.us";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzMiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMyAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYuNSIgY3k9IjE2IiByPSIxNiIgZmlsbD0iIzAzNjRGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjIxODYgOS40OTIxOUMxMC40NTM5IDkuNDkyMTkgOS44MzM5OCAxMC4xMTIxIDkuODMzOTggMTAuODc2OFYxMi40ODk4QzkuODMzOTggMTMuMjU0NSAxMC40NTM5IDEzLjg3NDQgMTEuMjE4NiAxMy44NzQ0SDEzLjY2ODRWMjIuODk3NkMxMy42Njg0IDIzLjY2MjMgMTQuMjg4MyAyNC4yODIyIDE1LjA1MyAyNC4yODIySDE2LjY2NkMxNy40MzA3IDI0LjI4MjIgMTguMDUwNiAyMy42NjIzIDE4LjA1MDYgMjIuODk3NlYxMi41MDE1QzE4LjA1MDYgMTIuNDk3NiAxOC4wNTA2IDEyLjQ5MzcgMTguMDUwNiAxMi40ODk4VjEwLjg3NjhDMTguMDUwNiAxMC4xMTIxIDE3LjQzMDcgOS40OTIxOSAxNi42NjYgOS40OTIxOUgxNS4wNTNIMTEuMjE4NloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMS4zMzc2IDEzLjg3NDRDMjIuNTQ3NyAxMy44NzQ0IDIzLjUyODcgMTIuODkzNCAyMy41Mjg3IDExLjY4MzNDMjMuNTI4NyAxMC40NzMyIDIyLjU0NzcgOS40OTIxOSAyMS4zMzc2IDkuNDkyMTlDMjAuMTI3NSA5LjQ5MjE5IDE5LjE0NjUgMTAuNDczMiAxOS4xNDY1IDExLjY4MzNDMTkuMTQ2NSAxMi44OTM0IDIwLjEyNzUgMTMuODc0NCAyMS4zMzc2IDEzLjg3NDRaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		this._params = params;
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isLoggedIn;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Loadable) throw new WalletNotReadyError();
			this._connecting = true;
			let TorusClass;
			try {
				TorusClass = (await import("./solanaEmbed.esm-BD3u8mmh.js")).default;
			} catch (error) {
				throw new WalletLoadError(error?.message, error);
			}
			let wallet;
			try {
				wallet = window.torus || new TorusClass();
			} catch (error) {
				throw new WalletConfigError(error?.message, error);
			}
			if (!wallet.isInitialized) try {
				await wallet.init(this._params);
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			let accounts;
			try {
				accounts = await wallet.login();
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			let publicKey;
			try {
				publicKey = new PublicKey(accounts[0]);
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				if (wallet.isLoggedIn) await wallet.cleanUp();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				transaction = await this.prepareTransaction(transaction, connection, sendOptions);
				signers?.length && transaction.partialSign(...signers);
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signMessage(message);
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-trezor/lib/esm/adapter.js
init_index_browser_esm();
const TrezorWalletName = "Trezor";
var TrezorWalletAdapter = class extends BaseSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = TrezorWalletName;
		this.url = "https://trezor.io";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBjbGlwLXBhdGg9InVybCgjYSkiPjxwYXRoIGQ9Ik01NCAwYzI5LjgyNCAwIDU0IDI0LjE3NiA1NCA1NHMtMjQuMTc2IDU0LTU0IDU0UzAgODMuODI0IDAgNTQgMjQuMTc2IDAgNTQgMHoiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNNzUuMjUgMzMuMzA1Qzc1LjI1IDIyLjIwNSA2NS42NjIgMTMgNTQgMTNjLTExLjY3MiAwLTIxLjI1OCA5LjIxMi0yMS4yNTggMjAuMzA1djYuNDlIMjR2NDYuNjgzTDUzLjk5IDEwMC41IDg0IDg2LjQ3NXYtNDYuNDdoLTguNzQ1bC0uMDA3LTYuNjk4LjAwMi0uMDAyem0tMzEuNjcgMGMwLTUuMjMyIDQuNTg1LTkuNDIgMTAuNDE4LTkuNDIgNS44MzUgMCAxMC40MTcgNC4xODggMTAuNDE3IDkuNDJ2Ni40OUg0My41OHYtNi40OXptMjguMzM1IDQ1LjYzN0w1My45OSA4Ny4zMmwtMTcuOTItOC4zNzJWNTAuODloMzUuODQ1djI4LjA1MnoiIGZpbGw9IiMxNzE3MTciLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDEwOHYxMDhIMHoiLz48L2NsaXBQYXRoPjwvZGVmcz48L3N2Zz4=";
		this.supportedTransactionVersions = new Set(["legacy", 0]);
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
		this._onDeviceEvent = (event) => {
			if (event.type === "device-disconnect") this._disconnected();
		};
		this._disconnected = async () => {
			const wallet = this._wallet;
			if (wallet) {
				this._wallet = null;
				this._publicKey = null;
				try {
					wallet.off("DEVICE_EVENT", this._onDeviceEvent);
					wallet.dispose();
				} catch (error) {
					this.emit("error", new WalletDisconnectionError(error?.message, error));
				}
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._derivationPath = config.derivationPath || `m/44'/501'/0'/0'`;
		this._wallet = null;
		this._connectUrl = config.connectUrl?.replace(/\/*$/, "/");
		this._connecting = false;
		this._publicKey = null;
		this._appName = config.appName || "Wallet Adapter";
		this._email = config.email || "noreply@anza.xyz";
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Loadable) throw new WalletNotReadyError();
			this._connecting = true;
			let wallet;
			try {
				const { default: TrezorConnect } = await import("./lib-7ww0EO0z.js").then(__toDynamicImportESM(1));
				wallet = TrezorConnect.default;
			} catch (error) {
				throw new WalletLoadError(error?.message, error);
			}
			try {
				await wallet.init({
					manifest: {
						appName: this._appName,
						email: this._email,
						appUrl: window.location.href
					},
					lazyLoad: true,
					...this._connectUrl ? {
						connectSrc: this._connectUrl,
						iframeSrc: this._connectUrl
					} : {}
				});
			} catch (error) {
				throw new WalletConfigError(error?.message, error);
			}
			let result;
			try {
				result = await wallet.solanaGetPublicKey({ path: this._derivationPath });
			} catch (error) {
				throw new WalletAccountError(error?.message, error);
			}
			if (!result.success) throw new WalletAccountError(result.payload?.error, result.payload);
			let publicKey;
			try {
				publicKey = new PublicKey(Buffer.from(result.payload.publicKey, "hex"));
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("DEVICE_EVENT", this._onDeviceEvent);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				wallet.off("DEVICE_EVENT", this._onDeviceEvent);
				await wallet.dispose();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
			this.emit("disconnect");
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			const publicKey = this._publicKey;
			if (!wallet || !publicKey) throw new WalletNotConnectedError();
			const serializedTransaction = isVersionedTransaction(transaction) ? transaction.message.serialize() : transaction.serializeMessage();
			let result;
			try {
				result = await wallet.solanaSignTransaction({
					path: this._derivationPath,
					serializedTx: Buffer.from(serializedTransaction).toString("hex")
				});
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
			if (!result.success) throw new WalletSignTransactionError(result.payload?.error, result.payload);
			try {
				const signature = Buffer.from(result.payload.signature, "hex");
				transaction.addSignature(publicKey, signature);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
			return transaction;
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-trust/lib/esm/adapter.js
init_index_browser_esm();
const TrustWalletName = "Trust";
var TrustWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = TrustWalletName;
		this.url = "https://trustwallet.com";
		this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTkyMCAxMDgwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQpO30uY2xzLTJ7ZmlsbDojMDUwMGZmO308L3N0eWxlPjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyLWdyYWRpZW50IiB4MT0iMTEyMy4yNiIgeTE9IjE4NjUuNzgiIHgyPSI5NTQuNjEiIHkyPSIxMzM3LjUiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAyMTgyKSBzY2FsZSgxIC0xKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iLjAyIiBzdG9wLWNvbG9yPSJibHVlIi8+PHN0b3Agb2Zmc2V0PSIuMDgiIHN0b3AtY29sb3I9IiMwMDk0ZmYiLz48c3RvcCBvZmZzZXQ9Ii4xNiIgc3RvcC1jb2xvcj0iIzQ4ZmY5MSIvPjxzdG9wIG9mZnNldD0iLjQyIiBzdG9wLWNvbG9yPSIjMDA5NGZmIi8+PHN0b3Agb2Zmc2V0PSIuNjgiIHN0b3AtY29sb3I9IiMwMDM4ZmYiLz48c3RvcCBvZmZzZXQ9Ii45IiBzdG9wLWNvbG9yPSIjMDUwMGZmIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJtNzM4LjcxLDQyMy40MWwyMjEuNDUtNzIuM3Y1MDAuNTJjLTE1OC4xOC02Ni43NC0yMjEuNDUtMTk0LjY1LTIyMS40NS0yNjYuOTR2LTE2MS4yOFoiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Im0xMTgxLjYyLDQyMy40MWwtMjIxLjQ1LTcyLjN2NTAwLjUyYzE1OC4xOC02Ni43NCwyMjEuNDUtMTk0LjY1LDIyMS40NS0yNjYuOTR2LTE2MS4yOFoiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Im04MjUuOTEsMjMwLjg1aDMwLjl2MTcuMzFjMTAuMTMtMTUuNTYsMjEuNzgtMTcuMzEsMzguODQtMTcuMzF2MzAuNmgtNy43N2MtMjAuNDQsMC0zMC4yMyw5LjYyLTMwLjIzLDI4LjY3djMyLjUyaC0zMS43NXYtOTEuNzlaIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJtOTk4Ljc4LDMyMi42M2gtMzEuNzV2LTguNzVjLTYuOTMsOC4wNS0xNi4zOCwxMS41NC0yOC4wMywxMS41NC0yMi4xMiwwLTM0LjYyLTEzLjExLTM0LjYyLTM3LjI0di01Ny4zNGgzMS43NXY1MC4xOGMwLDExLjM2LDUuNTcsMTgsMTUuMDIsMThzMTUuODgtNi40NywxNS44OC0xNy40OHYtNTAuN2gzMS43NXY5MS43OVoiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Im0xMDA2LjU0LDI5NC4zaDI5LjczYzEuMzYsNi42NCw1LjkxLDkuNDMsMTYuODgsOS40Myw4Ljk1LDAsMTQuMTktMi4wOSwxNC4xOS01Ljk0LDAtMi45OC0yLjU0LTQuOS05Ljc5LTYuNDdsLTIzLjk4LTUuNDJjLTE2LjA0LTMuNjYtMjQuMTUtMTIuOTMtMjQuMTUtMjcuOCwwLTE5LjU5LDE0LjM1LTI5LjczLDQyLjIxLTI5LjczczQxLjU0LDkuODgsNDMuOTEsMzEuMDRoLTI5LjU1Yy0uNS01LjU5LTYuMjUtOS4wMS0xNS43LTkuMDEtNy41OSwwLTEyLjQ5LDIuNDQtMTIuNDksNi4xMiwwLDMuMTQsMy4yLDUuNTksOS42Myw3LjE4bDI1LjE2LDYuMTJjMTYuNTQsNC4wMSwyNC40OSwxMi40MSwyNC40OSwyNi4wNSwwLDE4Ljg5LTE2LjM4LDMwLjA4LTQ0LjIzLDMwLjA4cy00Ni4yNy0xMi4wNi00Ni4yNy0zMS42NWgtLjAzWiIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0ibTExODEuNjIsMjU5LjR2LTI4LjU1aC03OC4zNXYyOC41NmgyMy4zOHY2My4yMmgzMS41OHYtNjMuMjRoMjMuMzlaIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJtODE3LjA4LDI1OS40di0yOC41NWgtNzguMzV2MjguNTZoMjMuMzh2NjMuMjJoMzEuNTh2LTYzLjI0aDIzLjM4WiIvPjwvc3ZnPg==";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.trustwallet?.solana?.isTrust) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.trustwallet.solana;
			if (!wallet.isConnected) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async sendTransaction(transaction, connection, options = {}) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signers, ...sendOptions } = options;
				transaction = await this.prepareTransaction(transaction, connection, sendOptions);
				signers?.length && transaction.partialSign(...signers);
				sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
				const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
				return signature;
			} catch (error) {
				if (error instanceof WalletError) throw error;
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-unsafe-burner/lib/esm/adapter.js
init_ed25519();
init_index_browser_esm();
const UnsafeBurnerWalletName = "Burner Wallet";
/**
* This burner wallet adapter is unsafe to use and is only included to provide an easy way for applications to test
* Wallet Adapter without using a third-party wallet.
*/
var UnsafeBurnerWalletAdapter = class extends BaseSignInMessageSignerWalletAdapter {
	constructor() {
		super();
		this.name = UnsafeBurnerWalletName;
		this.url = "https://github.com/anza-xyz/wallet-adapter#usage";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzQiIGhlaWdodD0iMzAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zNCAxMC42djIuN2wtOS41IDE2LjVoLTQuNmw2LTEwLjVhMi4xIDIuMSAwIDEgMCAyLTMuNGw0LjgtOC4zYTQgNCAwIDAgMSAxLjMgM1ptLTQuMyAxOS4xaC0uNmw0LjktOC40djQuMmMwIDIuMy0yIDQuMy00LjMgNC4zWm0yLTI4LjRjLS4zLS44LTEtMS4zLTItMS4zaC0xLjlsLTIuNCA0LjNIMzBsMS43LTNabS0zIDVoLTQuNkwxMC42IDI5LjhoNC43TDI4LjggNi40Wk0xOC43IDBoNC42bC0yLjUgNC4zaC00LjZMMTguNiAwWk0xNSA2LjRoNC42TDYgMjkuOEg0LjJjLS44IDAtMS43LS4zLTIuNC0uOEwxNSA2LjRaTTE0IDBIOS40TDcgNC4zaDQuNkwxNCAwWm0tMy42IDYuNEg1LjdMMCAxNi4ydjhMMTAuMyA2LjRaTTQuMyAwaC40TDAgOC4ydi00QzAgMiAxLjkgMCA0LjMgMFoiIGZpbGw9IiM5OTQ1RkYiLz48L3N2Zz4=";
		this.supportedTransactionVersions = new Set(["legacy", 0]);
		/**
		* Storing a keypair locally like this is not safe because any application using this adapter could retrieve the
		* secret key, and because the keypair will be lost any time the wallet is disconnected or the window is refreshed.
		*/
		this._keypair = null;
		console.warn("Your application is presently configured to use the `UnsafeBurnerWalletAdapter`. Find and remove it, then replace it with a list of adapters for wallets you would like your application to support. See https://github.com/anza-xyz/wallet-adapter#usage for an example.");
	}
	get connecting() {
		return false;
	}
	get publicKey() {
		return this._keypair && this._keypair.publicKey;
	}
	get readyState() {
		return WalletReadyState.Loadable;
	}
	async connect() {
		this._keypair = new Keypair();
		this.emit("connect", this._keypair.publicKey);
	}
	async disconnect() {
		this._keypair = null;
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		if (!this._keypair) throw new WalletNotConnectedError();
		if (isVersionedTransaction(transaction)) transaction.sign([this._keypair]);
		else transaction.partialSign(this._keypair);
		return transaction;
	}
	async signMessage(message) {
		if (!this._keypair) throw new WalletNotConnectedError();
		return ed25519.sign(message, this._keypair.secretKey.slice(0, 32));
	}
	async signIn(input = {}) {
		const { publicKey, secretKey } = this._keypair || (this._keypair = new Keypair());
		const domain = input.domain || window.location.host;
		const address = input.address || publicKey.toBase58();
		const signedMessage = createSignInMessage({
			...input,
			domain,
			address
		});
		const signature = ed25519.sign(signedMessage, secretKey.slice(0, 32));
		this.emit("connect", publicKey);
		return {
			account: {
				address,
				publicKey: publicKey.toBytes(),
				chains: [],
				features: []
			},
			signedMessage,
			signature
		};
	}
};

//#endregion
//#region node_modules/@walletconnect/solana-adapter/dist/constants.js
var WalletConnectChainID;
(function(WalletConnectChainID$1) {
	WalletConnectChainID$1["Mainnet"] = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp";
	WalletConnectChainID$1["Devnet"] = "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1";
	WalletConnectChainID$1["Deprecated_Mainnet"] = "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ";
	WalletConnectChainID$1["Deprecated_Devnet"] = "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K";
})(WalletConnectChainID || (WalletConnectChainID = {}));
var WalletConnectRPCMethods;
(function(WalletConnectRPCMethods$1) {
	WalletConnectRPCMethods$1["signTransaction"] = "solana_signTransaction";
	WalletConnectRPCMethods$1["signMessage"] = "solana_signMessage";
	WalletConnectRPCMethods$1["signAndSendTransaction"] = "solana_signAndSendTransaction";
	WalletConnectRPCMethods$1["signAndSendAllTransactions"] = "solana_signAndSendAllTransactions";
	WalletConnectRPCMethods$1["signAllTransactions"] = "solana_signAllTransactions";
})(WalletConnectRPCMethods || (WalletConnectRPCMethods = {}));
const SolanaChainIDs = {
	Mainnet: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
	Devnet: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
	Deprecated_Mainnet: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
	Deprecated_Devnet: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
};

//#endregion
//#region node_modules/@walletconnect/core/node_modules/@walletconnect/types/dist/index.es.js
var import_events$7 = /* @__PURE__ */ __toESM(require_events());
var a = Object.defineProperty, u$1 = (e, s, r$1) => s in e ? a(e, s, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: r$1
}) : e[s] = r$1, c$2 = (e, s, r$1) => u$1(e, typeof s != "symbol" ? s + "" : s, r$1);
var h$3 = class extends IEvents {
	constructor(s) {
		super(), this.opts = s, c$2(this, "protocol", "wc"), c$2(this, "version", 2);
	}
};
var p$4 = Object.defineProperty, b$2 = (e, s, r$1) => s in e ? p$4(e, s, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: r$1
}) : e[s] = r$1, v$4 = (e, s, r$1) => b$2(e, typeof s != "symbol" ? s + "" : s, r$1);
var I$3 = class extends IEvents {
	constructor(s, r$1) {
		super(), this.core = s, this.logger = r$1, v$4(this, "records", /* @__PURE__ */ new Map());
	}
};
var y$5 = class {
	constructor(s, r$1) {
		this.logger = s, this.core = r$1;
	}
};
var m$1 = class extends IEvents {
	constructor(s, r$1) {
		super(), this.relayer = s, this.logger = r$1;
	}
};
var d$2 = class extends IEvents {
	constructor(s) {
		super();
	}
};
var f$5 = class {
	constructor(s, r$1, t, q$4) {
		this.core = s, this.logger = r$1, this.name = t;
	}
};
var P$3 = class extends IEvents {
	constructor(s, r$1) {
		super(), this.relayer = s, this.logger = r$1;
	}
};
var S$4 = class extends IEvents {
	constructor(s, r$1) {
		super(), this.core = s, this.logger = r$1;
	}
};
var M$5 = class {
	constructor(s, r$1, t) {
		this.core = s, this.logger = r$1, this.store = t;
	}
};
var O$4 = class {
	constructor(s, r$1) {
		this.projectId = s, this.logger = r$1;
	}
};
var R$3 = class {
	constructor(s, r$1, t) {
		this.core = s, this.logger = r$1, this.telemetryEnabled = t;
	}
};

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/isHex.js
function isHex$2(value, { strict = true } = {}) {
	if (!value) return false;
	if (typeof value !== "string") return false;
	return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/size.js
/**
* @description Retrieves the size of the value (in bytes).
*
* @param value The value (hex or byte array) to retrieve the size of.
* @returns The size of the value (in bytes).
*/
function size$3(value) {
	if (isHex$2(value, { strict: false })) return Math.ceil((value.length - 2) / 2);
	return value.length;
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/version.js
const version$2 = "2.23.2";

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/base.js
var errorConfig$2 = {
	getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
	version: `viem@${version$2}`
};
var BaseError$2 = class BaseError$2 extends Error {
	constructor(shortMessage, args = {}) {
		const details = (() => {
			if (args.cause instanceof BaseError$2) return args.cause.details;
			if (args.cause?.message) return args.cause.message;
			return args.details;
		})();
		const docsPath = (() => {
			if (args.cause instanceof BaseError$2) return args.cause.docsPath || args.docsPath;
			return args.docsPath;
		})();
		const docsUrl = errorConfig$2.getDocsUrl?.({
			...args,
			docsPath
		});
		const message = [
			shortMessage || "An error occurred.",
			"",
			...args.metaMessages ? [...args.metaMessages, ""] : [],
			...docsUrl ? [`Docs: ${docsUrl}`] : [],
			...details ? [`Details: ${details}`] : [],
			...errorConfig$2.version ? [`Version: ${errorConfig$2.version}`] : []
		].join("\n");
		super(message, args.cause ? { cause: args.cause } : void 0);
		Object.defineProperty(this, "details", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "docsPath", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "metaMessages", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "shortMessage", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "version", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "name", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: "BaseError"
		});
		this.details = details;
		this.docsPath = docsPath;
		this.metaMessages = args.metaMessages;
		this.name = args.name ?? this.name;
		this.shortMessage = shortMessage;
		this.version = version$2;
	}
	walk(fn$5) {
		return walk$2(this, fn$5);
	}
};
function walk$2(err, fn$5) {
	if (fn$5?.(err)) return err;
	if (err && typeof err === "object" && "cause" in err && err.cause !== void 0) return walk$2(err.cause, fn$5);
	return fn$5 ? null : err;
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/data.js
var SizeExceedsPaddingSizeError$2 = class extends BaseError$2 {
	constructor({ size: size$4, targetSize, type }) {
		super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size$4}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
	}
};

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/pad.js
function pad$2(hexOrBytes, { dir, size: size$4 = 32 } = {}) {
	if (typeof hexOrBytes === "string") return padHex$2(hexOrBytes, {
		dir,
		size: size$4
	});
	return padBytes$2(hexOrBytes, {
		dir,
		size: size$4
	});
}
function padHex$2(hex_, { dir, size: size$4 = 32 } = {}) {
	if (size$4 === null) return hex_;
	const hex = hex_.replace("0x", "");
	if (hex.length > size$4 * 2) throw new SizeExceedsPaddingSizeError$2({
		size: Math.ceil(hex.length / 2),
		targetSize: size$4,
		type: "hex"
	});
	return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size$4 * 2, "0")}`;
}
function padBytes$2(bytes, { dir, size: size$4 = 32 } = {}) {
	if (size$4 === null) return bytes;
	if (bytes.length > size$4) throw new SizeExceedsPaddingSizeError$2({
		size: bytes.length,
		targetSize: size$4,
		type: "bytes"
	});
	const paddedBytes = new Uint8Array(size$4);
	for (let i$2 = 0; i$2 < size$4; i$2++) {
		const padEnd = dir === "right";
		paddedBytes[padEnd ? i$2 : size$4 - i$2 - 1] = bytes[padEnd ? i$2 : bytes.length - i$2 - 1];
	}
	return paddedBytes;
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError$2 = class extends BaseError$2 {
	constructor({ max, min, signed, size: size$4, value }) {
		super(`Number "${value}" is not in safe ${size$4 ? `${size$4 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
	}
};
var SizeOverflowError$2 = class extends BaseError$2 {
	constructor({ givenSize, maxSize }) {
		super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
	}
};

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize$2(hexOrBytes, { size: size$4 }) {
	if (size$3(hexOrBytes) > size$4) throw new SizeOverflowError$2({
		givenSize: size$3(hexOrBytes),
		maxSize: size$4
	});
}
/**
* Decodes a hex value into a bigint.
*
* - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint
*
* @param hex Hex value to decode.
* @param opts Options.
* @returns BigInt value.
*
* @example
* import { hexToBigInt } from 'viem'
* const data = hexToBigInt('0x1a4', { signed: true })
* // 420n
*
* @example
* import { hexToBigInt } from 'viem'
* const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
* // 420n
*/
function hexToBigInt$1(hex, opts = {}) {
	const { signed } = opts;
	if (opts.size) assertSize$2(hex, { size: opts.size });
	const value = BigInt(hex);
	if (!signed) return value;
	const size$4 = (hex.length - 2) / 2;
	if (value <= (1n << BigInt(size$4) * 8n - 1n) - 1n) return value;
	return value - BigInt(`0x${"f".padStart(size$4 * 2, "f")}`) - 1n;
}
/**
* Decodes a hex string into a number.
*
* - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber
*
* @param hex Hex value to decode.
* @param opts Options.
* @returns Number value.
*
* @example
* import { hexToNumber } from 'viem'
* const data = hexToNumber('0x1a4')
* // 420
*
* @example
* import { hexToNumber } from 'viem'
* const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
* // 420
*/
function hexToNumber$1(hex, opts = {}) {
	return Number(hexToBigInt$1(hex, opts));
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toHex.js
var hexes$2 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i$2) => i$2.toString(16).padStart(2, "0"));
/**
* Encodes a string, number, bigint, or ByteArray into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex
* - Example: https://viem.sh/docs/utilities/toHex#usage
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { toHex } from 'viem'
* const data = toHex('Hello world')
* // '0x48656c6c6f20776f726c6421'
*
* @example
* import { toHex } from 'viem'
* const data = toHex(420)
* // '0x1a4'
*
* @example
* import { toHex } from 'viem'
* const data = toHex('Hello world', { size: 32 })
* // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'
*/
function toHex$2(value, opts = {}) {
	if (typeof value === "number" || typeof value === "bigint") return numberToHex$2(value, opts);
	if (typeof value === "string") return stringToHex$2(value, opts);
	if (typeof value === "boolean") return boolToHex$2(value, opts);
	return bytesToHex$2(value, opts);
}
/**
* Encodes a boolean into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#booltohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { boolToHex } from 'viem'
* const data = boolToHex(true)
* // '0x1'
*
* @example
* import { boolToHex } from 'viem'
* const data = boolToHex(false)
* // '0x0'
*
* @example
* import { boolToHex } from 'viem'
* const data = boolToHex(true, { size: 32 })
* // '0x0000000000000000000000000000000000000000000000000000000000000001'
*/
function boolToHex$2(value, opts = {}) {
	const hex = `0x${Number(value)}`;
	if (typeof opts.size === "number") {
		assertSize$2(hex, { size: opts.size });
		return pad$2(hex, { size: opts.size });
	}
	return hex;
}
/**
* Encodes a bytes array into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#bytestohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { bytesToHex } from 'viem'
* const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
* // '0x48656c6c6f20576f726c6421'
*
* @example
* import { bytesToHex } from 'viem'
* const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })
* // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
*/
function bytesToHex$2(value, opts = {}) {
	let string = "";
	for (let i$2 = 0; i$2 < value.length; i$2++) string += hexes$2[value[i$2]];
	const hex = `0x${string}`;
	if (typeof opts.size === "number") {
		assertSize$2(hex, { size: opts.size });
		return pad$2(hex, {
			dir: "right",
			size: opts.size
		});
	}
	return hex;
}
/**
* Encodes a number or bigint into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#numbertohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { numberToHex } from 'viem'
* const data = numberToHex(420)
* // '0x1a4'
*
* @example
* import { numberToHex } from 'viem'
* const data = numberToHex(420, { size: 32 })
* // '0x00000000000000000000000000000000000000000000000000000000000001a4'
*/
function numberToHex$2(value_, opts = {}) {
	const { signed, size: size$4 } = opts;
	const value = BigInt(value_);
	let maxValue;
	if (size$4) if (signed) maxValue = (1n << BigInt(size$4) * 8n - 1n) - 1n;
	else maxValue = 2n ** (BigInt(size$4) * 8n) - 1n;
	else if (typeof value_ === "number") maxValue = BigInt(Number.MAX_SAFE_INTEGER);
	const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
	if (maxValue && value > maxValue || value < minValue) {
		const suffix = typeof value_ === "bigint" ? "n" : "";
		throw new IntegerOutOfRangeError$2({
			max: maxValue ? `${maxValue}${suffix}` : void 0,
			min: `${minValue}${suffix}`,
			signed,
			size: size$4,
			value: `${value_}${suffix}`
		});
	}
	const hex = `0x${(signed && value < 0 ? (1n << BigInt(size$4 * 8)) + BigInt(value) : value).toString(16)}`;
	if (size$4) return pad$2(hex, { size: size$4 });
	return hex;
}
var encoder$4 = /* @__PURE__ */ new TextEncoder();
/**
* Encodes a UTF-8 string into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#stringtohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { stringToHex } from 'viem'
* const data = stringToHex('Hello World!')
* // '0x48656c6c6f20576f726c6421'
*
* @example
* import { stringToHex } from 'viem'
* const data = stringToHex('Hello World!', { size: 32 })
* // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
*/
function stringToHex$2(value_, opts = {}) {
	return bytesToHex$2(encoder$4.encode(value_), opts);
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toBytes.js
var encoder$3 = /* @__PURE__ */ new TextEncoder();
/**
* Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.
*
* - Docs: https://viem.sh/docs/utilities/toBytes
* - Example: https://viem.sh/docs/utilities/toBytes#usage
*
* @param value Value to encode.
* @param opts Options.
* @returns Byte array value.
*
* @example
* import { toBytes } from 'viem'
* const data = toBytes('Hello world')
* // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
*
* @example
* import { toBytes } from 'viem'
* const data = toBytes(420)
* // Uint8Array([1, 164])
*
* @example
* import { toBytes } from 'viem'
* const data = toBytes(420, { size: 4 })
* // Uint8Array([0, 0, 1, 164])
*/
function toBytes$2(value, opts = {}) {
	if (typeof value === "number" || typeof value === "bigint") return numberToBytes$1(value, opts);
	if (typeof value === "boolean") return boolToBytes$1(value, opts);
	if (isHex$2(value)) return hexToBytes$1(value, opts);
	return stringToBytes$1(value, opts);
}
/**
* Encodes a boolean into a byte array.
*
* - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes
*
* @param value Boolean value to encode.
* @param opts Options.
* @returns Byte array value.
*
* @example
* import { boolToBytes } from 'viem'
* const data = boolToBytes(true)
* // Uint8Array([1])
*
* @example
* import { boolToBytes } from 'viem'
* const data = boolToBytes(true, { size: 32 })
* // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
*/
function boolToBytes$1(value, opts = {}) {
	const bytes = new Uint8Array(1);
	bytes[0] = Number(value);
	if (typeof opts.size === "number") {
		assertSize$2(bytes, { size: opts.size });
		return pad$2(bytes, { size: opts.size });
	}
	return bytes;
}
var charCodeMap$1 = {
	zero: 48,
	nine: 57,
	A: 65,
	F: 70,
	a: 97,
	f: 102
};
function charCodeToBase16$1(char) {
	if (char >= charCodeMap$1.zero && char <= charCodeMap$1.nine) return char - charCodeMap$1.zero;
	if (char >= charCodeMap$1.A && char <= charCodeMap$1.F) return char - (charCodeMap$1.A - 10);
	if (char >= charCodeMap$1.a && char <= charCodeMap$1.f) return char - (charCodeMap$1.a - 10);
}
/**
* Encodes a hex string into a byte array.
*
* - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes
*
* @param hex Hex string to encode.
* @param opts Options.
* @returns Byte array value.
*
* @example
* import { hexToBytes } from 'viem'
* const data = hexToBytes('0x48656c6c6f20776f726c6421')
* // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
*
* @example
* import { hexToBytes } from 'viem'
* const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })
* // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
*/
function hexToBytes$1(hex_, opts = {}) {
	let hex = hex_;
	if (opts.size) {
		assertSize$2(hex, { size: opts.size });
		hex = pad$2(hex, {
			dir: "right",
			size: opts.size
		});
	}
	let hexString = hex.slice(2);
	if (hexString.length % 2) hexString = `0${hexString}`;
	const length = hexString.length / 2;
	const bytes = new Uint8Array(length);
	for (let index$1 = 0, j$2 = 0; index$1 < length; index$1++) {
		const nibbleLeft = charCodeToBase16$1(hexString.charCodeAt(j$2++));
		const nibbleRight = charCodeToBase16$1(hexString.charCodeAt(j$2++));
		if (nibbleLeft === void 0 || nibbleRight === void 0) throw new BaseError$2(`Invalid byte sequence ("${hexString[j$2 - 2]}${hexString[j$2 - 1]}" in "${hexString}").`);
		bytes[index$1] = nibbleLeft * 16 + nibbleRight;
	}
	return bytes;
}
/**
* Encodes a number into a byte array.
*
* - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes
*
* @param value Number to encode.
* @param opts Options.
* @returns Byte array value.
*
* @example
* import { numberToBytes } from 'viem'
* const data = numberToBytes(420)
* // Uint8Array([1, 164])
*
* @example
* import { numberToBytes } from 'viem'
* const data = numberToBytes(420, { size: 4 })
* // Uint8Array([0, 0, 1, 164])
*/
function numberToBytes$1(value, opts) {
	return hexToBytes$1(numberToHex$2(value, opts));
}
/**
* Encodes a UTF-8 string into a byte array.
*
* - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes
*
* @param value String to encode.
* @param opts Options.
* @returns Byte array value.
*
* @example
* import { stringToBytes } from 'viem'
* const data = stringToBytes('Hello world!')
* // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])
*
* @example
* import { stringToBytes } from 'viem'
* const data = stringToBytes('Hello world!', { size: 32 })
* // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
*/
function stringToBytes$1(value, opts = {}) {
	const bytes = encoder$3.encode(value);
	if (typeof opts.size === "number") {
		assertSize$2(bytes, { size: opts.size });
		return pad$2(bytes, {
			dir: "right",
			size: opts.size
		});
	}
	return bytes;
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/_u64.js
/**
* Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
* @todo re-check https://issues.chromium.org/issues/42212588
* @module
*/
var U32_MASK64$1 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n$1 = /* @__PURE__ */ BigInt(32);
function fromBig$1(n$2, le$7 = false) {
	if (le$7) return {
		h: Number(n$2 & U32_MASK64$1),
		l: Number(n$2 >> _32n$1 & U32_MASK64$1)
	};
	return {
		h: Number(n$2 >> _32n$1 & U32_MASK64$1) | 0,
		l: Number(n$2 & U32_MASK64$1) | 0
	};
}
function split$1(lst, le$7 = false) {
	let Ah = new Uint32Array(lst.length);
	let Al = new Uint32Array(lst.length);
	for (let i$2 = 0; i$2 < lst.length; i$2++) {
		const { h: h$4, l: l$2 } = fromBig$1(lst[i$2], le$7);
		[Ah[i$2], Al[i$2]] = [h$4, l$2];
	}
	return [Ah, Al];
}
var rotlSH$1 = (h$4, l$2, s) => h$4 << s | l$2 >>> 32 - s;
var rotlSL$1 = (h$4, l$2, s) => l$2 << s | h$4 >>> 32 - s;
var rotlBH$1 = (h$4, l$2, s) => l$2 << s - 32 | h$4 >>> 64 - s;
var rotlBL$1 = (h$4, l$2, s) => h$4 << s - 32 | l$2 >>> 64 - s;

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/sha3.js
/**
* SHA3 (keccak) hash function, based on a new "Sponge function" design.
* Different from older hashes, the internal state is bigger than output size.
*
* Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
* [Website](https://keccak.team/keccak.html),
* [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
*
* Check out `sha3-addons` module for cSHAKE, k12, and others.
* @module
*/
var SHA3_PI$1 = [];
var SHA3_ROTL$1 = [];
var _SHA3_IOTA$1 = [];
var _0n$1 = /* @__PURE__ */ BigInt(0);
var _1n$1 = /* @__PURE__ */ BigInt(1);
var _2n$1 = /* @__PURE__ */ BigInt(2);
var _7n$1 = /* @__PURE__ */ BigInt(7);
var _256n$1 = /* @__PURE__ */ BigInt(256);
var _0x71n$1 = /* @__PURE__ */ BigInt(113);
for (let round = 0, R$5 = _1n$1, x$6 = 1, y$6 = 0; round < 24; round++) {
	[x$6, y$6] = [y$6, (2 * x$6 + 3 * y$6) % 5];
	SHA3_PI$1.push(2 * (5 * y$6 + x$6));
	SHA3_ROTL$1.push((round + 1) * (round + 2) / 2 % 64);
	let t = _0n$1;
	for (let j$2 = 0; j$2 < 7; j$2++) {
		R$5 = (R$5 << _1n$1 ^ (R$5 >> _7n$1) * _0x71n$1) % _256n$1;
		if (R$5 & _2n$1) t ^= _1n$1 << (_1n$1 << /* @__PURE__ */ BigInt(j$2)) - _1n$1;
	}
	_SHA3_IOTA$1.push(t);
}
var [SHA3_IOTA_H$1, SHA3_IOTA_L$1] = /* @__PURE__ */ split$1(_SHA3_IOTA$1, true);
var rotlH$1 = (h$4, l$2, s) => s > 32 ? rotlBH$1(h$4, l$2, s) : rotlSH$1(h$4, l$2, s);
var rotlL$1 = (h$4, l$2, s) => s > 32 ? rotlBL$1(h$4, l$2, s) : rotlSL$1(h$4, l$2, s);
/** `keccakf1600` internal function, additionally allows to adjust round count. */
function keccakP$1(s, rounds = 24) {
	const B$4 = new Uint32Array(10);
	for (let round = 24 - rounds; round < 24; round++) {
		for (let x$6 = 0; x$6 < 10; x$6++) B$4[x$6] = s[x$6] ^ s[x$6 + 10] ^ s[x$6 + 20] ^ s[x$6 + 30] ^ s[x$6 + 40];
		for (let x$6 = 0; x$6 < 10; x$6 += 2) {
			const idx1 = (x$6 + 8) % 10;
			const idx0 = (x$6 + 2) % 10;
			const B0 = B$4[idx0];
			const B1 = B$4[idx0 + 1];
			const Th = rotlH$1(B0, B1, 1) ^ B$4[idx1];
			const Tl = rotlL$1(B0, B1, 1) ^ B$4[idx1 + 1];
			for (let y$6 = 0; y$6 < 50; y$6 += 10) {
				s[x$6 + y$6] ^= Th;
				s[x$6 + y$6 + 1] ^= Tl;
			}
		}
		let curH = s[2];
		let curL = s[3];
		for (let t = 0; t < 24; t++) {
			const shift = SHA3_ROTL$1[t];
			const Th = rotlH$1(curH, curL, shift);
			const Tl = rotlL$1(curH, curL, shift);
			const PI = SHA3_PI$1[t];
			curH = s[PI];
			curL = s[PI + 1];
			s[PI] = Th;
			s[PI + 1] = Tl;
		}
		for (let y$6 = 0; y$6 < 50; y$6 += 10) {
			for (let x$6 = 0; x$6 < 10; x$6++) B$4[x$6] = s[y$6 + x$6];
			for (let x$6 = 0; x$6 < 10; x$6++) s[y$6 + x$6] ^= ~B$4[(x$6 + 2) % 10] & B$4[(x$6 + 4) % 10];
		}
		s[0] ^= SHA3_IOTA_H$1[round];
		s[1] ^= SHA3_IOTA_L$1[round];
	}
	B$4.fill(0);
}
/** Keccak sponge function. */
var Keccak$1 = class Keccak$1 extends Hash$2 {
	constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
		super();
		this.blockLen = blockLen;
		this.suffix = suffix;
		this.outputLen = outputLen;
		this.enableXOF = enableXOF;
		this.rounds = rounds;
		this.pos = 0;
		this.posOut = 0;
		this.finished = false;
		this.destroyed = false;
		anumber$1(outputLen);
		if (0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
		this.state = new Uint8Array(200);
		this.state32 = u32$1(this.state);
	}
	keccak() {
		if (!isLE$1) byteSwap32$1(this.state32);
		keccakP$1(this.state32, this.rounds);
		if (!isLE$1) byteSwap32$1(this.state32);
		this.posOut = 0;
		this.pos = 0;
	}
	update(data) {
		aexists$1(this);
		const { blockLen, state: state$2 } = this;
		data = toBytes$3(data);
		const len = data.length;
		for (let pos = 0; pos < len;) {
			const take = Math.min(blockLen - this.pos, len - pos);
			for (let i$2 = 0; i$2 < take; i$2++) state$2[this.pos++] ^= data[pos++];
			if (this.pos === blockLen) this.keccak();
		}
		return this;
	}
	finish() {
		if (this.finished) return;
		this.finished = true;
		const { state: state$2, suffix, pos, blockLen } = this;
		state$2[pos] ^= suffix;
		if ((suffix & 128) !== 0 && pos === blockLen - 1) this.keccak();
		state$2[blockLen - 1] ^= 128;
		this.keccak();
	}
	writeInto(out) {
		aexists$1(this, false);
		abytes$1(out);
		this.finish();
		const bufferOut = this.state;
		const { blockLen } = this;
		for (let pos = 0, len = out.length; pos < len;) {
			if (this.posOut >= blockLen) this.keccak();
			const take = Math.min(blockLen - this.posOut, len - pos);
			out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
			this.posOut += take;
			pos += take;
		}
		return out;
	}
	xofInto(out) {
		if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
		return this.writeInto(out);
	}
	xof(bytes) {
		anumber$1(bytes);
		return this.xofInto(new Uint8Array(bytes));
	}
	digestInto(out) {
		aoutput$1(out, this);
		if (this.finished) throw new Error("digest() was already called");
		this.writeInto(out);
		this.destroy();
		return out;
	}
	digest() {
		return this.digestInto(new Uint8Array(this.outputLen));
	}
	destroy() {
		this.destroyed = true;
		this.state.fill(0);
	}
	_cloneInto(to$3) {
		const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
		to$3 || (to$3 = new Keccak$1(blockLen, suffix, outputLen, enableXOF, rounds));
		to$3.state32.set(this.state32);
		to$3.pos = this.pos;
		to$3.posOut = this.posOut;
		to$3.finished = this.finished;
		to$3.rounds = rounds;
		to$3.suffix = suffix;
		to$3.outputLen = outputLen;
		to$3.enableXOF = enableXOF;
		to$3.destroyed = this.destroyed;
		return to$3;
	}
};
var gen$1 = (suffix, blockLen, outputLen) => wrapConstructor$1(() => new Keccak$1(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */
const sha3_224$1 = /* @__PURE__ */ gen$1(6, 144, 224 / 8);
/** SHA3-256 hash function. Different from keccak-256. */
const sha3_256$1 = /* @__PURE__ */ gen$1(6, 136, 256 / 8);
/** SHA3-384 hash function. */
const sha3_384$1 = /* @__PURE__ */ gen$1(6, 104, 384 / 8);
/** SHA3-512 hash function. */
const sha3_512$1 = /* @__PURE__ */ gen$1(6, 72, 512 / 8);
/** keccak-224 hash function. */
const keccak_224$1 = /* @__PURE__ */ gen$1(1, 144, 224 / 8);
/** keccak-256 hash function. Different from SHA3-256. */
const keccak_256$1 = /* @__PURE__ */ gen$1(1, 136, 256 / 8);
/** keccak-384 hash function. */
const keccak_384$1 = /* @__PURE__ */ gen$1(1, 104, 384 / 8);
/** keccak-512 hash function. */
const keccak_512$1 = /* @__PURE__ */ gen$1(1, 72, 512 / 8);
var genShake$1 = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts$1((opts = {}) => new Keccak$1(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */
const shake128$1 = /* @__PURE__ */ genShake$1(31, 168, 128 / 8);
/** SHAKE256 XOF with 256-bit security. */
const shake256$1 = /* @__PURE__ */ genShake$1(31, 136, 256 / 8);

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256$1(value, to_) {
	const to$3 = to_ || "hex";
	const bytes = keccak_256$1(isHex$2(value, { strict: false }) ? toBytes$2(value) : value);
	if (to$3 === "bytes") return bytes;
	return toHex$2(bytes);
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/lru.js
/**
* Map with a LRU (Least recently used) policy.
*
* @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
*/
var LruMap$2 = class extends Map {
	constructor(size$4) {
		super();
		Object.defineProperty(this, "maxSize", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		this.maxSize = size$4;
	}
	get(key) {
		const value = super.get(key);
		if (super.has(key) && value !== void 0) {
			this.delete(key);
			super.set(key, value);
		}
		return value;
	}
	set(key, value) {
		super.set(key, value);
		if (this.maxSize && this.size > this.maxSize) {
			const firstKey = this.keys().next().value;
			if (firstKey) this.delete(firstKey);
		}
		return this;
	}
};

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/getAddress.js
var checksumAddressCache$1 = /* @__PURE__ */ new LruMap$2(8192);
function checksumAddress$1(address_, chainId) {
	if (checksumAddressCache$1.has(`${address_}.${chainId}`)) return checksumAddressCache$1.get(`${address_}.${chainId}`);
	const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
	const hash = keccak256$1(stringToBytes$1(hexAddress), "bytes");
	const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
	for (let i$2 = 0; i$2 < 40; i$2 += 2) {
		if (hash[i$2 >> 1] >> 4 >= 8 && address[i$2]) address[i$2] = address[i$2].toUpperCase();
		if ((hash[i$2 >> 1] & 15) >= 8 && address[i$2 + 1]) address[i$2 + 1] = address[i$2 + 1].toUpperCase();
	}
	const result = `0x${address.join("")}`;
	checksumAddressCache$1.set(`${address_}.${chainId}`, result);
	return result;
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
/**
* @description Converts an ECDSA public key to an address.
*
* @param publicKey The public key to convert.
*
* @returns The address.
*/
function publicKeyToAddress$1(publicKey) {
	return checksumAddress$1(`0x${keccak256$1(`0x${publicKey.substring(4)}`).substring(26)}`);
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey$1({ hash, signature }) {
	const hashHex = isHex$2(hash) ? hash : toHex$2(hash);
	const { secp256k1 } = await import("./secp256k1-C_4w9QvT.js");
	return `0x${(() => {
		if (typeof signature === "object" && "r" in signature && "s" in signature) {
			const { r: r$1, s, v: v$5, yParity } = signature;
			const recoveryBit$1 = toRecoveryBit$1(Number(yParity ?? v$5));
			return new secp256k1.Signature(hexToBigInt$1(r$1), hexToBigInt$1(s)).addRecoveryBit(recoveryBit$1);
		}
		const signatureHex = isHex$2(signature) ? signature : toHex$2(signature);
		const recoveryBit = toRecoveryBit$1(hexToNumber$1(`0x${signatureHex.slice(130)}`));
		return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
	})().recoverPublicKey(hashHex.substring(2)).toHex(false)}`;
}
function toRecoveryBit$1(yParityOrV) {
	if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV;
	if (yParityOrV === 27) return 0;
	if (yParityOrV === 28) return 1;
	throw new Error("Invalid yParityOrV value");
}

//#endregion
//#region node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress$1({ hash, signature }) {
	return publicKeyToAddress$1(await recoverPublicKey$1({
		hash,
		signature
	}));
}

//#endregion
//#region node_modules/@walletconnect/utils/dist/index.es.js
var import_cjs$9 = require_cjs();
var import_cjs$10 = require_cjs$1();
var import_cjs$11 = require_cjs$2();
var import_elliptic$1 = require_elliptic();
var Pe$3 = ":";
function Ye$3(e) {
	const [t, n$2] = e.split(Pe$3);
	return {
		namespace: t,
		reference: n$2
	};
}
function Xe(e) {
	const [t, n$2, r$1] = e.split(Pe$3);
	return {
		namespace: t,
		reference: n$2,
		address: r$1
	};
}
function Le$7(e, t) {
	return e.includes(":") ? [e] : t.chains || [];
}
var Ft$5 = "ReactNative", H$4 = {
	reactNative: "react-native",
	node: "node",
	browser: "browser",
	unknown: "unknown"
}, Be$7 = " ", qr$1 = ":", qt$5 = "/", Qe$4 = 2, Gr$4 = 1e3, Gt$5 = "js";
function et$3() {
	return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function ne$3() {
	return !(0, import_cjs$10.getDocument)() && !!(0, import_cjs$10.getNavigator)() && navigator.product === Ft$5;
}
function Wr$3() {
	return ne$3() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function zr$3() {
	return ne$3() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Ae$3() {
	return !et$3() && !!(0, import_cjs$10.getNavigator)() && !!(0, import_cjs$10.getDocument)();
}
function ue$5() {
	return ne$3() ? H$4.reactNative : et$3() ? H$4.node : Ae$3() ? H$4.browser : H$4.unknown;
}
function Jr$3() {
	var e;
	try {
		return ne$3() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
	} catch {
		return;
	}
}
function Wt$5(e, t) {
	const n$2 = new URLSearchParams(e);
	for (const r$1 of Object.keys(t).sort()) if (t.hasOwnProperty(r$1)) {
		const o$2 = t[r$1];
		o$2 !== void 0 && n$2.set(r$1, o$2);
	}
	return n$2.toString();
}
function Yr$3() {
	return (0, import_cjs$11.getWindowMetadata)() || {
		name: "",
		description: "",
		url: "",
		icons: [""]
	};
}
function zt$5() {
	if (ue$5() === H$4.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
		const { OS: n$2, Version: r$1 } = global.Platform;
		return [n$2, r$1].join("-");
	}
	const e = detect();
	if (e === null) return "unknown";
	const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
	return e.type === "browser" ? [
		t,
		e.name,
		e.version
	].join("-") : [t, e.version].join("-");
}
function Jt$5() {
	var e;
	const t = ue$5();
	return t === H$4.browser ? [t, ((e = (0, import_cjs$10.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : t;
}
function Yt$4(e, t, n$2) {
	const r$1 = zt$5(), o$2 = Jt$5();
	return [
		[e, t].join("-"),
		[Gt$5, n$2].join("-"),
		r$1,
		o$2
	].join("/");
}
function Zr$2({ protocol: e, version: t, relayUrl: n$2, sdkVersion: r$1, auth: o$2, projectId: s, useOnCloseEvent: i$2, bundleId: c$3, packageName: u$2 }) {
	const a$1 = n$2.split("?"), f$7 = {
		auth: o$2,
		ua: Yt$4(e, t, r$1),
		projectId: s,
		useOnCloseEvent: i$2 || void 0,
		packageName: u$2 || void 0,
		bundleId: c$3 || void 0
	}, d$4 = Wt$5(a$1[1] || "", f$7);
	return a$1[0] + "?" + d$4;
}
function re$5(e, t) {
	return e.filter((n$2) => t.includes(n$2)).length === e.length;
}
function no$2(e) {
	return Object.fromEntries(e.entries());
}
function ro$3(e) {
	return new Map(Object.entries(e));
}
function co$3(e = import_cjs$9.FIVE_MINUTES, t) {
	const n$2 = (0, import_cjs$9.toMiliseconds)(e || import_cjs$9.FIVE_MINUTES);
	let r$1, o$2, s, i$2;
	return {
		resolve: (c$3) => {
			s && r$1 && (clearTimeout(s), r$1(c$3), i$2 = Promise.resolve(c$3));
		},
		reject: (c$3) => {
			s && o$2 && (clearTimeout(s), o$2(c$3));
		},
		done: () => new Promise((c$3, u$2) => {
			if (i$2) return c$3(i$2);
			s = setTimeout(() => {
				const a$1 = new Error(t);
				i$2 = Promise.reject(a$1), u$2(a$1);
			}, n$2), r$1 = c$3, o$2 = u$2;
		})
	};
}
function ao$3(e, t, n$2) {
	return new Promise(async (r$1, o$2) => {
		const s = setTimeout(() => o$2(new Error(n$2)), t);
		try {
			r$1(await e);
		} catch (i$2) {
			o$2(i$2);
		}
		clearTimeout(s);
	});
}
function tt$4(e, t) {
	if (typeof t == "string" && t.startsWith(`${e}:`)) return t;
	if (e.toLowerCase() === "topic") {
		if (typeof t != "string") throw new Error("Value must be \"string\" for expirer target type: topic");
		return `topic:${t}`;
	} else if (e.toLowerCase() === "id") {
		if (typeof t != "number") throw new Error("Value must be \"number\" for expirer target type: id");
		return `id:${t}`;
	}
	throw new Error(`Unknown expirer target type: ${e}`);
}
function uo$3(e) {
	return tt$4("topic", e);
}
function fo$3(e) {
	return tt$4("id", e);
}
function lo$3(e) {
	const [t, n$2] = e.split(":"), r$1 = {
		id: void 0,
		topic: void 0
	};
	if (t === "topic" && typeof n$2 == "string") r$1.topic = n$2;
	else if (t === "id" && Number.isInteger(Number(n$2))) r$1.id = Number(n$2);
	else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n$2}`);
	return r$1;
}
function ho$3(e, t) {
	return (0, import_cjs$9.fromMiliseconds)((t || Date.now()) + (0, import_cjs$9.toMiliseconds)(e));
}
function po$3(e) {
	return Date.now() >= (0, import_cjs$9.toMiliseconds)(e);
}
function go$3(e, t) {
	return `${e}${t ? `:${t}` : ""}`;
}
function Q$2(e = [], t = []) {
	return [...new Set([...e, ...t])];
}
async function yo$3({ id: e, topic: t, wcDeepLink: n$2 }) {
	var r$1;
	try {
		if (!n$2) return;
		const s = (typeof n$2 == "string" ? JSON.parse(n$2) : n$2)?.href;
		if (typeof s != "string") return;
		const i$2 = en$4(s, e, t), c$3 = ue$5();
		if (c$3 === H$4.browser) {
			if (!((r$1 = (0, import_cjs$10.getDocument)()) != null && r$1.hasFocus())) {
				console.warn("Document does not have focus, skipping deeplink.");
				return;
			}
			tn$4(i$2);
		} else c$3 === H$4.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i$2);
	} catch (o$2) {
		console.error(o$2);
	}
}
function en$4(e, t, n$2) {
	const r$1 = `requestId=${t}&sessionTopic=${n$2}`;
	e.endsWith("/") && (e = e.slice(0, -1));
	let o$2 = `${e}`;
	if (e.startsWith("https://t.me")) {
		const s = e.includes("?") ? "&startapp=" : "?startapp=";
		o$2 = `${o$2}${s}${on$4(r$1, !0)}`;
	} else o$2 = `${o$2}/wc?${r$1}`;
	return o$2;
}
function tn$4(e) {
	let t = "_self";
	rn$4() ? t = "_top" : (nn$4() || e.startsWith("https://") || e.startsWith("http://")) && (t = "_blank"), window.open(e, t, "noreferrer noopener");
}
async function mo$3(e, t) {
	let n$2 = "";
	try {
		if (Ae$3() && (n$2 = localStorage.getItem(t), n$2)) return n$2;
		n$2 = await e.getItem(t);
	} catch (r$1) {
		console.error(r$1);
	}
	return n$2;
}
function bo$3(e, t) {
	if (!e.includes(t)) return null;
	const n$2 = e.split(/([&,?,=])/);
	return n$2[n$2.indexOf(t) + 2];
}
function wo$3() {
	return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
		const t = Math.random() * 16 | 0;
		return (e === "x" ? t : t & 3 | 8).toString(16);
	});
}
function Eo$3() {
	return typeof process < "u" && process.env.IS_VITEST === "true";
}
function nn$4() {
	return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function rn$4() {
	try {
		return window.self !== window.top;
	} catch {
		return !1;
	}
}
function on$4(e, t = !1) {
	const n$2 = Buffer.from(e).toString("base64");
	return t ? n$2.replace(/[=]/g, "") : n$2;
}
function rt$3(e) {
	return Buffer.from(e, "base64").toString("utf-8");
}
function vo$3(e) {
	return new Promise((t) => setTimeout(t, e));
}
function Ne$4(e) {
	if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function xo$3(e) {
	return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function je$5(e, ...t) {
	if (!xo$3(e)) throw new Error("Uint8Array expected");
	if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function ot$3(e) {
	if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
	Ne$4(e.outputLen), Ne$4(e.blockLen);
}
function me$5(e, t = !0) {
	if (e.destroyed) throw new Error("Hash instance has been destroyed");
	if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function sn$5(e, t) {
	je$5(e);
	const n$2 = t.outputLen;
	if (e.length < n$2) throw new Error("digestInto() expects output buffer of length at least " + n$2);
}
var Ce$4 = BigInt(2 ** 32 - 1), cn$3 = BigInt(32);
function Oo$3(e, t = !1) {
	return t ? {
		h: Number(e & Ce$4),
		l: Number(e >> cn$3 & Ce$4)
	} : {
		h: Number(e >> cn$3 & Ce$4) | 0,
		l: Number(e & Ce$4) | 0
	};
}
function Io$3(e, t = !1) {
	let n$2 = new Uint32Array(e.length), r$1 = new Uint32Array(e.length);
	for (let o$2 = 0; o$2 < e.length; o$2++) {
		const { h: s, l: i$2 } = Oo$3(e[o$2], t);
		[n$2[o$2], r$1[o$2]] = [s, i$2];
	}
	return [n$2, r$1];
}
var Ao$3 = (e, t, n$2) => e << n$2 | t >>> 32 - n$2, No$3 = (e, t, n$2) => t << n$2 | e >>> 32 - n$2, So$3 = (e, t, n$2) => t << n$2 - 32 | e >>> 64 - n$2, Uo$3 = (e, t, n$2) => e << n$2 - 32 | t >>> 64 - n$2, be$4 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function _o$3(e) {
	return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
}
function st$3(e) {
	return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function J$7(e, t) {
	return e << 32 - t | e >>> t;
}
var an$3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function To$2(e) {
	return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
}
function un$4(e) {
	for (let t = 0; t < e.length; t++) e[t] = To$2(e[t]);
}
function $o$3(e) {
	if (typeof e != "string") throw new Error("utf8ToBytes expected string, got " + typeof e);
	return new Uint8Array(new TextEncoder().encode(e));
}
function we$5(e) {
	return typeof e == "string" && (e = $o$3(e)), je$5(e), e;
}
var it$4 = class {
	clone() {
		return this._cloneInto();
	}
};
function fn$4(e) {
	const t = (r$1) => e().update(we$5(r$1)).digest(), n$2 = e();
	return t.outputLen = n$2.outputLen, t.blockLen = n$2.blockLen, t.create = () => e(), t;
}
function Se$5(e = 32) {
	if (be$4 && typeof be$4.getRandomValues == "function") return be$4.getRandomValues(new Uint8Array(e));
	if (be$4 && typeof be$4.randomBytes == "function") return be$4.randomBytes(e);
	throw new Error("crypto.getRandomValues must be defined");
}
var ln$3 = [], dn$3 = [], hn$4 = [], Ro$2 = BigInt(0), Ue$7 = BigInt(1), Po$3 = BigInt(2), Lo$3 = BigInt(7), Bo$2 = BigInt(256), jo$2 = BigInt(113);
for (let e = 0, t = Ue$7, n$2 = 1, r$1 = 0; e < 24; e++) {
	[n$2, r$1] = [r$1, (2 * n$2 + 3 * r$1) % 5], ln$3.push(2 * (5 * r$1 + n$2)), dn$3.push((e + 1) * (e + 2) / 2 % 64);
	let o$2 = Ro$2;
	for (let s = 0; s < 7; s++) t = (t << Ue$7 ^ (t >> Lo$3) * jo$2) % Bo$2, t & Po$3 && (o$2 ^= Ue$7 << (Ue$7 << BigInt(s)) - Ue$7);
	hn$4.push(o$2);
}
var [Co$3, ko$2] = Io$3(hn$4, !0), pn$4 = (e, t, n$2) => n$2 > 32 ? So$3(e, t, n$2) : Ao$3(e, t, n$2), gn$4 = (e, t, n$2) => n$2 > 32 ? Uo$3(e, t, n$2) : No$3(e, t, n$2);
function Do$3(e, t = 24) {
	const n$2 = new Uint32Array(10);
	for (let r$1 = 24 - t; r$1 < 24; r$1++) {
		for (let i$2 = 0; i$2 < 10; i$2++) n$2[i$2] = e[i$2] ^ e[i$2 + 10] ^ e[i$2 + 20] ^ e[i$2 + 30] ^ e[i$2 + 40];
		for (let i$2 = 0; i$2 < 10; i$2 += 2) {
			const c$3 = (i$2 + 8) % 10, u$2 = (i$2 + 2) % 10, a$1 = n$2[u$2], l$2 = n$2[u$2 + 1], f$7 = pn$4(a$1, l$2, 1) ^ n$2[c$3], d$4 = gn$4(a$1, l$2, 1) ^ n$2[c$3 + 1];
			for (let g$2 = 0; g$2 < 50; g$2 += 10) e[i$2 + g$2] ^= f$7, e[i$2 + g$2 + 1] ^= d$4;
		}
		let o$2 = e[2], s = e[3];
		for (let i$2 = 0; i$2 < 24; i$2++) {
			const c$3 = dn$3[i$2], u$2 = pn$4(o$2, s, c$3), a$1 = gn$4(o$2, s, c$3), l$2 = ln$3[i$2];
			o$2 = e[l$2], s = e[l$2 + 1], e[l$2] = u$2, e[l$2 + 1] = a$1;
		}
		for (let i$2 = 0; i$2 < 50; i$2 += 10) {
			for (let c$3 = 0; c$3 < 10; c$3++) n$2[c$3] = e[i$2 + c$3];
			for (let c$3 = 0; c$3 < 10; c$3++) e[i$2 + c$3] ^= ~n$2[(c$3 + 2) % 10] & n$2[(c$3 + 4) % 10];
		}
		e[0] ^= Co$3[r$1], e[1] ^= ko$2[r$1];
	}
	n$2.fill(0);
}
var Bt$5 = class Bt$5 extends it$4 {
	constructor(t, n$2, r$1, o$2 = !1, s = 24) {
		if (super(), this.blockLen = t, this.suffix = n$2, this.outputLen = r$1, this.enableXOF = o$2, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Ne$4(r$1), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
		this.state = new Uint8Array(200), this.state32 = _o$3(this.state);
	}
	keccak() {
		an$3 || un$4(this.state32), Do$3(this.state32, this.rounds), an$3 || un$4(this.state32), this.posOut = 0, this.pos = 0;
	}
	update(t) {
		me$5(this);
		const { blockLen: n$2, state: r$1 } = this;
		t = we$5(t);
		const o$2 = t.length;
		for (let s = 0; s < o$2;) {
			const i$2 = Math.min(n$2 - this.pos, o$2 - s);
			for (let c$3 = 0; c$3 < i$2; c$3++) r$1[this.pos++] ^= t[s++];
			this.pos === n$2 && this.keccak();
		}
		return this;
	}
	finish() {
		if (this.finished) return;
		this.finished = !0;
		const { state: t, suffix: n$2, pos: r$1, blockLen: o$2 } = this;
		t[r$1] ^= n$2, n$2 & 128 && r$1 === o$2 - 1 && this.keccak(), t[o$2 - 1] ^= 128, this.keccak();
	}
	writeInto(t) {
		me$5(this, !1), je$5(t), this.finish();
		const n$2 = this.state, { blockLen: r$1 } = this;
		for (let o$2 = 0, s = t.length; o$2 < s;) {
			this.posOut >= r$1 && this.keccak();
			const i$2 = Math.min(r$1 - this.posOut, s - o$2);
			t.set(n$2.subarray(this.posOut, this.posOut + i$2), o$2), this.posOut += i$2, o$2 += i$2;
		}
		return t;
	}
	xofInto(t) {
		if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
		return this.writeInto(t);
	}
	xof(t) {
		return Ne$4(t), this.xofInto(new Uint8Array(t));
	}
	digestInto(t) {
		if (sn$5(t, this), this.finished) throw new Error("digest() was already called");
		return this.writeInto(t), this.destroy(), t;
	}
	digest() {
		return this.digestInto(new Uint8Array(this.outputLen));
	}
	destroy() {
		this.destroyed = !0, this.state.fill(0);
	}
	_cloneInto(t) {
		const { blockLen: n$2, suffix: r$1, outputLen: o$2, rounds: s, enableXOF: i$2 } = this;
		return t || (t = new Bt$5(n$2, r$1, o$2, i$2, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = r$1, t.outputLen = o$2, t.enableXOF = i$2, t.destroyed = this.destroyed, t;
	}
};
var Mo$3 = (e, t, n$2) => fn$4(() => new Bt$5(t, e, n$2)), Vo$3 = Mo$3(1, 136, 256 / 8), Ho$3 = "https://rpc.walletconnect.org/v1";
function ct$3(e) {
	const t = `Ethereum Signed Message:
${e.length}`, n$2 = new TextEncoder().encode(t + e);
	return "0x" + Buffer.from(Vo$3(n$2)).toString("hex");
}
async function yn$3(e, t, n$2, r$1, o$2, s) {
	switch (n$2.t) {
		case "eip191": return await mn$4(e, t, n$2.s);
		case "eip1271": return await bn$4(e, t, n$2.s, r$1, o$2, s);
		default: throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n$2.t}`);
	}
}
async function mn$4(e, t, n$2) {
	return (await recoverAddress$1({
		hash: ct$3(t),
		signature: n$2
	})).toLowerCase() === e.toLowerCase();
}
async function bn$4(e, t, n$2, r$1, o$2, s) {
	const i$2 = Ye$3(r$1);
	if (!i$2.namespace || !i$2.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r$1}`);
	try {
		const c$3 = "0x1626ba7e", u$2 = "0000000000000000000000000000000000000000000000000000000000000040", a$1 = "0000000000000000000000000000000000000000000000000000000000000041", l$2 = n$2.substring(2), d$4 = c$3 + ct$3(t).substring(2) + u$2 + a$1 + l$2, { result: y$6 } = await (await fetch(`${s || Ho$3}/?chainId=${r$1}&projectId=${o$2}`, {
			method: "POST",
			body: JSON.stringify({
				id: Ko$3(),
				jsonrpc: "2.0",
				method: "eth_call",
				params: [{
					to: e,
					data: d$4
				}, "latest"]
			})
		})).json();
		return y$6 ? y$6.slice(0, 10).toLowerCase() === c$3.toLowerCase() : !1;
	} catch (c$3) {
		return console.error("isValidEip1271Signature: ", c$3), !1;
	}
}
function Ko$3() {
	return Date.now() + Math.floor(Math.random() * 1e3);
}
var Fo$3 = Object.defineProperty, qo$2 = Object.defineProperties, Go$2 = Object.getOwnPropertyDescriptors, wn$4 = Object.getOwnPropertySymbols, Wo$3 = Object.prototype.hasOwnProperty, zo$2 = Object.prototype.propertyIsEnumerable, En$4 = (e, t, n$2) => t in e ? Fo$3(e, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: n$2
}) : e[t] = n$2, at$3 = (e, t) => {
	for (var n$2 in t || (t = {})) Wo$3.call(t, n$2) && En$4(e, n$2, t[n$2]);
	if (wn$4) for (var n$2 of wn$4(t)) zo$2.call(t, n$2) && En$4(e, n$2, t[n$2]);
	return e;
}, vn$4 = (e, t) => qo$2(e, Go$2(t));
var Jo$3 = "did:pkh:", ke$7 = (e) => e?.split(":"), xn$4 = (e) => {
	const t = e && ke$7(e);
	if (t) return e.includes(Jo$3) ? t[3] : t[1];
}, On$3 = (e) => {
	const t = e && ke$7(e);
	if (t) return t[2] + ":" + t[3];
}, ut$4 = (e) => {
	const t = e && ke$7(e);
	if (t) return t.pop();
};
async function Yo$3(e) {
	const { cacao: t, projectId: n$2 } = e, { s: r$1, p: o$2 } = t, s = In$3(o$2, o$2.iss);
	return await yn$3(ut$4(o$2.iss), s, r$1, On$3(o$2.iss), n$2);
}
var In$3 = (e, t) => {
	const n$2 = `${e.domain} wants you to sign in with your Ethereum account:`, r$1 = ut$4(t);
	if (!e.aud && !e.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
	let o$2 = e.statement || void 0;
	const s = `URI: ${e.aud || e.uri}`, i$2 = `Version: ${e.version}`, c$3 = `Chain ID: ${xn$4(t)}`, u$2 = `Nonce: ${e.nonce}`, a$1 = `Issued At: ${e.iat}`, l$2 = e.exp ? `Expiration Time: ${e.exp}` : void 0, f$7 = e.nbf ? `Not Before: ${e.nbf}` : void 0, d$4 = e.requestId ? `Request ID: ${e.requestId}` : void 0, g$2 = e.resources ? `Resources:${e.resources.map((h$4) => `
- ${h$4}`).join("")}` : void 0, y$6 = Me$5(e.resources);
	if (y$6) {
		const h$4 = oe$3(y$6);
		o$2 = dt$5(o$2, h$4);
	}
	return [
		n$2,
		r$1,
		"",
		o$2,
		"",
		s,
		i$2,
		c$3,
		u$2,
		a$1,
		l$2,
		f$7,
		d$4,
		g$2
	].filter((h$4) => h$4 != null).join(`
`);
};
function Un$4(e) {
	return Buffer.from(JSON.stringify(e)).toString("base64");
}
function _n$4(e) {
	return JSON.parse(Buffer.from(e, "base64").toString("utf-8"));
}
function Y$4(e) {
	if (!e) throw new Error("No recap provided, value is undefined");
	if (!e.att) throw new Error("No `att` property found");
	const t = Object.keys(e.att);
	if (!(t != null && t.length)) throw new Error("No resources found in `att` property");
	t.forEach((n$2) => {
		const r$1 = e.att[n$2];
		if (Array.isArray(r$1)) throw new Error(`Resource must be an object: ${n$2}`);
		if (typeof r$1 != "object") throw new Error(`Resource must be an object: ${n$2}`);
		if (!Object.keys(r$1).length) throw new Error(`Resource object is empty: ${n$2}`);
		Object.keys(r$1).forEach((o$2) => {
			const s = r$1[o$2];
			if (!Array.isArray(s)) throw new Error(`Ability limits ${o$2} must be an array of objects, found: ${s}`);
			if (!s.length) throw new Error(`Value of ${o$2} is empty array, must be an array with objects`);
			s.forEach((i$2) => {
				if (typeof i$2 != "object") throw new Error(`Ability limits (${o$2}) must be an array of objects, found: ${i$2}`);
			});
		});
	});
}
function Tn$4(e, t, n$2, r$1 = {}) {
	return n$2?.sort((o$2, s) => o$2.localeCompare(s)), { att: { [e]: ft$4(t, n$2, r$1) } };
}
function ft$4(e, t, n$2 = {}) {
	t = t?.sort((o$2, s) => o$2.localeCompare(s));
	const r$1 = t.map((o$2) => ({ [`${e}/${o$2}`]: [n$2] }));
	return Object.assign({}, ...r$1);
}
function De$5(e) {
	return Y$4(e), `urn:recap:${Un$4(e).replace(/=/g, "")}`;
}
function oe$3(e) {
	const t = _n$4(e.replace("urn:recap:", ""));
	return Y$4(t), t;
}
function ts$2(e, t, n$2) {
	return De$5(Tn$4(e, t, n$2));
}
function lt$3(e) {
	return e && e.includes("urn:recap:");
}
function ns$1(e, t) {
	return De$5(Rn$4(oe$3(e), oe$3(t)));
}
function Rn$4(e, t) {
	Y$4(e), Y$4(t);
	const n$2 = Object.keys(e.att).concat(Object.keys(t.att)).sort((o$2, s) => o$2.localeCompare(s)), r$1 = { att: {} };
	return n$2.forEach((o$2) => {
		var s, i$2;
		Object.keys(((s = e.att) == null ? void 0 : s[o$2]) || {}).concat(Object.keys(((i$2 = t.att) == null ? void 0 : i$2[o$2]) || {})).sort((c$3, u$2) => c$3.localeCompare(u$2)).forEach((c$3) => {
			var u$2, a$1;
			r$1.att[o$2] = vn$4(at$3({}, r$1.att[o$2]), { [c$3]: ((u$2 = e.att[o$2]) == null ? void 0 : u$2[c$3]) || ((a$1 = t.att[o$2]) == null ? void 0 : a$1[c$3]) });
		});
	}), r$1;
}
function dt$5(e = "", t) {
	Y$4(t);
	const n$2 = "I further authorize the stated URI to perform the following actions on my behalf: ";
	if (e.includes(n$2)) return e;
	const r$1 = [];
	let o$2 = 0;
	Object.keys(t.att).forEach((c$3) => {
		const u$2 = Object.keys(t.att[c$3]).map((f$7) => ({
			ability: f$7.split("/")[0],
			action: f$7.split("/")[1]
		}));
		u$2.sort((f$7, d$4) => f$7.action.localeCompare(d$4.action));
		const a$1 = {};
		u$2.forEach((f$7) => {
			a$1[f$7.ability] || (a$1[f$7.ability] = []), a$1[f$7.ability].push(f$7.action);
		});
		const l$2 = Object.keys(a$1).map((f$7) => (o$2++, `(${o$2}) '${f$7}': '${a$1[f$7].join("', '")}' for '${c$3}'.`));
		r$1.push(l$2.join(", ").replace(".,", "."));
	});
	const i$2 = `${n$2}${r$1.join(" ")}`;
	return `${e ? e + " " : ""}${i$2}`;
}
function rs$2(e) {
	var t;
	const n$2 = oe$3(e);
	Y$4(n$2);
	const r$1 = (t = n$2.att) == null ? void 0 : t.eip155;
	return r$1 ? Object.keys(r$1).map((o$2) => o$2.split("/")[1]) : [];
}
function os$2(e) {
	const t = oe$3(e);
	Y$4(t);
	const n$2 = [];
	return Object.values(t.att).forEach((r$1) => {
		Object.values(r$1).forEach((o$2) => {
			var s;
			(s = o$2?.[0]) != null && s.chains && n$2.push(o$2[0].chains);
		});
	}), [...new Set(n$2.flat())];
}
function Me$5(e) {
	if (!e) return;
	const t = e?.[e.length - 1];
	return lt$3(t) ? t : void 0;
}
function ht$5(e) {
	if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function Ln$4(e) {
	return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function F$5(e, ...t) {
	if (!Ln$4(e)) throw new Error("Uint8Array expected");
	if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function Bn$4(e, t = !0) {
	if (e.destroyed) throw new Error("Hash instance has been destroyed");
	if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function ss$2(e, t) {
	F$5(e);
	const n$2 = t.outputLen;
	if (e.length < n$2) throw new Error("digestInto() expects output buffer of length at least " + n$2);
}
function jn$4(e) {
	if (typeof e != "boolean") throw new Error(`boolean expected, not ${e}`);
}
var se$5 = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), is$2 = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
if (!(new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)) throw new Error("Non little-endian hardware is not supported");
function as$2(e) {
	if (typeof e != "string") throw new Error("string expected");
	return new Uint8Array(new TextEncoder().encode(e));
}
function pt$5(e) {
	if (typeof e == "string") e = as$2(e);
	else if (Ln$4(e)) e = gt$5(e);
	else throw new Error("Uint8Array expected, got " + typeof e);
	return e;
}
function us$1(e, t) {
	if (t == null || typeof t != "object") throw new Error("options must be defined");
	return Object.assign(e, t);
}
function fs$4(e, t) {
	if (e.length !== t.length) return !1;
	let n$2 = 0;
	for (let r$1 = 0; r$1 < e.length; r$1++) n$2 |= e[r$1] ^ t[r$1];
	return n$2 === 0;
}
var ls$4 = (e, t) => {
	function n$2(r$1, ...o$2) {
		if (F$5(r$1), e.nonceLength !== void 0) {
			const l$2 = o$2[0];
			if (!l$2) throw new Error("nonce / iv required");
			e.varSizeNonce ? F$5(l$2) : F$5(l$2, e.nonceLength);
		}
		const s = e.tagLength;
		s && o$2[1] !== void 0 && F$5(o$2[1]);
		const i$2 = t(r$1, ...o$2), c$3 = (l$2, f$7) => {
			if (f$7 !== void 0) {
				if (l$2 !== 2) throw new Error("cipher output not supported");
				F$5(f$7);
			}
		};
		let u$2 = !1;
		return {
			encrypt(l$2, f$7) {
				if (u$2) throw new Error("cannot encrypt() twice with same key + nonce");
				return u$2 = !0, F$5(l$2), c$3(i$2.encrypt.length, f$7), i$2.encrypt(l$2, f$7);
			},
			decrypt(l$2, f$7) {
				if (F$5(l$2), s && l$2.length < s) throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
				return c$3(i$2.decrypt.length, f$7), i$2.decrypt(l$2, f$7);
			}
		};
	}
	return Object.assign(n$2, e), n$2;
};
function Cn$4(e, t, n$2 = !0) {
	if (t === void 0) return new Uint8Array(e);
	if (t.length !== e) throw new Error("invalid output length, expected " + e + ", got: " + t.length);
	if (n$2 && !ds$2(t)) throw new Error("invalid output, must be aligned");
	return t;
}
function kn$4(e, t, n$2, r$1) {
	if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n$2, r$1);
	const o$2 = BigInt(32), s = BigInt(4294967295), i$2 = Number(n$2 >> o$2 & s), c$3 = Number(n$2 & s), u$2 = r$1 ? 4 : 0, a$1 = r$1 ? 0 : 4;
	e.setUint32(t + u$2, i$2, r$1), e.setUint32(t + a$1, c$3, r$1);
}
function ds$2(e) {
	return e.byteOffset % 4 === 0;
}
function gt$5(e) {
	return Uint8Array.from(e);
}
function Ee$7(...e) {
	for (let t = 0; t < e.length; t++) e[t].fill(0);
}
var Dn$4 = (e) => Uint8Array.from(e.split("").map((t) => t.charCodeAt(0))), hs$2 = Dn$4("expand 16-byte k"), ps$3 = Dn$4("expand 32-byte k"), gs$3 = se$5(hs$2), ys$4 = se$5(ps$3);
function x$5(e, t) {
	return e << t | e >>> 32 - t;
}
function yt$4(e) {
	return e.byteOffset % 4 === 0;
}
var Ve$5 = 64, ms$4 = 16, Mn$4 = 2 ** 32 - 1, Vn$4 = new Uint32Array();
function bs$4(e, t, n$2, r$1, o$2, s, i$2, c$3) {
	const u$2 = o$2.length, a$1 = new Uint8Array(Ve$5), l$2 = se$5(a$1), f$7 = yt$4(o$2) && yt$4(s), d$4 = f$7 ? se$5(o$2) : Vn$4, g$2 = f$7 ? se$5(s) : Vn$4;
	for (let y$6 = 0; y$6 < u$2; i$2++) {
		if (e(t, n$2, r$1, l$2, i$2, c$3), i$2 >= Mn$4) throw new Error("arx: counter overflow");
		const h$4 = Math.min(Ve$5, u$2 - y$6);
		if (f$7 && h$4 === Ve$5) {
			const m$2 = y$6 / 4;
			if (y$6 % 4 !== 0) throw new Error("arx: invalid block position");
			for (let B$4 = 0, b$3; B$4 < ms$4; B$4++) b$3 = m$2 + B$4, g$2[b$3] = d$4[b$3] ^ l$2[B$4];
			y$6 += Ve$5;
			continue;
		}
		for (let m$2 = 0, B$4; m$2 < h$4; m$2++) B$4 = y$6 + m$2, s[B$4] = o$2[B$4] ^ a$1[m$2];
		y$6 += h$4;
	}
}
function ws$3(e, t) {
	const { allowShortKeys: n$2, extendNonceFn: r$1, counterLength: o$2, counterRight: s, rounds: i$2 } = us$1({
		allowShortKeys: !1,
		counterLength: 8,
		counterRight: !1,
		rounds: 20
	}, t);
	if (typeof e != "function") throw new Error("core must be a function");
	return ht$5(o$2), ht$5(i$2), jn$4(s), jn$4(n$2), (c$3, u$2, a$1, l$2, f$7 = 0) => {
		F$5(c$3), F$5(u$2), F$5(a$1);
		const d$4 = a$1.length;
		if (l$2 === void 0 && (l$2 = new Uint8Array(d$4)), F$5(l$2), ht$5(f$7), f$7 < 0 || f$7 >= Mn$4) throw new Error("arx: counter overflow");
		if (l$2.length < d$4) throw new Error(`arx: output (${l$2.length}) is shorter than data (${d$4})`);
		const g$2 = [];
		let y$6 = c$3.length, h$4, m$2;
		if (y$6 === 32) g$2.push(h$4 = gt$5(c$3)), m$2 = ys$4;
		else if (y$6 === 16 && n$2) h$4 = new Uint8Array(32), h$4.set(c$3), h$4.set(c$3, 16), m$2 = gs$3, g$2.push(h$4);
		else throw new Error(`arx: invalid 32-byte key, got length=${y$6}`);
		yt$4(u$2) || g$2.push(u$2 = gt$5(u$2));
		const B$4 = se$5(h$4);
		if (r$1) {
			if (u$2.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
			r$1(m$2, B$4, se$5(u$2.subarray(0, 16)), B$4), u$2 = u$2.subarray(16);
		}
		const b$3 = 16 - o$2;
		if (b$3 !== u$2.length) throw new Error(`arx: nonce must be ${b$3} or 16 bytes`);
		if (b$3 !== 12) {
			const I$4 = new Uint8Array(12);
			I$4.set(u$2, s ? 0 : 12 - u$2.length), u$2 = I$4, g$2.push(u$2);
		}
		const _$4 = se$5(u$2);
		return bs$4(e, m$2, B$4, _$4, a$1, l$2, f$7, i$2), Ee$7(...g$2), l$2;
	};
}
var M$6 = (e, t) => e[t++] & 255 | (e[t++] & 255) << 8;
var Es$3 = class {
	constructor(t) {
		this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, t = pt$5(t), F$5(t, 32);
		const n$2 = M$6(t, 0), r$1 = M$6(t, 2), o$2 = M$6(t, 4), s = M$6(t, 6), i$2 = M$6(t, 8), c$3 = M$6(t, 10), u$2 = M$6(t, 12), a$1 = M$6(t, 14);
		this.r[0] = n$2 & 8191, this.r[1] = (n$2 >>> 13 | r$1 << 3) & 8191, this.r[2] = (r$1 >>> 10 | o$2 << 6) & 7939, this.r[3] = (o$2 >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | i$2 << 12) & 255, this.r[5] = i$2 >>> 1 & 8190, this.r[6] = (i$2 >>> 14 | c$3 << 2) & 8191, this.r[7] = (c$3 >>> 11 | u$2 << 5) & 8065, this.r[8] = (u$2 >>> 8 | a$1 << 8) & 8191, this.r[9] = a$1 >>> 5 & 127;
		for (let l$2 = 0; l$2 < 8; l$2++) this.pad[l$2] = M$6(t, 16 + 2 * l$2);
	}
	process(t, n$2, r$1 = !1) {
		const o$2 = r$1 ? 0 : 2048, { h: s, r: i$2 } = this, c$3 = i$2[0], u$2 = i$2[1], a$1 = i$2[2], l$2 = i$2[3], f$7 = i$2[4], d$4 = i$2[5], g$2 = i$2[6], y$6 = i$2[7], h$4 = i$2[8], m$2 = i$2[9], B$4 = M$6(t, n$2 + 0), b$3 = M$6(t, n$2 + 2), _$4 = M$6(t, n$2 + 4), I$4 = M$6(t, n$2 + 6), k$5 = M$6(t, n$2 + 8), E$6 = M$6(t, n$2 + 10), L$4 = M$6(t, n$2 + 12), j$2 = M$6(t, n$2 + 14);
		let v$5 = s[0] + (B$4 & 8191), O$5 = s[1] + ((B$4 >>> 13 | b$3 << 3) & 8191), w$3 = s[2] + ((b$3 >>> 10 | _$4 << 6) & 8191), R$5 = s[3] + ((_$4 >>> 7 | I$4 << 9) & 8191), A$5 = s[4] + ((I$4 >>> 4 | k$5 << 12) & 8191), T$3 = s[5] + (k$5 >>> 1 & 8191), N$4 = s[6] + ((k$5 >>> 14 | E$6 << 2) & 8191), S$6 = s[7] + ((E$6 >>> 11 | L$4 << 5) & 8191), U$1 = s[8] + ((L$4 >>> 8 | j$2 << 8) & 8191), $$6 = s[9] + (j$2 >>> 5 | o$2), p$5 = 0, C$6 = p$5 + v$5 * c$3 + O$5 * (5 * m$2) + w$3 * (5 * h$4) + R$5 * (5 * y$6) + A$5 * (5 * g$2);
		p$5 = C$6 >>> 13, C$6 &= 8191, C$6 += T$3 * (5 * d$4) + N$4 * (5 * f$7) + S$6 * (5 * l$2) + U$1 * (5 * a$1) + $$6 * (5 * u$2), p$5 += C$6 >>> 13, C$6 &= 8191;
		let D$3 = p$5 + v$5 * u$2 + O$5 * c$3 + w$3 * (5 * m$2) + R$5 * (5 * h$4) + A$5 * (5 * y$6);
		p$5 = D$3 >>> 13, D$3 &= 8191, D$3 += T$3 * (5 * g$2) + N$4 * (5 * d$4) + S$6 * (5 * f$7) + U$1 * (5 * l$2) + $$6 * (5 * a$1), p$5 += D$3 >>> 13, D$3 &= 8191;
		let P$5 = p$5 + v$5 * a$1 + O$5 * u$2 + w$3 * c$3 + R$5 * (5 * m$2) + A$5 * (5 * h$4);
		p$5 = P$5 >>> 13, P$5 &= 8191, P$5 += T$3 * (5 * y$6) + N$4 * (5 * g$2) + S$6 * (5 * d$4) + U$1 * (5 * f$7) + $$6 * (5 * l$2), p$5 += P$5 >>> 13, P$5 &= 8191;
		let G$4 = p$5 + v$5 * l$2 + O$5 * a$1 + w$3 * u$2 + R$5 * c$3 + A$5 * (5 * m$2);
		p$5 = G$4 >>> 13, G$4 &= 8191, G$4 += T$3 * (5 * h$4) + N$4 * (5 * y$6) + S$6 * (5 * g$2) + U$1 * (5 * d$4) + $$6 * (5 * f$7), p$5 += G$4 >>> 13, G$4 &= 8191;
		let X$1 = p$5 + v$5 * f$7 + O$5 * l$2 + w$3 * a$1 + R$5 * u$2 + A$5 * c$3;
		p$5 = X$1 >>> 13, X$1 &= 8191, X$1 += T$3 * (5 * m$2) + N$4 * (5 * h$4) + S$6 * (5 * y$6) + U$1 * (5 * g$2) + $$6 * (5 * d$4), p$5 += X$1 >>> 13, X$1 &= 8191;
		let Z$3 = p$5 + v$5 * d$4 + O$5 * f$7 + w$3 * l$2 + R$5 * a$1 + A$5 * u$2;
		p$5 = Z$3 >>> 13, Z$3 &= 8191, Z$3 += T$3 * c$3 + N$4 * (5 * m$2) + S$6 * (5 * h$4) + U$1 * (5 * y$6) + $$6 * (5 * g$2), p$5 += Z$3 >>> 13, Z$3 &= 8191;
		let he$4 = p$5 + v$5 * g$2 + O$5 * d$4 + w$3 * f$7 + R$5 * l$2 + A$5 * a$1;
		p$5 = he$4 >>> 13, he$4 &= 8191, he$4 += T$3 * u$2 + N$4 * c$3 + S$6 * (5 * m$2) + U$1 * (5 * h$4) + $$6 * (5 * y$6), p$5 += he$4 >>> 13, he$4 &= 8191;
		let pe$4 = p$5 + v$5 * y$6 + O$5 * g$2 + w$3 * d$4 + R$5 * f$7 + A$5 * l$2;
		p$5 = pe$4 >>> 13, pe$4 &= 8191, pe$4 += T$3 * a$1 + N$4 * u$2 + S$6 * c$3 + U$1 * (5 * m$2) + $$6 * (5 * h$4), p$5 += pe$4 >>> 13, pe$4 &= 8191;
		let ge$2 = p$5 + v$5 * h$4 + O$5 * y$6 + w$3 * g$2 + R$5 * d$4 + A$5 * f$7;
		p$5 = ge$2 >>> 13, ge$2 &= 8191, ge$2 += T$3 * l$2 + N$4 * a$1 + S$6 * u$2 + U$1 * c$3 + $$6 * (5 * m$2), p$5 += ge$2 >>> 13, ge$2 &= 8191;
		let ye$4 = p$5 + v$5 * m$2 + O$5 * h$4 + w$3 * y$6 + R$5 * g$2 + A$5 * d$4;
		p$5 = ye$4 >>> 13, ye$4 &= 8191, ye$4 += T$3 * f$7 + N$4 * l$2 + S$6 * a$1 + U$1 * u$2 + $$6 * c$3, p$5 += ye$4 >>> 13, ye$4 &= 8191, p$5 = (p$5 << 2) + p$5 | 0, p$5 = p$5 + C$6 | 0, C$6 = p$5 & 8191, p$5 = p$5 >>> 13, D$3 += p$5, s[0] = C$6, s[1] = D$3, s[2] = P$5, s[3] = G$4, s[4] = X$1, s[5] = Z$3, s[6] = he$4, s[7] = pe$4, s[8] = ge$2, s[9] = ye$4;
	}
	finalize() {
		const { h: t, pad: n$2 } = this, r$1 = new Uint16Array(10);
		let o$2 = t[1] >>> 13;
		t[1] &= 8191;
		for (let c$3 = 2; c$3 < 10; c$3++) t[c$3] += o$2, o$2 = t[c$3] >>> 13, t[c$3] &= 8191;
		t[0] += o$2 * 5, o$2 = t[0] >>> 13, t[0] &= 8191, t[1] += o$2, o$2 = t[1] >>> 13, t[1] &= 8191, t[2] += o$2, r$1[0] = t[0] + 5, o$2 = r$1[0] >>> 13, r$1[0] &= 8191;
		for (let c$3 = 1; c$3 < 10; c$3++) r$1[c$3] = t[c$3] + o$2, o$2 = r$1[c$3] >>> 13, r$1[c$3] &= 8191;
		r$1[9] -= 8192;
		let s = (o$2 ^ 1) - 1;
		for (let c$3 = 0; c$3 < 10; c$3++) r$1[c$3] &= s;
		s = ~s;
		for (let c$3 = 0; c$3 < 10; c$3++) t[c$3] = t[c$3] & s | r$1[c$3];
		t[0] = (t[0] | t[1] << 13) & 65535, t[1] = (t[1] >>> 3 | t[2] << 10) & 65535, t[2] = (t[2] >>> 6 | t[3] << 7) & 65535, t[3] = (t[3] >>> 9 | t[4] << 4) & 65535, t[4] = (t[4] >>> 12 | t[5] << 1 | t[6] << 14) & 65535, t[5] = (t[6] >>> 2 | t[7] << 11) & 65535, t[6] = (t[7] >>> 5 | t[8] << 8) & 65535, t[7] = (t[8] >>> 8 | t[9] << 5) & 65535;
		let i$2 = t[0] + n$2[0];
		t[0] = i$2 & 65535;
		for (let c$3 = 1; c$3 < 8; c$3++) i$2 = (t[c$3] + n$2[c$3] | 0) + (i$2 >>> 16) | 0, t[c$3] = i$2 & 65535;
		Ee$7(r$1);
	}
	update(t) {
		Bn$4(this);
		const { buffer: n$2, blockLen: r$1 } = this;
		t = pt$5(t);
		const o$2 = t.length;
		for (let s = 0; s < o$2;) {
			const i$2 = Math.min(r$1 - this.pos, o$2 - s);
			if (i$2 === r$1) {
				for (; r$1 <= o$2 - s; s += r$1) this.process(t, s);
				continue;
			}
			n$2.set(t.subarray(s, s + i$2), this.pos), this.pos += i$2, s += i$2, this.pos === r$1 && (this.process(n$2, 0, !1), this.pos = 0);
		}
		return this;
	}
	destroy() {
		Ee$7(this.h, this.r, this.buffer, this.pad);
	}
	digestInto(t) {
		Bn$4(this), ss$2(t, this), this.finished = !0;
		const { buffer: n$2, h: r$1 } = this;
		let { pos: o$2 } = this;
		if (o$2) {
			for (n$2[o$2++] = 1; o$2 < 16; o$2++) n$2[o$2] = 0;
			this.process(n$2, 0, !0);
		}
		this.finalize();
		let s = 0;
		for (let i$2 = 0; i$2 < 8; i$2++) t[s++] = r$1[i$2] >>> 0, t[s++] = r$1[i$2] >>> 8;
		return t;
	}
	digest() {
		const { buffer: t, outputLen: n$2 } = this;
		this.digestInto(t);
		const r$1 = t.slice(0, n$2);
		return this.destroy(), r$1;
	}
};
function vs$4(e) {
	const t = (r$1, o$2) => e(o$2).update(pt$5(r$1)).digest(), n$2 = e(new Uint8Array(32));
	return t.outputLen = n$2.outputLen, t.blockLen = n$2.blockLen, t.create = (r$1) => e(r$1), t;
}
var xs$4 = vs$4((e) => new Es$3(e));
function Os$4(e, t, n$2, r$1, o$2, s = 20) {
	let i$2 = e[0], c$3 = e[1], u$2 = e[2], a$1 = e[3], l$2 = t[0], f$7 = t[1], d$4 = t[2], g$2 = t[3], y$6 = t[4], h$4 = t[5], m$2 = t[6], B$4 = t[7], b$3 = o$2, _$4 = n$2[0], I$4 = n$2[1], k$5 = n$2[2], E$6 = i$2, L$4 = c$3, j$2 = u$2, v$5 = a$1, O$5 = l$2, w$3 = f$7, R$5 = d$4, A$5 = g$2, T$3 = y$6, N$4 = h$4, S$6 = m$2, U$1 = B$4, $$6 = b$3, p$5 = _$4, C$6 = I$4, D$3 = k$5;
	for (let G$4 = 0; G$4 < s; G$4 += 2) E$6 = E$6 + O$5 | 0, $$6 = x$5($$6 ^ E$6, 16), T$3 = T$3 + $$6 | 0, O$5 = x$5(O$5 ^ T$3, 12), E$6 = E$6 + O$5 | 0, $$6 = x$5($$6 ^ E$6, 8), T$3 = T$3 + $$6 | 0, O$5 = x$5(O$5 ^ T$3, 7), L$4 = L$4 + w$3 | 0, p$5 = x$5(p$5 ^ L$4, 16), N$4 = N$4 + p$5 | 0, w$3 = x$5(w$3 ^ N$4, 12), L$4 = L$4 + w$3 | 0, p$5 = x$5(p$5 ^ L$4, 8), N$4 = N$4 + p$5 | 0, w$3 = x$5(w$3 ^ N$4, 7), j$2 = j$2 + R$5 | 0, C$6 = x$5(C$6 ^ j$2, 16), S$6 = S$6 + C$6 | 0, R$5 = x$5(R$5 ^ S$6, 12), j$2 = j$2 + R$5 | 0, C$6 = x$5(C$6 ^ j$2, 8), S$6 = S$6 + C$6 | 0, R$5 = x$5(R$5 ^ S$6, 7), v$5 = v$5 + A$5 | 0, D$3 = x$5(D$3 ^ v$5, 16), U$1 = U$1 + D$3 | 0, A$5 = x$5(A$5 ^ U$1, 12), v$5 = v$5 + A$5 | 0, D$3 = x$5(D$3 ^ v$5, 8), U$1 = U$1 + D$3 | 0, A$5 = x$5(A$5 ^ U$1, 7), E$6 = E$6 + w$3 | 0, D$3 = x$5(D$3 ^ E$6, 16), S$6 = S$6 + D$3 | 0, w$3 = x$5(w$3 ^ S$6, 12), E$6 = E$6 + w$3 | 0, D$3 = x$5(D$3 ^ E$6, 8), S$6 = S$6 + D$3 | 0, w$3 = x$5(w$3 ^ S$6, 7), L$4 = L$4 + R$5 | 0, $$6 = x$5($$6 ^ L$4, 16), U$1 = U$1 + $$6 | 0, R$5 = x$5(R$5 ^ U$1, 12), L$4 = L$4 + R$5 | 0, $$6 = x$5($$6 ^ L$4, 8), U$1 = U$1 + $$6 | 0, R$5 = x$5(R$5 ^ U$1, 7), j$2 = j$2 + A$5 | 0, p$5 = x$5(p$5 ^ j$2, 16), T$3 = T$3 + p$5 | 0, A$5 = x$5(A$5 ^ T$3, 12), j$2 = j$2 + A$5 | 0, p$5 = x$5(p$5 ^ j$2, 8), T$3 = T$3 + p$5 | 0, A$5 = x$5(A$5 ^ T$3, 7), v$5 = v$5 + O$5 | 0, C$6 = x$5(C$6 ^ v$5, 16), N$4 = N$4 + C$6 | 0, O$5 = x$5(O$5 ^ N$4, 12), v$5 = v$5 + O$5 | 0, C$6 = x$5(C$6 ^ v$5, 8), N$4 = N$4 + C$6 | 0, O$5 = x$5(O$5 ^ N$4, 7);
	let P$5 = 0;
	r$1[P$5++] = i$2 + E$6 | 0, r$1[P$5++] = c$3 + L$4 | 0, r$1[P$5++] = u$2 + j$2 | 0, r$1[P$5++] = a$1 + v$5 | 0, r$1[P$5++] = l$2 + O$5 | 0, r$1[P$5++] = f$7 + w$3 | 0, r$1[P$5++] = d$4 + R$5 | 0, r$1[P$5++] = g$2 + A$5 | 0, r$1[P$5++] = y$6 + T$3 | 0, r$1[P$5++] = h$4 + N$4 | 0, r$1[P$5++] = m$2 + S$6 | 0, r$1[P$5++] = B$4 + U$1 | 0, r$1[P$5++] = b$3 + $$6 | 0, r$1[P$5++] = _$4 + p$5 | 0, r$1[P$5++] = I$4 + C$6 | 0, r$1[P$5++] = k$5 + D$3 | 0;
}
var Is$4 = ws$3(Os$4, {
	counterRight: !1,
	counterLength: 4,
	allowShortKeys: !1
}), As$4 = new Uint8Array(16), Hn$4 = (e, t) => {
	e.update(t);
	const n$2 = t.length % 16;
	n$2 && e.update(As$4.subarray(n$2));
}, Ns$3 = new Uint8Array(32);
function Kn$4(e, t, n$2, r$1, o$2) {
	const s = e(t, n$2, Ns$3), i$2 = xs$4.create(s);
	o$2 && Hn$4(i$2, o$2), Hn$4(i$2, r$1);
	const c$3 = new Uint8Array(16), u$2 = is$2(c$3);
	kn$4(u$2, 0, BigInt(o$2 ? o$2.length : 0), !0), kn$4(u$2, 8, BigInt(r$1.length), !0), i$2.update(c$3);
	const a$1 = i$2.digest();
	return Ee$7(s, c$3), a$1;
}
var Ss$4 = (e) => (t, n$2, r$1) => ({
	encrypt(s, i$2) {
		const c$3 = s.length;
		i$2 = Cn$4(c$3 + 16, i$2, !1), i$2.set(s);
		const u$2 = i$2.subarray(0, -16);
		e(t, n$2, u$2, u$2, 1);
		const a$1 = Kn$4(e, t, n$2, u$2, r$1);
		return i$2.set(a$1, c$3), Ee$7(a$1), i$2;
	},
	decrypt(s, i$2) {
		i$2 = Cn$4(s.length - 16, i$2, !1);
		const c$3 = s.subarray(0, -16), u$2 = s.subarray(-16), a$1 = Kn$4(e, t, n$2, c$3, r$1);
		if (!fs$4(u$2, a$1)) throw new Error("invalid tag");
		return i$2.set(s.subarray(0, -16)), e(t, n$2, i$2, i$2, 1), Ee$7(a$1), i$2;
	}
}), Fn$4 = ls$4({
	blockSize: 64,
	nonceLength: 12,
	tagLength: 16
}, Ss$4(Is$4));
var qn$4 = class extends it$4 {
	constructor(t, n$2) {
		super(), this.finished = !1, this.destroyed = !1, ot$3(t);
		const r$1 = we$5(n$2);
		if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
		this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
		const o$2 = this.blockLen, s = new Uint8Array(o$2);
		s.set(r$1.length > o$2 ? t.create().update(r$1).digest() : r$1);
		for (let i$2 = 0; i$2 < s.length; i$2++) s[i$2] ^= 54;
		this.iHash.update(s), this.oHash = t.create();
		for (let i$2 = 0; i$2 < s.length; i$2++) s[i$2] ^= 106;
		this.oHash.update(s), s.fill(0);
	}
	update(t) {
		return me$5(this), this.iHash.update(t), this;
	}
	digestInto(t) {
		me$5(this), je$5(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
	}
	digest() {
		const t = new Uint8Array(this.oHash.outputLen);
		return this.digestInto(t), t;
	}
	_cloneInto(t) {
		t || (t = Object.create(Object.getPrototypeOf(this), {}));
		const { oHash: n$2, iHash: r$1, finished: o$2, destroyed: s, blockLen: i$2, outputLen: c$3 } = this;
		return t = t, t.finished = o$2, t.destroyed = s, t.blockLen = i$2, t.outputLen = c$3, t.oHash = n$2._cloneInto(t.oHash), t.iHash = r$1._cloneInto(t.iHash), t;
	}
	destroy() {
		this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
	}
};
var mt$5 = (e, t, n$2) => new qn$4(e, t).update(n$2).digest();
mt$5.create = (e, t) => new qn$4(e, t);
function Us$3(e, t, n$2) {
	return ot$3(e), n$2 === void 0 && (n$2 = new Uint8Array(e.outputLen)), mt$5(e, we$5(n$2), we$5(t));
}
var bt$1 = new Uint8Array([0]), Gn$4 = new Uint8Array();
function _s$4(e, t, n$2, r$1 = 32) {
	if (ot$3(e), Ne$4(r$1), r$1 > 255 * e.outputLen) throw new Error("Length should be <= 255*HashLen");
	const o$2 = Math.ceil(r$1 / e.outputLen);
	n$2 === void 0 && (n$2 = Gn$4);
	const s = new Uint8Array(o$2 * e.outputLen), i$2 = mt$5.create(e, t), c$3 = i$2._cloneInto(), u$2 = new Uint8Array(i$2.outputLen);
	for (let a$1 = 0; a$1 < o$2; a$1++) bt$1[0] = a$1 + 1, c$3.update(a$1 === 0 ? Gn$4 : u$2).update(n$2).update(bt$1).digestInto(u$2), s.set(u$2, e.outputLen * a$1), i$2._cloneInto(c$3);
	return i$2.destroy(), c$3.destroy(), u$2.fill(0), bt$1.fill(0), s.slice(0, r$1);
}
var Ts$3 = (e, t, n$2, r$1, o$2) => _s$4(e, Us$3(e, t, n$2), r$1, o$2);
function $s$2(e, t, n$2, r$1) {
	if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n$2, r$1);
	const o$2 = BigInt(32), s = BigInt(4294967295), i$2 = Number(n$2 >> o$2 & s), c$3 = Number(n$2 & s), u$2 = r$1 ? 4 : 0, a$1 = r$1 ? 0 : 4;
	e.setUint32(t + u$2, i$2, r$1), e.setUint32(t + a$1, c$3, r$1);
}
function Rs$3(e, t, n$2) {
	return e & t ^ ~e & n$2;
}
function Ps$4(e, t, n$2) {
	return e & t ^ e & n$2 ^ t & n$2;
}
var Ls$5 = class extends it$4 {
	constructor(t, n$2, r$1, o$2) {
		super(), this.blockLen = t, this.outputLen = n$2, this.padOffset = r$1, this.isLE = o$2, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = st$3(this.buffer);
	}
	update(t) {
		me$5(this);
		const { view: n$2, buffer: r$1, blockLen: o$2 } = this;
		t = we$5(t);
		const s = t.length;
		for (let i$2 = 0; i$2 < s;) {
			const c$3 = Math.min(o$2 - this.pos, s - i$2);
			if (c$3 === o$2) {
				const u$2 = st$3(t);
				for (; o$2 <= s - i$2; i$2 += o$2) this.process(u$2, i$2);
				continue;
			}
			r$1.set(t.subarray(i$2, i$2 + c$3), this.pos), this.pos += c$3, i$2 += c$3, this.pos === o$2 && (this.process(n$2, 0), this.pos = 0);
		}
		return this.length += t.length, this.roundClean(), this;
	}
	digestInto(t) {
		me$5(this), sn$5(t, this), this.finished = !0;
		const { buffer: n$2, view: r$1, blockLen: o$2, isLE: s } = this;
		let { pos: i$2 } = this;
		n$2[i$2++] = 128, this.buffer.subarray(i$2).fill(0), this.padOffset > o$2 - i$2 && (this.process(r$1, 0), i$2 = 0);
		for (let f$7 = i$2; f$7 < o$2; f$7++) n$2[f$7] = 0;
		$s$2(r$1, o$2 - 8, BigInt(this.length * 8), s), this.process(r$1, 0);
		const c$3 = st$3(t), u$2 = this.outputLen;
		if (u$2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
		const a$1 = u$2 / 4, l$2 = this.get();
		if (a$1 > l$2.length) throw new Error("_sha2: outputLen bigger than state");
		for (let f$7 = 0; f$7 < a$1; f$7++) c$3.setUint32(4 * f$7, l$2[f$7], s);
	}
	digest() {
		const { buffer: t, outputLen: n$2 } = this;
		this.digestInto(t);
		const r$1 = t.slice(0, n$2);
		return this.destroy(), r$1;
	}
	_cloneInto(t) {
		t || (t = new this.constructor()), t.set(...this.get());
		const { blockLen: n$2, buffer: r$1, length: o$2, finished: s, destroyed: i$2, pos: c$3 } = this;
		return t.length = o$2, t.pos = c$3, t.finished = s, t.destroyed = i$2, o$2 % n$2 && t.buffer.set(r$1), t;
	}
};
var Bs$3 = new Uint32Array([
	1116352408,
	1899447441,
	3049323471,
	3921009573,
	961987163,
	1508970993,
	2453635748,
	2870763221,
	3624381080,
	310598401,
	607225278,
	1426881987,
	1925078388,
	2162078206,
	2614888103,
	3248222580,
	3835390401,
	4022224774,
	264347078,
	604807628,
	770255983,
	1249150122,
	1555081692,
	1996064986,
	2554220882,
	2821834349,
	2952996808,
	3210313671,
	3336571891,
	3584528711,
	113926993,
	338241895,
	666307205,
	773529912,
	1294757372,
	1396182291,
	1695183700,
	1986661051,
	2177026350,
	2456956037,
	2730485921,
	2820302411,
	3259730800,
	3345764771,
	3516065817,
	3600352804,
	4094571909,
	275423344,
	430227734,
	506948616,
	659060556,
	883997877,
	958139571,
	1322822218,
	1537002063,
	1747873779,
	1955562222,
	2024104815,
	2227730452,
	2361852424,
	2428436474,
	2756734187,
	3204031479,
	3329325298
]), ie$5 = new Uint32Array([
	1779033703,
	3144134277,
	1013904242,
	2773480762,
	1359893119,
	2600822924,
	528734635,
	1541459225
]), ce$5 = new Uint32Array(64);
var js$2 = class extends Ls$5 {
	constructor() {
		super(64, 32, 8, !1), this.A = ie$5[0] | 0, this.B = ie$5[1] | 0, this.C = ie$5[2] | 0, this.D = ie$5[3] | 0, this.E = ie$5[4] | 0, this.F = ie$5[5] | 0, this.G = ie$5[6] | 0, this.H = ie$5[7] | 0;
	}
	get() {
		const { A: t, B: n$2, C: r$1, D: o$2, E: s, F: i$2, G: c$3, H: u$2 } = this;
		return [
			t,
			n$2,
			r$1,
			o$2,
			s,
			i$2,
			c$3,
			u$2
		];
	}
	set(t, n$2, r$1, o$2, s, i$2, c$3, u$2) {
		this.A = t | 0, this.B = n$2 | 0, this.C = r$1 | 0, this.D = o$2 | 0, this.E = s | 0, this.F = i$2 | 0, this.G = c$3 | 0, this.H = u$2 | 0;
	}
	process(t, n$2) {
		for (let f$7 = 0; f$7 < 16; f$7++, n$2 += 4) ce$5[f$7] = t.getUint32(n$2, !1);
		for (let f$7 = 16; f$7 < 64; f$7++) {
			const d$4 = ce$5[f$7 - 15], g$2 = ce$5[f$7 - 2], y$6 = J$7(d$4, 7) ^ J$7(d$4, 18) ^ d$4 >>> 3;
			ce$5[f$7] = (J$7(g$2, 17) ^ J$7(g$2, 19) ^ g$2 >>> 10) + ce$5[f$7 - 7] + y$6 + ce$5[f$7 - 16] | 0;
		}
		let { A: r$1, B: o$2, C: s, D: i$2, E: c$3, F: u$2, G: a$1, H: l$2 } = this;
		for (let f$7 = 0; f$7 < 64; f$7++) {
			const d$4 = J$7(c$3, 6) ^ J$7(c$3, 11) ^ J$7(c$3, 25), g$2 = l$2 + d$4 + Rs$3(c$3, u$2, a$1) + Bs$3[f$7] + ce$5[f$7] | 0, h$4 = (J$7(r$1, 2) ^ J$7(r$1, 13) ^ J$7(r$1, 22)) + Ps$4(r$1, o$2, s) | 0;
			l$2 = a$1, a$1 = u$2, u$2 = c$3, c$3 = i$2 + g$2 | 0, i$2 = s, s = o$2, o$2 = r$1, r$1 = g$2 + h$4 | 0;
		}
		r$1 = r$1 + this.A | 0, o$2 = o$2 + this.B | 0, s = s + this.C | 0, i$2 = i$2 + this.D | 0, c$3 = c$3 + this.E | 0, u$2 = u$2 + this.F | 0, a$1 = a$1 + this.G | 0, l$2 = l$2 + this.H | 0, this.set(r$1, o$2, s, i$2, c$3, u$2, a$1, l$2);
	}
	roundClean() {
		ce$5.fill(0);
	}
	destroy() {
		this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
	}
};
var He$4 = fn$4(() => new js$2());
var Wn$4 = BigInt(0);
function wt$6(e) {
	return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function zn$4(e) {
	if (!wt$6(e)) throw new Error("Uint8Array expected");
}
var Cs$4 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function ks$4(e) {
	zn$4(e);
	let t = "";
	for (let n$2 = 0; n$2 < e.length; n$2++) t += Cs$4[e[n$2]];
	return t;
}
function Ds$3(e) {
	if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
	return e === "" ? Wn$4 : BigInt("0x" + e);
}
var ee$4 = {
	_0: 48,
	_9: 57,
	A: 65,
	F: 70,
	a: 97,
	f: 102
};
function Jn$4(e) {
	if (e >= ee$4._0 && e <= ee$4._9) return e - ee$4._0;
	if (e >= ee$4.A && e <= ee$4.F) return e - (ee$4.A - 10);
	if (e >= ee$4.a && e <= ee$4.f) return e - (ee$4.a - 10);
}
function Yn$4(e) {
	if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
	const t = e.length, n$2 = t / 2;
	if (t % 2) throw new Error("hex string expected, got unpadded hex of length " + t);
	const r$1 = new Uint8Array(n$2);
	for (let o$2 = 0, s = 0; o$2 < n$2; o$2++, s += 2) {
		const i$2 = Jn$4(e.charCodeAt(s)), c$3 = Jn$4(e.charCodeAt(s + 1));
		if (i$2 === void 0 || c$3 === void 0) {
			const u$2 = e[s] + e[s + 1];
			throw new Error("hex string expected, got non-hex character \"" + u$2 + "\" at index " + s);
		}
		r$1[o$2] = i$2 * 16 + c$3;
	}
	return r$1;
}
function Xn$4(e) {
	return zn$4(e), Ds$3(ks$4(Uint8Array.from(e).reverse()));
}
function Ms$3(e, t) {
	return Yn$4(e.toString(16).padStart(t * 2, "0"));
}
function Vs$5(e, t) {
	return Ms$3(e, t).reverse();
}
function Zn$4(e, t, n$2) {
	let r$1;
	if (typeof t == "string") try {
		r$1 = Yn$4(t);
	} catch (s) {
		throw new Error(e + " must be hex string or Uint8Array, cause: " + s);
	}
	else if (wt$6(t)) r$1 = Uint8Array.from(t);
	else throw new Error(e + " must be hex string or Uint8Array");
	const o$2 = r$1.length;
	if (typeof n$2 == "number" && o$2 !== n$2) throw new Error(e + " of length " + n$2 + " expected, got " + o$2);
	return r$1;
}
var Et$6 = (e) => typeof e == "bigint" && Wn$4 <= e;
function Hs$3(e, t, n$2) {
	return Et$6(e) && Et$6(t) && Et$6(n$2) && t <= e && e < n$2;
}
function Qn$4(e, t, n$2, r$1) {
	if (!Hs$3(t, n$2, r$1)) throw new Error("expected valid " + e + ": " + n$2 + " <= n < " + r$1 + ", got " + t);
}
var Ks$2 = {
	bigint: (e) => typeof e == "bigint",
	function: (e) => typeof e == "function",
	boolean: (e) => typeof e == "boolean",
	string: (e) => typeof e == "string",
	stringOrUint8Array: (e) => typeof e == "string" || wt$6(e),
	isSafeInteger: (e) => Number.isSafeInteger(e),
	array: (e) => Array.isArray(e),
	field: (e, t) => t.Fp.isValid(e),
	hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function Fs$3(e, t, n$2 = {}) {
	const r$1 = (o$2, s, i$2) => {
		const c$3 = Ks$2[s];
		if (typeof c$3 != "function") throw new Error("invalid validator function");
		const u$2 = e[o$2];
		if (!(i$2 && u$2 === void 0) && !c$3(u$2, e)) throw new Error("param " + String(o$2) + " is invalid. Expected " + s + ", got " + u$2);
	};
	for (const [o$2, s] of Object.entries(t)) r$1(o$2, s, !1);
	for (const [o$2, s] of Object.entries(n$2)) r$1(o$2, s, !0);
	return e;
}
var ve$3 = BigInt(0), Ke$7 = BigInt(1);
function er$4(e, t) {
	const n$2 = e % t;
	return n$2 >= ve$3 ? n$2 : t + n$2;
}
function qs$6(e, t, n$2) {
	if (t < ve$3) throw new Error("invalid exponent, negatives unsupported");
	if (n$2 <= ve$3) throw new Error("invalid modulus");
	if (n$2 === Ke$7) return ve$3;
	let r$1 = Ke$7;
	for (; t > ve$3;) t & Ke$7 && (r$1 = r$1 * e % n$2), e = e * e % n$2, t >>= Ke$7;
	return r$1;
}
function z$5(e, t, n$2) {
	let r$1 = e;
	for (; t-- > ve$3;) r$1 *= r$1, r$1 %= n$2;
	return r$1;
}
var xe$4 = BigInt(0), vt$4 = BigInt(1);
function Gs$4(e) {
	return Fs$3(e, { a: "bigint" }, {
		montgomeryBits: "isSafeInteger",
		nByteLength: "isSafeInteger",
		adjustScalarBytes: "function",
		domain: "function",
		powPminus2: "function",
		Gu: "bigint"
	}), Object.freeze({ ...e });
}
function Ws$4(e) {
	const t = Gs$4(e), { P: n$2 } = t, r$1 = (b$3) => er$4(b$3, n$2), o$2 = t.montgomeryBits, s = Math.ceil(o$2 / 8), i$2 = t.nByteLength, c$3 = t.adjustScalarBytes || ((b$3) => b$3), u$2 = t.powPminus2 || ((b$3) => qs$6(b$3, n$2 - BigInt(2), n$2));
	function a$1(b$3, _$4, I$4) {
		const k$5 = r$1(b$3 * (_$4 - I$4));
		return _$4 = r$1(_$4 - k$5), I$4 = r$1(I$4 + k$5), [_$4, I$4];
	}
	const l$2 = (t.a - BigInt(2)) / BigInt(4);
	function f$7(b$3, _$4) {
		Qn$4("u", b$3, xe$4, n$2), Qn$4("scalar", _$4, xe$4, n$2);
		const I$4 = _$4, k$5 = b$3;
		let E$6 = vt$4, L$4 = xe$4, j$2 = b$3, v$5 = vt$4, O$5 = xe$4, w$3;
		for (let A$5 = BigInt(o$2 - 1); A$5 >= xe$4; A$5--) {
			const T$3 = I$4 >> A$5 & vt$4;
			O$5 ^= T$3, w$3 = a$1(O$5, E$6, j$2), E$6 = w$3[0], j$2 = w$3[1], w$3 = a$1(O$5, L$4, v$5), L$4 = w$3[0], v$5 = w$3[1], O$5 = T$3;
			const N$4 = E$6 + L$4, S$6 = r$1(N$4 * N$4), U$1 = E$6 - L$4, $$6 = r$1(U$1 * U$1), p$5 = S$6 - $$6, C$6 = j$2 + v$5, P$5 = r$1((j$2 - v$5) * N$4), G$4 = r$1(C$6 * U$1), X$1 = P$5 + G$4, Z$3 = P$5 - G$4;
			j$2 = r$1(X$1 * X$1), v$5 = r$1(k$5 * r$1(Z$3 * Z$3)), E$6 = r$1(S$6 * $$6), L$4 = r$1(p$5 * (S$6 + r$1(l$2 * p$5)));
		}
		w$3 = a$1(O$5, E$6, j$2), E$6 = w$3[0], j$2 = w$3[1], w$3 = a$1(O$5, L$4, v$5), L$4 = w$3[0], v$5 = w$3[1];
		const R$5 = u$2(L$4);
		return r$1(E$6 * R$5);
	}
	function d$4(b$3) {
		return Vs$5(r$1(b$3), s);
	}
	function g$2(b$3) {
		const _$4 = Zn$4("u coordinate", b$3, s);
		return i$2 === 32 && (_$4[31] &= 127), Xn$4(_$4);
	}
	function y$6(b$3) {
		const _$4 = Zn$4("scalar", b$3), I$4 = _$4.length;
		if (I$4 !== s && I$4 !== i$2) {
			let k$5 = "" + s + " or " + i$2;
			throw new Error("invalid scalar, expected " + k$5 + " bytes, got " + I$4);
		}
		return Xn$4(c$3(_$4));
	}
	function h$4(b$3, _$4) {
		const E$6 = f$7(g$2(_$4), y$6(b$3));
		if (E$6 === xe$4) throw new Error("invalid private or public key received");
		return d$4(E$6);
	}
	const m$2 = d$4(t.Gu);
	function B$4(b$3) {
		return h$4(b$3, m$2);
	}
	return {
		scalarMult: h$4,
		scalarMultBase: B$4,
		getSharedSecret: (b$3, _$4) => h$4(b$3, _$4),
		getPublicKey: (b$3) => B$4(b$3),
		utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) },
		GuBytes: m$2
	};
}
var xt$5 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var zs$1 = BigInt(1), tr$4 = BigInt(2), Js$3 = BigInt(3), Ys$4 = BigInt(5);
function Xs$3(e) {
	const t = BigInt(10), n$2 = BigInt(20), r$1 = BigInt(40), o$2 = BigInt(80), s = xt$5, c$3 = e * e % s * e % s, a$1 = z$5(z$5(c$3, tr$4, s) * c$3 % s, zs$1, s) * e % s, l$2 = z$5(a$1, Ys$4, s) * a$1 % s, f$7 = z$5(l$2, t, s) * l$2 % s, d$4 = z$5(f$7, n$2, s) * f$7 % s, g$2 = z$5(d$4, r$1, s) * d$4 % s;
	return {
		pow_p_5_8: z$5(z$5(z$5(z$5(g$2, o$2, s) * g$2 % s, o$2, s) * g$2 % s, t, s) * l$2 % s, tr$4, s) * e % s,
		b2: c$3
	};
}
function Zs$4(e) {
	return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;
}
var Ot$4 = Ws$4({
	P: xt$5,
	a: BigInt(486662),
	montgomeryBits: 255,
	nByteLength: 32,
	Gu: BigInt(9),
	powPminus2: (e) => {
		const t = xt$5, { pow_p_5_8: n$2, b2: r$1 } = Xs$3(e);
		return er$4(z$5(n$2, Js$3, t) * r$1, t);
	},
	adjustScalarBytes: Zs$4,
	randomBytes: Se$5
}), It$3 = "base10", V$6 = "base16", At$5 = "base64pad", Qs$3 = "base64url", Oe$6 = "utf8", Nt$5 = 0, Ie$4 = 1, _e$5 = 2, ei$4 = 0, nr$4 = 1, Te$4 = 12, St$6 = 32;
function ti$3() {
	const e = Ot$4.utils.randomPrivateKey(), t = Ot$4.getPublicKey(e);
	return {
		privateKey: toString(e, V$6),
		publicKey: toString(t, V$6)
	};
}
function ni$3() {
	return toString(Se$5(St$6), V$6);
}
function ri$3(e, t) {
	return toString(Ts$3(He$4, Ot$4.getSharedSecret(fromString(e, V$6), fromString(t, V$6)), void 0, void 0, St$6), V$6);
}
function oi$2(e) {
	return toString(He$4(fromString(e, V$6)), V$6);
}
function si$3(e) {
	return toString(He$4(fromString(e, Oe$6)), V$6);
}
function Ut$5(e) {
	return fromString(`${e}`, It$3);
}
function fe$3(e) {
	return Number(toString(e, It$3));
}
function ii$3(e) {
	const t = Ut$5(typeof e.type < "u" ? e.type : Nt$5);
	if (fe$3(t) === Ie$4 && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
	const n$2 = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, V$6) : void 0, r$1 = typeof e.iv < "u" ? fromString(e.iv, V$6) : Se$5(Te$4);
	return _t$6({
		type: t,
		sealed: Fn$4(fromString(e.symKey, V$6), r$1).encrypt(fromString(e.message, Oe$6)),
		iv: r$1,
		senderPublicKey: n$2,
		encoding: e.encoding
	});
}
function ci$2(e) {
	const t = fromString(e.symKey, V$6), { sealed: n$2, iv: r$1 } = Fe$4(e), o$2 = Fn$4(t, r$1).decrypt(n$2);
	if (o$2 === null) throw new Error("Failed to decrypt");
	return toString(o$2, Oe$6);
}
function ai$2(e, t) {
	const n$2 = Ut$5(_e$5), r$1 = Se$5(Te$4);
	return _t$6({
		type: n$2,
		sealed: fromString(e, Oe$6),
		iv: r$1,
		encoding: t
	});
}
function ui$3(e, t) {
	const { sealed: n$2 } = Fe$4({
		encoded: e,
		encoding: t
	});
	return toString(n$2, Oe$6);
}
function _t$6(e) {
	const { encoding: t = At$5 } = e;
	if (fe$3(e.type) === _e$5) return toString(concat([e.type, e.sealed]), t);
	if (fe$3(e.type) === Ie$4) {
		if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
		return toString(concat([
			e.type,
			e.senderPublicKey,
			e.iv,
			e.sealed
		]), t);
	}
	return toString(concat([
		e.type,
		e.iv,
		e.sealed
	]), t);
}
function Fe$4(e) {
	const { encoded: t, encoding: n$2 = At$5 } = e, r$1 = fromString(t, n$2), o$2 = r$1.slice(ei$4, nr$4), s = nr$4;
	if (fe$3(o$2) === Ie$4) {
		const a$1 = s + St$6, l$2 = a$1 + Te$4, f$7 = r$1.slice(s, a$1), d$4 = r$1.slice(a$1, l$2);
		return {
			type: o$2,
			sealed: r$1.slice(l$2),
			iv: d$4,
			senderPublicKey: f$7
		};
	}
	if (fe$3(o$2) === _e$5) return {
		type: o$2,
		sealed: r$1.slice(s),
		iv: Se$5(Te$4)
	};
	const i$2 = s + Te$4, c$3 = r$1.slice(s, i$2);
	return {
		type: o$2,
		sealed: r$1.slice(i$2),
		iv: c$3
	};
}
function fi$3(e, t) {
	const n$2 = Fe$4({
		encoded: e,
		encoding: t?.encoding
	});
	return rr$2({
		type: fe$3(n$2.type),
		senderPublicKey: typeof n$2.senderPublicKey < "u" ? toString(n$2.senderPublicKey, V$6) : void 0,
		receiverPublicKey: t?.receiverPublicKey
	});
}
function rr$2(e) {
	const t = e?.type || Nt$5;
	if (t === Ie$4) {
		if (typeof e?.senderPublicKey > "u") throw new Error("missing sender public key");
		if (typeof e?.receiverPublicKey > "u") throw new Error("missing receiver public key");
	}
	return {
		type: t,
		senderPublicKey: e?.senderPublicKey,
		receiverPublicKey: e?.receiverPublicKey
	};
}
function li$3(e) {
	return e.type === Ie$4 && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function di$3(e) {
	return e.type === _e$5;
}
function or$4(e) {
	return new import_elliptic$1.ec("p256").keyFromPublic({
		x: Buffer.from(e.x, "base64").toString("hex"),
		y: Buffer.from(e.y, "base64").toString("hex")
	}, "hex");
}
function hi$3(e) {
	let t = e.replace(/-/g, "+").replace(/_/g, "/");
	const n$2 = t.length % 4;
	return n$2 > 0 && (t += "=".repeat(4 - n$2)), t;
}
function pi$3(e) {
	return Buffer.from(hi$3(e), "base64");
}
function gi$2(e, t) {
	const [n$2, r$1, o$2] = e.split("."), s = pi$3(o$2);
	if (s.length !== 64) throw new Error("Invalid signature length");
	const i$2 = s.slice(0, 32).toString("hex"), c$3 = s.slice(32, 64).toString("hex"), a$1 = He$4(`${n$2}.${r$1}`), l$2 = or$4(t), f$7 = toString(a$1, V$6);
	if (!l$2.verify(f$7, {
		r: i$2,
		s: c$3
	})) throw new Error("Invalid signature");
	return sn(e).payload;
}
var sr$4 = "irn";
function yi$3(e) {
	return e?.relay || { protocol: sr$4 };
}
function mi$3(e) {
	const t = C$3[e];
	if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${e}`);
	return t;
}
function ir$4(e, t = "-") {
	const n$2 = {}, r$1 = "relay" + t;
	return Object.keys(e).forEach((o$2) => {
		if (o$2.startsWith(r$1)) {
			const s = o$2.replace(r$1, "");
			n$2[s] = e[o$2];
		}
	}), n$2;
}
function bi$3(e) {
	if (!e.includes("wc:")) {
		const a$1 = rt$3(e);
		a$1 != null && a$1.includes("wc:") && (e = a$1);
	}
	e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
	const t = e.indexOf(":"), n$2 = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r$1 = e.substring(0, t), o$2 = e.substring(t + 1, n$2).split("@"), s = typeof n$2 < "u" ? e.substring(n$2) : "", i$2 = new URLSearchParams(s), c$3 = {};
	i$2.forEach((a$1, l$2) => {
		c$3[l$2] = a$1;
	});
	const u$2 = typeof c$3.methods == "string" ? c$3.methods.split(",") : void 0;
	return {
		protocol: r$1,
		topic: cr$4(o$2[0]),
		version: parseInt(o$2[1], 10),
		symKey: c$3.symKey,
		relay: ir$4(c$3),
		methods: u$2,
		expiryTimestamp: c$3.expiryTimestamp ? parseInt(c$3.expiryTimestamp, 10) : void 0
	};
}
function cr$4(e) {
	return e.startsWith("//") ? e.substring(2) : e;
}
function ar$3(e, t = "-") {
	const n$2 = "relay", r$1 = {};
	return Object.keys(e).forEach((o$2) => {
		const s = o$2, i$2 = n$2 + t + s;
		e[s] && (r$1[i$2] = e[s]);
	}), r$1;
}
function wi$2(e) {
	const t = new URLSearchParams(), n$2 = ar$3(e.relay);
	Object.keys(n$2).sort().forEach((o$2) => {
		t.set(o$2, n$2[o$2]);
	}), t.set("symKey", e.symKey), e.expiryTimestamp && t.set("expiryTimestamp", e.expiryTimestamp.toString()), e.methods && t.set("methods", e.methods.join(","));
	const r$1 = t.toString();
	return `${e.protocol}:${e.topic}@${e.version}?${r$1}`;
}
function Ei$3(e, t, n$2) {
	return `${e}?wc_ev=${n$2}&topic=${t}`;
}
function le$6(e) {
	const t = [];
	return e.forEach((n$2) => {
		const [r$1, o$2] = n$2.split(":");
		t.push(`${r$1}:${o$2}`);
	}), t;
}
function lr$4(e) {
	const t = [];
	return Object.values(e).forEach((n$2) => {
		t.push(...le$6(n$2.accounts));
	}), t;
}
function dr$4(e, t) {
	const n$2 = [];
	return Object.values(e).forEach((r$1) => {
		le$6(r$1.accounts).includes(t) && n$2.push(...r$1.methods);
	}), n$2;
}
function hr$3(e, t) {
	const n$2 = [];
	return Object.values(e).forEach((r$1) => {
		le$6(r$1.accounts).includes(t) && n$2.push(...r$1.events);
	}), n$2;
}
function Tt$3(e) {
	return e.includes(":");
}
function pr$2(e) {
	return Tt$3(e) ? e.split(":")[0] : e;
}
function gr$4(e) {
	const t = {};
	return e?.forEach((n$2) => {
		var r$1;
		const [o$2, s] = n$2.split(":");
		t[o$2] || (t[o$2] = {
			accounts: [],
			chains: [],
			events: [],
			methods: []
		}), t[o$2].accounts.push(n$2), (r$1 = t[o$2].chains) == null || r$1.push(`${o$2}:${s}`);
	}), t;
}
function Ti$2(e, t) {
	t = t.map((r$1) => r$1.replace("did:pkh:", ""));
	const n$2 = gr$4(t);
	for (const [r$1, o$2] of Object.entries(n$2)) o$2.methods ? o$2.methods = Q$2(o$2.methods, e) : o$2.methods = e, o$2.events = ["chainChanged", "accountsChanged"];
	return n$2;
}
var yr$4 = {
	INVALID_METHOD: {
		message: "Invalid method.",
		code: 1001
	},
	INVALID_EVENT: {
		message: "Invalid event.",
		code: 1002
	},
	INVALID_UPDATE_REQUEST: {
		message: "Invalid update request.",
		code: 1003
	},
	INVALID_EXTEND_REQUEST: {
		message: "Invalid extend request.",
		code: 1004
	},
	INVALID_SESSION_SETTLE_REQUEST: {
		message: "Invalid session settle request.",
		code: 1005
	},
	UNAUTHORIZED_METHOD: {
		message: "Unauthorized method.",
		code: 3001
	},
	UNAUTHORIZED_EVENT: {
		message: "Unauthorized event.",
		code: 3002
	},
	UNAUTHORIZED_UPDATE_REQUEST: {
		message: "Unauthorized update request.",
		code: 3003
	},
	UNAUTHORIZED_EXTEND_REQUEST: {
		message: "Unauthorized extend request.",
		code: 3004
	},
	USER_REJECTED: {
		message: "User rejected.",
		code: 5e3
	},
	USER_REJECTED_CHAINS: {
		message: "User rejected chains.",
		code: 5001
	},
	USER_REJECTED_METHODS: {
		message: "User rejected methods.",
		code: 5002
	},
	USER_REJECTED_EVENTS: {
		message: "User rejected events.",
		code: 5003
	},
	UNSUPPORTED_CHAINS: {
		message: "Unsupported chains.",
		code: 5100
	},
	UNSUPPORTED_METHODS: {
		message: "Unsupported methods.",
		code: 5101
	},
	UNSUPPORTED_EVENTS: {
		message: "Unsupported events.",
		code: 5102
	},
	UNSUPPORTED_ACCOUNTS: {
		message: "Unsupported accounts.",
		code: 5103
	},
	UNSUPPORTED_NAMESPACE_KEY: {
		message: "Unsupported namespace key.",
		code: 5104
	},
	USER_DISCONNECTED: {
		message: "User disconnected.",
		code: 6e3
	},
	SESSION_SETTLEMENT_FAILED: {
		message: "Session settlement failed.",
		code: 7e3
	},
	WC_METHOD_UNSUPPORTED: {
		message: "Unsupported wc_ method.",
		code: 10001
	}
}, mr$3 = {
	NOT_INITIALIZED: {
		message: "Not initialized.",
		code: 1
	},
	NO_MATCHING_KEY: {
		message: "No matching key.",
		code: 2
	},
	RESTORE_WILL_OVERRIDE: {
		message: "Restore will override.",
		code: 3
	},
	RESUBSCRIBED: {
		message: "Resubscribed.",
		code: 4
	},
	MISSING_OR_INVALID: {
		message: "Missing or invalid.",
		code: 5
	},
	EXPIRED: {
		message: "Expired.",
		code: 6
	},
	UNKNOWN_TYPE: {
		message: "Unknown type.",
		code: 7
	},
	MISMATCHED_TOPIC: {
		message: "Mismatched topic.",
		code: 8
	},
	NON_CONFORMING_NAMESPACES: {
		message: "Non conforming namespaces.",
		code: 9
	}
};
function te$4(e, t) {
	const { message: n$2, code: r$1 } = mr$3[e];
	return {
		message: t ? `${n$2} ${t}` : n$2,
		code: r$1
	};
}
function de$3(e, t) {
	const { message: n$2, code: r$1 } = yr$4[e];
	return {
		message: t ? `${n$2} ${t}` : n$2,
		code: r$1
	};
}
function $e$3(e, t) {
	return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : !0 : !1;
}
function qe$3(e) {
	return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function ae$4(e) {
	return typeof e > "u";
}
function q$3(e, t) {
	return t && ae$4(e) ? !0 : typeof e == "string" && !!e.trim().length;
}
function Ge$7(e, t) {
	return t && ae$4(e) ? !0 : typeof e == "number" && !isNaN(e);
}
function $i$2(e, t) {
	const { requiredNamespaces: n$2 } = t, r$1 = Object.keys(e.namespaces), o$2 = Object.keys(n$2);
	let s = !0;
	return re$5(o$2, r$1) ? (r$1.forEach((i$2) => {
		const { accounts: c$3, methods: u$2, events: a$1 } = e.namespaces[i$2], l$2 = le$6(c$3), f$7 = n$2[i$2];
		(!re$5(Le$7(i$2, f$7), l$2) || !re$5(f$7.methods, u$2) || !re$5(f$7.events, a$1)) && (s = !1);
	}), s) : !1;
}
function Re$3(e) {
	return q$3(e, !1) && e.includes(":") ? e.split(":").length === 2 : !1;
}
function br$4(e) {
	if (q$3(e, !1) && e.includes(":")) {
		const t = e.split(":");
		if (t.length === 3) {
			const n$2 = t[0] + ":" + t[1];
			return !!t[2] && Re$3(n$2);
		}
	}
	return !1;
}
function Ri$3(e) {
	function t(n$2) {
		try {
			return typeof new URL(n$2) < "u";
		} catch {
			return !1;
		}
	}
	try {
		if (q$3(e, !1)) {
			if (t(e)) return !0;
			return t(rt$3(e));
		}
	} catch {}
	return !1;
}
function Pi$3(e) {
	var t;
	return (t = e?.proposer) == null ? void 0 : t.publicKey;
}
function Li$3(e) {
	return e?.topic;
}
function Bi$3(e, t) {
	let n$2 = null;
	return q$3(e?.publicKey, !1) || (n$2 = te$4("MISSING_OR_INVALID", `${t} controller public key should be a string`)), n$2;
}
function Rt$6(e) {
	let t = !0;
	return $e$3(e) ? e.length && (t = e.every((n$2) => q$3(n$2, !1))) : t = !1, t;
}
function wr$4(e, t, n$2) {
	let r$1 = null;
	return $e$3(t) && t.length ? t.forEach((o$2) => {
		r$1 || Re$3(o$2) || (r$1 = de$3("UNSUPPORTED_CHAINS", `${n$2}, chain ${o$2} should be a string and conform to "namespace:chainId" format`));
	}) : Re$3(e) || (r$1 = de$3("UNSUPPORTED_CHAINS", `${n$2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r$1;
}
function Er$4(e, t, n$2) {
	let r$1 = null;
	return Object.entries(e).forEach(([o$2, s]) => {
		if (r$1) return;
		const i$2 = wr$4(o$2, Le$7(o$2, s), `${t} ${n$2}`);
		i$2 && (r$1 = i$2);
	}), r$1;
}
function vr$4(e, t) {
	let n$2 = null;
	return $e$3(e) ? e.forEach((r$1) => {
		n$2 || br$4(r$1) || (n$2 = de$3("UNSUPPORTED_ACCOUNTS", `${t}, account ${r$1} should be a string and conform to "namespace:chainId:address" format`));
	}) : n$2 = de$3("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n$2;
}
function xr$4(e, t) {
	let n$2 = null;
	return Object.values(e).forEach((r$1) => {
		if (n$2) return;
		const o$2 = vr$4(r$1?.accounts, `${t} namespace`);
		o$2 && (n$2 = o$2);
	}), n$2;
}
function Or$4(e, t) {
	let n$2 = null;
	return Rt$6(e?.methods) ? Rt$6(e?.events) || (n$2 = de$3("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : n$2 = de$3("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), n$2;
}
function Pt$4(e, t) {
	let n$2 = null;
	return Object.values(e).forEach((r$1) => {
		if (n$2) return;
		const o$2 = Or$4(r$1, `${t}, namespace`);
		o$2 && (n$2 = o$2);
	}), n$2;
}
function ji$3(e, t, n$2) {
	let r$1 = null;
	if (e && qe$3(e)) {
		const o$2 = Pt$4(e, t);
		o$2 && (r$1 = o$2);
		const s = Er$4(e, t, n$2);
		s && (r$1 = s);
	} else r$1 = te$4("MISSING_OR_INVALID", `${t}, ${n$2} should be an object with data`);
	return r$1;
}
function Ir$3(e, t) {
	let n$2 = null;
	if (e && qe$3(e)) {
		const r$1 = Pt$4(e, t);
		r$1 && (n$2 = r$1);
		const o$2 = xr$4(e, t);
		o$2 && (n$2 = o$2);
	} else n$2 = te$4("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
	return n$2;
}
function Ar$3(e) {
	return q$3(e.protocol, !0);
}
function Ci$4(e, t) {
	let n$2 = !1;
	return t && !e ? n$2 = !0 : e && $e$3(e) && e.length && e.forEach((r$1) => {
		n$2 = Ar$3(r$1);
	}), n$2;
}
function ki$3(e) {
	return typeof e == "number";
}
function Di$3(e) {
	return typeof e < "u" && true;
}
function Mi$2(e) {
	return !(!e || typeof e != "object" || !e.code || !Ge$7(e.code, !1) || !e.message || !q$3(e.message, !1));
}
function Vi$3(e) {
	return !(ae$4(e) || !q$3(e.method, !1));
}
function Hi$2(e) {
	return !(ae$4(e) || ae$4(e.result) && ae$4(e.error) || !Ge$7(e.id, !1) || !q$3(e.jsonrpc, !1));
}
function Ki$3(e) {
	return !(ae$4(e) || !q$3(e.name, !1));
}
function Fi$3(e, t) {
	return !(!Re$3(t) || !lr$4(e).includes(t));
}
function qi$2(e, t, n$2) {
	return q$3(n$2, !1) ? dr$4(e, t).includes(n$2) : !1;
}
function Gi$3(e, t, n$2) {
	return q$3(n$2, !1) ? hr$3(e, t).includes(n$2) : !1;
}
function Nr$3(e, t, n$2) {
	let r$1 = null;
	const o$2 = Wi$2(e), s = zi$4(t), i$2 = Object.keys(o$2), c$3 = Object.keys(s), u$2 = Sr$4(Object.keys(e)), a$1 = Sr$4(Object.keys(t)), l$2 = u$2.filter((f$7) => !a$1.includes(f$7));
	return l$2.length && (r$1 = te$4("NON_CONFORMING_NAMESPACES", `${n$2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l$2.toString()}
      Received: ${Object.keys(t).toString()}`)), re$5(i$2, c$3) || (r$1 = te$4("NON_CONFORMING_NAMESPACES", `${n$2} namespaces chains don't satisfy required namespaces.
      Required: ${i$2.toString()}
      Approved: ${c$3.toString()}`)), Object.keys(t).forEach((f$7) => {
		if (!f$7.includes(":") || r$1) return;
		const d$4 = le$6(t[f$7].accounts);
		d$4.includes(f$7) || (r$1 = te$4("NON_CONFORMING_NAMESPACES", `${n$2} namespaces accounts don't satisfy namespace accounts for ${f$7}
        Required: ${f$7}
        Approved: ${d$4.toString()}`));
	}), i$2.forEach((f$7) => {
		r$1 || (re$5(o$2[f$7].methods, s[f$7].methods) ? re$5(o$2[f$7].events, s[f$7].events) || (r$1 = te$4("NON_CONFORMING_NAMESPACES", `${n$2} namespaces events don't satisfy namespace events for ${f$7}`)) : r$1 = te$4("NON_CONFORMING_NAMESPACES", `${n$2} namespaces methods don't satisfy namespace methods for ${f$7}`));
	}), r$1;
}
function Wi$2(e) {
	const t = {};
	return Object.keys(e).forEach((n$2) => {
		var r$1;
		n$2.includes(":") ? t[n$2] = e[n$2] : (r$1 = e[n$2].chains) == null || r$1.forEach((o$2) => {
			t[o$2] = {
				methods: e[n$2].methods,
				events: e[n$2].events
			};
		});
	}), t;
}
function Sr$4(e) {
	return [...new Set(e.map((t) => t.includes(":") ? t.split(":")[0] : t))];
}
function zi$4(e) {
	const t = {};
	return Object.keys(e).forEach((n$2) => {
		if (n$2.includes(":")) t[n$2] = e[n$2];
		else le$6(e[n$2].accounts)?.forEach((o$2) => {
			t[o$2] = {
				accounts: e[n$2].accounts.filter((s) => s.includes(`${o$2}:`)),
				methods: e[n$2].methods,
				events: e[n$2].events
			};
		});
	}), t;
}
function Ji$2(e, t) {
	return Ge$7(e, !1) && e <= t.max && e >= t.min;
}
function Yi$3() {
	const e = ue$5();
	return new Promise((t) => {
		switch (e) {
			case H$4.browser:
				t(Ur$4());
				break;
			case H$4.reactNative:
				t(_r$4());
				break;
			case H$4.node:
				t(Tr$3());
				break;
			default: t(!0);
		}
	});
}
function Ur$4() {
	return Ae$3() && navigator?.onLine;
}
async function _r$4() {
	if (ne$3() && typeof global < "u" && global != null && global.NetInfo) return (await (global == null ? void 0 : global.NetInfo.fetch()))?.isConnected;
	return !0;
}
function Tr$3() {
	return !0;
}
function Xi$2(e) {
	switch (ue$5()) {
		case H$4.browser:
			$r$4(e);
			break;
		case H$4.reactNative:
			Rr$4(e);
			break;
		case H$4.node: break;
	}
}
function $r$4(e) {
	!ne$3() && Ae$3() && (window.addEventListener("online", () => e(!0)), window.addEventListener("offline", () => e(!1)));
}
function Rr$4(e) {
	ne$3() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((t) => e(t?.isConnected));
}
var Lt$5 = {};
var Zi$2 = class {
	static get(t) {
		return Lt$5[t];
	}
	static set(t, n$2) {
		Lt$5[t] = n$2;
	}
	static delete(t) {
		delete Lt$5[t];
	}
};

//#endregion
//#region node_modules/lodash.isequal/index.js
var require_lodash = /* @__PURE__ */ __commonJS({ "node_modules/lodash.isequal/index.js": ((exports, module) => {
	/**
	* Lodash (Custom Build) <https://lodash.com/>
	* Build: `lodash modularize exports="npm" -o ./`
	* Copyright JS Foundation and other contributors <https://js.foundation/>
	* Released under MIT license <https://lodash.com/license>
	* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	*/
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = "__lodash_hash_undefined__";
	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	/** `Object#toString` result references. */
	var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
	var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
	/**
	* Used to match `RegExp`
	* [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	*/
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
	/** Detect free variable `self`. */
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function("return this")();
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	/** Used to access faster Node.js helpers. */
	var nodeUtil = function() {
		try {
			return freeProcess && freeProcess.binding && freeProcess.binding("util");
		} catch (e) {}
	}();
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	/**
	* A specialized version of `_.filter` for arrays without support for
	* iteratee shorthands.
	*
	* @private
	* @param {Array} [array] The array to iterate over.
	* @param {Function} predicate The function invoked per iteration.
	* @returns {Array} Returns the new filtered array.
	*/
	function arrayFilter(array, predicate) {
		var index$1 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
		while (++index$1 < length) {
			var value = array[index$1];
			if (predicate(value, index$1, array)) result[resIndex++] = value;
		}
		return result;
	}
	/**
	* Appends the elements of `values` to `array`.
	*
	* @private
	* @param {Array} array The array to modify.
	* @param {Array} values The values to append.
	* @returns {Array} Returns `array`.
	*/
	function arrayPush(array, values) {
		var index$1 = -1, length = values.length, offset = array.length;
		while (++index$1 < length) array[offset + index$1] = values[index$1];
		return array;
	}
	/**
	* A specialized version of `_.some` for arrays without support for iteratee
	* shorthands.
	*
	* @private
	* @param {Array} [array] The array to iterate over.
	* @param {Function} predicate The function invoked per iteration.
	* @returns {boolean} Returns `true` if any element passes the predicate check,
	*  else `false`.
	*/
	function arraySome(array, predicate) {
		var index$1 = -1, length = array == null ? 0 : array.length;
		while (++index$1 < length) if (predicate(array[index$1], index$1, array)) return true;
		return false;
	}
	/**
	* The base implementation of `_.times` without support for iteratee shorthands
	* or max array length checks.
	*
	* @private
	* @param {number} n The number of times to invoke `iteratee`.
	* @param {Function} iteratee The function invoked per iteration.
	* @returns {Array} Returns the array of results.
	*/
	function baseTimes(n$2, iteratee) {
		var index$1 = -1, result = Array(n$2);
		while (++index$1 < n$2) result[index$1] = iteratee(index$1);
		return result;
	}
	/**
	* The base implementation of `_.unary` without support for storing metadata.
	*
	* @private
	* @param {Function} func The function to cap arguments for.
	* @returns {Function} Returns the new capped function.
	*/
	function baseUnary(func) {
		return function(value) {
			return func(value);
		};
	}
	/**
	* Checks if a `cache` value for `key` exists.
	*
	* @private
	* @param {Object} cache The cache to query.
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function cacheHas(cache, key) {
		return cache.has(key);
	}
	/**
	* Gets the value at `key` of `object`.
	*
	* @private
	* @param {Object} [object] The object to query.
	* @param {string} key The key of the property to get.
	* @returns {*} Returns the property value.
	*/
	function getValue(object, key) {
		return object == null ? void 0 : object[key];
	}
	/**
	* Converts `map` to its key-value pairs.
	*
	* @private
	* @param {Object} map The map to convert.
	* @returns {Array} Returns the key-value pairs.
	*/
	function mapToArray(map) {
		var index$1 = -1, result = Array(map.size);
		map.forEach(function(value, key) {
			result[++index$1] = [key, value];
		});
		return result;
	}
	/**
	* Creates a unary function that invokes `func` with its argument transformed.
	*
	* @private
	* @param {Function} func The function to wrap.
	* @param {Function} transform The argument transform.
	* @returns {Function} Returns the new function.
	*/
	function overArg(func, transform) {
		return function(arg) {
			return func(transform(arg));
		};
	}
	/**
	* Converts `set` to an array of its values.
	*
	* @private
	* @param {Object} set The set to convert.
	* @returns {Array} Returns the values.
	*/
	function setToArray(set) {
		var index$1 = -1, result = Array(set.size);
		set.forEach(function(value) {
			result[++index$1] = value;
		});
		return result;
	}
	/** Used for built-in method references. */
	var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root["__core-js_shared__"];
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = function() {
		var uid$1 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
		return uid$1 ? "Symbol(src)_1." + uid$1 : "";
	}();
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var nativeObjectToString = objectProto.toString;
	/** Used to detect if a method is native. */
	var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
	/** Built-in value references. */
	var Buffer$1 = moduleExports ? root.Buffer : void 0, Symbol$1 = root.Symbol, Uint8Array$1 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
	var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
	var DataView$1 = getNative(root, "DataView"), Map$1 = getNative(root, "Map"), Promise$1 = getNative(root, "Promise"), Set$1 = getNative(root, "Set"), WeakMap$1 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
	/**
	* Creates a hash object.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function Hash$1(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	/**
	* Removes all key-value entries from the hash.
	*
	* @private
	* @name clear
	* @memberOf Hash
	*/
	function hashClear() {
		this.__data__ = nativeCreate ? nativeCreate(null) : {};
		this.size = 0;
	}
	/**
	* Removes `key` and its value from the hash.
	*
	* @private
	* @name delete
	* @memberOf Hash
	* @param {Object} hash The hash to modify.
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function hashDelete(key) {
		var result = this.has(key) && delete this.__data__[key];
		this.size -= result ? 1 : 0;
		return result;
	}
	/**
	* Gets the hash value for `key`.
	*
	* @private
	* @name get
	* @memberOf Hash
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function hashGet(key) {
		var data = this.__data__;
		if (nativeCreate) {
			var result = data[key];
			return result === HASH_UNDEFINED ? void 0 : result;
		}
		return hasOwnProperty.call(data, key) ? data[key] : void 0;
	}
	/**
	* Checks if a hash value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf Hash
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function hashHas(key) {
		var data = this.__data__;
		return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
	}
	/**
	* Sets the hash `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf Hash
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the hash instance.
	*/
	function hashSet(key, value) {
		var data = this.__data__;
		this.size += this.has(key) ? 0 : 1;
		data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
		return this;
	}
	Hash$1.prototype.clear = hashClear;
	Hash$1.prototype["delete"] = hashDelete;
	Hash$1.prototype.get = hashGet;
	Hash$1.prototype.has = hashHas;
	Hash$1.prototype.set = hashSet;
	/**
	* Creates an list cache object.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function ListCache(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	/**
	* Removes all key-value entries from the list cache.
	*
	* @private
	* @name clear
	* @memberOf ListCache
	*/
	function listCacheClear() {
		this.__data__ = [];
		this.size = 0;
	}
	/**
	* Removes `key` and its value from the list cache.
	*
	* @private
	* @name delete
	* @memberOf ListCache
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function listCacheDelete(key) {
		var data = this.__data__, index$1 = assocIndexOf(data, key);
		if (index$1 < 0) return false;
		if (index$1 == data.length - 1) data.pop();
		else splice.call(data, index$1, 1);
		--this.size;
		return true;
	}
	/**
	* Gets the list cache value for `key`.
	*
	* @private
	* @name get
	* @memberOf ListCache
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function listCacheGet(key) {
		var data = this.__data__, index$1 = assocIndexOf(data, key);
		return index$1 < 0 ? void 0 : data[index$1][1];
	}
	/**
	* Checks if a list cache value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf ListCache
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function listCacheHas(key) {
		return assocIndexOf(this.__data__, key) > -1;
	}
	/**
	* Sets the list cache `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf ListCache
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the list cache instance.
	*/
	function listCacheSet(key, value) {
		var data = this.__data__, index$1 = assocIndexOf(data, key);
		if (index$1 < 0) {
			++this.size;
			data.push([key, value]);
		} else data[index$1][1] = value;
		return this;
	}
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype["delete"] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	/**
	* Creates a map cache object to store key-value pairs.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function MapCache(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	/**
	* Removes all key-value entries from the map.
	*
	* @private
	* @name clear
	* @memberOf MapCache
	*/
	function mapCacheClear() {
		this.size = 0;
		this.__data__ = {
			"hash": new Hash$1(),
			"map": new (Map$1 || ListCache)(),
			"string": new Hash$1()
		};
	}
	/**
	* Removes `key` and its value from the map.
	*
	* @private
	* @name delete
	* @memberOf MapCache
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function mapCacheDelete(key) {
		var result = getMapData(this, key)["delete"](key);
		this.size -= result ? 1 : 0;
		return result;
	}
	/**
	* Gets the map value for `key`.
	*
	* @private
	* @name get
	* @memberOf MapCache
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function mapCacheGet(key) {
		return getMapData(this, key).get(key);
	}
	/**
	* Checks if a map value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf MapCache
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function mapCacheHas(key) {
		return getMapData(this, key).has(key);
	}
	/**
	* Sets the map `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf MapCache
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the map cache instance.
	*/
	function mapCacheSet(key, value) {
		var data = getMapData(this, key), size$4 = data.size;
		data.set(key, value);
		this.size += data.size == size$4 ? 0 : 1;
		return this;
	}
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype["delete"] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	/**
	*
	* Creates an array cache object to store unique values.
	*
	* @private
	* @constructor
	* @param {Array} [values] The values to cache.
	*/
	function SetCache(values) {
		var index$1 = -1, length = values == null ? 0 : values.length;
		this.__data__ = new MapCache();
		while (++index$1 < length) this.add(values[index$1]);
	}
	/**
	* Adds `value` to the array cache.
	*
	* @private
	* @name add
	* @memberOf SetCache
	* @alias push
	* @param {*} value The value to cache.
	* @returns {Object} Returns the cache instance.
	*/
	function setCacheAdd(value) {
		this.__data__.set(value, HASH_UNDEFINED);
		return this;
	}
	/**
	* Checks if `value` is in the array cache.
	*
	* @private
	* @name has
	* @memberOf SetCache
	* @param {*} value The value to search for.
	* @returns {number} Returns `true` if `value` is found, else `false`.
	*/
	function setCacheHas(value) {
		return this.__data__.has(value);
	}
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	/**
	* Creates a stack cache object to store key-value pairs.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function Stack(entries) {
		this.size = (this.__data__ = new ListCache(entries)).size;
	}
	/**
	* Removes all key-value entries from the stack.
	*
	* @private
	* @name clear
	* @memberOf Stack
	*/
	function stackClear() {
		this.__data__ = new ListCache();
		this.size = 0;
	}
	/**
	* Removes `key` and its value from the stack.
	*
	* @private
	* @name delete
	* @memberOf Stack
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function stackDelete(key) {
		var data = this.__data__, result = data["delete"](key);
		this.size = data.size;
		return result;
	}
	/**
	* Gets the stack value for `key`.
	*
	* @private
	* @name get
	* @memberOf Stack
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function stackGet(key) {
		return this.__data__.get(key);
	}
	/**
	* Checks if a stack value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf Stack
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function stackHas(key) {
		return this.__data__.has(key);
	}
	/**
	* Sets the stack `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf Stack
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the stack cache instance.
	*/
	function stackSet(key, value) {
		var data = this.__data__;
		if (data instanceof ListCache) {
			var pairs = data.__data__;
			if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
				pairs.push([key, value]);
				this.size = ++data.size;
				return this;
			}
			data = this.__data__ = new MapCache(pairs);
		}
		data.set(key, value);
		this.size = data.size;
		return this;
	}
	Stack.prototype.clear = stackClear;
	Stack.prototype["delete"] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	/**
	* Creates an array of the enumerable property names of the array-like `value`.
	*
	* @private
	* @param {*} value The value to query.
	* @param {boolean} inherited Specify returning inherited property names.
	* @returns {Array} Returns the array of property names.
	*/
	function arrayLikeKeys(value, inherited) {
		var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
		for (var key in value) if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) result.push(key);
		return result;
	}
	/**
	* Gets the index at which the `key` is found in `array` of key-value pairs.
	*
	* @private
	* @param {Array} array The array to inspect.
	* @param {*} key The key to search for.
	* @returns {number} Returns the index of the matched value, else `-1`.
	*/
	function assocIndexOf(array, key) {
		var length = array.length;
		while (length--) if (eq(array[length][0], key)) return length;
		return -1;
	}
	/**
	* The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	* `keysFunc` and `symbolsFunc` to get the enumerable property names and
	* symbols of `object`.
	*
	* @private
	* @param {Object} object The object to query.
	* @param {Function} keysFunc The function to get the keys of `object`.
	* @param {Function} symbolsFunc The function to get the symbols of `object`.
	* @returns {Array} Returns the array of property names and symbols.
	*/
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
		var result = keysFunc(object);
		return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}
	/**
	* The base implementation of `getTag` without fallbacks for buggy environments.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the `toStringTag`.
	*/
	function baseGetTag(value) {
		if (value == null) return value === void 0 ? undefinedTag : nullTag;
		return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	}
	/**
	* The base implementation of `_.isArguments`.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an `arguments` object,
	*/
	function baseIsArguments(value) {
		return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	/**
	* The base implementation of `_.isEqual` which supports partial comparisons
	* and tracks traversed objects.
	*
	* @private
	* @param {*} value The value to compare.
	* @param {*} other The other value to compare.
	* @param {boolean} bitmask The bitmask flags.
	*  1 - Unordered comparison
	*  2 - Partial comparison
	* @param {Function} [customizer] The function to customize comparisons.
	* @param {Object} [stack] Tracks traversed `value` and `other` objects.
	* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	*/
	function baseIsEqual(value, other, bitmask, customizer, stack) {
		if (value === other) return true;
		if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) return value !== value && other !== other;
		return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}
	/**
	* A specialized version of `baseIsEqual` for arrays and objects which performs
	* deep comparisons and tracks traversed objects enabling objects with circular
	* references to be compared.
	*
	* @private
	* @param {Object} object The object to compare.
	* @param {Object} other The other object to compare.
	* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	* @param {Function} customizer The function to customize comparisons.
	* @param {Function} equalFunc The function to determine equivalents of values.
	* @param {Object} [stack] Tracks traversed `object` and `other` objects.
	* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	*/
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
		var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
		objTag = objTag == argsTag ? objectTag : objTag;
		othTag = othTag == argsTag ? objectTag : othTag;
		var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
		if (isSameTag && isBuffer(object)) {
			if (!isBuffer(other)) return false;
			objIsArr = true;
			objIsObj = false;
		}
		if (isSameTag && !objIsObj) {
			stack || (stack = new Stack());
			return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
		}
		if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
			var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
			if (objIsWrapped || othIsWrapped) {
				var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
				stack || (stack = new Stack());
				return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
			}
		}
		if (!isSameTag) return false;
		stack || (stack = new Stack());
		return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}
	/**
	* The base implementation of `_.isNative` without bad shim checks.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a native function,
	*  else `false`.
	*/
	function baseIsNative(value) {
		if (!isObject(value) || isMasked(value)) return false;
		return (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));
	}
	/**
	* The base implementation of `_.isTypedArray` without Node.js optimizations.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	*/
	function baseIsTypedArray(value) {
		return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	/**
	* The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	*
	* @private
	* @param {Object} object The object to query.
	* @returns {Array} Returns the array of property names.
	*/
	function baseKeys(object) {
		if (!isPrototype(object)) return nativeKeys(object);
		var result = [];
		for (var key in Object(object)) if (hasOwnProperty.call(object, key) && key != "constructor") result.push(key);
		return result;
	}
	/**
	* A specialized version of `baseIsEqualDeep` for arrays with support for
	* partial deep comparisons.
	*
	* @private
	* @param {Array} array The array to compare.
	* @param {Array} other The other array to compare.
	* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	* @param {Function} customizer The function to customize comparisons.
	* @param {Function} equalFunc The function to determine equivalents of values.
	* @param {Object} stack Tracks traversed `array` and `other` objects.
	* @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	*/
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
		var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
		if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
		var stacked = stack.get(array);
		if (stacked && stack.get(other)) return stacked == other;
		var index$1 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
		stack.set(array, other);
		stack.set(other, array);
		while (++index$1 < arrLength) {
			var arrValue = array[index$1], othValue = other[index$1];
			if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index$1, other, array, stack) : customizer(arrValue, othValue, index$1, array, other, stack);
			if (compared !== void 0) {
				if (compared) continue;
				result = false;
				break;
			}
			if (seen) {
				if (!arraySome(other, function(othValue$1, othIndex) {
					if (!cacheHas(seen, othIndex) && (arrValue === othValue$1 || equalFunc(arrValue, othValue$1, bitmask, customizer, stack))) return seen.push(othIndex);
				})) {
					result = false;
					break;
				}
			} else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
				result = false;
				break;
			}
		}
		stack["delete"](array);
		stack["delete"](other);
		return result;
	}
	/**
	* A specialized version of `baseIsEqualDeep` for comparing objects of
	* the same `toStringTag`.
	*
	* **Note:** This function only supports comparing values with tags of
	* `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	*
	* @private
	* @param {Object} object The object to compare.
	* @param {Object} other The other object to compare.
	* @param {string} tag The `toStringTag` of the objects to compare.
	* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	* @param {Function} customizer The function to customize comparisons.
	* @param {Function} equalFunc The function to determine equivalents of values.
	* @param {Object} stack Tracks traversed `object` and `other` objects.
	* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	*/
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
		switch (tag) {
			case dataViewTag:
				if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
				object = object.buffer;
				other = other.buffer;
			case arrayBufferTag:
				if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) return false;
				return true;
			case boolTag:
			case dateTag:
			case numberTag: return eq(+object, +other);
			case errorTag: return object.name == other.name && object.message == other.message;
			case regexpTag:
			case stringTag: return object == other + "";
			case mapTag: var convert = mapToArray;
			case setTag:
				var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
				convert || (convert = setToArray);
				if (object.size != other.size && !isPartial) return false;
				var stacked = stack.get(object);
				if (stacked) return stacked == other;
				bitmask |= COMPARE_UNORDERED_FLAG;
				stack.set(object, other);
				var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
				stack["delete"](object);
				return result;
			case symbolTag: if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
		}
		return false;
	}
	/**
	* A specialized version of `baseIsEqualDeep` for objects with support for
	* partial deep comparisons.
	*
	* @private
	* @param {Object} object The object to compare.
	* @param {Object} other The other object to compare.
	* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	* @param {Function} customizer The function to customize comparisons.
	* @param {Function} equalFunc The function to determine equivalents of values.
	* @param {Object} stack Tracks traversed `object` and `other` objects.
	* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	*/
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
		var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length;
		if (objLength != getAllKeys(other).length && !isPartial) return false;
		var index$1 = objLength;
		while (index$1--) {
			var key = objProps[index$1];
			if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return false;
		}
		var stacked = stack.get(object);
		if (stacked && stack.get(other)) return stacked == other;
		var result = true;
		stack.set(object, other);
		stack.set(other, object);
		var skipCtor = isPartial;
		while (++index$1 < objLength) {
			key = objProps[index$1];
			var objValue = object[key], othValue = other[key];
			if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
			if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
				result = false;
				break;
			}
			skipCtor || (skipCtor = key == "constructor");
		}
		if (result && !skipCtor) {
			var objCtor = object.constructor, othCtor = other.constructor;
			if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
		}
		stack["delete"](object);
		stack["delete"](other);
		return result;
	}
	/**
	* Creates an array of own enumerable property names and symbols of `object`.
	*
	* @private
	* @param {Object} object The object to query.
	* @returns {Array} Returns the array of property names and symbols.
	*/
	function getAllKeys(object) {
		return baseGetAllKeys(object, keys, getSymbols);
	}
	/**
	* Gets the data for `map`.
	*
	* @private
	* @param {Object} map The map to query.
	* @param {string} key The reference key.
	* @returns {*} Returns the map data.
	*/
	function getMapData(map, key) {
		var data = map.__data__;
		return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
	}
	/**
	* Gets the native function at `key` of `object`.
	*
	* @private
	* @param {Object} object The object to query.
	* @param {string} key The key of the method to get.
	* @returns {*} Returns the function if it's native, else `undefined`.
	*/
	function getNative(object, key) {
		var value = getValue(object, key);
		return baseIsNative(value) ? value : void 0;
	}
	/**
	* A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the raw `toStringTag`.
	*/
	function getRawTag(value) {
		var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
		try {
			value[symToStringTag] = void 0;
			var unmasked = true;
		} catch (e) {}
		var result = nativeObjectToString.call(value);
		if (unmasked) if (isOwn) value[symToStringTag] = tag;
		else delete value[symToStringTag];
		return result;
	}
	/**
	* Creates an array of the own enumerable symbols of `object`.
	*
	* @private
	* @param {Object} object The object to query.
	* @returns {Array} Returns the array of symbols.
	*/
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
		if (object == null) return [];
		object = Object(object);
		return arrayFilter(nativeGetSymbols(object), function(symbol) {
			return propertyIsEnumerable.call(object, symbol);
		});
	};
	/**
	* Gets the `toStringTag` of `value`.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the `toStringTag`.
	*/
	var getTag = baseGetTag;
	if (DataView$1 && getTag(new DataView$1(/* @__PURE__ */ new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag(new Map$1()) != mapTag || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) getTag = function(value) {
		var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
		if (ctorString) switch (ctorString) {
			case dataViewCtorString: return dataViewTag;
			case mapCtorString: return mapTag;
			case promiseCtorString: return promiseTag;
			case setCtorString: return setTag;
			case weakMapCtorString: return weakMapTag;
		}
		return result;
	};
	/**
	* Checks if `value` is a valid array-like index.
	*
	* @private
	* @param {*} value The value to check.
	* @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	* @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	*/
	function isIndex(value, length) {
		length = length == null ? MAX_SAFE_INTEGER : length;
		return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}
	/**
	* Checks if `value` is suitable for use as unique object key.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	*/
	function isKeyable(value) {
		var type = typeof value;
		return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
	}
	/**
	* Checks if `func` has its source masked.
	*
	* @private
	* @param {Function} func The function to check.
	* @returns {boolean} Returns `true` if `func` is masked, else `false`.
	*/
	function isMasked(func) {
		return !!maskSrcKey && maskSrcKey in func;
	}
	/**
	* Checks if `value` is likely a prototype object.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	*/
	function isPrototype(value) {
		var Ctor = value && value.constructor;
		return value === (typeof Ctor == "function" && Ctor.prototype || objectProto);
	}
	/**
	* Converts `value` to a string using `Object.prototype.toString`.
	*
	* @private
	* @param {*} value The value to convert.
	* @returns {string} Returns the converted string.
	*/
	function objectToString(value) {
		return nativeObjectToString.call(value);
	}
	/**
	* Converts `func` to its source code.
	*
	* @private
	* @param {Function} func The function to convert.
	* @returns {string} Returns the source code.
	*/
	function toSource(func) {
		if (func != null) {
			try {
				return funcToString.call(func);
			} catch (e) {}
			try {
				return func + "";
			} catch (e) {}
		}
		return "";
	}
	/**
	* Performs a
	* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	* comparison between two values to determine if they are equivalent.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to compare.
	* @param {*} other The other value to compare.
	* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	* @example
	*
	* var object = { 'a': 1 };
	* var other = { 'a': 1 };
	*
	* _.eq(object, object);
	* // => true
	*
	* _.eq(object, other);
	* // => false
	*
	* _.eq('a', 'a');
	* // => true
	*
	* _.eq('a', Object('a'));
	* // => false
	*
	* _.eq(NaN, NaN);
	* // => true
	*/
	function eq(value, other) {
		return value === other || value !== value && other !== other;
	}
	/**
	* Checks if `value` is likely an `arguments` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an `arguments` object,
	*  else `false`.
	* @example
	*
	* _.isArguments(function() { return arguments; }());
	* // => true
	*
	* _.isArguments([1, 2, 3]);
	* // => false
	*/
	var isArguments = baseIsArguments(function() {
		return arguments;
	}()) ? baseIsArguments : function(value) {
		return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
	};
	/**
	* Checks if `value` is classified as an `Array` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an array, else `false`.
	* @example
	*
	* _.isArray([1, 2, 3]);
	* // => true
	*
	* _.isArray(document.body.children);
	* // => false
	*
	* _.isArray('abc');
	* // => false
	*
	* _.isArray(_.noop);
	* // => false
	*/
	var isArray = Array.isArray;
	/**
	* Checks if `value` is array-like. A value is considered array-like if it's
	* not a function and has a `value.length` that's an integer greater than or
	* equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	* @example
	*
	* _.isArrayLike([1, 2, 3]);
	* // => true
	*
	* _.isArrayLike(document.body.children);
	* // => true
	*
	* _.isArrayLike('abc');
	* // => true
	*
	* _.isArrayLike(_.noop);
	* // => false
	*/
	function isArrayLike(value) {
		return value != null && isLength(value.length) && !isFunction(value);
	}
	/**
	* Checks if `value` is a buffer.
	*
	* @static
	* @memberOf _
	* @since 4.3.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	* @example
	*
	* _.isBuffer(new Buffer(2));
	* // => true
	*
	* _.isBuffer(new Uint8Array(2));
	* // => false
	*/
	var isBuffer = nativeIsBuffer || stubFalse;
	/**
	* Performs a deep comparison between two values to determine if they are
	* equivalent.
	*
	* **Note:** This method supports comparing arrays, array buffers, booleans,
	* date objects, error objects, maps, numbers, `Object` objects, regexes,
	* sets, strings, symbols, and typed arrays. `Object` objects are compared
	* by their own, not inherited, enumerable properties. Functions and DOM
	* nodes are compared by strict equality, i.e. `===`.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to compare.
	* @param {*} other The other value to compare.
	* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	* @example
	*
	* var object = { 'a': 1 };
	* var other = { 'a': 1 };
	*
	* _.isEqual(object, other);
	* // => true
	*
	* object === other;
	* // => false
	*/
	function isEqual(value, other) {
		return baseIsEqual(value, other);
	}
	/**
	* Checks if `value` is classified as a `Function` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a function, else `false`.
	* @example
	*
	* _.isFunction(_);
	* // => true
	*
	* _.isFunction(/abc/);
	* // => false
	*/
	function isFunction(value) {
		if (!isObject(value)) return false;
		var tag = baseGetTag(value);
		return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	/**
	* Checks if `value` is a valid array-like length.
	*
	* **Note:** This method is loosely based on
	* [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	* @example
	*
	* _.isLength(3);
	* // => true
	*
	* _.isLength(Number.MIN_VALUE);
	* // => false
	*
	* _.isLength(Infinity);
	* // => false
	*
	* _.isLength('3');
	* // => false
	*/
	function isLength(value) {
		return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	/**
	* Checks if `value` is the
	* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an object, else `false`.
	* @example
	*
	* _.isObject({});
	* // => true
	*
	* _.isObject([1, 2, 3]);
	* // => true
	*
	* _.isObject(_.noop);
	* // => true
	*
	* _.isObject(null);
	* // => false
	*/
	function isObject(value) {
		var type = typeof value;
		return value != null && (type == "object" || type == "function");
	}
	/**
	* Checks if `value` is object-like. A value is object-like if it's not `null`
	* and has a `typeof` result of "object".
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	* @example
	*
	* _.isObjectLike({});
	* // => true
	*
	* _.isObjectLike([1, 2, 3]);
	* // => true
	*
	* _.isObjectLike(_.noop);
	* // => false
	*
	* _.isObjectLike(null);
	* // => false
	*/
	function isObjectLike(value) {
		return value != null && typeof value == "object";
	}
	/**
	* Checks if `value` is classified as a typed array.
	*
	* @static
	* @memberOf _
	* @since 3.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	* @example
	*
	* _.isTypedArray(new Uint8Array);
	* // => true
	*
	* _.isTypedArray([]);
	* // => false
	*/
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	/**
	* Creates an array of the own enumerable property names of `object`.
	*
	* **Note:** Non-object values are coerced to objects. See the
	* [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	* for more details.
	*
	* @static
	* @since 0.1.0
	* @memberOf _
	* @category Object
	* @param {Object} object The object to query.
	* @returns {Array} Returns the array of property names.
	* @example
	*
	* function Foo() {
	*   this.a = 1;
	*   this.b = 2;
	* }
	*
	* Foo.prototype.c = 3;
	*
	* _.keys(new Foo);
	* // => ['a', 'b'] (iteration order is not guaranteed)
	*
	* _.keys('hi');
	* // => ['0', '1']
	*/
	function keys(object) {
		return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	/**
	* This method returns a new empty array.
	*
	* @static
	* @memberOf _
	* @since 4.13.0
	* @category Util
	* @returns {Array} Returns the new empty array.
	* @example
	*
	* var arrays = _.times(2, _.stubArray);
	*
	* console.log(arrays);
	* // => [[], []]
	*
	* console.log(arrays[0] === arrays[1]);
	* // => false
	*/
	function stubArray() {
		return [];
	}
	/**
	* This method returns `false`.
	*
	* @static
	* @memberOf _
	* @since 4.13.0
	* @category Util
	* @returns {boolean} Returns `false`.
	* @example
	*
	* _.times(2, _.stubFalse);
	* // => [false, false]
	*/
	function stubFalse() {
		return false;
	}
	module.exports = isEqual;
}) });

//#endregion
//#region node_modules/@walletconnect/core/dist/index.es.js
var import_events$6 = /* @__PURE__ */ __toESM(require_events());
var import_cjs$7 = require_cjs();
var import_lodash = /* @__PURE__ */ __toESM(require_lodash());
var import_cjs$8 = require_cjs$1();
var xe$3 = "wc", Oe$5 = 2, he$3 = "core", B$3 = `${xe$3}@2:${he$3}:`, mt$4 = {
	name: he$3,
	logger: "error"
}, vt$3 = { database: ":memory:" }, ft$3 = "crypto", Ae$4 = "client_ed25519_seed", _t$5 = import_cjs$7.ONE_DAY, Et$5 = "keychain", wt$5 = "0.3", It$2 = "messages", Tt$4 = "0.3", Ne$3 = import_cjs$7.SIX_HOURS, Ct$3 = "publisher", Pt$3 = "irn", St$5 = "error", $e$6 = "wss://relay.walletconnect.org", Rt$5 = "relayer", T$1 = {
	message: "relayer_message",
	message_ack: "relayer_message_ack",
	connect: "relayer_connect",
	disconnect: "relayer_disconnect",
	error: "relayer_error",
	connection_stalled: "relayer_connection_stalled",
	transport_closed: "relayer_transport_closed",
	publish: "relayer_publish"
}, xt$4 = "_subscription", L$3 = {
	payload: "payload",
	connect: "connect",
	disconnect: "disconnect",
	error: "error"
}, Ot$3 = .1, Us$2 = { database: ":memory:" }, me$4 = "2.19.0", Fs$2 = 1e4, Q$3 = {
	link_mode: "link_mode",
	relay: "relay"
}, At$6 = "0.3", Nt$4 = "WALLETCONNECT_CLIENT_ID", ze$4 = "WALLETCONNECT_LINK_MODE_APPS", $$5 = {
	created: "subscription_created",
	deleted: "subscription_deleted",
	expired: "subscription_expired",
	disabled: "subscription_disabled",
	sync: "subscription_sync",
	resubscribed: "subscription_resubscribed"
}, Ms$2 = import_cjs$7.THIRTY_DAYS, $t$2 = "subscription", zt$4 = "0.3", Lt$4 = import_cjs$7.FIVE_SECONDS * 1e3, kt$5 = "pairing", Ut$4 = "0.3", Ks$1 = import_cjs$7.THIRTY_DAYS, ie$4 = {
	wc_pairingDelete: {
		req: {
			ttl: import_cjs$7.ONE_DAY,
			prompt: !1,
			tag: 1e3
		},
		res: {
			ttl: import_cjs$7.ONE_DAY,
			prompt: !1,
			tag: 1001
		}
	},
	wc_pairingPing: {
		req: {
			ttl: import_cjs$7.THIRTY_SECONDS,
			prompt: !1,
			tag: 1002
		},
		res: {
			ttl: import_cjs$7.THIRTY_SECONDS,
			prompt: !1,
			tag: 1003
		}
	},
	unregistered_method: {
		req: {
			ttl: import_cjs$7.ONE_DAY,
			prompt: !1,
			tag: 0
		},
		res: {
			ttl: import_cjs$7.ONE_DAY,
			prompt: !1,
			tag: 0
		}
	}
}, se$4 = {
	create: "pairing_create",
	expire: "pairing_expire",
	delete: "pairing_delete",
	ping: "pairing_ping"
}, F$4 = {
	created: "history_created",
	updated: "history_updated",
	deleted: "history_deleted",
	sync: "history_sync"
}, Ft$4 = "history", Mt$4 = "0.3", Kt$3 = "expirer", M$4 = {
	created: "expirer_created",
	deleted: "expirer_deleted",
	expired: "expirer_expired",
	sync: "expirer_sync"
}, Bt$4 = "0.3", Bs$2 = import_cjs$7.ONE_DAY, jt$4 = "verify-api", js$1 = "https://verify.walletconnect.com", Vt$3 = "https://verify.walletconnect.org", le$4 = Vt$3, qt$4 = `${le$4}/v3`, Gt$4 = [js$1, Vt$3], Ht$2 = "echo", Yt$5 = "https://echo.walletconnect.com", Vs$4 = "event-client", q$2 = {
	pairing_started: "pairing_started",
	pairing_uri_validation_success: "pairing_uri_validation_success",
	pairing_uri_not_expired: "pairing_uri_not_expired",
	store_new_pairing: "store_new_pairing",
	subscribing_pairing_topic: "subscribing_pairing_topic",
	subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
	existing_pairing: "existing_pairing",
	pairing_not_expired: "pairing_not_expired",
	emit_inactive_pairing: "emit_inactive_pairing",
	emit_session_proposal: "emit_session_proposal",
	subscribing_to_pairing_topic: "subscribing_to_pairing_topic"
}, J$5 = {
	no_wss_connection: "no_wss_connection",
	no_internet_connection: "no_internet_connection",
	malformed_pairing_uri: "malformed_pairing_uri",
	active_pairing_already_exists: "active_pairing_already_exists",
	subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
	pairing_expired: "pairing_expired",
	proposal_expired: "proposal_expired",
	proposal_listener_not_found: "proposal_listener_not_found"
}, qs$4 = {
	session_approve_started: "session_approve_started",
	proposal_not_expired: "proposal_not_expired",
	session_namespaces_validation_success: "session_namespaces_validation_success",
	create_session_topic: "create_session_topic",
	subscribing_session_topic: "subscribing_session_topic",
	subscribe_session_topic_success: "subscribe_session_topic_success",
	publishing_session_approve: "publishing_session_approve",
	session_approve_publish_success: "session_approve_publish_success",
	store_session: "store_session",
	publishing_session_settle: "publishing_session_settle",
	session_settle_publish_success: "session_settle_publish_success"
}, Gs$3 = {
	no_internet_connection: "no_internet_connection",
	no_wss_connection: "no_wss_connection",
	proposal_expired: "proposal_expired",
	subscribe_session_topic_failure: "subscribe_session_topic_failure",
	session_approve_publish_failure: "session_approve_publish_failure",
	session_settle_publish_failure: "session_settle_publish_failure",
	session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure",
	proposal_not_found: "proposal_not_found"
}, Hs$2 = {
	authenticated_session_approve_started: "authenticated_session_approve_started",
	authenticated_session_not_expired: "authenticated_session_not_expired",
	chains_caip2_compliant: "chains_caip2_compliant",
	chains_evm_compliant: "chains_evm_compliant",
	create_authenticated_session_topic: "create_authenticated_session_topic",
	cacaos_verified: "cacaos_verified",
	store_authenticated_session: "store_authenticated_session",
	subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic",
	subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success",
	publishing_authenticated_session_approve: "publishing_authenticated_session_approve",
	authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success"
}, Ys$3 = {
	no_internet_connection: "no_internet_connection",
	no_wss_connection: "no_wss_connection",
	missing_session_authenticate_request: "missing_session_authenticate_request",
	session_authenticate_request_expired: "session_authenticate_request_expired",
	chains_caip2_compliant_failure: "chains_caip2_compliant_failure",
	chains_evm_compliant_failure: "chains_evm_compliant_failure",
	invalid_cacao: "invalid_cacao",
	subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure",
	authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure",
	authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found"
}, Jt$4 = .1, Xt$3 = "event-client", Wt$4 = 86400, Zt$3 = "https://pulse.walletconnect.org/batch";
function Js$2(n$2, e) {
	if (n$2.length >= 255) throw new TypeError("Alphabet too long");
	for (var t = new Uint8Array(256), s = 0; s < t.length; s++) t[s] = 255;
	for (var i$2 = 0; i$2 < n$2.length; i$2++) {
		var r$1 = n$2.charAt(i$2), o$2 = r$1.charCodeAt(0);
		if (t[o$2] !== 255) throw new TypeError(r$1 + " is ambiguous");
		t[o$2] = i$2;
	}
	var a$1 = n$2.length, c$3 = n$2.charAt(0), h$4 = Math.log(a$1) / Math.log(256), u$2 = Math.log(256) / Math.log(a$1);
	function g$2(l$2) {
		if (l$2 instanceof Uint8Array || (ArrayBuffer.isView(l$2) ? l$2 = new Uint8Array(l$2.buffer, l$2.byteOffset, l$2.byteLength) : Array.isArray(l$2) && (l$2 = Uint8Array.from(l$2))), !(l$2 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
		if (l$2.length === 0) return "";
		for (var y$6 = 0, O$5 = 0, w$3 = 0, v$5 = l$2.length; w$3 !== v$5 && l$2[w$3] === 0;) w$3++, y$6++;
		for (var k$5 = (v$5 - w$3) * u$2 + 1 >>> 0, I$4 = new Uint8Array(k$5); w$3 !== v$5;) {
			for (var V$7 = l$2[w$3], X$1 = 0, K$4 = k$5 - 1; (V$7 !== 0 || X$1 < O$5) && K$4 !== -1; K$4--, X$1++) V$7 += 256 * I$4[K$4] >>> 0, I$4[K$4] = V$7 % a$1 >>> 0, V$7 = V$7 / a$1 >>> 0;
			if (V$7 !== 0) throw new Error("Non-zero carry");
			O$5 = X$1, w$3++;
		}
		for (var Y$5 = k$5 - O$5; Y$5 !== k$5 && I$4[Y$5] === 0;) Y$5++;
		for (var ge$2 = c$3.repeat(y$6); Y$5 < k$5; ++Y$5) ge$2 += n$2.charAt(I$4[Y$5]);
		return ge$2;
	}
	function m$2(l$2) {
		if (typeof l$2 != "string") throw new TypeError("Expected String");
		if (l$2.length === 0) return new Uint8Array();
		var y$6 = 0;
		if (l$2[y$6] !== " ") {
			for (var O$5 = 0, w$3 = 0; l$2[y$6] === c$3;) O$5++, y$6++;
			for (var v$5 = (l$2.length - y$6) * h$4 + 1 >>> 0, k$5 = new Uint8Array(v$5); l$2[y$6];) {
				var I$4 = t[l$2.charCodeAt(y$6)];
				if (I$4 === 255) return;
				for (var V$7 = 0, X$1 = v$5 - 1; (I$4 !== 0 || V$7 < w$3) && X$1 !== -1; X$1--, V$7++) I$4 += a$1 * k$5[X$1] >>> 0, k$5[X$1] = I$4 % 256 >>> 0, I$4 = I$4 / 256 >>> 0;
				if (I$4 !== 0) throw new Error("Non-zero carry");
				w$3 = V$7, y$6++;
			}
			if (l$2[y$6] !== " ") {
				for (var K$4 = v$5 - w$3; K$4 !== v$5 && k$5[K$4] === 0;) K$4++;
				for (var Y$5 = new Uint8Array(O$5 + (v$5 - K$4)), ge$2 = O$5; K$4 !== v$5;) Y$5[ge$2++] = k$5[K$4++];
				return Y$5;
			}
		}
	}
	function A$5(l$2) {
		var y$6 = m$2(l$2);
		if (y$6) return y$6;
		throw new Error(`Non-${e} character`);
	}
	return {
		encode: g$2,
		decodeUnsafe: m$2,
		decode: A$5
	};
}
var Ws$3 = Js$2;
var Qt$3 = (n$2) => {
	if (n$2 instanceof Uint8Array && n$2.constructor.name === "Uint8Array") return n$2;
	if (n$2 instanceof ArrayBuffer) return new Uint8Array(n$2);
	if (ArrayBuffer.isView(n$2)) return new Uint8Array(n$2.buffer, n$2.byteOffset, n$2.byteLength);
	throw new Error("Unknown type, must be binary type");
}, Zs$3 = (n$2) => new TextEncoder().encode(n$2), Qs$4 = (n$2) => new TextDecoder().decode(n$2);
var er$3 = class {
	constructor(e, t, s) {
		this.name = e, this.prefix = t, this.baseEncode = s;
	}
	encode(e) {
		if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
		throw Error("Unknown type, must be binary type");
	}
};
var tr$3 = class {
	constructor(e, t, s) {
		if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
		this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;
	}
	decode(e) {
		if (typeof e == "string") {
			if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
			return this.baseDecode(e.slice(this.prefix.length));
		} else throw Error("Can only multibase decode strings");
	}
	or(e) {
		return ei$3(this, e);
	}
};
var ir$3 = class {
	constructor(e) {
		this.decoders = e;
	}
	or(e) {
		return ei$3(this, e);
	}
	decode(e) {
		const t = e[0], s = this.decoders[t];
		if (s) return s.decode(e);
		throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
	}
};
var ei$3 = (n$2, e) => new ir$3({
	...n$2.decoders || { [n$2.prefix]: n$2 },
	...e.decoders || { [e.prefix]: e }
});
var sr$3 = class {
	constructor(e, t, s, i$2) {
		this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = i$2, this.encoder = new er$3(e, t, s), this.decoder = new tr$3(e, t, i$2);
	}
	encode(e) {
		return this.encoder.encode(e);
	}
	decode(e) {
		return this.decoder.decode(e);
	}
};
var ve$2 = ({ name: n$2, prefix: e, encode: t, decode: s }) => new sr$3(n$2, e, t, s), ue$4 = ({ prefix: n$2, name: e, alphabet: t }) => {
	const { encode: s, decode: i$2 } = Ws$3(t, e);
	return ve$2({
		prefix: n$2,
		name: e,
		encode: s,
		decode: (r$1) => Qt$3(i$2(r$1))
	});
}, rr$3 = (n$2, e, t, s) => {
	const i$2 = {};
	for (let u$2 = 0; u$2 < e.length; ++u$2) i$2[e[u$2]] = u$2;
	let r$1 = n$2.length;
	for (; n$2[r$1 - 1] === "=";) --r$1;
	const o$2 = new Uint8Array(r$1 * t / 8 | 0);
	let a$1 = 0, c$3 = 0, h$4 = 0;
	for (let u$2 = 0; u$2 < r$1; ++u$2) {
		const g$2 = i$2[n$2[u$2]];
		if (g$2 === void 0) throw new SyntaxError(`Non-${s} character`);
		c$3 = c$3 << t | g$2, a$1 += t, a$1 >= 8 && (a$1 -= 8, o$2[h$4++] = 255 & c$3 >> a$1);
	}
	if (a$1 >= t || 255 & c$3 << 8 - a$1) throw new SyntaxError("Unexpected end of data");
	return o$2;
}, nr$3 = (n$2, e, t) => {
	const s = e[e.length - 1] === "=", i$2 = (1 << t) - 1;
	let r$1 = "", o$2 = 0, a$1 = 0;
	for (let c$3 = 0; c$3 < n$2.length; ++c$3) for (a$1 = a$1 << 8 | n$2[c$3], o$2 += 8; o$2 > t;) o$2 -= t, r$1 += e[i$2 & a$1 >> o$2];
	if (o$2 && (r$1 += e[i$2 & a$1 << t - o$2]), s) for (; r$1.length * t & 7;) r$1 += "=";
	return r$1;
}, C$5 = ({ name: n$2, prefix: e, bitsPerChar: t, alphabet: s }) => ve$2({
	prefix: e,
	name: n$2,
	encode(i$2) {
		return nr$3(i$2, s, t);
	},
	decode(i$2) {
		return rr$3(i$2, s, t, n$2);
	}
}), or$3 = ve$2({
	prefix: "\0",
	name: "identity",
	encode: (n$2) => Qs$4(n$2),
	decode: (n$2) => Zs$3(n$2)
});
var ar$2 = Object.freeze({
	__proto__: null,
	identity: or$3
});
var cr$3 = C$5({
	prefix: "0",
	name: "base2",
	alphabet: "01",
	bitsPerChar: 1
});
var hr$2 = Object.freeze({
	__proto__: null,
	base2: cr$3
});
var lr$3 = C$5({
	prefix: "7",
	name: "base8",
	alphabet: "01234567",
	bitsPerChar: 3
});
var ur$1 = Object.freeze({
	__proto__: null,
	base8: lr$3
});
var dr$3 = ue$4({
	prefix: "9",
	name: "base10",
	alphabet: "0123456789"
});
var pr$3 = Object.freeze({
	__proto__: null,
	base10: dr$3
});
var gr$3 = C$5({
	prefix: "f",
	name: "base16",
	alphabet: "0123456789abcdef",
	bitsPerChar: 4
}), yr$3 = C$5({
	prefix: "F",
	name: "base16upper",
	alphabet: "0123456789ABCDEF",
	bitsPerChar: 4
});
var br$3 = Object.freeze({
	__proto__: null,
	base16: gr$3,
	base16upper: yr$3
});
var Dr$2 = C$5({
	prefix: "b",
	name: "base32",
	alphabet: "abcdefghijklmnopqrstuvwxyz234567",
	bitsPerChar: 5
}), mr$2 = C$5({
	prefix: "B",
	name: "base32upper",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
	bitsPerChar: 5
}), vr$3 = C$5({
	prefix: "c",
	name: "base32pad",
	alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
	bitsPerChar: 5
}), fr$2 = C$5({
	prefix: "C",
	name: "base32padupper",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
	bitsPerChar: 5
}), _r$3 = C$5({
	prefix: "v",
	name: "base32hex",
	alphabet: "0123456789abcdefghijklmnopqrstuv",
	bitsPerChar: 5
}), Er$3 = C$5({
	prefix: "V",
	name: "base32hexupper",
	alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
	bitsPerChar: 5
}), wr$3 = C$5({
	prefix: "t",
	name: "base32hexpad",
	alphabet: "0123456789abcdefghijklmnopqrstuv=",
	bitsPerChar: 5
}), Ir$4 = C$5({
	prefix: "T",
	name: "base32hexpadupper",
	alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
	bitsPerChar: 5
}), Tr$2 = C$5({
	prefix: "h",
	name: "base32z",
	alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
	bitsPerChar: 5
});
var Cr$2 = Object.freeze({
	__proto__: null,
	base32: Dr$2,
	base32upper: mr$2,
	base32pad: vr$3,
	base32padupper: fr$2,
	base32hex: _r$3,
	base32hexupper: Er$3,
	base32hexpad: wr$3,
	base32hexpadupper: Ir$4,
	base32z: Tr$2
});
var Pr$2 = ue$4({
	prefix: "k",
	name: "base36",
	alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), Sr$3 = ue$4({
	prefix: "K",
	name: "base36upper",
	alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var Rr$3 = Object.freeze({
	__proto__: null,
	base36: Pr$2,
	base36upper: Sr$3
});
var xr$3 = ue$4({
	name: "base58btc",
	prefix: "z",
	alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), Or$3 = ue$4({
	name: "base58flickr",
	prefix: "Z",
	alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var Ar$4 = Object.freeze({
	__proto__: null,
	base58btc: xr$3,
	base58flickr: Or$3
});
var Nr$4 = C$5({
	prefix: "m",
	name: "base64",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	bitsPerChar: 6
}), $r$3 = C$5({
	prefix: "M",
	name: "base64pad",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
	bitsPerChar: 6
}), zr$4 = C$5({
	prefix: "u",
	name: "base64url",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
	bitsPerChar: 6
}), Lr$2 = C$5({
	prefix: "U",
	name: "base64urlpad",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
	bitsPerChar: 6
});
var kr$2 = Object.freeze({
	__proto__: null,
	base64: Nr$4,
	base64pad: $r$3,
	base64url: zr$4,
	base64urlpad: Lr$2
});
var ti$4 = Array.from(""), Ur$3 = ti$4.reduce((n$2, e, t) => (n$2[t] = e, n$2), []), Fr$2 = ti$4.reduce((n$2, e, t) => (n$2[e.codePointAt(0)] = t, n$2), []);
function Mr$2(n$2) {
	return n$2.reduce((e, t) => (e += Ur$3[t], e), "");
}
function Kr$2(n$2) {
	const e = [];
	for (const t of n$2) {
		const s = Fr$2[t.codePointAt(0)];
		if (s === void 0) throw new Error(`Non-base256emoji character: ${t}`);
		e.push(s);
	}
	return new Uint8Array(e);
}
var Br$3 = ve$2({
	prefix: "",
	name: "base256emoji",
	encode: Mr$2,
	decode: Kr$2
});
var jr$2 = Object.freeze({
	__proto__: null,
	base256emoji: Br$3
}), Vr$2 = si$4, ii$4 = 128, Gr$3 = -128, Hr$2 = Math.pow(2, 31);
function si$4(n$2, e, t) {
	e = e || [], t = t || 0;
	for (var s = t; n$2 >= Hr$2;) e[t++] = n$2 & 255 | ii$4, n$2 /= 128;
	for (; n$2 & Gr$3;) e[t++] = n$2 & 255 | ii$4, n$2 >>>= 7;
	return e[t] = n$2 | 0, si$4.bytes = t - s + 1, e;
}
var Yr$4 = Le$6, Jr$4 = 128, ri$4 = 127;
function Le$6(n$2, s) {
	var t = 0, s = s || 0, i$2 = 0, r$1 = s, o$2, a$1 = n$2.length;
	do {
		if (r$1 >= a$1) throw Le$6.bytes = 0, /* @__PURE__ */ new RangeError("Could not decode varint");
		o$2 = n$2[r$1++], t += i$2 < 28 ? (o$2 & ri$4) << i$2 : (o$2 & ri$4) * Math.pow(2, i$2), i$2 += 7;
	} while (o$2 >= Jr$4);
	return Le$6.bytes = r$1 - s, t;
}
var Xr$3 = Math.pow(2, 7), Wr$4 = Math.pow(2, 14), Zr$3 = Math.pow(2, 21), Qr$2 = Math.pow(2, 28), en$3 = Math.pow(2, 35), tn$3 = Math.pow(2, 42), sn$4 = Math.pow(2, 49), rn$3 = Math.pow(2, 56), nn$3 = Math.pow(2, 63), on$3 = function(n$2) {
	return n$2 < Xr$3 ? 1 : n$2 < Wr$4 ? 2 : n$2 < Zr$3 ? 3 : n$2 < Qr$2 ? 4 : n$2 < en$3 ? 5 : n$2 < tn$3 ? 6 : n$2 < sn$4 ? 7 : n$2 < rn$3 ? 8 : n$2 < nn$3 ? 9 : 10;
}, ni$4 = {
	encode: Vr$2,
	decode: Yr$4,
	encodingLength: on$3
};
var oi$3 = (n$2, e, t = 0) => (ni$4.encode(n$2, e, t), e), ai$3 = (n$2) => ni$4.encodingLength(n$2), ke$6 = (n$2, e) => {
	const t = e.byteLength, s = ai$3(n$2), i$2 = s + ai$3(t), r$1 = new Uint8Array(i$2 + t);
	return oi$3(n$2, r$1, 0), oi$3(t, r$1, s), r$1.set(e, i$2), new cn$2(n$2, t, e, r$1);
};
var cn$2 = class {
	constructor(e, t, s, i$2) {
		this.code = e, this.size = t, this.digest = s, this.bytes = i$2;
	}
};
var ci$3 = ({ name: n$2, code: e, encode: t }) => new hn$3(n$2, e, t);
var hn$3 = class {
	constructor(e, t, s) {
		this.name = e, this.code = t, this.encode = s;
	}
	digest(e) {
		if (e instanceof Uint8Array) {
			const t = this.encode(e);
			return t instanceof Uint8Array ? ke$6(this.code, t) : t.then((s) => ke$6(this.code, s));
		} else throw Error("Unknown type, must be binary type");
	}
};
var hi$2 = (n$2) => async (e) => new Uint8Array(await crypto.subtle.digest(n$2, e)), ln$2 = ci$3({
	name: "sha2-256",
	code: 18,
	encode: hi$2("SHA-256")
}), un$3 = ci$3({
	name: "sha2-512",
	code: 19,
	encode: hi$2("SHA-512")
});
var dn$2 = Object.freeze({
	__proto__: null,
	sha256: ln$2,
	sha512: un$3
});
var li$4 = 0, pn$3 = "identity", ui$4 = Qt$3, gn$3 = (n$2) => ke$6(li$4, ui$4(n$2)), yn$2 = {
	code: li$4,
	name: pn$3,
	encode: ui$4,
	digest: gn$3
};
var bn$3 = Object.freeze({
	__proto__: null,
	identity: yn$2
});
new TextEncoder(), new TextDecoder();
var di$4 = {
	...ar$2,
	...hr$2,
	...ur$1,
	...pr$3,
	...br$3,
	...Cr$2,
	...Rr$3,
	...Ar$4,
	...kr$2,
	...jr$2
};
({
	...dn$2,
	...bn$3
});
function Dn$3(n$2 = 0) {
	return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(n$2) : new Uint8Array(n$2);
}
function pi$2(n$2, e, t, s) {
	return {
		name: n$2,
		prefix: e,
		encoder: {
			name: n$2,
			prefix: e,
			encode: t
		},
		decoder: { decode: s }
	};
}
var gi$3 = pi$2("utf8", "u", (n$2) => "u" + new TextDecoder("utf8").decode(n$2), (n$2) => new TextEncoder().encode(n$2.substring(1))), Ue$6 = pi$2("ascii", "a", (n$2) => {
	let e = "a";
	for (let t = 0; t < n$2.length; t++) e += String.fromCharCode(n$2[t]);
	return e;
}, (n$2) => {
	n$2 = n$2.substring(1);
	const e = Dn$3(n$2.length);
	for (let t = 0; t < n$2.length; t++) e[t] = n$2.charCodeAt(t);
	return e;
}), mn$3 = {
	utf8: gi$3,
	"utf-8": gi$3,
	hex: di$4.base16,
	latin1: Ue$6,
	ascii: Ue$6,
	binary: Ue$6,
	...di$4
};
function vn$3(n$2, e = "utf8") {
	const t = mn$3[e];
	if (!t) throw new Error(`Unsupported encoding "${e}"`);
	return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n$2, "utf8") : t.decoder.decode(`${t.prefix}${n$2}`);
}
var fn$3 = Object.defineProperty, _n$3 = (n$2, e, t) => e in n$2 ? fn$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, G$3 = (n$2, e, t) => _n$3(n$2, typeof e != "symbol" ? e + "" : e, t);
var yi$4 = class {
	constructor(e, t) {
		this.core = e, this.logger = t, G$3(this, "keychain", /* @__PURE__ */ new Map()), G$3(this, "name", Et$5), G$3(this, "version", wt$5), G$3(this, "initialized", !1), G$3(this, "storagePrefix", B$3), G$3(this, "init", async () => {
			if (!this.initialized) {
				const s = await this.getKeyChain();
				typeof s < "u" && (this.keychain = s), this.initialized = !0;
			}
		}), G$3(this, "has", (s) => (this.isInitialized(), this.keychain.has(s))), G$3(this, "set", async (s, i$2) => {
			this.isInitialized(), this.keychain.set(s, i$2), await this.persist();
		}), G$3(this, "get", (s) => {
			this.isInitialized();
			const i$2 = this.keychain.get(s);
			if (typeof i$2 > "u") {
				const { message: r$1 } = te$4("NO_MATCHING_KEY", `${this.name}: ${s}`);
				throw new Error(r$1);
			}
			return i$2;
		}), G$3(this, "del", async (s) => {
			this.isInitialized(), this.keychain.delete(s), await this.persist();
		}), this.core = e, this.logger = E$1(t, this.name);
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
	}
	async setKeyChain(e) {
		await this.core.storage.setItem(this.storageKey, no$2(e));
	}
	async getKeyChain() {
		const e = await this.core.storage.getItem(this.storageKey);
		return typeof e < "u" ? ro$3(e) : void 0;
	}
	async persist() {
		await this.setKeyChain(this.keychain);
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$4("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var En$3 = Object.defineProperty, wn$3 = (n$2, e, t) => e in n$2 ? En$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, P$4 = (n$2, e, t) => wn$3(n$2, typeof e != "symbol" ? e + "" : e, t);
var bi$4 = class {
	constructor(e, t, s) {
		this.core = e, this.logger = t, P$4(this, "name", ft$3), P$4(this, "keychain"), P$4(this, "randomSessionIdentifier", ni$3()), P$4(this, "initialized", !1), P$4(this, "init", async () => {
			this.initialized || (await this.keychain.init(), this.initialized = !0);
		}), P$4(this, "hasKeys", (i$2) => (this.isInitialized(), this.keychain.has(i$2))), P$4(this, "getClientId", async () => {
			this.isInitialized();
			const i$2 = await this.getClientSeed(), r$1 = Po$4(i$2);
			return Qe$5(r$1.publicKey);
		}), P$4(this, "generateKeyPair", () => {
			this.isInitialized();
			const i$2 = ti$3();
			return this.setPrivateKey(i$2.publicKey, i$2.privateKey);
		}), P$4(this, "signJWT", async (i$2) => {
			this.isInitialized();
			const r$1 = await this.getClientSeed(), o$2 = Po$4(r$1), a$1 = this.randomSessionIdentifier, c$3 = _t$5;
			return await Qo$1(a$1, i$2, c$3, o$2);
		}), P$4(this, "generateSharedKey", (i$2, r$1, o$2) => {
			this.isInitialized();
			const c$3 = ri$3(this.getPrivateKey(i$2), r$1);
			return this.setSymKey(c$3, o$2);
		}), P$4(this, "setSymKey", async (i$2, r$1) => {
			this.isInitialized();
			const o$2 = r$1 || oi$2(i$2);
			return await this.keychain.set(o$2, i$2), o$2;
		}), P$4(this, "deleteKeyPair", async (i$2) => {
			this.isInitialized(), await this.keychain.del(i$2);
		}), P$4(this, "deleteSymKey", async (i$2) => {
			this.isInitialized(), await this.keychain.del(i$2);
		}), P$4(this, "encode", async (i$2, r$1, o$2) => {
			this.isInitialized();
			const a$1 = rr$2(o$2), c$3 = safeJsonStringify(r$1);
			if (di$3(a$1)) return ai$2(c$3, o$2?.encoding);
			if (li$3(a$1)) {
				const m$2 = a$1.senderPublicKey, A$5 = a$1.receiverPublicKey;
				i$2 = await this.generateSharedKey(m$2, A$5);
			}
			const h$4 = this.getSymKey(i$2), { type: u$2, senderPublicKey: g$2 } = a$1;
			return ii$3({
				type: u$2,
				symKey: h$4,
				message: c$3,
				senderPublicKey: g$2,
				encoding: o$2?.encoding
			});
		}), P$4(this, "decode", async (i$2, r$1, o$2) => {
			this.isInitialized();
			const a$1 = fi$3(r$1, o$2);
			if (di$3(a$1)) return safeJsonParse(ui$3(r$1, o$2?.encoding));
			if (li$3(a$1)) {
				const c$3 = a$1.receiverPublicKey, h$4 = a$1.senderPublicKey;
				i$2 = await this.generateSharedKey(c$3, h$4);
			}
			try {
				return safeJsonParse(ci$2({
					symKey: this.getSymKey(i$2),
					encoded: r$1,
					encoding: o$2?.encoding
				}));
			} catch (c$3) {
				this.logger.error(`Failed to decode message from topic: '${i$2}', clientId: '${await this.getClientId()}'`), this.logger.error(c$3);
			}
		}), P$4(this, "getPayloadType", (i$2, r$1 = At$5) => {
			return fe$3(Fe$4({
				encoded: i$2,
				encoding: r$1
			}).type);
		}), P$4(this, "getPayloadSenderPublicKey", (i$2, r$1 = At$5) => {
			const o$2 = Fe$4({
				encoded: i$2,
				encoding: r$1
			});
			return o$2.senderPublicKey ? toString(o$2.senderPublicKey, V$6) : void 0;
		}), this.core = e, this.logger = E$1(t, this.name), this.keychain = s || new yi$4(this.core, this.logger);
	}
	get context() {
		return y$1(this.logger);
	}
	async setPrivateKey(e, t) {
		return await this.keychain.set(e, t), e;
	}
	getPrivateKey(e) {
		return this.keychain.get(e);
	}
	async getClientSeed() {
		let e = "";
		try {
			e = this.keychain.get(Ae$4);
		} catch {
			e = ni$3(), await this.keychain.set(Ae$4, e);
		}
		return vn$3(e, "base16");
	}
	getSymKey(e) {
		return this.keychain.get(e);
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$4("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var In$4 = Object.defineProperty, Tn$3 = (n$2, e, t) => e in n$2 ? In$4(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, H$3 = (n$2, e, t) => Tn$3(n$2, typeof e != "symbol" ? e + "" : e, t);
var Di$4 = class extends y$5 {
	constructor(e, t) {
		super(e, t), this.logger = e, this.core = t, H$3(this, "messages", /* @__PURE__ */ new Map()), H$3(this, "name", It$2), H$3(this, "version", Tt$4), H$3(this, "initialized", !1), H$3(this, "storagePrefix", B$3), H$3(this, "init", async () => {
			if (!this.initialized) {
				this.logger.trace("Initialized");
				try {
					const s = await this.getRelayerMessages();
					typeof s < "u" && (this.messages = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
						type: "method",
						method: "restore",
						size: this.messages.size
					});
				} catch (s) {
					this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);
				} finally {
					this.initialized = !0;
				}
			}
		}), H$3(this, "set", async (s, i$2) => {
			this.isInitialized();
			const r$1 = si$3(i$2);
			let o$2 = this.messages.get(s);
			return typeof o$2 > "u" && (o$2 = {}), typeof o$2[r$1] < "u" || (o$2[r$1] = i$2, this.messages.set(s, o$2), await this.persist()), r$1;
		}), H$3(this, "get", (s) => {
			this.isInitialized();
			let i$2 = this.messages.get(s);
			return typeof i$2 > "u" && (i$2 = {}), i$2;
		}), H$3(this, "has", (s, i$2) => {
			this.isInitialized();
			return typeof this.get(s)[si$3(i$2)] < "u";
		}), H$3(this, "del", async (s) => {
			this.isInitialized(), this.messages.delete(s), await this.persist();
		}), this.logger = E$1(e, this.name), this.core = t;
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
	}
	async setRelayerMessages(e) {
		await this.core.storage.setItem(this.storageKey, no$2(e));
	}
	async getRelayerMessages() {
		const e = await this.core.storage.getItem(this.storageKey);
		return typeof e < "u" ? ro$3(e) : void 0;
	}
	async persist() {
		await this.setRelayerMessages(this.messages);
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$4("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var Cn$3 = Object.defineProperty, Pn$2 = Object.defineProperties, Sn$2 = Object.getOwnPropertyDescriptors, mi$4 = Object.getOwnPropertySymbols, Rn$3 = Object.prototype.hasOwnProperty, xn$3 = Object.prototype.propertyIsEnumerable, Fe$5 = (n$2, e, t) => e in n$2 ? Cn$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, fe$4 = (n$2, e) => {
	for (var t in e || (e = {})) Rn$3.call(e, t) && Fe$5(n$2, t, e[t]);
	if (mi$4) for (var t of mi$4(e)) xn$3.call(e, t) && Fe$5(n$2, t, e[t]);
	return n$2;
}, Me$7 = (n$2, e) => Pn$2(n$2, Sn$2(e)), j$1 = (n$2, e, t) => Fe$5(n$2, typeof e != "symbol" ? e + "" : e, t);
var On$4 = class extends m$1 {
	constructor(e, t) {
		super(e, t), this.relayer = e, this.logger = t, j$1(this, "events", new import_events$6.EventEmitter()), j$1(this, "name", Ct$3), j$1(this, "queue", /* @__PURE__ */ new Map()), j$1(this, "publishTimeout", (0, import_cjs$7.toMiliseconds)(import_cjs$7.ONE_MINUTE)), j$1(this, "initialPublishTimeout", (0, import_cjs$7.toMiliseconds)(import_cjs$7.ONE_SECOND * 15)), j$1(this, "needsTransportRestart", !1), j$1(this, "publish", async (s, i$2, r$1) => {
			var o$2;
			this.logger.debug("Publishing Payload"), this.logger.trace({
				type: "method",
				method: "publish",
				params: {
					topic: s,
					message: i$2,
					opts: r$1
				}
			});
			const a$1 = r$1?.ttl || Ne$3, c$3 = yi$3(r$1), h$4 = r$1?.prompt || !1, u$2 = r$1?.tag || 0, g$2 = r$1?.id || getBigIntRpcId().toString(), m$2 = {
				topic: s,
				message: i$2,
				opts: {
					ttl: a$1,
					relay: c$3,
					prompt: h$4,
					tag: u$2,
					id: g$2,
					attestation: r$1?.attestation,
					tvf: r$1?.tvf
				}
			}, A$5 = `Failed to publish payload, please try again. id:${g$2} tag:${u$2}`;
			try {
				const l$2 = new Promise(async (y$6) => {
					const O$5 = ({ id: v$5 }) => {
						m$2.opts.id === v$5 && (this.removeRequestFromQueue(v$5), this.relayer.events.removeListener(T$1.publish, O$5), y$6(m$2));
					};
					this.relayer.events.on(T$1.publish, O$5);
					const w$3 = ao$3(new Promise((v$5, k$5) => {
						this.rpcPublish({
							topic: s,
							message: i$2,
							ttl: a$1,
							prompt: h$4,
							tag: u$2,
							id: g$2,
							attestation: r$1?.attestation,
							tvf: r$1?.tvf
						}).then(v$5).catch((I$4) => {
							this.logger.warn(I$4, I$4?.message), k$5(I$4);
						});
					}), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${g$2} tag:${u$2}`);
					try {
						await w$3, this.events.removeListener(T$1.publish, O$5);
					} catch (v$5) {
						this.queue.set(g$2, Me$7(fe$4({}, m$2), { attempt: 1 })), this.logger.warn(v$5, v$5?.message);
					}
				});
				this.logger.trace({
					type: "method",
					method: "publish",
					params: {
						id: g$2,
						topic: s,
						message: i$2,
						opts: r$1
					}
				}), await ao$3(l$2, this.publishTimeout, A$5);
			} catch (l$2) {
				if (this.logger.debug("Failed to Publish Payload"), this.logger.error(l$2), (o$2 = r$1?.internal) != null && o$2.throwOnFailedPublish) throw l$2;
			} finally {
				this.queue.delete(g$2);
			}
		}), j$1(this, "on", (s, i$2) => {
			this.events.on(s, i$2);
		}), j$1(this, "once", (s, i$2) => {
			this.events.once(s, i$2);
		}), j$1(this, "off", (s, i$2) => {
			this.events.off(s, i$2);
		}), j$1(this, "removeListener", (s, i$2) => {
			this.events.removeListener(s, i$2);
		}), this.relayer = e, this.logger = E$1(t, this.name), this.registerEventListeners();
	}
	get context() {
		return y$1(this.logger);
	}
	async rpcPublish(e) {
		var t, s, i$2, r$1;
		const { topic: o$2, message: a$1, ttl: c$3 = Ne$3, prompt: h$4, tag: u$2, id: g$2, attestation: m$2, tvf: A$5 } = e, l$2 = {
			method: mi$3(yi$3().protocol).publish,
			params: fe$4({
				topic: o$2,
				message: a$1,
				ttl: c$3,
				prompt: h$4,
				tag: u$2,
				attestation: m$2
			}, A$5),
			id: g$2
		};
		ae$4((t = l$2.params) == null ? void 0 : t.prompt) && ((s = l$2.params) == null || delete s.prompt), ae$4((i$2 = l$2.params) == null ? void 0 : i$2.tag) && ((r$1 = l$2.params) == null || delete r$1.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
			type: "message",
			direction: "outgoing",
			request: l$2
		});
		const y$6 = await this.relayer.request(l$2);
		return this.relayer.events.emit(T$1.publish, e), this.logger.debug("Successfully Published Payload"), y$6;
	}
	removeRequestFromQueue(e) {
		this.queue.delete(e);
	}
	checkQueue() {
		this.queue.forEach(async (e, t) => {
			const s = e.attempt + 1;
			this.queue.set(t, Me$7(fe$4({}, e), { attempt: s }));
			const { topic: i$2, message: r$1, opts: o$2, attestation: a$1 } = e;
			this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s}`), await this.rpcPublish(Me$7(fe$4({}, e), {
				topic: i$2,
				message: r$1,
				ttl: o$2.ttl,
				prompt: o$2.prompt,
				tag: o$2.tag,
				id: o$2.id,
				attestation: a$1,
				tvf: o$2.tvf
			})), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
		});
	}
	registerEventListeners() {
		this.relayer.core.heartbeat.on(r.pulse, () => {
			if (this.needsTransportRestart) {
				this.needsTransportRestart = !1, this.relayer.events.emit(T$1.connection_stalled);
				return;
			}
			this.checkQueue();
		}), this.relayer.on(T$1.message_ack, (e) => {
			this.removeRequestFromQueue(e.id.toString());
		});
	}
};
var An$2 = Object.defineProperty, Nn$2 = (n$2, e, t) => e in n$2 ? An$2(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, re$4 = (n$2, e, t) => Nn$2(n$2, typeof e != "symbol" ? e + "" : e, t);
var $n$2 = class {
	constructor() {
		re$4(this, "map", /* @__PURE__ */ new Map()), re$4(this, "set", (e, t) => {
			const s = this.get(e);
			this.exists(e, t) || this.map.set(e, [...s, t]);
		}), re$4(this, "get", (e) => this.map.get(e) || []), re$4(this, "exists", (e, t) => this.get(e).includes(t)), re$4(this, "delete", (e, t) => {
			if (typeof t > "u") {
				this.map.delete(e);
				return;
			}
			if (!this.map.has(e)) return;
			const s = this.get(e);
			if (!this.exists(e, t)) return;
			const i$2 = s.filter((r$1) => r$1 !== t);
			if (!i$2.length) {
				this.map.delete(e);
				return;
			}
			this.map.set(e, i$2);
		}), re$4(this, "clear", () => {
			this.map.clear();
		});
	}
	get topics() {
		return Array.from(this.map.keys());
	}
};
var zn$3 = Object.defineProperty, Ln$3 = Object.defineProperties, kn$3 = Object.getOwnPropertyDescriptors, vi$3 = Object.getOwnPropertySymbols, Un$3 = Object.prototype.hasOwnProperty, Fn$3 = Object.prototype.propertyIsEnumerable, Ke$6 = (n$2, e, t) => e in n$2 ? zn$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, de$5 = (n$2, e) => {
	for (var t in e || (e = {})) Un$3.call(e, t) && Ke$6(n$2, t, e[t]);
	if (vi$3) for (var t of vi$3(e)) Fn$3.call(e, t) && Ke$6(n$2, t, e[t]);
	return n$2;
}, Be$6 = (n$2, e) => Ln$3(n$2, kn$3(e)), D$2 = (n$2, e, t) => Ke$6(n$2, typeof e != "symbol" ? e + "" : e, t);
var fi$4 = class extends P$3 {
	constructor(e, t) {
		super(e, t), this.relayer = e, this.logger = t, D$2(this, "subscriptions", /* @__PURE__ */ new Map()), D$2(this, "topicMap", new $n$2()), D$2(this, "events", new import_events$6.EventEmitter()), D$2(this, "name", $t$2), D$2(this, "version", zt$4), D$2(this, "pending", /* @__PURE__ */ new Map()), D$2(this, "cached", []), D$2(this, "initialized", !1), D$2(this, "pendingSubscriptionWatchLabel", "pending_sub_watch_label"), D$2(this, "pollingInterval", 20), D$2(this, "storagePrefix", B$3), D$2(this, "subscribeTimeout", (0, import_cjs$7.toMiliseconds)(import_cjs$7.ONE_MINUTE)), D$2(this, "initialSubscribeTimeout", (0, import_cjs$7.toMiliseconds)(import_cjs$7.ONE_SECOND * 15)), D$2(this, "clientId"), D$2(this, "batchSubscribeTopicsLimit", 500), D$2(this, "init", async () => {
			this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = !0;
		}), D$2(this, "subscribe", async (s, i$2) => {
			this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({
				type: "method",
				method: "subscribe",
				params: {
					topic: s,
					opts: i$2
				}
			});
			try {
				const r$1 = yi$3(i$2), o$2 = {
					topic: s,
					relay: r$1,
					transportType: i$2?.transportType
				};
				this.pending.set(s, o$2);
				const a$1 = await this.rpcSubscribe(s, r$1, i$2);
				return typeof a$1 == "string" && (this.onSubscribe(a$1, o$2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({
					type: "method",
					method: "subscribe",
					params: {
						topic: s,
						opts: i$2
					}
				})), a$1;
			} catch (r$1) {
				throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r$1), r$1;
			}
		}), D$2(this, "unsubscribe", async (s, i$2) => {
			this.isInitialized(), typeof i$2?.id < "u" ? await this.unsubscribeById(s, i$2.id, i$2) : await this.unsubscribeByTopic(s, i$2);
		}), D$2(this, "isSubscribed", async (s) => {
			if (this.topics.includes(s)) return !0;
			const i$2 = `${this.pendingSubscriptionWatchLabel}_${s}`;
			return await new Promise((r$1, o$2) => {
				const a$1 = new import_cjs$7.Watch();
				a$1.start(i$2);
				const c$3 = setInterval(() => {
					(!this.pending.has(s) && this.topics.includes(s) || this.cached.some((h$4) => h$4.topic === s)) && (clearInterval(c$3), a$1.stop(i$2), r$1(!0)), a$1.elapsed(i$2) >= Lt$4 && (clearInterval(c$3), a$1.stop(i$2), o$2(/* @__PURE__ */ new Error("Subscription resolution timeout")));
				}, this.pollingInterval);
			}).catch(() => !1);
		}), D$2(this, "on", (s, i$2) => {
			this.events.on(s, i$2);
		}), D$2(this, "once", (s, i$2) => {
			this.events.once(s, i$2);
		}), D$2(this, "off", (s, i$2) => {
			this.events.off(s, i$2);
		}), D$2(this, "removeListener", (s, i$2) => {
			this.events.removeListener(s, i$2);
		}), D$2(this, "start", async () => {
			await this.onConnect();
		}), D$2(this, "stop", async () => {
			await this.onDisconnect();
		}), D$2(this, "restart", async () => {
			await this.restore(), await this.onRestart();
		}), D$2(this, "checkPending", async () => {
			if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
			const s = [];
			this.pending.forEach((i$2) => {
				s.push(i$2);
			}), await this.batchSubscribe(s);
		}), D$2(this, "registerEventListeners", () => {
			this.relayer.core.heartbeat.on(r.pulse, async () => {
				await this.checkPending();
			}), this.events.on($$5.created, async (s) => {
				const i$2 = $$5.created;
				this.logger.info(`Emitting ${i$2}`), this.logger.debug({
					type: "event",
					event: i$2,
					data: s
				}), await this.persist();
			}), this.events.on($$5.deleted, async (s) => {
				const i$2 = $$5.deleted;
				this.logger.info(`Emitting ${i$2}`), this.logger.debug({
					type: "event",
					event: i$2,
					data: s
				}), await this.persist();
			});
		}), this.relayer = e, this.logger = E$1(t, this.name), this.clientId = "";
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
	}
	get length() {
		return this.subscriptions.size;
	}
	get ids() {
		return Array.from(this.subscriptions.keys());
	}
	get values() {
		return Array.from(this.subscriptions.values());
	}
	get topics() {
		return this.topicMap.topics;
	}
	get hasAnyTopics() {
		return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
	}
	hasSubscription(e, t) {
		let s = !1;
		try {
			s = this.getSubscription(e).topic === t;
		} catch {}
		return s;
	}
	reset() {
		this.cached = [], this.initialized = !0;
	}
	onDisable() {
		this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
	}
	async unsubscribeByTopic(e, t) {
		const s = this.topicMap.get(e);
		await Promise.all(s.map(async (i$2) => await this.unsubscribeById(e, i$2, t)));
	}
	async unsubscribeById(e, t, s) {
		this.logger.debug("Unsubscribing Topic"), this.logger.trace({
			type: "method",
			method: "unsubscribe",
			params: {
				topic: e,
				id: t,
				opts: s
			}
		});
		try {
			const i$2 = yi$3(s);
			await this.restartToComplete({
				topic: e,
				id: t,
				relay: i$2
			}), await this.rpcUnsubscribe(e, t, i$2);
			const r$1 = de$3("USER_DISCONNECTED", `${this.name}, ${e}`);
			await this.onUnsubscribe(e, t, r$1), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({
				type: "method",
				method: "unsubscribe",
				params: {
					topic: e,
					id: t,
					opts: s
				}
			});
		} catch (i$2) {
			throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i$2), i$2;
		}
	}
	async rpcSubscribe(e, t, s) {
		var i$2;
		(!s || s?.transportType === Q$3.relay) && await this.restartToComplete({
			topic: e,
			id: e,
			relay: t
		});
		const r$1 = {
			method: mi$3(t.protocol).subscribe,
			params: { topic: e }
		};
		this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
			type: "payload",
			direction: "outgoing",
			request: r$1
		});
		const o$2 = (i$2 = s?.internal) == null ? void 0 : i$2.throwOnFailedPublish;
		try {
			const a$1 = await this.getSubscriptionId(e);
			if (s?.transportType === Q$3.link_mode) return setTimeout(() => {
				(this.relayer.connected || this.relayer.connecting) && this.relayer.request(r$1).catch((u$2) => this.logger.warn(u$2));
			}, (0, import_cjs$7.toMiliseconds)(import_cjs$7.ONE_SECOND)), a$1;
			const h$4 = await ao$3(new Promise(async (u$2) => {
				const g$2 = (m$2) => {
					m$2.topic === e && (this.events.removeListener($$5.created, g$2), u$2(m$2.id));
				};
				this.events.on($$5.created, g$2);
				try {
					const m$2 = await ao$3(new Promise((A$5, l$2) => {
						this.relayer.request(r$1).catch((y$6) => {
							this.logger.warn(y$6, y$6?.message), l$2(y$6);
						}).then(A$5);
					}), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
					this.events.removeListener($$5.created, g$2), u$2(m$2);
				} catch {}
			}), this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
			if (!h$4 && o$2) throw new Error(`Subscribing to ${e} failed, please try again`);
			return h$4 ? a$1 : null;
		} catch (a$1) {
			if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(T$1.connection_stalled), o$2) throw a$1;
		}
		return null;
	}
	async rpcBatchSubscribe(e) {
		if (!e.length) return;
		const t = e[0].relay, s = {
			method: mi$3(t.protocol).batchSubscribe,
			params: { topics: e.map((i$2) => i$2.topic) }
		};
		this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
			type: "payload",
			direction: "outgoing",
			request: s
		});
		try {
			await await ao$3(new Promise((i$2) => {
				this.relayer.request(s).catch((r$1) => this.logger.warn(r$1)).then(i$2);
			}), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
		} catch {
			this.relayer.events.emit(T$1.connection_stalled);
		}
	}
	async rpcBatchFetchMessages(e) {
		if (!e.length) return;
		const t = e[0].relay, s = {
			method: mi$3(t.protocol).batchFetchMessages,
			params: { topics: e.map((r$1) => r$1.topic) }
		};
		this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
			type: "payload",
			direction: "outgoing",
			request: s
		});
		let i$2;
		try {
			i$2 = await await ao$3(new Promise((r$1, o$2) => {
				this.relayer.request(s).catch((a$1) => {
					this.logger.warn(a$1), o$2(a$1);
				}).then(r$1);
			}), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
		} catch {
			this.relayer.events.emit(T$1.connection_stalled);
		}
		return i$2;
	}
	rpcUnsubscribe(e, t, s) {
		const i$2 = {
			method: mi$3(s.protocol).unsubscribe,
			params: {
				topic: e,
				id: t
			}
		};
		return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
			type: "payload",
			direction: "outgoing",
			request: i$2
		}), this.relayer.request(i$2);
	}
	onSubscribe(e, t) {
		this.setSubscription(e, Be$6(de$5({}, t), { id: e })), this.pending.delete(t.topic);
	}
	onBatchSubscribe(e) {
		e.length && e.forEach((t) => {
			this.setSubscription(t.id, de$5({}, t)), this.pending.delete(t.topic);
		});
	}
	async onUnsubscribe(e, t, s) {
		this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e);
	}
	async setRelayerSubscriptions(e) {
		await this.relayer.core.storage.setItem(this.storageKey, e);
	}
	async getRelayerSubscriptions() {
		return await this.relayer.core.storage.getItem(this.storageKey);
	}
	setSubscription(e, t) {
		this.logger.debug("Setting subscription"), this.logger.trace({
			type: "method",
			method: "setSubscription",
			id: e,
			subscription: t
		}), this.addSubscription(e, t);
	}
	addSubscription(e, t) {
		this.subscriptions.set(e, de$5({}, t)), this.topicMap.set(t.topic, e), this.events.emit($$5.created, t);
	}
	getSubscription(e) {
		this.logger.debug("Getting subscription"), this.logger.trace({
			type: "method",
			method: "getSubscription",
			id: e
		});
		const t = this.subscriptions.get(e);
		if (!t) {
			const { message: s } = te$4("NO_MATCHING_KEY", `${this.name}: ${e}`);
			throw new Error(s);
		}
		return t;
	}
	deleteSubscription(e, t) {
		this.logger.debug("Deleting subscription"), this.logger.trace({
			type: "method",
			method: "deleteSubscription",
			id: e,
			reason: t
		});
		const s = this.getSubscription(e);
		this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit($$5.deleted, Be$6(de$5({}, s), { reason: t }));
	}
	async persist() {
		await this.setRelayerSubscriptions(this.values), this.events.emit($$5.sync);
	}
	async onRestart() {
		if (this.cached.length) {
			const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
			for (let s = 0; s < t; s++) {
				const i$2 = e.splice(0, this.batchSubscribeTopicsLimit);
				await this.batchSubscribe(i$2);
			}
		}
		this.events.emit($$5.resubscribed);
	}
	async restore() {
		try {
			const e = await this.getRelayerSubscriptions();
			if (typeof e > "u" || !e.length) return;
			if (this.subscriptions.size) {
				const { message: t } = te$4("RESTORE_WILL_OVERRIDE", this.name);
				throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
			}
			this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({
				type: "method",
				method: "restore",
				subscriptions: this.values
			});
		} catch (e) {
			this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
		}
	}
	async batchSubscribe(e) {
		e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => Be$6(de$5({}, t), { id: await this.getSubscriptionId(t.topic) })))));
	}
	async batchFetchMessages(e) {
		if (!e.length) return;
		this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
		const t = await this.rpcBatchFetchMessages(e);
		t && t.messages && (await vo$3((0, import_cjs$7.toMiliseconds)(import_cjs$7.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
	}
	async onConnect() {
		await this.restart(), this.reset();
	}
	onDisconnect() {
		this.onDisable();
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$4("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
	async restartToComplete(e) {
		!this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
	}
	async getClientId() {
		return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
	}
	async getSubscriptionId(e) {
		return si$3(e + await this.getClientId());
	}
};
var Mn$3 = Object.defineProperty, _i$2 = Object.getOwnPropertySymbols, Kn$3 = Object.prototype.hasOwnProperty, Bn$3 = Object.prototype.propertyIsEnumerable, je$4 = (n$2, e, t) => e in n$2 ? Mn$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, Ei$4 = (n$2, e) => {
	for (var t in e || (e = {})) Kn$3.call(e, t) && je$4(n$2, t, e[t]);
	if (_i$2) for (var t of _i$2(e)) Bn$3.call(e, t) && je$4(n$2, t, e[t]);
	return n$2;
}, p$3 = (n$2, e, t) => je$4(n$2, typeof e != "symbol" ? e + "" : e, t);
var wi$3 = class extends d$2 {
	constructor(e) {
		super(e), p$3(this, "protocol", "wc"), p$3(this, "version", 2), p$3(this, "core"), p$3(this, "logger"), p$3(this, "events", new import_events$6.EventEmitter()), p$3(this, "provider"), p$3(this, "messages"), p$3(this, "subscriber"), p$3(this, "publisher"), p$3(this, "name", Rt$5), p$3(this, "transportExplicitlyClosed", !1), p$3(this, "initialized", !1), p$3(this, "connectionAttemptInProgress", !1), p$3(this, "relayUrl"), p$3(this, "projectId"), p$3(this, "packageName"), p$3(this, "bundleId"), p$3(this, "hasExperiencedNetworkDisruption", !1), p$3(this, "pingTimeout"), p$3(this, "heartBeatTimeout", (0, import_cjs$7.toMiliseconds)(import_cjs$7.THIRTY_SECONDS + import_cjs$7.FIVE_SECONDS)), p$3(this, "reconnectTimeout"), p$3(this, "connectPromise"), p$3(this, "reconnectInProgress", !1), p$3(this, "requestsInFlight", []), p$3(this, "connectTimeout", (0, import_cjs$7.toMiliseconds)(import_cjs$7.ONE_SECOND * 15)), p$3(this, "request", async (t) => {
			var s, i$2;
			this.logger.debug("Publishing Request Payload");
			const r$1 = t.id || getBigIntRpcId().toString();
			await this.toEstablishConnection();
			try {
				this.logger.trace({
					id: r$1,
					method: t.method,
					topic: (s = t.params) == null ? void 0 : s.topic
				}, "relayer.request - publishing...");
				const o$2 = `${r$1}:${((i$2 = t.params) == null ? void 0 : i$2.tag) || ""}`;
				this.requestsInFlight.push(o$2);
				const a$1 = await this.provider.request(t);
				return this.requestsInFlight = this.requestsInFlight.filter((c$3) => c$3 !== o$2), a$1;
			} catch (o$2) {
				throw this.logger.debug(`Failed to Publish Request: ${r$1}`), o$2;
			}
		}), p$3(this, "resetPingTimeout", () => {
			if (et$3()) try {
				clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
					var t, s, i$2;
					this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (i$2 = (s = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s.socket) == null || i$2.terminate();
				}, this.heartBeatTimeout);
			} catch (t) {
				this.logger.warn(t, t?.message);
			}
		}), p$3(this, "onPayloadHandler", (t) => {
			this.onProviderPayload(t), this.resetPingTimeout();
		}), p$3(this, "onConnectHandler", () => {
			this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(T$1.connect);
		}), p$3(this, "onDisconnectHandler", () => {
			this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
		}), p$3(this, "onProviderErrorHandler", (t) => {
			this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(T$1.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
		}), p$3(this, "registerProviderListeners", () => {
			this.provider.on(L$3.payload, this.onPayloadHandler), this.provider.on(L$3.connect, this.onConnectHandler), this.provider.on(L$3.disconnect, this.onDisconnectHandler), this.provider.on(L$3.error, this.onProviderErrorHandler);
		}), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E$1(e.logger, this.name) : (0, import_browser.default)(k({ level: e.logger || St$5 })), this.messages = new Di$4(this.logger, e.core), this.subscriber = new fi$4(this, this.logger), this.publisher = new On$4(this, this.logger), this.relayUrl = e?.relayUrl || $e$6, this.projectId = e.projectId, Wr$3() ? this.packageName = Jr$3() : zr$3() && (this.bundleId = Jr$3()), this.provider = {};
	}
	async init() {
		if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.hasAnyTopics) try {
			await this.transportOpen();
		} catch (e) {
			this.logger.warn(e, e?.message);
		}
	}
	get context() {
		return y$1(this.logger);
	}
	get connected() {
		var e, t, s;
		return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 1 || !1;
	}
	get connecting() {
		var e, t, s;
		return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 0 || this.connectPromise !== void 0 || !1;
	}
	async publish(e, t, s) {
		this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({
			topic: e,
			message: t,
			publishedAt: Date.now(),
			transportType: Q$3.relay
		});
	}
	async subscribe(e, t) {
		var s, i$2, r$1;
		this.isInitialized(), (!(t != null && t.transportType) || t?.transportType === "relay") && await this.toEstablishConnection();
		const o$2 = typeof ((s = t?.internal) == null ? void 0 : s.throwOnFailedPublish) > "u" ? !0 : (i$2 = t?.internal) == null ? void 0 : i$2.throwOnFailedPublish;
		let a$1 = ((r$1 = this.subscriber.topicMap.get(e)) == null ? void 0 : r$1[0]) || "", c$3;
		const h$4 = (u$2) => {
			u$2.topic === e && (this.subscriber.off($$5.created, h$4), c$3());
		};
		return await Promise.all([new Promise((u$2) => {
			c$3 = u$2, this.subscriber.on($$5.created, h$4);
		}), new Promise(async (u$2, g$2) => {
			a$1 = await this.subscriber.subscribe(e, Ei$4({ internal: { throwOnFailedPublish: o$2 } }, t)).catch((m$2) => {
				o$2 && g$2(m$2);
			}) || a$1, u$2();
		})]), a$1;
	}
	async unsubscribe(e, t) {
		this.isInitialized(), await this.subscriber.unsubscribe(e, t);
	}
	on(e, t) {
		this.events.on(e, t);
	}
	once(e, t) {
		this.events.once(e, t);
	}
	off(e, t) {
		this.events.off(e, t);
	}
	removeListener(e, t) {
		this.events.removeListener(e, t);
	}
	async transportDisconnect() {
		this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ao$3(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
	}
	async transportClose() {
		this.transportExplicitlyClosed = !0, await this.transportDisconnect();
	}
	async transportOpen(e) {
		if (!this.subscriber.hasAnyTopics) {
			this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
			return;
		}
		if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, s) => {
			await this.connect(e).then(t).catch(s).finally(() => {
				this.connectPromise = void 0;
			});
		}), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
	}
	async restartTransport(e) {
		this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
	}
	async confirmOnlineStateOrThrow() {
		if (!await Yi$3()) throw new Error("No internet connection detected. Please restart your network and try again.");
	}
	async handleBatchMessageEvents(e) {
		if (e?.length === 0) {
			this.logger.trace("Batch message events is empty. Ignoring...");
			return;
		}
		const t = e.sort((s, i$2) => s.publishedAt - i$2.publishedAt);
		this.logger.debug(`Batch of ${t.length} message events sorted`);
		for (const s of t) try {
			await this.onMessageEvent(s);
		} catch (i$2) {
			this.logger.warn(i$2, "Error while processing batch message event: " + i$2?.message);
		}
		this.logger.trace(`Batch of ${t.length} message events processed`);
	}
	async onLinkMessageEvent(e, t) {
		const { topic: s } = e;
		if (!t.sessionExists) {
			const r$1 = {
				topic: s,
				expiry: ho$3(import_cjs$7.FIVE_MINUTES),
				relay: { protocol: "irn" },
				active: !1
			};
			await this.core.pairing.pairings.set(s, r$1);
		}
		this.events.emit(T$1.message, e), await this.recordMessageEvent(e);
	}
	async connect(e) {
		await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
		let t = 1;
		for (; t < 6;) {
			try {
				if (this.transportExplicitlyClosed) break;
				this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (s, i$2) => {
					const r$1 = () => {
						i$2(/* @__PURE__ */ new Error("Connection interrupted while trying to subscribe"));
					};
					this.provider.once(L$3.disconnect, r$1), await ao$3(new Promise((o$2, a$1) => {
						this.provider.connect().then(o$2).catch(a$1);
					}), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o$2) => {
						i$2(o$2);
					}).finally(() => {
						this.provider.off(L$3.disconnect, r$1), clearTimeout(this.reconnectTimeout);
					}), await new Promise(async (o$2, a$1) => {
						const c$3 = () => {
							a$1(/* @__PURE__ */ new Error("Connection interrupted while trying to subscribe"));
						};
						this.provider.once(L$3.disconnect, c$3), await this.subscriber.start().then(o$2).catch(a$1).finally(() => {
							this.provider.off(L$3.disconnect, c$3);
						});
					}), this.hasExperiencedNetworkDisruption = !1, s();
				});
			} catch (s) {
				await this.subscriber.stop();
				const i$2 = s;
				this.logger.warn({}, i$2.message), this.hasExperiencedNetworkDisruption = !0;
			} finally {
				this.connectionAttemptInProgress = !1;
			}
			if (this.connected) {
				this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
				break;
			}
			await new Promise((s) => setTimeout(s, (0, import_cjs$7.toMiliseconds)(t * 1))), t++;
		}
	}
	startPingTimeout() {
		var e, t, s, i$2, r$1;
		if (et$3()) try {
			(t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r$1 = (i$2 = (s = this.provider) == null ? void 0 : s.connection) == null ? void 0 : i$2.socket) == null || r$1.on("ping", () => {
				this.resetPingTimeout();
			})), this.resetPingTimeout();
		} catch (o$2) {
			this.logger.warn(o$2, o$2?.message);
		}
	}
	async createProvider() {
		this.provider.connection && this.unregisterProviderListeners();
		const e = await this.core.crypto.signJWT(this.relayUrl);
		this.provider = new o(new f$2(Zr$2({
			sdkVersion: me$4,
			protocol: this.protocol,
			version: this.version,
			relayUrl: this.relayUrl,
			projectId: this.projectId,
			auth: e,
			useOnCloseEvent: !0,
			bundleId: this.bundleId,
			packageName: this.packageName
		}))), this.registerProviderListeners();
	}
	async recordMessageEvent(e) {
		const { topic: t, message: s } = e;
		await this.messages.set(t, s);
	}
	async shouldIgnoreMessageEvent(e) {
		const { topic: t, message: s } = e;
		if (!s || s.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${s}`), !0;
		if (!await this.subscriber.isSubscribed(t)) return this.logger.warn(`Ignoring message for non-subscribed topic ${t}`), !0;
		const i$2 = this.messages.has(t, s);
		return i$2 && this.logger.warn(`Ignoring duplicate message: ${s}`), i$2;
	}
	async onProviderPayload(e) {
		if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({
			type: "payload",
			direction: "incoming",
			payload: e
		}), isJsonRpcRequest(e)) {
			if (!e.method.endsWith(xt$4)) return;
			const t = e.params, { topic: s, message: i$2, publishedAt: r$1, attestation: o$2 } = t.data, a$1 = {
				topic: s,
				message: i$2,
				publishedAt: r$1,
				transportType: Q$3.relay,
				attestation: o$2
			};
			this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ei$4({
				type: "event",
				event: t.id
			}, a$1)), this.events.emit(t.id, a$1), await this.acknowledgePayload(e), await this.onMessageEvent(a$1);
		} else isJsonRpcResponse(e) && this.events.emit(T$1.message_ack, e);
	}
	async onMessageEvent(e) {
		await this.shouldIgnoreMessageEvent(e) || (this.events.emit(T$1.message, e), await this.recordMessageEvent(e));
	}
	async acknowledgePayload(e) {
		const t = formatJsonRpcResult(e.id, !0);
		await this.provider.connection.send(t);
	}
	unregisterProviderListeners() {
		this.provider.off(L$3.payload, this.onPayloadHandler), this.provider.off(L$3.connect, this.onConnectHandler), this.provider.off(L$3.disconnect, this.onDisconnectHandler), this.provider.off(L$3.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
	}
	async registerEventListeners() {
		let e = await Yi$3();
		Xi$2(async (t) => {
			e !== t && (e = t, t ? await this.transportOpen().catch((s) => this.logger.error(s, s?.message)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
		});
	}
	async onProviderDisconnect() {
		clearTimeout(this.pingTimeout), this.events.emit(T$1.disconnect), this.connectionAttemptInProgress = !1, !this.reconnectInProgress && (this.reconnectInProgress = !0, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
			await this.transportOpen().catch((e) => this.logger.error(e, e?.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = !1;
		}, (0, import_cjs$7.toMiliseconds)(Ot$3)))));
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$4("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
	async toEstablishConnection() {
		await this.confirmOnlineStateOrThrow(), !this.connected && await this.connect();
	}
};
var jn$3 = Object.defineProperty, Ii$2 = Object.getOwnPropertySymbols, Vn$3 = Object.prototype.hasOwnProperty, qn$3 = Object.prototype.propertyIsEnumerable, Ve$4 = (n$2, e, t) => e in n$2 ? jn$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, Ti$3 = (n$2, e) => {
	for (var t in e || (e = {})) Vn$3.call(e, t) && Ve$4(n$2, t, e[t]);
	if (Ii$2) for (var t of Ii$2(e)) qn$3.call(e, t) && Ve$4(n$2, t, e[t]);
	return n$2;
}, z$4 = (n$2, e, t) => Ve$4(n$2, typeof e != "symbol" ? e + "" : e, t);
var Ci$3 = class extends f$5 {
	constructor(e, t, s, i$2 = B$3, r$1 = void 0) {
		super(e, t, s, i$2), this.core = e, this.logger = t, this.name = s, z$4(this, "map", /* @__PURE__ */ new Map()), z$4(this, "version", At$6), z$4(this, "cached", []), z$4(this, "initialized", !1), z$4(this, "getKey"), z$4(this, "storagePrefix", B$3), z$4(this, "recentlyDeleted", []), z$4(this, "recentlyDeletedLimit", 200), z$4(this, "init", async () => {
			this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o$2) => {
				this.getKey && o$2 !== null && !ae$4(o$2) ? this.map.set(this.getKey(o$2), o$2) : Pi$3(o$2) ? this.map.set(o$2.id, o$2) : Li$3(o$2) && this.map.set(o$2.topic, o$2);
			}), this.cached = [], this.initialized = !0);
		}), z$4(this, "set", async (o$2, a$1) => {
			this.isInitialized(), this.map.has(o$2) ? await this.update(o$2, a$1) : (this.logger.debug("Setting value"), this.logger.trace({
				type: "method",
				method: "set",
				key: o$2,
				value: a$1
			}), this.map.set(o$2, a$1), await this.persist());
		}), z$4(this, "get", (o$2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({
			type: "method",
			method: "get",
			key: o$2
		}), this.getData(o$2))), z$4(this, "getAll", (o$2) => (this.isInitialized(), o$2 ? this.values.filter((a$1) => Object.keys(o$2).every((c$3) => (0, import_lodash.default)(a$1[c$3], o$2[c$3]))) : this.values)), z$4(this, "update", async (o$2, a$1) => {
			this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({
				type: "method",
				method: "update",
				key: o$2,
				update: a$1
			});
			const c$3 = Ti$3(Ti$3({}, this.getData(o$2)), a$1);
			this.map.set(o$2, c$3), await this.persist();
		}), z$4(this, "delete", async (o$2, a$1) => {
			this.isInitialized(), this.map.has(o$2) && (this.logger.debug("Deleting value"), this.logger.trace({
				type: "method",
				method: "delete",
				key: o$2,
				reason: a$1
			}), this.map.delete(o$2), this.addToRecentlyDeleted(o$2), await this.persist());
		}), this.logger = E$1(t, this.name), this.storagePrefix = i$2, this.getKey = r$1;
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
	}
	get length() {
		return this.map.size;
	}
	get keys() {
		return Array.from(this.map.keys());
	}
	get values() {
		return Array.from(this.map.values());
	}
	addToRecentlyDeleted(e) {
		this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
	}
	async setDataStore(e) {
		await this.core.storage.setItem(this.storageKey, e);
	}
	async getDataStore() {
		return await this.core.storage.getItem(this.storageKey);
	}
	getData(e) {
		const t = this.map.get(e);
		if (!t) {
			if (this.recentlyDeleted.includes(e)) {
				const { message: i$2 } = te$4("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
				throw this.logger.error(i$2), new Error(i$2);
			}
			const { message: s } = te$4("NO_MATCHING_KEY", `${this.name}: ${e}`);
			throw this.logger.error(s), new Error(s);
		}
		return t;
	}
	async persist() {
		await this.setDataStore(this.values);
	}
	async restore() {
		try {
			const e = await this.getDataStore();
			if (typeof e > "u" || !e.length) return;
			if (this.map.size) {
				const { message: t } = te$4("RESTORE_WILL_OVERRIDE", this.name);
				throw this.logger.error(t), new Error(t);
			}
			this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({
				type: "method",
				method: "restore",
				value: this.values
			});
		} catch (e) {
			this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
		}
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$4("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var Gn$3 = Object.defineProperty, Hn$3 = (n$2, e, t) => e in n$2 ? Gn$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, d$3 = (n$2, e, t) => Hn$3(n$2, typeof e != "symbol" ? e + "" : e, t);
var Pi$4 = class {
	constructor(e, t) {
		this.core = e, this.logger = t, d$3(this, "name", kt$5), d$3(this, "version", Ut$4), d$3(this, "events", new import_events$6.default()), d$3(this, "pairings"), d$3(this, "initialized", !1), d$3(this, "storagePrefix", B$3), d$3(this, "ignoredPayloadTypes", [Ie$4]), d$3(this, "registeredMethods", []), d$3(this, "init", async () => {
			this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
		}), d$3(this, "register", ({ methods: s }) => {
			this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...s])];
		}), d$3(this, "create", async (s) => {
			this.isInitialized();
			const i$2 = ni$3(), r$1 = await this.core.crypto.setSymKey(i$2), o$2 = ho$3(import_cjs$7.FIVE_MINUTES), a$1 = { protocol: Pt$3 }, c$3 = {
				topic: r$1,
				expiry: o$2,
				relay: a$1,
				active: !1,
				methods: s?.methods
			}, h$4 = wi$2({
				protocol: this.core.protocol,
				version: this.core.version,
				topic: r$1,
				symKey: i$2,
				relay: a$1,
				expiryTimestamp: o$2,
				methods: s?.methods
			});
			return this.events.emit(se$4.create, c$3), this.core.expirer.set(r$1, o$2), await this.pairings.set(r$1, c$3), await this.core.relayer.subscribe(r$1, { transportType: s?.transportType }), {
				topic: r$1,
				uri: h$4
			};
		}), d$3(this, "pair", async (s) => {
			this.isInitialized();
			const i$2 = this.core.eventClient.createEvent({ properties: {
				topic: s?.uri,
				trace: [q$2.pairing_started]
			} });
			this.isValidPair(s, i$2);
			const { topic: r$1, symKey: o$2, relay: a$1, expiryTimestamp: c$3, methods: h$4 } = bi$3(s.uri);
			i$2.props.properties.topic = r$1, i$2.addTrace(q$2.pairing_uri_validation_success), i$2.addTrace(q$2.pairing_uri_not_expired);
			let u$2;
			if (this.pairings.keys.includes(r$1)) {
				if (u$2 = this.pairings.get(r$1), i$2.addTrace(q$2.existing_pairing), u$2.active) throw i$2.setError(J$5.active_pairing_already_exists), /* @__PURE__ */ new Error(`Pairing already exists: ${r$1}. Please try again with a new connection URI.`);
				i$2.addTrace(q$2.pairing_not_expired);
			}
			const g$2 = c$3 || ho$3(import_cjs$7.FIVE_MINUTES), m$2 = {
				topic: r$1,
				relay: a$1,
				expiry: g$2,
				active: !1,
				methods: h$4
			};
			this.core.expirer.set(r$1, g$2), await this.pairings.set(r$1, m$2), i$2.addTrace(q$2.store_new_pairing), s.activatePairing && await this.activate({ topic: r$1 }), this.events.emit(se$4.create, m$2), i$2.addTrace(q$2.emit_inactive_pairing), this.core.crypto.keychain.has(r$1) || await this.core.crypto.setSymKey(o$2, r$1), i$2.addTrace(q$2.subscribing_pairing_topic);
			try {
				await this.core.relayer.confirmOnlineStateOrThrow();
			} catch {
				i$2.setError(J$5.no_internet_connection);
			}
			try {
				await this.core.relayer.subscribe(r$1, { relay: a$1 });
			} catch (A$5) {
				throw i$2.setError(J$5.subscribe_pairing_topic_failure), A$5;
			}
			return i$2.addTrace(q$2.subscribe_pairing_topic_success), m$2;
		}), d$3(this, "activate", async ({ topic: s }) => {
			this.isInitialized();
			const i$2 = ho$3(import_cjs$7.FIVE_MINUTES);
			this.core.expirer.set(s, i$2), await this.pairings.update(s, {
				active: !0,
				expiry: i$2
			});
		}), d$3(this, "ping", async (s) => {
			this.isInitialized(), await this.isValidPing(s), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
			const { topic: i$2 } = s;
			if (this.pairings.keys.includes(i$2)) {
				const r$1 = await this.sendRequest(i$2, "wc_pairingPing", {}), { done: o$2, resolve: a$1, reject: c$3 } = co$3();
				this.events.once(go$3("pairing_ping", r$1), ({ error: h$4 }) => {
					h$4 ? c$3(h$4) : a$1();
				}), await o$2();
			}
		}), d$3(this, "updateExpiry", async ({ topic: s, expiry: i$2 }) => {
			this.isInitialized(), await this.pairings.update(s, { expiry: i$2 });
		}), d$3(this, "updateMetadata", async ({ topic: s, metadata: i$2 }) => {
			this.isInitialized(), await this.pairings.update(s, { peerMetadata: i$2 });
		}), d$3(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), d$3(this, "disconnect", async (s) => {
			this.isInitialized(), await this.isValidDisconnect(s);
			const { topic: i$2 } = s;
			this.pairings.keys.includes(i$2) && (await this.sendRequest(i$2, "wc_pairingDelete", de$3("USER_DISCONNECTED")), await this.deletePairing(i$2));
		}), d$3(this, "formatUriFromPairing", (s) => {
			this.isInitialized();
			const { topic: i$2, relay: r$1, expiry: o$2, methods: a$1 } = s, c$3 = this.core.crypto.keychain.get(i$2);
			return wi$2({
				protocol: this.core.protocol,
				version: this.core.version,
				topic: i$2,
				symKey: c$3,
				relay: r$1,
				expiryTimestamp: o$2,
				methods: a$1
			});
		}), d$3(this, "sendRequest", async (s, i$2, r$1) => {
			const o$2 = formatJsonRpcRequest(i$2, r$1), a$1 = await this.core.crypto.encode(s, o$2), c$3 = ie$4[i$2].req;
			return this.core.history.set(s, o$2), this.core.relayer.publish(s, a$1, c$3), o$2.id;
		}), d$3(this, "sendResult", async (s, i$2, r$1) => {
			const o$2 = formatJsonRpcResult(s, r$1), a$1 = await this.core.crypto.encode(i$2, o$2), h$4 = ie$4[(await this.core.history.get(i$2, s)).request.method].res;
			await this.core.relayer.publish(i$2, a$1, h$4), await this.core.history.resolve(o$2);
		}), d$3(this, "sendError", async (s, i$2, r$1) => {
			const o$2 = formatJsonRpcError(s, r$1), a$1 = await this.core.crypto.encode(i$2, o$2), c$3 = (await this.core.history.get(i$2, s)).request.method, h$4 = ie$4[c$3] ? ie$4[c$3].res : ie$4.unregistered_method.res;
			await this.core.relayer.publish(i$2, a$1, h$4), await this.core.history.resolve(o$2);
		}), d$3(this, "deletePairing", async (s, i$2) => {
			await this.core.relayer.unsubscribe(s), await Promise.all([
				this.pairings.delete(s, de$3("USER_DISCONNECTED")),
				this.core.crypto.deleteSymKey(s),
				i$2 ? Promise.resolve() : this.core.expirer.del(s)
			]);
		}), d$3(this, "cleanup", async () => {
			const s = this.pairings.getAll().filter((i$2) => po$3(i$2.expiry));
			await Promise.all(s.map((i$2) => this.deletePairing(i$2.topic)));
		}), d$3(this, "onRelayEventRequest", (s) => {
			const { topic: i$2, payload: r$1 } = s;
			switch (r$1.method) {
				case "wc_pairingPing": return this.onPairingPingRequest(i$2, r$1);
				case "wc_pairingDelete": return this.onPairingDeleteRequest(i$2, r$1);
				default: return this.onUnknownRpcMethodRequest(i$2, r$1);
			}
		}), d$3(this, "onRelayEventResponse", async (s) => {
			const { topic: i$2, payload: r$1 } = s, o$2 = (await this.core.history.get(i$2, r$1.id)).request.method;
			switch (o$2) {
				case "wc_pairingPing": return this.onPairingPingResponse(i$2, r$1);
				default: return this.onUnknownRpcMethodResponse(o$2);
			}
		}), d$3(this, "onPairingPingRequest", async (s, i$2) => {
			const { id: r$1 } = i$2;
			try {
				this.isValidPing({ topic: s }), await this.sendResult(r$1, s, !0), this.events.emit(se$4.ping, {
					id: r$1,
					topic: s
				});
			} catch (o$2) {
				await this.sendError(r$1, s, o$2), this.logger.error(o$2);
			}
		}), d$3(this, "onPairingPingResponse", (s, i$2) => {
			const { id: r$1 } = i$2;
			setTimeout(() => {
				isJsonRpcResult(i$2) ? this.events.emit(go$3("pairing_ping", r$1), {}) : isJsonRpcError(i$2) && this.events.emit(go$3("pairing_ping", r$1), { error: i$2.error });
			}, 500);
		}), d$3(this, "onPairingDeleteRequest", async (s, i$2) => {
			const { id: r$1 } = i$2;
			try {
				this.isValidDisconnect({ topic: s }), await this.deletePairing(s), this.events.emit(se$4.delete, {
					id: r$1,
					topic: s
				});
			} catch (o$2) {
				await this.sendError(r$1, s, o$2), this.logger.error(o$2);
			}
		}), d$3(this, "onUnknownRpcMethodRequest", async (s, i$2) => {
			const { id: r$1, method: o$2 } = i$2;
			try {
				if (this.registeredMethods.includes(o$2)) return;
				const a$1 = de$3("WC_METHOD_UNSUPPORTED", o$2);
				await this.sendError(r$1, s, a$1), this.logger.error(a$1);
			} catch (a$1) {
				await this.sendError(r$1, s, a$1), this.logger.error(a$1);
			}
		}), d$3(this, "onUnknownRpcMethodResponse", (s) => {
			this.registeredMethods.includes(s) || this.logger.error(de$3("WC_METHOD_UNSUPPORTED", s));
		}), d$3(this, "isValidPair", (s, i$2) => {
			var r$1;
			if (!Di$3(s)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", `pair() params: ${s}`);
				throw i$2.setError(J$5.malformed_pairing_uri), new Error(a$1);
			}
			if (!Ri$3(s.uri)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", `pair() uri: ${s.uri}`);
				throw i$2.setError(J$5.malformed_pairing_uri), new Error(a$1);
			}
			const o$2 = bi$3(s?.uri);
			if (!((r$1 = o$2?.relay) != null && r$1.protocol)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", "pair() uri#relay-protocol");
				throw i$2.setError(J$5.malformed_pairing_uri), new Error(a$1);
			}
			if (!(o$2 != null && o$2.symKey)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", "pair() uri#symKey");
				throw i$2.setError(J$5.malformed_pairing_uri), new Error(a$1);
			}
			if (o$2 != null && o$2.expiryTimestamp && (0, import_cjs$7.toMiliseconds)(o$2?.expiryTimestamp) < Date.now()) {
				i$2.setError(J$5.pairing_expired);
				const { message: a$1 } = te$4("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
				throw new Error(a$1);
			}
		}), d$3(this, "isValidPing", async (s) => {
			if (!Di$3(s)) {
				const { message: r$1 } = te$4("MISSING_OR_INVALID", `ping() params: ${s}`);
				throw new Error(r$1);
			}
			const { topic: i$2 } = s;
			await this.isValidPairingTopic(i$2);
		}), d$3(this, "isValidDisconnect", async (s) => {
			if (!Di$3(s)) {
				const { message: r$1 } = te$4("MISSING_OR_INVALID", `disconnect() params: ${s}`);
				throw new Error(r$1);
			}
			const { topic: i$2 } = s;
			await this.isValidPairingTopic(i$2);
		}), d$3(this, "isValidPairingTopic", async (s) => {
			if (!q$3(s, !1)) {
				const { message: i$2 } = te$4("MISSING_OR_INVALID", `pairing topic should be a string: ${s}`);
				throw new Error(i$2);
			}
			if (!this.pairings.keys.includes(s)) {
				const { message: i$2 } = te$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s}`);
				throw new Error(i$2);
			}
			if (po$3(this.pairings.get(s).expiry)) {
				await this.deletePairing(s);
				const { message: i$2 } = te$4("EXPIRED", `pairing topic: ${s}`);
				throw new Error(i$2);
			}
		}), this.core = e, this.logger = E$1(t, this.name), this.pairings = new Ci$3(this.core, this.logger, this.name, this.storagePrefix);
	}
	get context() {
		return y$1(this.logger);
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$4("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
	registerRelayerEvents() {
		this.core.relayer.on(T$1.message, async (e) => {
			const { topic: t, message: s, transportType: i$2 } = e;
			if (!this.pairings.keys.includes(t) || i$2 === Q$3.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s))) return;
			const r$1 = await this.core.crypto.decode(t, s);
			try {
				isJsonRpcRequest(r$1) ? (this.core.history.set(t, r$1), this.onRelayEventRequest({
					topic: t,
					payload: r$1
				})) : isJsonRpcResponse(r$1) && (await this.core.history.resolve(r$1), await this.onRelayEventResponse({
					topic: t,
					payload: r$1
				}), this.core.history.delete(t, r$1.id));
			} catch (o$2) {
				this.logger.error(o$2);
			}
		});
	}
	registerExpirerEvents() {
		this.core.expirer.on(M$4.expired, async (e) => {
			const { topic: t } = lo$3(e.target);
			t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(se$4.expire, { topic: t }));
		});
	}
};
var Yn$3 = Object.defineProperty, Jn$3 = (n$2, e, t) => e in n$2 ? Yn$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, S$5 = (n$2, e, t) => Jn$3(n$2, typeof e != "symbol" ? e + "" : e, t);
var Si$2 = class extends I$3 {
	constructor(e, t) {
		super(e, t), this.core = e, this.logger = t, S$5(this, "records", /* @__PURE__ */ new Map()), S$5(this, "events", new import_events$6.EventEmitter()), S$5(this, "name", Ft$4), S$5(this, "version", Mt$4), S$5(this, "cached", []), S$5(this, "initialized", !1), S$5(this, "storagePrefix", B$3), S$5(this, "init", async () => {
			this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s) => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
		}), S$5(this, "set", (s, i$2, r$1) => {
			if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({
				type: "method",
				method: "set",
				topic: s,
				request: i$2,
				chainId: r$1
			}), this.records.has(i$2.id)) return;
			const o$2 = {
				id: i$2.id,
				topic: s,
				request: {
					method: i$2.method,
					params: i$2.params || null
				},
				chainId: r$1,
				expiry: ho$3(import_cjs$7.THIRTY_DAYS)
			};
			this.records.set(o$2.id, o$2), this.persist(), this.events.emit(F$4.created, o$2);
		}), S$5(this, "resolve", async (s) => {
			if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({
				type: "method",
				method: "update",
				response: s
			}), !this.records.has(s.id)) return;
			const i$2 = await this.getRecord(s.id);
			typeof i$2.response > "u" && (i$2.response = isJsonRpcError(s) ? { error: s.error } : { result: s.result }, this.records.set(i$2.id, i$2), this.persist(), this.events.emit(F$4.updated, i$2));
		}), S$5(this, "get", async (s, i$2) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({
			type: "method",
			method: "get",
			topic: s,
			id: i$2
		}), await this.getRecord(i$2))), S$5(this, "delete", (s, i$2) => {
			this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({
				type: "method",
				method: "delete",
				id: i$2
			}), this.values.forEach((r$1) => {
				if (r$1.topic === s) {
					if (typeof i$2 < "u" && r$1.id !== i$2) return;
					this.records.delete(r$1.id), this.events.emit(F$4.deleted, r$1);
				}
			}), this.persist();
		}), S$5(this, "exists", async (s, i$2) => (this.isInitialized(), this.records.has(i$2) ? (await this.getRecord(i$2)).topic === s : !1)), S$5(this, "on", (s, i$2) => {
			this.events.on(s, i$2);
		}), S$5(this, "once", (s, i$2) => {
			this.events.once(s, i$2);
		}), S$5(this, "off", (s, i$2) => {
			this.events.off(s, i$2);
		}), S$5(this, "removeListener", (s, i$2) => {
			this.events.removeListener(s, i$2);
		}), this.logger = E$1(t, this.name);
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
	}
	get size() {
		return this.records.size;
	}
	get keys() {
		return Array.from(this.records.keys());
	}
	get values() {
		return Array.from(this.records.values());
	}
	get pending() {
		const e = [];
		return this.values.forEach((t) => {
			if (typeof t.response < "u") return;
			const s = {
				topic: t.topic,
				request: formatJsonRpcRequest(t.request.method, t.request.params, t.id),
				chainId: t.chainId
			};
			return e.push(s);
		}), e;
	}
	async setJsonRpcRecords(e) {
		await this.core.storage.setItem(this.storageKey, e);
	}
	async getJsonRpcRecords() {
		return await this.core.storage.getItem(this.storageKey);
	}
	getRecord(e) {
		this.isInitialized();
		const t = this.records.get(e);
		if (!t) {
			const { message: s } = te$4("NO_MATCHING_KEY", `${this.name}: ${e}`);
			throw new Error(s);
		}
		return t;
	}
	async persist() {
		await this.setJsonRpcRecords(this.values), this.events.emit(F$4.sync);
	}
	async restore() {
		try {
			const e = await this.getJsonRpcRecords();
			if (typeof e > "u" || !e.length) return;
			if (this.records.size) {
				const { message: t } = te$4("RESTORE_WILL_OVERRIDE", this.name);
				throw this.logger.error(t), new Error(t);
			}
			this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
				type: "method",
				method: "restore",
				records: this.values
			});
		} catch (e) {
			this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
		}
	}
	registerEventListeners() {
		this.events.on(F$4.created, (e) => {
			const t = F$4.created;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				record: e
			});
		}), this.events.on(F$4.updated, (e) => {
			const t = F$4.updated;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				record: e
			});
		}), this.events.on(F$4.deleted, (e) => {
			const t = F$4.deleted;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				record: e
			});
		}), this.core.heartbeat.on(r.pulse, () => {
			this.cleanup();
		});
	}
	cleanup() {
		try {
			this.isInitialized();
			let e = !1;
			this.records.forEach((t) => {
				(0, import_cjs$7.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(F$4.deleted, t, !1), e = !0);
			}), e && this.persist();
		} catch (e) {
			this.logger.warn(e);
		}
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$4("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var Xn$3 = Object.defineProperty, Wn$3 = (n$2, e, t) => e in n$2 ? Xn$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, x$4 = (n$2, e, t) => Wn$3(n$2, typeof e != "symbol" ? e + "" : e, t);
var Ri$4 = class extends S$4 {
	constructor(e, t) {
		super(e, t), this.core = e, this.logger = t, x$4(this, "expirations", /* @__PURE__ */ new Map()), x$4(this, "events", new import_events$6.EventEmitter()), x$4(this, "name", Kt$3), x$4(this, "version", Bt$4), x$4(this, "cached", []), x$4(this, "initialized", !1), x$4(this, "storagePrefix", B$3), x$4(this, "init", async () => {
			this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s) => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
		}), x$4(this, "has", (s) => {
			try {
				const i$2 = this.formatTarget(s);
				return typeof this.getExpiration(i$2) < "u";
			} catch {
				return !1;
			}
		}), x$4(this, "set", (s, i$2) => {
			this.isInitialized();
			const r$1 = this.formatTarget(s), o$2 = {
				target: r$1,
				expiry: i$2
			};
			this.expirations.set(r$1, o$2), this.checkExpiry(r$1, o$2), this.events.emit(M$4.created, {
				target: r$1,
				expiration: o$2
			});
		}), x$4(this, "get", (s) => {
			this.isInitialized();
			const i$2 = this.formatTarget(s);
			return this.getExpiration(i$2);
		}), x$4(this, "del", (s) => {
			if (this.isInitialized(), this.has(s)) {
				const i$2 = this.formatTarget(s), r$1 = this.getExpiration(i$2);
				this.expirations.delete(i$2), this.events.emit(M$4.deleted, {
					target: i$2,
					expiration: r$1
				});
			}
		}), x$4(this, "on", (s, i$2) => {
			this.events.on(s, i$2);
		}), x$4(this, "once", (s, i$2) => {
			this.events.once(s, i$2);
		}), x$4(this, "off", (s, i$2) => {
			this.events.off(s, i$2);
		}), x$4(this, "removeListener", (s, i$2) => {
			this.events.removeListener(s, i$2);
		}), this.logger = E$1(t, this.name);
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
	}
	get length() {
		return this.expirations.size;
	}
	get keys() {
		return Array.from(this.expirations.keys());
	}
	get values() {
		return Array.from(this.expirations.values());
	}
	formatTarget(e) {
		if (typeof e == "string") return uo$3(e);
		if (typeof e == "number") return fo$3(e);
		const { message: t } = te$4("UNKNOWN_TYPE", `Target type: ${typeof e}`);
		throw new Error(t);
	}
	async setExpirations(e) {
		await this.core.storage.setItem(this.storageKey, e);
	}
	async getExpirations() {
		return await this.core.storage.getItem(this.storageKey);
	}
	async persist() {
		await this.setExpirations(this.values), this.events.emit(M$4.sync);
	}
	async restore() {
		try {
			const e = await this.getExpirations();
			if (typeof e > "u" || !e.length) return;
			if (this.expirations.size) {
				const { message: t } = te$4("RESTORE_WILL_OVERRIDE", this.name);
				throw this.logger.error(t), new Error(t);
			}
			this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({
				type: "method",
				method: "restore",
				expirations: this.values
			});
		} catch (e) {
			this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
		}
	}
	getExpiration(e) {
		const t = this.expirations.get(e);
		if (!t) {
			const { message: s } = te$4("NO_MATCHING_KEY", `${this.name}: ${e}`);
			throw this.logger.warn(s), new Error(s);
		}
		return t;
	}
	checkExpiry(e, t) {
		const { expiry: s } = t;
		(0, import_cjs$7.toMiliseconds)(s) - Date.now() <= 0 && this.expire(e, t);
	}
	expire(e, t) {
		this.expirations.delete(e), this.events.emit(M$4.expired, {
			target: e,
			expiration: t
		});
	}
	checkExpirations() {
		this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
	}
	registerEventListeners() {
		this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(M$4.created, (e) => {
			const t = M$4.created;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				data: e
			}), this.persist();
		}), this.events.on(M$4.expired, (e) => {
			const t = M$4.expired;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				data: e
			}), this.persist();
		}), this.events.on(M$4.deleted, (e) => {
			const t = M$4.deleted;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				data: e
			}), this.persist();
		});
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$4("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var Zn$3 = Object.defineProperty, Qn$3 = (n$2, e, t) => e in n$2 ? Zn$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, _$3 = (n$2, e, t) => Qn$3(n$2, typeof e != "symbol" ? e + "" : e, t);
var xi$3 = class extends M$5 {
	constructor(e, t, s) {
		super(e, t, s), this.core = e, this.logger = t, this.store = s, _$3(this, "name", jt$4), _$3(this, "abortController"), _$3(this, "isDevEnv"), _$3(this, "verifyUrlV3", qt$4), _$3(this, "storagePrefix", B$3), _$3(this, "version", Oe$5), _$3(this, "publicKey"), _$3(this, "fetchPromise"), _$3(this, "init", async () => {
			var i$2;
			this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_cjs$7.toMiliseconds)((i$2 = this.publicKey) == null ? void 0 : i$2.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
		}), _$3(this, "register", async (i$2) => {
			if (!Ae$3() || this.isDevEnv) return;
			const r$1 = window.location.origin, { id: o$2, decryptedId: a$1 } = i$2, c$3 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r$1}&id=${o$2}&decryptedId=${a$1}`;
			try {
				const h$4 = (0, import_cjs$8.getDocument)(), u$2 = this.startAbortTimer(import_cjs$7.ONE_SECOND * 5), g$2 = await new Promise((m$2, A$5) => {
					const l$2 = () => {
						window.removeEventListener("message", O$5), h$4.body.removeChild(y$6), A$5("attestation aborted");
					};
					this.abortController.signal.addEventListener("abort", l$2);
					const y$6 = h$4.createElement("iframe");
					y$6.src = c$3, y$6.style.display = "none", y$6.addEventListener("error", l$2, { signal: this.abortController.signal });
					const O$5 = (w$3) => {
						if (w$3.data && typeof w$3.data == "string") try {
							const v$5 = JSON.parse(w$3.data);
							if (v$5.type === "verify_attestation") {
								if (sn(v$5.attestation).payload.id !== o$2) return;
								clearInterval(u$2), h$4.body.removeChild(y$6), this.abortController.signal.removeEventListener("abort", l$2), window.removeEventListener("message", O$5), m$2(v$5.attestation === null ? "" : v$5.attestation);
							}
						} catch (v$5) {
							this.logger.warn(v$5);
						}
					};
					h$4.body.appendChild(y$6), window.addEventListener("message", O$5, { signal: this.abortController.signal });
				});
				return this.logger.debug("jwt attestation", g$2), g$2;
			} catch (h$4) {
				this.logger.warn(h$4);
			}
			return "";
		}), _$3(this, "resolve", async (i$2) => {
			if (this.isDevEnv) return "";
			const { attestationId: r$1, hash: o$2, encryptedId: a$1 } = i$2;
			if (r$1 === "") {
				this.logger.debug("resolve: attestationId is empty, skipping");
				return;
			}
			if (r$1) {
				if (sn(r$1).payload.id !== a$1) return;
				const h$4 = await this.isValidJwtAttestation(r$1);
				if (h$4) {
					if (!h$4.isVerified) {
						this.logger.warn("resolve: jwt attestation: origin url not verified");
						return;
					}
					return h$4;
				}
			}
			if (!o$2) return;
			const c$3 = this.getVerifyUrl(i$2?.verifyUrl);
			return this.fetchAttestation(o$2, c$3);
		}), _$3(this, "fetchAttestation", async (i$2, r$1) => {
			this.logger.debug(`resolving attestation: ${i$2} from url: ${r$1}`);
			const o$2 = this.startAbortTimer(import_cjs$7.ONE_SECOND * 5), a$1 = await fetch(`${r$1}/attestation/${i$2}?v2Supported=true`, { signal: this.abortController.signal });
			return clearTimeout(o$2), a$1.status === 200 ? await a$1.json() : void 0;
		}), _$3(this, "getVerifyUrl", (i$2) => {
			let r$1 = i$2 || le$4;
			return Gt$4.includes(r$1) || (this.logger.info(`verify url: ${r$1}, not included in trusted list, assigning default: ${le$4}`), r$1 = le$4), r$1;
		}), _$3(this, "fetchPublicKey", async () => {
			try {
				this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
				const i$2 = this.startAbortTimer(import_cjs$7.FIVE_SECONDS), r$1 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
				return clearTimeout(i$2), await r$1.json();
			} catch (i$2) {
				this.logger.warn(i$2);
			}
		}), _$3(this, "persistPublicKey", async (i$2) => {
			this.logger.debug("persisting public key to local storage", i$2), await this.store.setItem(this.storeKey, i$2), this.publicKey = i$2;
		}), _$3(this, "removePublicKey", async () => {
			this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
		}), _$3(this, "isValidJwtAttestation", async (i$2) => {
			const r$1 = await this.getPublicKey();
			try {
				if (r$1) return this.validateAttestation(i$2, r$1);
			} catch (a$1) {
				this.logger.error(a$1), this.logger.warn("error validating attestation");
			}
			const o$2 = await this.fetchAndPersistPublicKey();
			try {
				if (o$2) return this.validateAttestation(i$2, o$2);
			} catch (a$1) {
				this.logger.error(a$1), this.logger.warn("error validating attestation");
			}
		}), _$3(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), _$3(this, "fetchAndPersistPublicKey", async () => {
			if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
			this.fetchPromise = new Promise(async (r$1) => {
				const o$2 = await this.fetchPublicKey();
				o$2 && (await this.persistPublicKey(o$2), r$1(o$2));
			});
			const i$2 = await this.fetchPromise;
			return this.fetchPromise = void 0, i$2;
		}), _$3(this, "validateAttestation", (i$2, r$1) => {
			const o$2 = gi$2(i$2, r$1.publicKey), a$1 = {
				hasExpired: (0, import_cjs$7.toMiliseconds)(o$2.exp) < Date.now(),
				payload: o$2
			};
			if (a$1.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), /* @__PURE__ */ new Error("JWT attestation expired");
			return {
				origin: a$1.payload.origin,
				isScam: a$1.payload.isScam,
				isVerified: a$1.payload.isVerified
			};
		}), this.logger = E$1(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Eo$3(), this.init();
	}
	get storeKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
	}
	get context() {
		return y$1(this.logger);
	}
	startAbortTimer(e) {
		return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_cjs$7.toMiliseconds)(e));
	}
};
var eo$2 = Object.defineProperty, to$2 = (n$2, e, t) => e in n$2 ? eo$2(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, Oi$2 = (n$2, e, t) => to$2(n$2, typeof e != "symbol" ? e + "" : e, t);
var Ai$2 = class extends O$4 {
	constructor(e, t) {
		super(e, t), this.projectId = e, this.logger = t, Oi$2(this, "context", Ht$2), Oi$2(this, "registerDeviceToken", async (s) => {
			const { clientId: i$2, token: r$1, notificationType: o$2, enableEncrypted: a$1 = !1 } = s, c$3 = `${Yt$5}/${this.projectId}/clients`;
			await fetch(c$3, {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({
					client_id: i$2,
					type: o$2,
					token: r$1,
					always_raw: a$1
				})
			});
		}), this.logger = E$1(t, this.context);
	}
};
var io$2 = Object.defineProperty, Ni$2 = Object.getOwnPropertySymbols, so$2 = Object.prototype.hasOwnProperty, ro$4 = Object.prototype.propertyIsEnumerable, qe$5 = (n$2, e, t) => e in n$2 ? io$2(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, pe$3 = (n$2, e) => {
	for (var t in e || (e = {})) so$2.call(e, t) && qe$5(n$2, t, e[t]);
	if (Ni$2) for (var t of Ni$2(e)) ro$4.call(e, t) && qe$5(n$2, t, e[t]);
	return n$2;
}, E$5 = (n$2, e, t) => qe$5(n$2, typeof e != "symbol" ? e + "" : e, t);
var $i$3 = class extends R$3 {
	constructor(e, t, s = !0) {
		super(e, t, s), this.core = e, this.logger = t, E$5(this, "context", Xt$3), E$5(this, "storagePrefix", B$3), E$5(this, "storageVersion", Jt$4), E$5(this, "events", /* @__PURE__ */ new Map()), E$5(this, "shouldPersist", !1), E$5(this, "init", async () => {
			if (!Eo$3()) try {
				const i$2 = {
					eventId: wo$3(),
					timestamp: Date.now(),
					domain: this.getAppDomain(),
					props: {
						event: "INIT",
						type: "",
						properties: {
							client_id: await this.core.crypto.getClientId(),
							user_agent: Yt$4(this.core.relayer.protocol, this.core.relayer.version, me$4)
						}
					}
				};
				await this.sendEvent([i$2]);
			} catch (i$2) {
				this.logger.warn(i$2);
			}
		}), E$5(this, "createEvent", (i$2) => {
			const { event: r$1 = "ERROR", type: o$2 = "", properties: { topic: a$1, trace: c$3 } } = i$2, h$4 = wo$3(), u$2 = this.core.projectId || "", m$2 = pe$3({
				eventId: h$4,
				timestamp: Date.now(),
				props: {
					event: r$1,
					type: o$2,
					properties: {
						topic: a$1,
						trace: c$3
					}
				},
				bundleId: u$2,
				domain: this.getAppDomain()
			}, this.setMethods(h$4));
			return this.telemetryEnabled && (this.events.set(h$4, m$2), this.shouldPersist = !0), m$2;
		}), E$5(this, "getEvent", (i$2) => {
			const { eventId: r$1, topic: o$2 } = i$2;
			if (r$1) return this.events.get(r$1);
			const a$1 = Array.from(this.events.values()).find((c$3) => c$3.props.properties.topic === o$2);
			if (a$1) return pe$3(pe$3({}, a$1), this.setMethods(a$1.eventId));
		}), E$5(this, "deleteEvent", (i$2) => {
			const { eventId: r$1 } = i$2;
			this.events.delete(r$1), this.shouldPersist = !0;
		}), E$5(this, "setEventListeners", () => {
			this.core.heartbeat.on(r.pulse, async () => {
				this.shouldPersist && await this.persist(), this.events.forEach((i$2) => {
					(0, import_cjs$7.fromMiliseconds)(Date.now()) - (0, import_cjs$7.fromMiliseconds)(i$2.timestamp) > Wt$4 && (this.events.delete(i$2.eventId), this.shouldPersist = !0);
				});
			});
		}), E$5(this, "setMethods", (i$2) => ({
			addTrace: (r$1) => this.addTrace(i$2, r$1),
			setError: (r$1) => this.setError(i$2, r$1)
		})), E$5(this, "addTrace", (i$2, r$1) => {
			const o$2 = this.events.get(i$2);
			o$2 && (o$2.props.properties.trace.push(r$1), this.events.set(i$2, o$2), this.shouldPersist = !0);
		}), E$5(this, "setError", (i$2, r$1) => {
			const o$2 = this.events.get(i$2);
			o$2 && (o$2.props.type = r$1, o$2.timestamp = Date.now(), this.events.set(i$2, o$2), this.shouldPersist = !0);
		}), E$5(this, "persist", async () => {
			await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
		}), E$5(this, "restore", async () => {
			try {
				const i$2 = await this.core.storage.getItem(this.storageKey) || [];
				if (!i$2.length) return;
				i$2.forEach((r$1) => {
					this.events.set(r$1.eventId, pe$3(pe$3({}, r$1), this.setMethods(r$1.eventId)));
				});
			} catch (i$2) {
				this.logger.warn(i$2);
			}
		}), E$5(this, "submit", async () => {
			if (!this.telemetryEnabled || this.events.size === 0) return;
			const i$2 = [];
			for (const [r$1, o$2] of this.events) o$2.props.type && i$2.push(o$2);
			if (i$2.length !== 0) try {
				if ((await this.sendEvent(i$2)).ok) for (const r$1 of i$2) this.events.delete(r$1.eventId), this.shouldPersist = !0;
			} catch (r$1) {
				this.logger.warn(r$1);
			}
		}), E$5(this, "sendEvent", async (i$2) => {
			const r$1 = this.getAppDomain() ? "" : "&sp=desktop";
			return await fetch(`${Zt$3}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${me$4}${r$1}`, {
				method: "POST",
				body: JSON.stringify(i$2)
			});
		}), E$5(this, "getAppDomain", () => Yr$3().url), this.logger = E$1(t, this.context), this.telemetryEnabled = s, s ? this.restore().then(async () => {
			await this.submit(), this.setEventListeners();
		}) : this.persist();
	}
	get storageKey() {
		return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
	}
};
var no$3 = Object.defineProperty, zi$3 = Object.getOwnPropertySymbols, oo$3 = Object.prototype.hasOwnProperty, ao$4 = Object.prototype.propertyIsEnumerable, Ge$6 = (n$2, e, t) => e in n$2 ? no$3(n$2, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n$2[e] = t, Li$4 = (n$2, e) => {
	for (var t in e || (e = {})) oo$3.call(e, t) && Ge$6(n$2, t, e[t]);
	if (zi$3) for (var t of zi$3(e)) ao$4.call(e, t) && Ge$6(n$2, t, e[t]);
	return n$2;
}, f$6 = (n$2, e, t) => Ge$6(n$2, typeof e != "symbol" ? e + "" : e, t);
var _e$7 = class _e$7 extends h$3 {
	constructor(e) {
		var t;
		super(e), f$6(this, "protocol", xe$3), f$6(this, "version", Oe$5), f$6(this, "name", he$3), f$6(this, "relayUrl"), f$6(this, "projectId"), f$6(this, "customStoragePrefix"), f$6(this, "events", new import_events$6.EventEmitter()), f$6(this, "logger"), f$6(this, "heartbeat"), f$6(this, "relayer"), f$6(this, "crypto"), f$6(this, "storage"), f$6(this, "history"), f$6(this, "expirer"), f$6(this, "pairing"), f$6(this, "verify"), f$6(this, "echoClient"), f$6(this, "linkModeSupportedApps"), f$6(this, "eventClient"), f$6(this, "initialized", !1), f$6(this, "logChunkController"), f$6(this, "on", (o$2, a$1) => this.events.on(o$2, a$1)), f$6(this, "once", (o$2, a$1) => this.events.once(o$2, a$1)), f$6(this, "off", (o$2, a$1) => this.events.off(o$2, a$1)), f$6(this, "removeListener", (o$2, a$1) => this.events.removeListener(o$2, a$1)), f$6(this, "dispatchEnvelope", ({ topic: o$2, message: a$1, sessionExists: c$3 }) => {
			if (!o$2 || !a$1) return;
			const h$4 = {
				topic: o$2,
				message: a$1,
				publishedAt: Date.now(),
				transportType: Q$3.link_mode
			};
			this.relayer.onLinkMessageEvent(h$4, { sessionExists: c$3 });
		}), this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || $e$6, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
		const { logger: i$2, chunkLoggerController: r$1 } = A({
			opts: k({
				level: typeof e?.logger == "string" && e.logger ? e.logger : mt$4.logger,
				name: he$3
			}),
			maxSizeInBytes: e?.maxLogBlobSizeInBytes,
			loggerOverride: e?.logger
		});
		this.logChunkController = r$1, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
			var o$2, a$1;
			(o$2 = this.logChunkController) != null && o$2.downloadLogsBlobInBrowser && ((a$1 = this.logChunkController) == null || a$1.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
		}), this.logger = E$1(i$2, this.name), this.heartbeat = new i(), this.crypto = new bi$4(this, this.logger, e?.keychain), this.history = new Si$2(this, this.logger), this.expirer = new Ri$4(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(Li$4(Li$4({}, vt$3), e?.storageOptions)), this.relayer = new wi$3({
			core: this,
			logger: this.logger,
			relayUrl: this.relayUrl,
			projectId: this.projectId
		}), this.pairing = new Pi$4(this, this.logger), this.verify = new xi$3(this, this.logger, this.storage), this.echoClient = new Ai$2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new $i$3(this, this.logger, e?.telemetryEnabled);
	}
	static async init(e) {
		const t = new _e$7(e);
		await t.initialize();
		const s = await t.crypto.getClientId();
		return await t.storage.setItem(Nt$4, s), t;
	}
	get context() {
		return y$1(this.logger);
	}
	async start() {
		this.initialized || await this.initialize();
	}
	async getLogsBlob() {
		var e;
		return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
	}
	async addLinkModeSupportedApp(e) {
		this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(ze$4, this.linkModeSupportedApps));
	}
	async initialize() {
		this.logger.trace("Initialized");
		try {
			await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(ze$4) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
		} catch (e) {
			throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
		}
	}
};
var co$2 = _e$7;

//#endregion
//#region node_modules/@walletconnect/sign-client/node_modules/@walletconnect/types/dist/index.es.js
var import_events$5 = /* @__PURE__ */ __toESM(require_events());
var T$2 = Object.defineProperty, k$4 = (e, s, r$1) => s in e ? T$2(e, s, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: r$1
}) : e[s] = r$1, i$1 = (e, s, r$1) => k$4(e, typeof s != "symbol" ? s + "" : s, r$1);
var J$6 = class {
	constructor(s) {
		this.opts = s, i$1(this, "protocol", "wc"), i$1(this, "version", 2);
	}
};
var V$5 = class {
	constructor(s) {
		this.client = s;
	}
};

//#endregion
//#region node_modules/@walletconnect/sign-client/dist/index.es.js
var import_cjs$6 = require_cjs();
var import_events$4 = /* @__PURE__ */ __toESM(require_events());
var De$4 = "wc", Le$5 = 2, Me$6 = "client", me$3 = `${De$4}@${Le$5}:${Me$6}:`, _e$6 = {
	name: Me$6,
	logger: "error",
	controller: !1,
	relayUrl: "wss://relay.walletconnect.org"
}, gs$2 = {
	session_proposal: "session_proposal",
	session_update: "session_update",
	session_extend: "session_extend",
	session_ping: "session_ping",
	session_delete: "session_delete",
	session_expire: "session_expire",
	session_request: "session_request",
	session_request_sent: "session_request_sent",
	session_event: "session_event",
	proposal_expire: "proposal_expire",
	session_authenticate: "session_authenticate",
	session_request_expire: "session_request_expire",
	session_connect: "session_connect"
}, ys$3 = { database: ":memory:" }, ke$5 = "WALLETCONNECT_DEEPLINK_CHOICE", ws$2 = {
	created: "history_created",
	updated: "history_updated",
	deleted: "history_deleted",
	sync: "history_sync"
}, ms$3 = "history", _s$3 = "0.3", pt$4 = "proposal", Es$2 = import_cjs$6.THIRTY_DAYS, $e$5 = "Proposal expired", ht$4 = "session", Y$3 = import_cjs$6.SEVEN_DAYS, dt$4 = "engine", N$3 = {
	wc_sessionPropose: {
		req: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !0,
			tag: 1100
		},
		res: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !1,
			tag: 1101
		},
		reject: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !1,
			tag: 1120
		},
		autoReject: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !1,
			tag: 1121
		}
	},
	wc_sessionSettle: {
		req: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !1,
			tag: 1102
		},
		res: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !1,
			tag: 1103
		}
	},
	wc_sessionUpdate: {
		req: {
			ttl: import_cjs$6.ONE_DAY,
			prompt: !1,
			tag: 1104
		},
		res: {
			ttl: import_cjs$6.ONE_DAY,
			prompt: !1,
			tag: 1105
		}
	},
	wc_sessionExtend: {
		req: {
			ttl: import_cjs$6.ONE_DAY,
			prompt: !1,
			tag: 1106
		},
		res: {
			ttl: import_cjs$6.ONE_DAY,
			prompt: !1,
			tag: 1107
		}
	},
	wc_sessionRequest: {
		req: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !0,
			tag: 1108
		},
		res: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !1,
			tag: 1109
		}
	},
	wc_sessionEvent: {
		req: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !0,
			tag: 1110
		},
		res: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !1,
			tag: 1111
		}
	},
	wc_sessionDelete: {
		req: {
			ttl: import_cjs$6.ONE_DAY,
			prompt: !1,
			tag: 1112
		},
		res: {
			ttl: import_cjs$6.ONE_DAY,
			prompt: !1,
			tag: 1113
		}
	},
	wc_sessionPing: {
		req: {
			ttl: import_cjs$6.ONE_DAY,
			prompt: !1,
			tag: 1114
		},
		res: {
			ttl: import_cjs$6.ONE_DAY,
			prompt: !1,
			tag: 1115
		}
	},
	wc_sessionAuthenticate: {
		req: {
			ttl: import_cjs$6.ONE_HOUR,
			prompt: !0,
			tag: 1116
		},
		res: {
			ttl: import_cjs$6.ONE_HOUR,
			prompt: !1,
			tag: 1117
		},
		reject: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !1,
			tag: 1118
		},
		autoReject: {
			ttl: import_cjs$6.FIVE_MINUTES,
			prompt: !1,
			tag: 1119
		}
	}
}, Ee$5 = {
	min: import_cjs$6.FIVE_MINUTES,
	max: import_cjs$6.SEVEN_DAYS
}, $$4 = {
	idle: "IDLE",
	active: "ACTIVE"
}, Ke$5 = {
	eth_sendTransaction: { key: "" },
	eth_sendRawTransaction: { key: "" },
	wallet_sendCalls: { key: "" },
	solana_signTransaction: { key: "signature" },
	solana_signAllTransactions: { key: "transactions" },
	solana_signAndSendTransaction: { key: "signature" }
}, ut$5 = "request", gt$4 = [
	"wc_sessionPropose",
	"wc_sessionRequest",
	"wc_authRequest",
	"wc_sessionAuthenticate"
], yt$3 = "wc", Ss$3 = 1.5, wt$4 = "auth", mt$3 = "authKeys", _t$4 = "pairingTopics", Et$4 = "requests", ce$4 = `${yt$3}@1.5:${wt$4}:`, le$5 = `${ce$4}:PUB_KEY`;
var Rs$2 = Object.defineProperty, fs$3 = Object.defineProperties, Is$3 = Object.getOwnPropertyDescriptors, St$4 = Object.getOwnPropertySymbols, vs$3 = Object.prototype.hasOwnProperty, qs$5 = Object.prototype.propertyIsEnumerable, Ue$5 = (S$6, n$2, e) => n$2 in S$6 ? Rs$2(S$6, n$2, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : S$6[n$2] = e, v$3 = (S$6, n$2) => {
	for (var e in n$2 || (n$2 = {})) vs$3.call(n$2, e) && Ue$5(S$6, e, n$2[e]);
	if (St$4) for (var e of St$4(n$2)) qs$5.call(n$2, e) && Ue$5(S$6, e, n$2[e]);
	return S$6;
}, x$3 = (S$6, n$2) => fs$3(S$6, Is$3(n$2)), c$1 = (S$6, n$2, e) => Ue$5(S$6, typeof n$2 != "symbol" ? n$2 + "" : n$2, e);
var Ts$2 = class extends V$5 {
	constructor(n$2) {
		super(n$2), c$1(this, "name", dt$4), c$1(this, "events", new import_events$4.default()), c$1(this, "initialized", !1), c$1(this, "requestQueue", {
			state: $$4.idle,
			queue: []
		}), c$1(this, "sessionRequestQueue", {
			state: $$4.idle,
			queue: []
		}), c$1(this, "requestQueueDelay", import_cjs$6.ONE_SECOND), c$1(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c$1(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c$1(this, "recentlyDeletedLimit", 200), c$1(this, "relayMessageCache", []), c$1(this, "pendingSessions", /* @__PURE__ */ new Map()), c$1(this, "init", async () => {
			this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N$3) }), this.initialized = !0, setTimeout(() => {
				this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
			}, (0, import_cjs$6.toMiliseconds)(this.requestQueueDelay)));
		}), c$1(this, "connect", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			const t = x$3(v$3({}, e), {
				requiredNamespaces: e.requiredNamespaces || {},
				optionalNamespaces: e.optionalNamespaces || {}
			});
			await this.isValidConnect(t);
			const { pairingTopic: s, requiredNamespaces: i$2, optionalNamespaces: r$1, sessionProperties: o$2, relays: a$1 } = t;
			let l$2 = s, u$2, g$2 = !1;
			try {
				if (l$2) {
					const R$5 = this.client.core.pairing.pairings.get(l$2);
					this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), g$2 = R$5.active;
				}
			} catch (R$5) {
				throw this.client.logger.error(`connect() -> pairing.get(${l$2}) failed`), R$5;
			}
			if (!l$2 || !g$2) {
				const { topic: R$5, uri: D$3 } = await this.client.core.pairing.create();
				l$2 = R$5, u$2 = D$3;
			}
			if (!l$2) {
				const { message: R$5 } = te$4("NO_MATCHING_KEY", `connect() pairing topic: ${l$2}`);
				throw new Error(R$5);
			}
			const h$4 = await this.client.core.crypto.generateKeyPair(), d$4 = N$3.wc_sessionPropose.req.ttl || import_cjs$6.FIVE_MINUTES, y$6 = ho$3(d$4), m$2 = x$3(v$3({
				requiredNamespaces: i$2,
				optionalNamespaces: r$1,
				relays: a$1 ?? [{ protocol: Pt$3 }],
				proposer: {
					publicKey: h$4,
					metadata: this.client.metadata
				},
				expiryTimestamp: y$6,
				pairingTopic: l$2
			}, o$2 && { sessionProperties: o$2 }), { id: payloadId() }), I$4 = go$3("session_connect", m$2.id), { reject: p$5, resolve: E$6, done: V$7 } = co$3(d$4, $e$5), q$4 = ({ id: R$5 }) => {
				R$5 === m$2.id && (this.client.events.off("proposal_expire", q$4), this.pendingSessions.delete(m$2.id), this.events.emit(I$4, { error: {
					message: $e$5,
					code: 0
				} }));
			};
			return this.client.events.on("proposal_expire", q$4), this.events.once(I$4, ({ error: R$5, session: D$3 }) => {
				this.client.events.off("proposal_expire", q$4), R$5 ? p$5(R$5) : D$3 && E$6(D$3);
			}), await this.sendRequest({
				topic: l$2,
				method: "wc_sessionPropose",
				params: m$2,
				throwOnFailedPublish: !0,
				clientRpcId: m$2.id
			}), await this.setProposal(m$2.id, m$2), {
				uri: u$2,
				approval: V$7
			};
		}), c$1(this, "pair", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			try {
				return await this.client.core.pairing.pair(e);
			} catch (t) {
				throw this.client.logger.error("pair() failed"), t;
			}
		}), c$1(this, "approve", async (e) => {
			var t, s, i$2;
			const r$1 = this.client.core.eventClient.createEvent({ properties: {
				topic: (t = e?.id) == null ? void 0 : t.toString(),
				trace: [qs$4.session_approve_started]
			} });
			try {
				this.isInitialized(), await this.confirmOnlineStateOrThrow();
			} catch (P$5) {
				throw r$1.setError(Gs$3.no_internet_connection), P$5;
			}
			try {
				await this.isValidProposalId(e?.id);
			} catch (P$5) {
				throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`), r$1.setError(Gs$3.proposal_not_found), P$5;
			}
			try {
				await this.isValidApprove(e);
			} catch (P$5) {
				throw this.client.logger.error("approve() -> isValidApprove() failed"), r$1.setError(Gs$3.session_approve_namespace_validation_failure), P$5;
			}
			const { id: o$2, relayProtocol: a$1, namespaces: l$2, sessionProperties: u$2, sessionConfig: g$2 } = e, h$4 = this.client.proposal.get(o$2);
			this.client.core.eventClient.deleteEvent({ eventId: r$1.eventId });
			const { pairingTopic: d$4, proposer: y$6, requiredNamespaces: m$2, optionalNamespaces: I$4 } = h$4;
			let p$5 = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: d$4 });
			p$5 || (p$5 = (i$2 = this.client.core.eventClient) == null ? void 0 : i$2.createEvent({
				type: qs$4.session_approve_started,
				properties: {
					topic: d$4,
					trace: [qs$4.session_approve_started, qs$4.session_namespaces_validation_success]
				}
			}));
			const E$6 = await this.client.core.crypto.generateKeyPair(), V$7 = y$6.publicKey, q$4 = await this.client.core.crypto.generateSharedKey(E$6, V$7), R$5 = v$3(v$3({
				relay: { protocol: a$1 ?? "irn" },
				namespaces: l$2,
				controller: {
					publicKey: E$6,
					metadata: this.client.metadata
				},
				expiry: ho$3(Y$3)
			}, u$2 && { sessionProperties: u$2 }), g$2 && { sessionConfig: g$2 }), D$3 = Q$3.relay;
			p$5.addTrace(qs$4.subscribing_session_topic);
			try {
				await this.client.core.relayer.subscribe(q$4, { transportType: D$3 });
			} catch (P$5) {
				throw p$5.setError(Gs$3.subscribe_session_topic_failure), P$5;
			}
			p$5.addTrace(qs$4.subscribe_session_topic_success);
			const ee$5 = x$3(v$3({}, R$5), {
				topic: q$4,
				requiredNamespaces: m$2,
				optionalNamespaces: I$4,
				pairingTopic: d$4,
				acknowledged: !1,
				self: R$5.controller,
				peer: {
					publicKey: y$6.publicKey,
					metadata: y$6.metadata
				},
				controller: E$6,
				transportType: Q$3.relay
			});
			await this.client.session.set(q$4, ee$5), p$5.addTrace(qs$4.store_session);
			try {
				p$5.addTrace(qs$4.publishing_session_settle), await this.sendRequest({
					topic: q$4,
					method: "wc_sessionSettle",
					params: R$5,
					throwOnFailedPublish: !0
				}).catch((P$5) => {
					throw p$5?.setError(Gs$3.session_settle_publish_failure), P$5;
				}), p$5.addTrace(qs$4.session_settle_publish_success), p$5.addTrace(qs$4.publishing_session_approve), await this.sendResult({
					id: o$2,
					topic: d$4,
					result: {
						relay: { protocol: a$1 ?? "irn" },
						responderPublicKey: E$6
					},
					throwOnFailedPublish: !0
				}).catch((P$5) => {
					throw p$5?.setError(Gs$3.session_approve_publish_failure), P$5;
				}), p$5.addTrace(qs$4.session_approve_publish_success);
			} catch (P$5) {
				throw this.client.logger.error(P$5), this.client.session.delete(q$4, de$3("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(q$4), P$5;
			}
			return this.client.core.eventClient.deleteEvent({ eventId: p$5.eventId }), await this.client.core.pairing.updateMetadata({
				topic: d$4,
				metadata: y$6.metadata
			}), await this.client.proposal.delete(o$2, de$3("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: d$4 }), await this.setExpiry(q$4, ho$3(Y$3)), {
				topic: q$4,
				acknowledged: () => Promise.resolve(this.client.session.get(q$4))
			};
		}), c$1(this, "reject", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			try {
				await this.isValidReject(e);
			} catch (r$1) {
				throw this.client.logger.error("reject() -> isValidReject() failed"), r$1;
			}
			const { id: t, reason: s } = e;
			let i$2;
			try {
				i$2 = this.client.proposal.get(t).pairingTopic;
			} catch (r$1) {
				throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r$1;
			}
			i$2 && (await this.sendError({
				id: t,
				topic: i$2,
				error: s,
				rpcOpts: N$3.wc_sessionPropose.reject
			}), await this.client.proposal.delete(t, de$3("USER_DISCONNECTED")));
		}), c$1(this, "update", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			try {
				await this.isValidUpdate(e);
			} catch (g$2) {
				throw this.client.logger.error("update() -> isValidUpdate() failed"), g$2;
			}
			const { topic: t, namespaces: s } = e, { done: i$2, resolve: r$1, reject: o$2 } = co$3(), a$1 = payloadId(), l$2 = getBigIntRpcId().toString(), u$2 = this.client.session.get(t).namespaces;
			return this.events.once(go$3("session_update", a$1), ({ error: g$2 }) => {
				g$2 ? o$2(g$2) : r$1();
			}), await this.client.session.update(t, { namespaces: s }), await this.sendRequest({
				topic: t,
				method: "wc_sessionUpdate",
				params: { namespaces: s },
				throwOnFailedPublish: !0,
				clientRpcId: a$1,
				relayRpcId: l$2
			}).catch((g$2) => {
				this.client.logger.error(g$2), this.client.session.update(t, { namespaces: u$2 }), o$2(g$2);
			}), { acknowledged: i$2 };
		}), c$1(this, "extend", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			try {
				await this.isValidExtend(e);
			} catch (a$1) {
				throw this.client.logger.error("extend() -> isValidExtend() failed"), a$1;
			}
			const { topic: t } = e, s = payloadId(), { done: i$2, resolve: r$1, reject: o$2 } = co$3();
			return this.events.once(go$3("session_extend", s), ({ error: a$1 }) => {
				a$1 ? o$2(a$1) : r$1();
			}), await this.setExpiry(t, ho$3(Y$3)), this.sendRequest({
				topic: t,
				method: "wc_sessionExtend",
				params: {},
				clientRpcId: s,
				throwOnFailedPublish: !0
			}).catch((a$1) => {
				o$2(a$1);
			}), { acknowledged: i$2 };
		}), c$1(this, "request", async (e) => {
			this.isInitialized();
			try {
				await this.isValidRequest(e);
			} catch (p$5) {
				throw this.client.logger.error("request() -> isValidRequest() failed"), p$5;
			}
			const { chainId: t, request: s, topic: i$2, expiry: r$1 = N$3.wc_sessionRequest.req.ttl } = e, o$2 = this.client.session.get(i$2);
			o$2?.transportType === Q$3.relay && await this.confirmOnlineStateOrThrow();
			const a$1 = payloadId(), l$2 = getBigIntRpcId().toString(), { done: u$2, resolve: g$2, reject: h$4 } = co$3(r$1, "Request expired. Please try again.");
			this.events.once(go$3("session_request", a$1), ({ error: p$5, result: E$6 }) => {
				p$5 ? h$4(p$5) : g$2(E$6);
			});
			const d$4 = "wc_sessionRequest", y$6 = this.getAppLinkIfEnabled(o$2.peer.metadata, o$2.transportType);
			if (y$6) return await this.sendRequest({
				clientRpcId: a$1,
				relayRpcId: l$2,
				topic: i$2,
				method: d$4,
				params: {
					request: x$3(v$3({}, s), { expiryTimestamp: ho$3(r$1) }),
					chainId: t
				},
				expiry: r$1,
				throwOnFailedPublish: !0,
				appLink: y$6
			}).catch((p$5) => h$4(p$5)), this.client.events.emit("session_request_sent", {
				topic: i$2,
				request: s,
				chainId: t,
				id: a$1
			}), await u$2();
			const m$2 = {
				request: x$3(v$3({}, s), { expiryTimestamp: ho$3(r$1) }),
				chainId: t
			}, I$4 = this.shouldSetTVF(d$4, m$2);
			return await Promise.all([
				new Promise(async (p$5) => {
					await this.sendRequest(v$3({
						clientRpcId: a$1,
						relayRpcId: l$2,
						topic: i$2,
						method: d$4,
						params: m$2,
						expiry: r$1,
						throwOnFailedPublish: !0
					}, I$4 && { tvf: this.getTVFParams(a$1, m$2) })).catch((E$6) => h$4(E$6)), this.client.events.emit("session_request_sent", {
						topic: i$2,
						request: s,
						chainId: t,
						id: a$1
					}), p$5();
				}),
				new Promise(async (p$5) => {
					var E$6;
					if (!((E$6 = o$2.sessionConfig) != null && E$6.disableDeepLink)) await yo$3({
						id: a$1,
						topic: i$2,
						wcDeepLink: await mo$3(this.client.core.storage, ke$5)
					});
					p$5();
				}),
				u$2()
			]).then((p$5) => p$5[2]);
		}), c$1(this, "respond", async (e) => {
			this.isInitialized(), await this.isValidRespond(e);
			const { topic: t, response: s } = e, { id: i$2 } = s, r$1 = this.client.session.get(t);
			r$1.transportType === Q$3.relay && await this.confirmOnlineStateOrThrow();
			const o$2 = this.getAppLinkIfEnabled(r$1.peer.metadata, r$1.transportType);
			isJsonRpcResult(s) ? await this.sendResult({
				id: i$2,
				topic: t,
				result: s.result,
				throwOnFailedPublish: !0,
				appLink: o$2
			}) : isJsonRpcError(s) && await this.sendError({
				id: i$2,
				topic: t,
				error: s.error,
				appLink: o$2
			}), this.cleanupAfterResponse(e);
		}), c$1(this, "ping", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			try {
				await this.isValidPing(e);
			} catch (s) {
				throw this.client.logger.error("ping() -> isValidPing() failed"), s;
			}
			const { topic: t } = e;
			if (this.client.session.keys.includes(t)) {
				const s = payloadId(), i$2 = getBigIntRpcId().toString(), { done: r$1, resolve: o$2, reject: a$1 } = co$3();
				this.events.once(go$3("session_ping", s), ({ error: l$2 }) => {
					l$2 ? a$1(l$2) : o$2();
				}), await Promise.all([this.sendRequest({
					topic: t,
					method: "wc_sessionPing",
					params: {},
					throwOnFailedPublish: !0,
					clientRpcId: s,
					relayRpcId: i$2
				}), r$1()]);
			} else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t }));
		}), c$1(this, "emit", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
			const { topic: t, event: s, chainId: i$2 } = e, r$1 = getBigIntRpcId().toString(), o$2 = payloadId();
			await this.sendRequest({
				topic: t,
				method: "wc_sessionEvent",
				params: {
					event: s,
					chainId: i$2
				},
				throwOnFailedPublish: !0,
				relayRpcId: r$1,
				clientRpcId: o$2
			});
		}), c$1(this, "disconnect", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
			const { topic: t } = e;
			if (this.client.session.keys.includes(t)) await this.sendRequest({
				topic: t,
				method: "wc_sessionDelete",
				params: de$3("USER_DISCONNECTED"),
				throwOnFailedPublish: !0
			}), await this.deleteSession({
				topic: t,
				emitEvent: !1
			});
			else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
			else {
				const { message: s } = te$4("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
				throw new Error(s);
			}
		}), c$1(this, "find", (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => $i$2(t, e)))), c$1(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c$1(this, "authenticate", async (e, t) => {
			var s;
			this.isInitialized(), this.isValidAuthenticate(e);
			const i$2 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), r$1 = i$2 ? Q$3.link_mode : Q$3.relay;
			r$1 === Q$3.relay && await this.confirmOnlineStateOrThrow();
			const { chains: o$2, statement: a$1 = "", uri: l$2, domain: u$2, nonce: g$2, type: h$4, exp: d$4, nbf: y$6, methods: m$2 = [], expiry: I$4 } = e, p$5 = [...e.resources || []], { topic: E$6, uri: V$7 } = await this.client.core.pairing.create({
				methods: ["wc_sessionAuthenticate"],
				transportType: r$1
			});
			this.client.logger.info({
				message: "Generated new pairing",
				pairing: {
					topic: E$6,
					uri: V$7
				}
			});
			const q$4 = await this.client.core.crypto.generateKeyPair(), R$5 = oi$2(q$4);
			if (await Promise.all([this.client.auth.authKeys.set(le$5, {
				responseTopic: R$5,
				publicKey: q$4
			}), this.client.auth.pairingTopics.set(R$5, {
				topic: R$5,
				pairingTopic: E$6
			})]), await this.client.core.relayer.subscribe(R$5, { transportType: r$1 }), this.client.logger.info(`sending request to new pairing topic: ${E$6}`), m$2.length > 0) {
				const { namespace: b$3 } = Ye$3(o$2[0]);
				let L$4 = ts$2(b$3, "request", m$2);
				Me$5(p$5) && (L$4 = ns$1(L$4, p$5.pop())), p$5.push(L$4);
			}
			const D$3 = I$4 && I$4 > N$3.wc_sessionAuthenticate.req.ttl ? I$4 : N$3.wc_sessionAuthenticate.req.ttl, ee$5 = {
				authPayload: {
					type: h$4 ?? "caip122",
					chains: o$2,
					statement: a$1,
					aud: l$2,
					domain: u$2,
					version: "1",
					nonce: g$2,
					iat: (/* @__PURE__ */ new Date()).toISOString(),
					exp: d$4,
					nbf: y$6,
					resources: p$5
				},
				requester: {
					publicKey: q$4,
					metadata: this.client.metadata
				},
				expiryTimestamp: ho$3(D$3)
			}, X$1 = {
				requiredNamespaces: {},
				optionalNamespaces: { eip155: {
					chains: o$2,
					methods: [...new Set(["personal_sign", ...m$2])],
					events: ["chainChanged", "accountsChanged"]
				} },
				relays: [{ protocol: "irn" }],
				pairingTopic: E$6,
				proposer: {
					publicKey: q$4,
					metadata: this.client.metadata
				},
				expiryTimestamp: ho$3(N$3.wc_sessionPropose.req.ttl),
				id: payloadId()
			}, { done: ft$5, resolve: Fe$6, reject: Re$4 } = co$3(D$3, "Request expired"), te$6 = payloadId(), pe$4 = go$3("session_connect", X$1.id), fe$5 = go$3("session_request", te$6), he$4 = async ({ error: b$3, session: L$4 }) => {
				this.events.off(fe$5, Ie$6), b$3 ? Re$4(b$3) : L$4 && Fe$6({ session: L$4 });
			}, Ie$6 = async (b$3) => {
				var L$4, je$6, Qe$6;
				if (await this.deletePendingAuthRequest(te$6, {
					message: "fulfilled",
					code: 0
				}), b$3.error) {
					const ie$6 = de$3("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
					return b$3.error.code === ie$6.code ? void 0 : (this.events.off(pe$4, he$4), Re$4(b$3.error.message));
				}
				await this.deleteProposal(X$1.id), this.events.off(pe$4, he$4);
				const { cacaos: He$5, responder: Q$4 } = b$3.result, qe$6 = [], ze$6 = [];
				for (const ie$6 of He$5) {
					await Yo$3({
						cacao: ie$6,
						projectId: this.client.core.projectId
					}) || (this.client.logger.error(ie$6, "Signature verification failed"), Re$4(de$3("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
					const { p: Te$5 } = ie$6, Ne$5 = Me$5(Te$5.resources), Ye$6 = [On$3(Te$5.iss)], It$4 = ut$4(Te$5.iss);
					if (Ne$5) {
						const Pe$4 = rs$2(Ne$5), vt$5 = os$2(Ne$5);
						qe$6.push(...Pe$4), Ye$6.push(...vt$5);
					}
					for (const Pe$4 of Ye$6) ze$6.push(`${Pe$4}:${It$4}`);
				}
				const se$6 = await this.client.core.crypto.generateSharedKey(q$4, Q$4.publicKey);
				let de$6;
				qe$6.length > 0 && (de$6 = {
					topic: se$6,
					acknowledged: !0,
					self: {
						publicKey: q$4,
						metadata: this.client.metadata
					},
					peer: Q$4,
					controller: Q$4.publicKey,
					expiry: ho$3(Y$3),
					requiredNamespaces: {},
					optionalNamespaces: {},
					relay: { protocol: "irn" },
					pairingTopic: E$6,
					namespaces: Ti$2([...new Set(qe$6)], [...new Set(ze$6)]),
					transportType: r$1
				}, await this.client.core.relayer.subscribe(se$6, { transportType: r$1 }), await this.client.session.set(se$6, de$6), E$6 && await this.client.core.pairing.updateMetadata({
					topic: E$6,
					metadata: Q$4.metadata
				}), de$6 = this.client.session.get(se$6)), (L$4 = this.client.metadata.redirect) != null && L$4.linkMode && (je$6 = Q$4.metadata.redirect) != null && je$6.linkMode && (Qe$6 = Q$4.metadata.redirect) != null && Qe$6.universal && t && (this.client.core.addLinkModeSupportedApp(Q$4.metadata.redirect.universal), this.client.session.update(se$6, { transportType: Q$3.link_mode })), Fe$6({
					auths: He$5,
					session: de$6
				});
			};
			this.events.once(pe$4, he$4), this.events.once(fe$5, Ie$6);
			let ve$4;
			try {
				if (i$2) {
					const b$3 = formatJsonRpcRequest("wc_sessionAuthenticate", ee$5, te$6);
					this.client.core.history.set(E$6, b$3);
					ve$4 = Ei$3(t, E$6, await this.client.core.crypto.encode("", b$3, {
						type: _e$5,
						encoding: Qs$3
					}));
				} else await Promise.all([this.sendRequest({
					topic: E$6,
					method: "wc_sessionAuthenticate",
					params: ee$5,
					expiry: e.expiry,
					throwOnFailedPublish: !0,
					clientRpcId: te$6
				}), this.sendRequest({
					topic: E$6,
					method: "wc_sessionPropose",
					params: X$1,
					expiry: N$3.wc_sessionPropose.req.ttl,
					throwOnFailedPublish: !0,
					clientRpcId: X$1.id
				})]);
			} catch (b$3) {
				throw this.events.off(pe$4, he$4), this.events.off(fe$5, Ie$6), b$3;
			}
			return await this.setProposal(X$1.id, X$1), await this.setAuthRequest(te$6, {
				request: x$3(v$3({}, ee$5), { verifyContext: {} }),
				pairingTopic: E$6,
				transportType: r$1
			}), {
				uri: ve$4 ?? V$7,
				response: ft$5
			};
		}), c$1(this, "approveSessionAuthenticate", async (e) => {
			const { id: t, auths: s } = e, i$2 = this.client.core.eventClient.createEvent({ properties: {
				topic: t.toString(),
				trace: [Hs$2.authenticated_session_approve_started]
			} });
			try {
				this.isInitialized();
			} catch (I$4) {
				throw i$2.setError(Ys$3.no_internet_connection), I$4;
			}
			const r$1 = this.getPendingAuthRequest(t);
			if (!r$1) throw i$2.setError(Ys$3.authenticated_session_pending_request_not_found), /* @__PURE__ */ new Error(`Could not find pending auth request with id ${t}`);
			const o$2 = r$1.transportType || Q$3.relay;
			o$2 === Q$3.relay && await this.confirmOnlineStateOrThrow();
			const a$1 = r$1.requester.publicKey, l$2 = await this.client.core.crypto.generateKeyPair(), u$2 = oi$2(a$1), g$2 = {
				type: Ie$4,
				receiverPublicKey: a$1,
				senderPublicKey: l$2
			}, h$4 = [], d$4 = [];
			for (const I$4 of s) {
				if (!await Yo$3({
					cacao: I$4,
					projectId: this.client.core.projectId
				})) {
					i$2.setError(Ys$3.invalid_cacao);
					const R$5 = de$3("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
					throw await this.sendError({
						id: t,
						topic: u$2,
						error: R$5,
						encodeOpts: g$2
					}), new Error(R$5.message);
				}
				i$2.addTrace(Hs$2.cacaos_verified);
				const { p: p$5 } = I$4, E$6 = Me$5(p$5.resources), V$7 = [On$3(p$5.iss)], q$4 = ut$4(p$5.iss);
				if (E$6) {
					const R$5 = rs$2(E$6), D$3 = os$2(E$6);
					h$4.push(...R$5), V$7.push(...D$3);
				}
				for (const R$5 of V$7) d$4.push(`${R$5}:${q$4}`);
			}
			const y$6 = await this.client.core.crypto.generateSharedKey(l$2, a$1);
			i$2.addTrace(Hs$2.create_authenticated_session_topic);
			let m$2;
			if (h$4?.length > 0) {
				m$2 = {
					topic: y$6,
					acknowledged: !0,
					self: {
						publicKey: l$2,
						metadata: this.client.metadata
					},
					peer: {
						publicKey: a$1,
						metadata: r$1.requester.metadata
					},
					controller: a$1,
					expiry: ho$3(Y$3),
					authentication: s,
					requiredNamespaces: {},
					optionalNamespaces: {},
					relay: { protocol: "irn" },
					pairingTopic: r$1.pairingTopic,
					namespaces: Ti$2([...new Set(h$4)], [...new Set(d$4)]),
					transportType: o$2
				}, i$2.addTrace(Hs$2.subscribing_authenticated_session_topic);
				try {
					await this.client.core.relayer.subscribe(y$6, { transportType: o$2 });
				} catch (I$4) {
					throw i$2.setError(Ys$3.subscribe_authenticated_session_topic_failure), I$4;
				}
				i$2.addTrace(Hs$2.subscribe_authenticated_session_topic_success), await this.client.session.set(y$6, m$2), i$2.addTrace(Hs$2.store_authenticated_session), await this.client.core.pairing.updateMetadata({
					topic: r$1.pairingTopic,
					metadata: r$1.requester.metadata
				});
			}
			i$2.addTrace(Hs$2.publishing_authenticated_session_approve);
			try {
				await this.sendResult({
					topic: u$2,
					id: t,
					result: {
						cacaos: s,
						responder: {
							publicKey: l$2,
							metadata: this.client.metadata
						}
					},
					encodeOpts: g$2,
					throwOnFailedPublish: !0,
					appLink: this.getAppLinkIfEnabled(r$1.requester.metadata, o$2)
				});
			} catch (I$4) {
				throw i$2.setError(Ys$3.authenticated_session_approve_publish_failure), I$4;
			}
			return await this.client.auth.requests.delete(t, {
				message: "fulfilled",
				code: 0
			}), await this.client.core.pairing.activate({ topic: r$1.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i$2.eventId }), { session: m$2 };
		}), c$1(this, "rejectSessionAuthenticate", async (e) => {
			this.isInitialized();
			const { id: t, reason: s } = e, i$2 = this.getPendingAuthRequest(t);
			if (!i$2) throw new Error(`Could not find pending auth request with id ${t}`);
			i$2.transportType === Q$3.relay && await this.confirmOnlineStateOrThrow();
			const r$1 = i$2.requester.publicKey, o$2 = await this.client.core.crypto.generateKeyPair(), a$1 = oi$2(r$1), l$2 = {
				type: Ie$4,
				receiverPublicKey: r$1,
				senderPublicKey: o$2
			};
			await this.sendError({
				id: t,
				topic: a$1,
				error: s,
				encodeOpts: l$2,
				rpcOpts: N$3.wc_sessionAuthenticate.reject,
				appLink: this.getAppLinkIfEnabled(i$2.requester.metadata, i$2.transportType)
			}), await this.client.auth.requests.delete(t, {
				message: "rejected",
				code: 0
			}), await this.client.proposal.delete(t, de$3("USER_DISCONNECTED"));
		}), c$1(this, "formatAuthMessage", (e) => {
			this.isInitialized();
			const { request: t, iss: s } = e;
			return In$3(t, s);
		}), c$1(this, "processRelayMessageCache", () => {
			setTimeout(async () => {
				if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0;) try {
					const e = this.relayMessageCache.shift();
					e && await this.onRelayMessage(e);
				} catch (e) {
					this.client.logger.error(e);
				}
			}, 50);
		}), c$1(this, "cleanupDuplicatePairings", async (e) => {
			if (e.pairingTopic) try {
				const t = this.client.core.pairing.pairings.get(e.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((i$2) => {
					var r$1, o$2;
					return ((r$1 = i$2.peerMetadata) == null ? void 0 : r$1.url) && ((o$2 = i$2.peerMetadata) == null ? void 0 : o$2.url) === e.peer.metadata.url && i$2.topic && i$2.topic !== t.topic;
				});
				if (s.length === 0) return;
				this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((i$2) => this.client.core.pairing.disconnect({ topic: i$2.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
			} catch (t) {
				this.client.logger.error(t);
			}
		}), c$1(this, "deleteSession", async (e) => {
			var t;
			const { topic: s, expirerHasDeleted: i$2 = !1, emitEvent: r$1 = !0, id: o$2 = 0 } = e, { self: a$1 } = this.client.session.get(s);
			await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, de$3("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(a$1.publicKey) && await this.client.core.crypto.deleteKeyPair(a$1.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), i$2 || this.client.core.expirer.del(s), this.client.core.storage.removeItem(ke$5).catch((l$2) => this.client.logger.warn(l$2)), this.getPendingSessionRequests().forEach((l$2) => {
				l$2.topic === s && this.deletePendingSessionRequest(l$2.id, de$3("USER_DISCONNECTED"));
			}), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $$4.idle), r$1 && this.client.events.emit("session_delete", {
				id: o$2,
				topic: s
			});
		}), c$1(this, "deleteProposal", async (e, t) => {
			if (t) try {
				const s = this.client.proposal.get(e);
				this.client.core.eventClient.getEvent({ topic: s.pairingTopic })?.setError(Gs$3.proposal_expired);
			} catch {}
			await Promise.all([this.client.proposal.delete(e, de$3("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
		}), c$1(this, "deletePendingSessionRequest", async (e, t, s = !1) => {
			await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i$2) => i$2.id !== e), s && (this.sessionRequestQueue.state = $$4.idle, this.client.events.emit("session_request_expire", { id: e }));
		}), c$1(this, "deletePendingAuthRequest", async (e, t, s = !1) => {
			await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
		}), c$1(this, "setExpiry", async (e, t) => {
			this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
		}), c$1(this, "setProposal", async (e, t) => {
			this.client.core.expirer.set(e, ho$3(N$3.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
		}), c$1(this, "setAuthRequest", async (e, t) => {
			const { request: s, pairingTopic: i$2, transportType: r$1 = Q$3.relay } = t;
			this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, {
				authPayload: s.authPayload,
				requester: s.requester,
				expiryTimestamp: s.expiryTimestamp,
				id: e,
				pairingTopic: i$2,
				verifyContext: s.verifyContext,
				transportType: r$1
			});
		}), c$1(this, "setPendingSessionRequest", async (e) => {
			const { id: t, topic: s, params: i$2, verifyContext: r$1 } = e, o$2 = i$2.request.expiryTimestamp || ho$3(N$3.wc_sessionRequest.req.ttl);
			this.client.core.expirer.set(t, o$2), await this.client.pendingRequest.set(t, {
				id: t,
				topic: s,
				params: i$2,
				verifyContext: r$1
			});
		}), c$1(this, "sendRequest", async (e) => {
			const { topic: t, method: s, params: i$2, expiry: r$1, relayRpcId: o$2, clientRpcId: a$1, throwOnFailedPublish: l$2, appLink: u$2, tvf: g$2 } = e, h$4 = formatJsonRpcRequest(s, i$2, a$1);
			let d$4;
			const y$6 = !!u$2;
			try {
				const p$5 = y$6 ? Qs$3 : At$5;
				d$4 = await this.client.core.crypto.encode(t, h$4, { encoding: p$5 });
			} catch (p$5) {
				throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), p$5;
			}
			let m$2;
			if (gt$4.includes(s)) {
				const p$5 = si$3(JSON.stringify(h$4)), E$6 = si$3(d$4);
				m$2 = await this.client.core.verify.register({
					id: E$6,
					decryptedId: p$5
				});
			}
			const I$4 = N$3[s].req;
			if (I$4.attestation = m$2, r$1 && (I$4.ttl = r$1), o$2 && (I$4.id = o$2), this.client.core.history.set(t, h$4), y$6) {
				const p$5 = Ei$3(u$2, t, d$4);
				await global.Linking.openURL(p$5, this.client.name);
			} else {
				const p$5 = N$3[s].req;
				r$1 && (p$5.ttl = r$1), o$2 && (p$5.id = o$2), p$5.tvf = x$3(v$3({}, g$2), { correlationId: h$4.id }), l$2 ? (p$5.internal = x$3(v$3({}, p$5.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(t, d$4, p$5)) : this.client.core.relayer.publish(t, d$4, p$5).catch((E$6) => this.client.logger.error(E$6));
			}
			return h$4.id;
		}), c$1(this, "sendResult", async (e) => {
			const { id: t, topic: s, result: i$2, throwOnFailedPublish: r$1, encodeOpts: o$2, appLink: a$1 } = e, l$2 = formatJsonRpcResult(t, i$2);
			let u$2;
			const g$2 = a$1 && typeof (global == null ? void 0 : global.Linking) < "u";
			try {
				const y$6 = g$2 ? Qs$3 : At$5;
				u$2 = await this.client.core.crypto.encode(s, l$2, x$3(v$3({}, o$2 || {}), { encoding: y$6 }));
			} catch (y$6) {
				throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), y$6;
			}
			let h$4, d$4;
			try {
				h$4 = await this.client.core.history.get(s, t);
				const y$6 = h$4.request;
				try {
					this.shouldSetTVF(y$6.method, y$6.params) && (d$4 = this.getTVFParams(t, y$6.params, i$2));
				} catch (m$2) {
					this.client.logger.warn("sendResult() -> getTVFParams() failed", m$2);
				}
			} catch (y$6) {
				throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), y$6;
			}
			if (g$2) {
				const y$6 = Ei$3(a$1, s, u$2);
				await global.Linking.openURL(y$6, this.client.name);
			} else {
				const m$2 = N$3[h$4.request.method].res;
				m$2.tvf = x$3(v$3({}, d$4), { correlationId: t }), r$1 ? (m$2.internal = x$3(v$3({}, m$2.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(s, u$2, m$2)) : this.client.core.relayer.publish(s, u$2, m$2).catch((I$4) => this.client.logger.error(I$4));
			}
			await this.client.core.history.resolve(l$2);
		}), c$1(this, "sendError", async (e) => {
			const { id: t, topic: s, error: i$2, encodeOpts: r$1, rpcOpts: o$2, appLink: a$1 } = e, l$2 = formatJsonRpcError(t, i$2);
			let u$2;
			const g$2 = a$1 && typeof (global == null ? void 0 : global.Linking) < "u";
			try {
				const d$4 = g$2 ? Qs$3 : At$5;
				u$2 = await this.client.core.crypto.encode(s, l$2, x$3(v$3({}, r$1 || {}), { encoding: d$4 }));
			} catch (d$4) {
				throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), d$4;
			}
			let h$4;
			try {
				h$4 = await this.client.core.history.get(s, t);
			} catch (d$4) {
				throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), d$4;
			}
			if (g$2) {
				const d$4 = Ei$3(a$1, s, u$2);
				await global.Linking.openURL(d$4, this.client.name);
			} else {
				const d$4 = h$4.request.method, y$6 = o$2 || N$3[d$4].res;
				this.client.core.relayer.publish(s, u$2, y$6);
			}
			await this.client.core.history.resolve(l$2);
		}), c$1(this, "cleanup", async () => {
			const e = [], t = [];
			this.client.session.getAll().forEach((s) => {
				let i$2 = !1;
				po$3(s.expiry) && (i$2 = !0), this.client.core.crypto.keychain.has(s.topic) || (i$2 = !0), i$2 && e.push(s.topic);
			}), this.client.proposal.getAll().forEach((s) => {
				po$3(s.expiryTimestamp) && t.push(s.id);
			}), await Promise.all([...e.map((s) => this.deleteSession({ topic: s })), ...t.map((s) => this.deleteProposal(s))]);
		}), c$1(this, "onRelayEventRequest", async (e) => {
			this.requestQueue.queue.push(e), await this.processRequestsQueue();
		}), c$1(this, "processRequestsQueue", async () => {
			if (this.requestQueue.state === $$4.active) {
				this.client.logger.info("Request queue already active, skipping...");
				return;
			}
			for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
				this.requestQueue.state = $$4.active;
				const e = this.requestQueue.queue.shift();
				if (e) try {
					await this.processRequest(e);
				} catch (t) {
					this.client.logger.warn(t);
				}
			}
			this.requestQueue.state = $$4.idle;
		}), c$1(this, "processRequest", async (e) => {
			const { topic: t, payload: s, attestation: i$2, transportType: r$1, encryptedId: o$2 } = e, a$1 = s.method;
			if (!this.shouldIgnorePairingRequest({
				topic: t,
				requestMethod: a$1
			})) switch (a$1) {
				case "wc_sessionPropose": return await this.onSessionProposeRequest({
					topic: t,
					payload: s,
					attestation: i$2,
					encryptedId: o$2
				});
				case "wc_sessionSettle": return await this.onSessionSettleRequest(t, s);
				case "wc_sessionUpdate": return await this.onSessionUpdateRequest(t, s);
				case "wc_sessionExtend": return await this.onSessionExtendRequest(t, s);
				case "wc_sessionPing": return await this.onSessionPingRequest(t, s);
				case "wc_sessionDelete": return await this.onSessionDeleteRequest(t, s);
				case "wc_sessionRequest": return await this.onSessionRequest({
					topic: t,
					payload: s,
					attestation: i$2,
					encryptedId: o$2,
					transportType: r$1
				});
				case "wc_sessionEvent": return await this.onSessionEventRequest(t, s);
				case "wc_sessionAuthenticate": return await this.onSessionAuthenticateRequest({
					topic: t,
					payload: s,
					attestation: i$2,
					encryptedId: o$2,
					transportType: r$1
				});
				default: return this.client.logger.info(`Unsupported request method ${a$1}`);
			}
		}), c$1(this, "onRelayEventResponse", async (e) => {
			const { topic: t, payload: s, transportType: i$2 } = e, r$1 = (await this.client.core.history.get(t, s.id)).request.method;
			switch (r$1) {
				case "wc_sessionPropose": return this.onSessionProposeResponse(t, s, i$2);
				case "wc_sessionSettle": return this.onSessionSettleResponse(t, s);
				case "wc_sessionUpdate": return this.onSessionUpdateResponse(t, s);
				case "wc_sessionExtend": return this.onSessionExtendResponse(t, s);
				case "wc_sessionPing": return this.onSessionPingResponse(t, s);
				case "wc_sessionRequest": return this.onSessionRequestResponse(t, s);
				case "wc_sessionAuthenticate": return this.onSessionAuthenticateResponse(t, s);
				default: return this.client.logger.info(`Unsupported response method ${r$1}`);
			}
		}), c$1(this, "onRelayEventUnknownPayload", (e) => {
			const { topic: t } = e, { message: s } = te$4("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
			throw new Error(s);
		}), c$1(this, "shouldIgnorePairingRequest", (e) => {
			const { topic: t, requestMethod: s } = e, i$2 = this.expectedPairingMethodMap.get(t);
			return !i$2 || i$2.includes(s) ? !1 : !!(i$2.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
		}), c$1(this, "onSessionProposeRequest", async (e) => {
			const { topic: t, payload: s, attestation: i$2, encryptedId: r$1 } = e, { params: o$2, id: a$1 } = s;
			try {
				const l$2 = this.client.core.eventClient.getEvent({ topic: t });
				this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l$2?.setError(J$5.proposal_listener_not_found)), this.isValidConnect(v$3({}, s.params));
				const g$2 = v$3({
					id: a$1,
					pairingTopic: t,
					expiryTimestamp: o$2.expiryTimestamp || ho$3(N$3.wc_sessionPropose.req.ttl)
				}, o$2);
				await this.setProposal(a$1, g$2);
				const h$4 = await this.getVerifyContext({
					attestationId: i$2,
					hash: si$3(JSON.stringify(s)),
					encryptedId: r$1,
					metadata: g$2.proposer.metadata
				});
				l$2?.addTrace(q$2.emit_session_proposal), this.client.events.emit("session_proposal", {
					id: a$1,
					params: g$2,
					verifyContext: h$4
				});
			} catch (l$2) {
				await this.sendError({
					id: a$1,
					topic: t,
					error: l$2,
					rpcOpts: N$3.wc_sessionPropose.autoReject
				}), this.client.logger.error(l$2);
			}
		}), c$1(this, "onSessionProposeResponse", async (e, t, s) => {
			const { id: i$2 } = t;
			if (isJsonRpcResult(t)) {
				const { result: r$1 } = t;
				this.client.logger.trace({
					type: "method",
					method: "onSessionProposeResponse",
					result: r$1
				});
				const o$2 = this.client.proposal.get(i$2);
				this.client.logger.trace({
					type: "method",
					method: "onSessionProposeResponse",
					proposal: o$2
				});
				const a$1 = o$2.proposer.publicKey;
				this.client.logger.trace({
					type: "method",
					method: "onSessionProposeResponse",
					selfPublicKey: a$1
				});
				const l$2 = r$1.responderPublicKey;
				this.client.logger.trace({
					type: "method",
					method: "onSessionProposeResponse",
					peerPublicKey: l$2
				});
				const u$2 = await this.client.core.crypto.generateSharedKey(a$1, l$2);
				this.pendingSessions.set(i$2, {
					sessionTopic: u$2,
					pairingTopic: e,
					proposalId: i$2,
					publicKey: a$1
				});
				const g$2 = await this.client.core.relayer.subscribe(u$2, { transportType: s });
				this.client.logger.trace({
					type: "method",
					method: "onSessionProposeResponse",
					subscriptionId: g$2
				}), await this.client.core.pairing.activate({ topic: e });
			} else if (isJsonRpcError(t)) {
				await this.client.proposal.delete(i$2, de$3("USER_DISCONNECTED"));
				const r$1 = go$3("session_connect", i$2);
				if (this.events.listenerCount(r$1) === 0) throw new Error(`emitting ${r$1} without any listeners, 954`);
				this.events.emit(r$1, { error: t.error });
			}
		}), c$1(this, "onSessionSettleRequest", async (e, t) => {
			const { id: s, params: i$2 } = t;
			try {
				this.isValidSessionSettleRequest(i$2);
				const { relay: r$1, controller: o$2, expiry: a$1, namespaces: l$2, sessionProperties: u$2, sessionConfig: g$2 } = t.params, h$4 = [...this.pendingSessions.values()].find((m$2) => m$2.sessionTopic === e);
				if (!h$4) return this.client.logger.error(`Pending session not found for topic ${e}`);
				const d$4 = this.client.proposal.get(h$4.proposalId), y$6 = x$3(v$3(v$3({
					topic: e,
					relay: r$1,
					expiry: a$1,
					namespaces: l$2,
					acknowledged: !0,
					pairingTopic: h$4.pairingTopic,
					requiredNamespaces: d$4.requiredNamespaces,
					optionalNamespaces: d$4.optionalNamespaces,
					controller: o$2.publicKey,
					self: {
						publicKey: h$4.publicKey,
						metadata: this.client.metadata
					},
					peer: {
						publicKey: o$2.publicKey,
						metadata: o$2.metadata
					}
				}, u$2 && { sessionProperties: u$2 }), g$2 && { sessionConfig: g$2 }), { transportType: Q$3.relay });
				await this.client.session.set(y$6.topic, y$6), await this.setExpiry(y$6.topic, y$6.expiry), await this.client.core.pairing.updateMetadata({
					topic: h$4.pairingTopic,
					metadata: y$6.peer.metadata
				}), this.client.events.emit("session_connect", { session: y$6 }), this.events.emit(go$3("session_connect", h$4.proposalId), { session: y$6 }), this.pendingSessions.delete(h$4.proposalId), this.deleteProposal(h$4.proposalId, !1), this.cleanupDuplicatePairings(y$6), await this.sendResult({
					id: t.id,
					topic: e,
					result: !0,
					throwOnFailedPublish: !0
				});
			} catch (r$1) {
				await this.sendError({
					id: s,
					topic: e,
					error: r$1
				}), this.client.logger.error(r$1);
			}
		}), c$1(this, "onSessionSettleResponse", async (e, t) => {
			const { id: s } = t;
			isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: !0 }), this.events.emit(go$3("session_approve", s), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, de$3("USER_DISCONNECTED")), this.events.emit(go$3("session_approve", s), { error: t.error }));
		}), c$1(this, "onSessionUpdateRequest", async (e, t) => {
			const { params: s, id: i$2 } = t;
			try {
				const r$1 = `${e}_session_update`, o$2 = Zi$2.get(r$1);
				if (o$2 && this.isRequestOutOfSync(o$2, i$2)) {
					this.client.logger.warn(`Discarding out of sync request - ${i$2}`), this.sendError({
						id: i$2,
						topic: e,
						error: de$3("INVALID_UPDATE_REQUEST")
					});
					return;
				}
				this.isValidUpdate(v$3({ topic: e }, s));
				try {
					Zi$2.set(r$1, i$2), await this.client.session.update(e, { namespaces: s.namespaces }), await this.sendResult({
						id: i$2,
						topic: e,
						result: !0,
						throwOnFailedPublish: !0
					});
				} catch (a$1) {
					throw Zi$2.delete(r$1), a$1;
				}
				this.client.events.emit("session_update", {
					id: i$2,
					topic: e,
					params: s
				});
			} catch (r$1) {
				await this.sendError({
					id: i$2,
					topic: e,
					error: r$1
				}), this.client.logger.error(r$1);
			}
		}), c$1(this, "isRequestOutOfSync", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c$1(this, "onSessionUpdateResponse", (e, t) => {
			const { id: s } = t, i$2 = go$3("session_update", s);
			if (this.events.listenerCount(i$2) === 0) throw new Error(`emitting ${i$2} without any listeners`);
			isJsonRpcResult(t) ? this.events.emit(go$3("session_update", s), {}) : isJsonRpcError(t) && this.events.emit(go$3("session_update", s), { error: t.error });
		}), c$1(this, "onSessionExtendRequest", async (e, t) => {
			const { id: s } = t;
			try {
				this.isValidExtend({ topic: e }), await this.setExpiry(e, ho$3(Y$3)), await this.sendResult({
					id: s,
					topic: e,
					result: !0,
					throwOnFailedPublish: !0
				}), this.client.events.emit("session_extend", {
					id: s,
					topic: e
				});
			} catch (i$2) {
				await this.sendError({
					id: s,
					topic: e,
					error: i$2
				}), this.client.logger.error(i$2);
			}
		}), c$1(this, "onSessionExtendResponse", (e, t) => {
			const { id: s } = t, i$2 = go$3("session_extend", s);
			if (this.events.listenerCount(i$2) === 0) throw new Error(`emitting ${i$2} without any listeners`);
			isJsonRpcResult(t) ? this.events.emit(go$3("session_extend", s), {}) : isJsonRpcError(t) && this.events.emit(go$3("session_extend", s), { error: t.error });
		}), c$1(this, "onSessionPingRequest", async (e, t) => {
			const { id: s } = t;
			try {
				this.isValidPing({ topic: e }), await this.sendResult({
					id: s,
					topic: e,
					result: !0,
					throwOnFailedPublish: !0
				}), this.client.events.emit("session_ping", {
					id: s,
					topic: e
				});
			} catch (i$2) {
				await this.sendError({
					id: s,
					topic: e,
					error: i$2
				}), this.client.logger.error(i$2);
			}
		}), c$1(this, "onSessionPingResponse", (e, t) => {
			const { id: s } = t, i$2 = go$3("session_ping", s);
			if (this.events.listenerCount(i$2) === 0) throw new Error(`emitting ${i$2} without any listeners`);
			setTimeout(() => {
				isJsonRpcResult(t) ? this.events.emit(go$3("session_ping", s), {}) : isJsonRpcError(t) && this.events.emit(go$3("session_ping", s), { error: t.error });
			}, 500);
		}), c$1(this, "onSessionDeleteRequest", async (e, t) => {
			const { id: s } = t;
			try {
				this.isValidDisconnect({
					topic: e,
					reason: t.params
				}), Promise.all([
					new Promise((i$2) => {
						this.client.core.relayer.once(T$1.publish, async () => {
							i$2(await this.deleteSession({
								topic: e,
								id: s
							}));
						});
					}),
					this.sendResult({
						id: s,
						topic: e,
						result: !0,
						throwOnFailedPublish: !0
					}),
					this.cleanupPendingSentRequestsForTopic({
						topic: e,
						error: de$3("USER_DISCONNECTED")
					})
				]).catch((i$2) => this.client.logger.error(i$2));
			} catch (i$2) {
				this.client.logger.error(i$2);
			}
		}), c$1(this, "onSessionRequest", async (e) => {
			var t, s, i$2;
			const { topic: r$1, payload: o$2, attestation: a$1, encryptedId: l$2, transportType: u$2 } = e, { id: g$2, params: h$4 } = o$2;
			try {
				await this.isValidRequest(v$3({ topic: r$1 }, h$4));
				const d$4 = this.client.session.get(r$1), m$2 = {
					id: g$2,
					topic: r$1,
					params: h$4,
					verifyContext: await this.getVerifyContext({
						attestationId: a$1,
						hash: si$3(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", h$4, g$2))),
						encryptedId: l$2,
						metadata: d$4.peer.metadata,
						transportType: u$2
					})
				};
				await this.setPendingSessionRequest(m$2), u$2 === Q$3.link_mode && (t = d$4.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = d$4.peer.metadata.redirect) == null ? void 0 : s.universal), (i$2 = this.client.signConfig) != null && i$2.disableRequestQueue ? this.emitSessionRequest(m$2) : (this.addSessionRequestToSessionRequestQueue(m$2), this.processSessionRequestQueue());
			} catch (d$4) {
				await this.sendError({
					id: g$2,
					topic: r$1,
					error: d$4
				}), this.client.logger.error(d$4);
			}
		}), c$1(this, "onSessionRequestResponse", (e, t) => {
			const { id: s } = t, i$2 = go$3("session_request", s);
			if (this.events.listenerCount(i$2) === 0) throw new Error(`emitting ${i$2} without any listeners`);
			isJsonRpcResult(t) ? this.events.emit(go$3("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(go$3("session_request", s), { error: t.error });
		}), c$1(this, "onSessionEventRequest", async (e, t) => {
			const { id: s, params: i$2 } = t;
			try {
				const r$1 = `${e}_session_event_${i$2.event.name}`, o$2 = Zi$2.get(r$1);
				if (o$2 && this.isRequestOutOfSync(o$2, s)) {
					this.client.logger.info(`Discarding out of sync request - ${s}`);
					return;
				}
				this.isValidEmit(v$3({ topic: e }, i$2)), this.client.events.emit("session_event", {
					id: s,
					topic: e,
					params: i$2
				}), Zi$2.set(r$1, s);
			} catch (r$1) {
				await this.sendError({
					id: s,
					topic: e,
					error: r$1
				}), this.client.logger.error(r$1);
			}
		}), c$1(this, "onSessionAuthenticateResponse", (e, t) => {
			const { id: s } = t;
			this.client.logger.trace({
				type: "method",
				method: "onSessionAuthenticateResponse",
				topic: e,
				payload: t
			}), isJsonRpcResult(t) ? this.events.emit(go$3("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(go$3("session_request", s), { error: t.error });
		}), c$1(this, "onSessionAuthenticateRequest", async (e) => {
			var t;
			const { topic: s, payload: i$2, attestation: r$1, encryptedId: o$2, transportType: a$1 } = e;
			try {
				const { requester: l$2, authPayload: u$2, expiryTimestamp: g$2 } = i$2.params, h$4 = await this.getVerifyContext({
					attestationId: r$1,
					hash: si$3(JSON.stringify(i$2)),
					encryptedId: o$2,
					metadata: l$2.metadata,
					transportType: a$1
				}), d$4 = {
					requester: l$2,
					pairingTopic: s,
					id: i$2.id,
					authPayload: u$2,
					verifyContext: h$4,
					expiryTimestamp: g$2
				};
				await this.setAuthRequest(i$2.id, {
					request: d$4,
					pairingTopic: s,
					transportType: a$1
				}), a$1 === Q$3.link_mode && (t = l$2.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l$2.metadata.redirect.universal), this.client.events.emit("session_authenticate", {
					topic: s,
					params: i$2.params,
					id: i$2.id,
					verifyContext: h$4
				});
			} catch (l$2) {
				this.client.logger.error(l$2);
				const u$2 = i$2.params.requester.publicKey, g$2 = await this.client.core.crypto.generateKeyPair(), h$4 = this.getAppLinkIfEnabled(i$2.params.requester.metadata, a$1), d$4 = {
					type: Ie$4,
					receiverPublicKey: u$2,
					senderPublicKey: g$2
				};
				await this.sendError({
					id: i$2.id,
					topic: s,
					error: l$2,
					encodeOpts: d$4,
					rpcOpts: N$3.wc_sessionAuthenticate.autoReject,
					appLink: h$4
				});
			}
		}), c$1(this, "addSessionRequestToSessionRequestQueue", (e) => {
			this.sessionRequestQueue.queue.push(e);
		}), c$1(this, "cleanupAfterResponse", (e) => {
			this.deletePendingSessionRequest(e.response.id, {
				message: "fulfilled",
				code: 0
			}), setTimeout(() => {
				this.sessionRequestQueue.state = $$4.idle, this.processSessionRequestQueue();
			}, (0, import_cjs$6.toMiliseconds)(this.requestQueueDelay));
		}), c$1(this, "cleanupPendingSentRequestsForTopic", ({ topic: e, error: t }) => {
			const s = this.client.core.history.pending;
			s.length > 0 && s.filter((i$2) => i$2.topic === e && i$2.request.method === "wc_sessionRequest").forEach((i$2) => {
				const r$1 = i$2.request.id, o$2 = go$3("session_request", r$1);
				if (this.events.listenerCount(o$2) === 0) throw new Error(`emitting ${o$2} without any listeners`);
				this.events.emit(go$3("session_request", i$2.request.id), { error: t });
			});
		}), c$1(this, "processSessionRequestQueue", () => {
			if (this.sessionRequestQueue.state === $$4.active) {
				this.client.logger.info("session request queue is already active.");
				return;
			}
			const e = this.sessionRequestQueue.queue[0];
			if (!e) {
				this.client.logger.info("session request queue is empty.");
				return;
			}
			try {
				this.sessionRequestQueue.state = $$4.active, this.emitSessionRequest(e);
			} catch (t) {
				this.client.logger.error(t);
			}
		}), c$1(this, "emitSessionRequest", (e) => {
			this.client.events.emit("session_request", e);
		}), c$1(this, "onPairingCreated", (e) => {
			if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
			const t = this.client.proposal.getAll().find((s) => s.pairingTopic === e.topic);
			t && this.onSessionProposeRequest({
				topic: e.topic,
				payload: formatJsonRpcRequest("wc_sessionPropose", {
					requiredNamespaces: t.requiredNamespaces,
					optionalNamespaces: t.optionalNamespaces,
					relays: t.relays,
					proposer: t.proposer,
					sessionProperties: t.sessionProperties
				}, t.id)
			});
		}), c$1(this, "isValidConnect", async (e) => {
			if (!Di$3(e)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
				throw new Error(a$1);
			}
			const { pairingTopic: t, requiredNamespaces: s, optionalNamespaces: i$2, sessionProperties: r$1, relays: o$2 } = e;
			if (ae$4(t) || await this.isValidPairingTopic(t), !Ci$4(o$2, !0)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", `connect() relays: ${o$2}`);
				throw new Error(a$1);
			}
			!ae$4(s) && qe$3(s) !== 0 && this.validateNamespaces(s, "requiredNamespaces"), !ae$4(i$2) && qe$3(i$2) !== 0 && this.validateNamespaces(i$2, "optionalNamespaces"), ae$4(r$1) || this.validateSessionProps(r$1, "sessionProperties");
		}), c$1(this, "validateNamespaces", (e, t) => {
			const s = ji$3(e, "connect()", t);
			if (s) throw new Error(s.message);
		}), c$1(this, "isValidApprove", async (e) => {
			if (!Di$3(e)) throw new Error(te$4("MISSING_OR_INVALID", `approve() params: ${e}`).message);
			const { id: t, namespaces: s, relayProtocol: i$2, sessionProperties: r$1 } = e;
			this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
			const o$2 = this.client.proposal.get(t), a$1 = Ir$3(s, "approve()");
			if (a$1) throw new Error(a$1.message);
			const l$2 = Nr$3(o$2.requiredNamespaces, s, "approve()");
			if (l$2) throw new Error(l$2.message);
			if (!q$3(i$2, !0)) {
				const { message: u$2 } = te$4("MISSING_OR_INVALID", `approve() relayProtocol: ${i$2}`);
				throw new Error(u$2);
			}
			ae$4(r$1) || this.validateSessionProps(r$1, "sessionProperties");
		}), c$1(this, "isValidReject", async (e) => {
			if (!Di$3(e)) {
				const { message: i$2 } = te$4("MISSING_OR_INVALID", `reject() params: ${e}`);
				throw new Error(i$2);
			}
			const { id: t, reason: s } = e;
			if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !Mi$2(s)) {
				const { message: i$2 } = te$4("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
				throw new Error(i$2);
			}
		}), c$1(this, "isValidSessionSettleRequest", (e) => {
			if (!Di$3(e)) {
				const { message: l$2 } = te$4("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
				throw new Error(l$2);
			}
			const { relay: t, controller: s, namespaces: i$2, expiry: r$1 } = e;
			if (!Ar$3(t)) {
				const { message: l$2 } = te$4("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
				throw new Error(l$2);
			}
			const o$2 = Bi$3(s, "onSessionSettleRequest()");
			if (o$2) throw new Error(o$2.message);
			const a$1 = Ir$3(i$2, "onSessionSettleRequest()");
			if (a$1) throw new Error(a$1.message);
			if (po$3(r$1)) {
				const { message: l$2 } = te$4("EXPIRED", "onSessionSettleRequest()");
				throw new Error(l$2);
			}
		}), c$1(this, "isValidUpdate", async (e) => {
			if (!Di$3(e)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", `update() params: ${e}`);
				throw new Error(a$1);
			}
			const { topic: t, namespaces: s } = e;
			this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
			const i$2 = this.client.session.get(t), r$1 = Ir$3(s, "update()");
			if (r$1) throw new Error(r$1.message);
			const o$2 = Nr$3(i$2.requiredNamespaces, s, "update()");
			if (o$2) throw new Error(o$2.message);
		}), c$1(this, "isValidExtend", async (e) => {
			if (!Di$3(e)) {
				const { message: s } = te$4("MISSING_OR_INVALID", `extend() params: ${e}`);
				throw new Error(s);
			}
			const { topic: t } = e;
			this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
		}), c$1(this, "isValidRequest", async (e) => {
			if (!Di$3(e)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", `request() params: ${e}`);
				throw new Error(a$1);
			}
			const { topic: t, request: s, chainId: i$2, expiry: r$1 } = e;
			this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
			const { namespaces: o$2 } = this.client.session.get(t);
			if (!Fi$3(o$2, i$2)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", `request() chainId: ${i$2}`);
				throw new Error(a$1);
			}
			if (!Vi$3(s)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
				throw new Error(a$1);
			}
			if (!qi$2(o$2, i$2, s.method)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", `request() method: ${s.method}`);
				throw new Error(a$1);
			}
			if (r$1 && !Ji$2(r$1, Ee$5)) {
				const { message: a$1 } = te$4("MISSING_OR_INVALID", `request() expiry: ${r$1}. Expiry must be a number (in seconds) between ${Ee$5.min} and ${Ee$5.max}`);
				throw new Error(a$1);
			}
		}), c$1(this, "isValidRespond", async (e) => {
			var t;
			if (!Di$3(e)) {
				const { message: r$1 } = te$4("MISSING_OR_INVALID", `respond() params: ${e}`);
				throw new Error(r$1);
			}
			const { topic: s, response: i$2 } = e;
			try {
				await this.isValidSessionTopic(s);
			} catch (r$1) {
				throw (t = e?.response) != null && t.id && this.cleanupAfterResponse(e), r$1;
			}
			if (!Hi$2(i$2)) {
				const { message: r$1 } = te$4("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i$2)}`);
				throw new Error(r$1);
			}
		}), c$1(this, "isValidPing", async (e) => {
			if (!Di$3(e)) {
				const { message: s } = te$4("MISSING_OR_INVALID", `ping() params: ${e}`);
				throw new Error(s);
			}
			const { topic: t } = e;
			await this.isValidSessionOrPairingTopic(t);
		}), c$1(this, "isValidEmit", async (e) => {
			if (!Di$3(e)) {
				const { message: o$2 } = te$4("MISSING_OR_INVALID", `emit() params: ${e}`);
				throw new Error(o$2);
			}
			const { topic: t, event: s, chainId: i$2 } = e;
			await this.isValidSessionTopic(t);
			const { namespaces: r$1 } = this.client.session.get(t);
			if (!Fi$3(r$1, i$2)) {
				const { message: o$2 } = te$4("MISSING_OR_INVALID", `emit() chainId: ${i$2}`);
				throw new Error(o$2);
			}
			if (!Ki$3(s)) {
				const { message: o$2 } = te$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
				throw new Error(o$2);
			}
			if (!Gi$3(r$1, i$2, s.name)) {
				const { message: o$2 } = te$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
				throw new Error(o$2);
			}
		}), c$1(this, "isValidDisconnect", async (e) => {
			if (!Di$3(e)) {
				const { message: s } = te$4("MISSING_OR_INVALID", `disconnect() params: ${e}`);
				throw new Error(s);
			}
			const { topic: t } = e;
			await this.isValidSessionOrPairingTopic(t);
		}), c$1(this, "isValidAuthenticate", (e) => {
			const { chains: t, uri: s, domain: i$2, nonce: r$1 } = e;
			if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
			if (!q$3(s, !1)) throw new Error("uri is required parameter");
			if (!q$3(i$2, !1)) throw new Error("domain is required parameter");
			if (!q$3(r$1, !1)) throw new Error("nonce is required parameter");
			if ([...new Set(t.map((a$1) => Ye$3(a$1).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
			const { namespace: o$2 } = Ye$3(t[0]);
			if (o$2 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
		}), c$1(this, "getVerifyContext", async (e) => {
			const { attestationId: t, hash: s, encryptedId: i$2, metadata: r$1, transportType: o$2 } = e, a$1 = { verified: {
				verifyUrl: r$1.verifyUrl || le$4,
				validation: "UNKNOWN",
				origin: r$1.url || ""
			} };
			try {
				if (o$2 === Q$3.link_mode) {
					const u$2 = this.getAppLinkIfEnabled(r$1, o$2);
					return a$1.verified.validation = u$2 && new URL(u$2).origin === new URL(r$1.url).origin ? "VALID" : "INVALID", a$1;
				}
				const l$2 = await this.client.core.verify.resolve({
					attestationId: t,
					hash: s,
					encryptedId: i$2,
					verifyUrl: r$1.verifyUrl
				});
				l$2 && (a$1.verified.origin = l$2.origin, a$1.verified.isScam = l$2.isScam, a$1.verified.validation = l$2.origin === new URL(r$1.url).origin ? "VALID" : "INVALID");
			} catch (l$2) {
				this.client.logger.warn(l$2);
			}
			return this.client.logger.debug(`Verify context: ${JSON.stringify(a$1)}`), a$1;
		}), c$1(this, "validateSessionProps", (e, t) => {
			Object.values(e).forEach((s) => {
				if (!q$3(s, !1)) {
					const { message: i$2 } = te$4("MISSING_OR_INVALID", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);
					throw new Error(i$2);
				}
			});
		}), c$1(this, "getPendingAuthRequest", (e) => {
			const t = this.client.auth.requests.get(e);
			return typeof t == "object" ? t : void 0;
		}), c$1(this, "addToRecentlyDeleted", (e, t) => {
			if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
				let s = 0;
				const i$2 = this.recentlyDeletedLimit / 2;
				for (const r$1 of this.recentlyDeletedMap.keys()) {
					if (s++ >= i$2) break;
					this.recentlyDeletedMap.delete(r$1);
				}
			}
		}), c$1(this, "checkRecentlyDeleted", (e) => {
			const t = this.recentlyDeletedMap.get(e);
			if (t) {
				const { message: s } = te$4("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
				throw new Error(s);
			}
		}), c$1(this, "isLinkModeEnabled", (e, t) => {
			var s, i$2, r$1, o$2, a$1, l$2, u$2, g$2, h$4;
			return !e || t !== Q$3.link_mode ? !1 : ((i$2 = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i$2.linkMode) === !0 && ((o$2 = (r$1 = this.client.metadata) == null ? void 0 : r$1.redirect) == null ? void 0 : o$2.universal) !== void 0 && ((l$2 = (a$1 = this.client.metadata) == null ? void 0 : a$1.redirect) == null ? void 0 : l$2.universal) !== "" && ((u$2 = e?.redirect) == null ? void 0 : u$2.universal) !== void 0 && ((g$2 = e?.redirect) == null ? void 0 : g$2.universal) !== "" && ((h$4 = e?.redirect) == null ? void 0 : h$4.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
		}), c$1(this, "getAppLinkIfEnabled", (e, t) => {
			var s;
			return this.isLinkModeEnabled(e, t) ? (s = e?.redirect) == null ? void 0 : s.universal : void 0;
		}), c$1(this, "handleLinkModeMessage", ({ url: e }) => {
			if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
			const t = bo$3(e, "topic") || "", s = decodeURIComponent(bo$3(e, "wc_ev") || ""), i$2 = this.client.session.keys.includes(t);
			i$2 && this.client.session.update(t, { transportType: Q$3.link_mode }), this.client.core.dispatchEnvelope({
				topic: t,
				message: s,
				sessionExists: i$2
			});
		}), c$1(this, "registerLinkModeListeners", async () => {
			var e;
			if (Eo$3() || ne$3() && (e = this.client.metadata.redirect) != null && e.linkMode) {
				const t = global == null ? void 0 : global.Linking;
				if (typeof t < "u") {
					t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
					const s = await t.getInitialURL();
					s && setTimeout(() => {
						this.handleLinkModeMessage({ url: s });
					}, 50);
				}
			}
		}), c$1(this, "shouldSetTVF", (e, t) => {
			if (!t || e !== "wc_sessionRequest") return !1;
			const { request: s } = t;
			return Object.keys(Ke$5).includes(s.method);
		}), c$1(this, "getTVFParams", (e, t, s) => {
			var i$2, r$1;
			try {
				const o$2 = t.request.method, a$1 = this.extractTxHashesFromResult(o$2, s);
				return x$3(v$3({
					correlationId: e,
					rpcMethods: [o$2],
					chainId: t.chainId
				}, this.isValidContractData(t.request.params) && { contractAddresses: [(r$1 = (i$2 = t.request.params) == null ? void 0 : i$2[0]) == null ? void 0 : r$1.to] }), { txHashes: a$1 });
			} catch (o$2) {
				this.client.logger.warn("Error getting TVF params", o$2);
			}
			return {};
		}), c$1(this, "isValidContractData", (e) => {
			var t;
			if (!e) return !1;
			try {
				const s = e?.data || ((t = e?.[0]) == null ? void 0 : t.data);
				if (!s.startsWith("0x")) return !1;
				const i$2 = s.slice(2);
				return /^[0-9a-fA-F]*$/.test(i$2) ? i$2.length % 2 === 0 : !1;
			} catch {}
			return !1;
		}), c$1(this, "extractTxHashesFromResult", (e, t) => {
			try {
				const s = Ke$5[e];
				if (typeof t == "string") return [t];
				const i$2 = t[s.key];
				if ($e$3(i$2)) return i$2;
				if (typeof i$2 == "string") return [i$2];
			} catch (s) {
				this.client.logger.warn("Error extracting tx hashes from result", s);
			}
			return [];
		});
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: n$2 } = te$4("NOT_INITIALIZED", this.name);
			throw new Error(n$2);
		}
	}
	async confirmOnlineStateOrThrow() {
		await this.client.core.relayer.confirmOnlineStateOrThrow();
	}
	registerRelayerEvents() {
		this.client.core.relayer.on(T$1.message, (n$2) => {
			!this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(n$2) : this.onRelayMessage(n$2);
		});
	}
	async onRelayMessage(n$2) {
		const { topic: e, message: t, attestation: s, transportType: i$2 } = n$2, { publicKey: r$1 } = this.client.auth.authKeys.keys.includes(le$5) ? this.client.auth.authKeys.get(le$5) : {
			responseTopic: void 0,
			publicKey: void 0
		}, o$2 = await this.client.core.crypto.decode(e, t, {
			receiverPublicKey: r$1,
			encoding: i$2 === Q$3.link_mode ? Qs$3 : At$5
		});
		try {
			isJsonRpcRequest(o$2) ? (this.client.core.history.set(e, o$2), this.onRelayEventRequest({
				topic: e,
				payload: o$2,
				attestation: s,
				transportType: i$2,
				encryptedId: si$3(t)
			})) : isJsonRpcResponse(o$2) ? (await this.client.core.history.resolve(o$2), await this.onRelayEventResponse({
				topic: e,
				payload: o$2,
				transportType: i$2
			}), this.client.core.history.delete(e, o$2.id)) : this.onRelayEventUnknownPayload({
				topic: e,
				payload: o$2,
				transportType: i$2
			});
		} catch (a$1) {
			this.client.logger.error(a$1);
		}
	}
	registerExpirerEvents() {
		this.client.core.expirer.on(M$4.expired, async (n$2) => {
			const { topic: e, id: t } = lo$3(n$2.target);
			if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, te$4("EXPIRED"), !0);
			if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, te$4("EXPIRED"), !0);
			e ? this.client.session.keys.includes(e) && (await this.deleteSession({
				topic: e,
				expirerHasDeleted: !0
			}), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, !0), this.client.events.emit("proposal_expire", { id: t }));
		});
	}
	registerPairingEvents() {
		this.client.core.pairing.events.on(se$4.create, (n$2) => this.onPairingCreated(n$2)), this.client.core.pairing.events.on(se$4.delete, (n$2) => {
			this.addToRecentlyDeleted(n$2.topic, "pairing");
		});
	}
	isValidPairingTopic(n$2) {
		if (!q$3(n$2, !1)) {
			const { message: e } = te$4("MISSING_OR_INVALID", `pairing topic should be a string: ${n$2}`);
			throw new Error(e);
		}
		if (!this.client.core.pairing.pairings.keys.includes(n$2)) {
			const { message: e } = te$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n$2}`);
			throw new Error(e);
		}
		if (po$3(this.client.core.pairing.pairings.get(n$2).expiry)) {
			const { message: e } = te$4("EXPIRED", `pairing topic: ${n$2}`);
			throw new Error(e);
		}
	}
	async isValidSessionTopic(n$2) {
		if (!q$3(n$2, !1)) {
			const { message: e } = te$4("MISSING_OR_INVALID", `session topic should be a string: ${n$2}`);
			throw new Error(e);
		}
		if (this.checkRecentlyDeleted(n$2), !this.client.session.keys.includes(n$2)) {
			const { message: e } = te$4("NO_MATCHING_KEY", `session topic doesn't exist: ${n$2}`);
			throw new Error(e);
		}
		if (po$3(this.client.session.get(n$2).expiry)) {
			await this.deleteSession({ topic: n$2 });
			const { message: e } = te$4("EXPIRED", `session topic: ${n$2}`);
			throw new Error(e);
		}
		if (!this.client.core.crypto.keychain.has(n$2)) {
			const { message: e } = te$4("MISSING_OR_INVALID", `session topic does not exist in keychain: ${n$2}`);
			throw await this.deleteSession({ topic: n$2 }), new Error(e);
		}
	}
	async isValidSessionOrPairingTopic(n$2) {
		if (this.checkRecentlyDeleted(n$2), this.client.session.keys.includes(n$2)) await this.isValidSessionTopic(n$2);
		else if (this.client.core.pairing.pairings.keys.includes(n$2)) this.isValidPairingTopic(n$2);
		else if (q$3(n$2, !1)) {
			const { message: e } = te$4("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n$2}`);
			throw new Error(e);
		} else {
			const { message: e } = te$4("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n$2}`);
			throw new Error(e);
		}
	}
	async isValidProposalId(n$2) {
		if (!ki$3(n$2)) {
			const { message: e } = te$4("MISSING_OR_INVALID", `proposal id should be a number: ${n$2}`);
			throw new Error(e);
		}
		if (!this.client.proposal.keys.includes(n$2)) {
			const { message: e } = te$4("NO_MATCHING_KEY", `proposal id doesn't exist: ${n$2}`);
			throw new Error(e);
		}
		if (po$3(this.client.proposal.get(n$2).expiryTimestamp)) {
			await this.deleteProposal(n$2);
			const { message: e } = te$4("EXPIRED", `proposal id: ${n$2}`);
			throw new Error(e);
		}
	}
};
var Ns$2 = class extends Ci$3 {
	constructor(n$2, e) {
		super(n$2, e, pt$4, me$3), this.core = n$2, this.logger = e;
	}
};
var Rt$4 = class extends Ci$3 {
	constructor(n$2, e) {
		super(n$2, e, ht$4, me$3), this.core = n$2, this.logger = e;
	}
};
var Ps$3 = class extends Ci$3 {
	constructor(n$2, e) {
		super(n$2, e, ut$5, me$3, (t) => t.id), this.core = n$2, this.logger = e;
	}
};
var Os$3 = class extends Ci$3 {
	constructor(n$2, e) {
		super(n$2, e, mt$3, ce$4, () => le$5), this.core = n$2, this.logger = e;
	}
};
var bs$3 = class extends Ci$3 {
	constructor(n$2, e) {
		super(n$2, e, _t$4, ce$4), this.core = n$2, this.logger = e;
	}
};
var As$3 = class extends Ci$3 {
	constructor(n$2, e) {
		super(n$2, e, Et$4, ce$4, (t) => t.id), this.core = n$2, this.logger = e;
	}
};
var Cs$3 = Object.defineProperty, xs$3 = (S$6, n$2, e) => n$2 in S$6 ? Cs$3(S$6, n$2, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : S$6[n$2] = e, Ge$5 = (S$6, n$2, e) => xs$3(S$6, typeof n$2 != "symbol" ? n$2 + "" : n$2, e);
var Vs$3 = class {
	constructor(n$2, e) {
		this.core = n$2, this.logger = e, Ge$5(this, "authKeys"), Ge$5(this, "pairingTopics"), Ge$5(this, "requests"), this.authKeys = new Os$3(this.core, this.logger), this.pairingTopics = new bs$3(this.core, this.logger), this.requests = new As$3(this.core, this.logger);
	}
	async init() {
		await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
	}
};
var Ds$2 = Object.defineProperty, Ls$3 = (S$6, n$2, e) => n$2 in S$6 ? Ds$2(S$6, n$2, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : S$6[n$2] = e, _$2 = (S$6, n$2, e) => Ls$3(S$6, typeof n$2 != "symbol" ? n$2 + "" : n$2, e);
var Se$3 = class Se$3 extends J$6 {
	constructor(n$2) {
		super(n$2), _$2(this, "protocol", De$4), _$2(this, "version", Le$5), _$2(this, "name", _e$6.name), _$2(this, "metadata"), _$2(this, "core"), _$2(this, "logger"), _$2(this, "events", new import_events$4.EventEmitter()), _$2(this, "engine"), _$2(this, "session"), _$2(this, "proposal"), _$2(this, "pendingRequest"), _$2(this, "auth"), _$2(this, "signConfig"), _$2(this, "on", (t, s) => this.events.on(t, s)), _$2(this, "once", (t, s) => this.events.once(t, s)), _$2(this, "off", (t, s) => this.events.off(t, s)), _$2(this, "removeListener", (t, s) => this.events.removeListener(t, s)), _$2(this, "removeAllListeners", (t) => this.events.removeAllListeners(t)), _$2(this, "connect", async (t) => {
			try {
				return await this.engine.connect(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "pair", async (t) => {
			try {
				return await this.engine.pair(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "approve", async (t) => {
			try {
				return await this.engine.approve(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "reject", async (t) => {
			try {
				return await this.engine.reject(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "update", async (t) => {
			try {
				return await this.engine.update(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "extend", async (t) => {
			try {
				return await this.engine.extend(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "request", async (t) => {
			try {
				return await this.engine.request(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "respond", async (t) => {
			try {
				return await this.engine.respond(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "ping", async (t) => {
			try {
				return await this.engine.ping(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "emit", async (t) => {
			try {
				return await this.engine.emit(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "disconnect", async (t) => {
			try {
				return await this.engine.disconnect(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "find", (t) => {
			try {
				return this.engine.find(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "getPendingSessionRequests", () => {
			try {
				return this.engine.getPendingSessionRequests();
			} catch (t) {
				throw this.logger.error(t.message), t;
			}
		}), _$2(this, "authenticate", async (t, s) => {
			try {
				return await this.engine.authenticate(t, s);
			} catch (i$2) {
				throw this.logger.error(i$2.message), i$2;
			}
		}), _$2(this, "formatAuthMessage", (t) => {
			try {
				return this.engine.formatAuthMessage(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "approveSessionAuthenticate", async (t) => {
			try {
				return await this.engine.approveSessionAuthenticate(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), _$2(this, "rejectSessionAuthenticate", async (t) => {
			try {
				return await this.engine.rejectSessionAuthenticate(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), this.name = n$2?.name || _e$6.name, this.metadata = n$2?.metadata || Yr$3(), this.signConfig = n$2?.signConfig;
		const e = typeof n$2?.logger < "u" && typeof n$2?.logger != "string" ? n$2.logger : (0, import_browser.default)(k({ level: n$2?.logger || _e$6.logger }));
		this.core = n$2?.core || new co$2(n$2), this.logger = E$1(e, this.name), this.session = new Rt$4(this.core, this.logger), this.proposal = new Ns$2(this.core, this.logger), this.pendingRequest = new Ps$3(this.core, this.logger), this.engine = new Ts$2(this), this.auth = new Vs$3(this.core, this.logger);
	}
	static async init(n$2) {
		const e = new Se$3(n$2);
		return await e.initialize(), e;
	}
	get context() {
		return y$1(this.logger);
	}
	get pairing() {
		return this.core.pairing.pairings;
	}
	async initialize() {
		this.logger.trace("Initialized");
		try {
			await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
				this.engine.processRelayMessageCache();
			}, (0, import_cjs$6.toMiliseconds)(import_cjs$6.ONE_SECOND));
		} catch (n$2) {
			throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n$2.message), n$2;
		}
	}
};

//#endregion
//#region node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events$3 = /* @__PURE__ */ __toESM(require_events());
var be$3 = "error", _t$3 = "wss://relay.walletconnect.org", $e$4 = `wc@2:universal_provider:`, ye$2 = "https://rpc.walletconnect.org/v1/", w$2 = "generic", Ot$2 = `${ye$2}bundler`, f$4 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var G$2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function At$3() {
	this.__data__ = [], this.size = 0;
}
var jt$3 = At$3;
function Ht$1(r$1, e) {
	return r$1 === e || r$1 !== r$1 && e !== e;
}
var z$3 = Ht$1, Et$3 = z$3;
function St$3(r$1, e) {
	for (var t = r$1.length; t--;) if (Et$3(r$1[t][0], e)) return t;
	return -1;
}
var k$3 = St$3, Nt$3 = k$3, Dt = Array.prototype.splice;
function qt$3(r$1) {
	var e = this.__data__, t = Nt$3(e, r$1);
	if (t < 0) return !1;
	return t == e.length - 1 ? e.pop() : Dt.call(e, t, 1), --this.size, !0;
}
var Rt$3 = qt$3, xt$3 = k$3;
function Lt$3(r$1) {
	var e = this.__data__, t = xt$3(e, r$1);
	return t < 0 ? void 0 : e[t][1];
}
var Ut$3 = Lt$3, Ft$3 = k$3;
function Mt$2(r$1) {
	return Ft$3(this.__data__, r$1) > -1;
}
var Gt$3 = Mt$2, zt$3 = k$3;
function kt$4(r$1, e) {
	var t = this.__data__, i$2 = zt$3(t, r$1);
	return i$2 < 0 ? (++this.size, t.push([r$1, e])) : t[i$2][1] = e, this;
}
var Bt$3 = kt$4, Vt$2 = jt$3, Jt$3 = Rt$3, Kt$2 = Ut$3, Wt$3 = Gt$3, Xt$2 = Bt$3;
function _$1(r$1) {
	var e = -1, t = r$1 == null ? 0 : r$1.length;
	for (this.clear(); ++e < t;) {
		var i$2 = r$1[e];
		this.set(i$2[0], i$2[1]);
	}
}
_$1.prototype.clear = Vt$2, _$1.prototype.delete = Jt$3, _$1.prototype.get = Kt$2, _$1.prototype.has = Wt$3, _$1.prototype.set = Xt$2;
var B$2 = _$1, Yt$3 = B$2;
function Zt$2() {
	this.__data__ = new Yt$3(), this.size = 0;
}
var Qt$2 = Zt$2;
function er$2(r$1) {
	var e = this.__data__, t = e.delete(r$1);
	return this.size = e.size, t;
}
var tr$2 = er$2;
function rr$1(r$1) {
	return this.__data__.get(r$1);
}
var ir$2 = rr$1;
function sr$2(r$1) {
	return this.__data__.has(r$1);
}
var nr$2 = sr$2, we$3 = typeof G$2 == "object" && G$2 && G$2.Object === Object && G$2, or$2 = we$3, cr$2 = typeof self == "object" && self && self.Object === Object && self, C$4 = or$2 || cr$2 || Function("return this")(), _e$4 = C$4.Symbol, Ce$3 = _e$4, Ie$3 = Object.prototype, lr$2 = Ie$3.hasOwnProperty, dr$2 = Ie$3.toString, F$3 = Ce$3 ? Ce$3.toStringTag : void 0;
function vr$2(r$1) {
	var e = lr$2.call(r$1, F$3), t = r$1[F$3];
	try {
		r$1[F$3] = void 0;
		var i$2 = !0;
	} catch {}
	var s = dr$2.call(r$1);
	return i$2 && (e ? r$1[F$3] = t : delete r$1[F$3]), s;
}
var fr$1 = vr$2, gr$2 = Object.prototype.toString;
function Pr$1(r$1) {
	return gr$2.call(r$1);
}
var br$2 = Pr$1, Oe$3 = _e$4, $r$2 = fr$1, yr$2 = br$2, wr$2 = "[object Null]", _r$2 = "[object Undefined]", Ae$2 = Oe$3 ? Oe$3.toStringTag : void 0;
function Cr$1(r$1) {
	return r$1 == null ? r$1 === void 0 ? _r$2 : wr$2 : Ae$2 && Ae$2 in Object(r$1) ? $r$2(r$1) : yr$2(r$1);
}
var V$4 = Cr$1;
function Ir$2(r$1) {
	var e = typeof r$1;
	return r$1 != null && (e == "object" || e == "function");
}
var $$3 = Ir$2, Or$2 = V$4, Ar$2 = $$3, jr$1 = "[object AsyncFunction]", Hr$1 = "[object Function]", Er$2 = "[object GeneratorFunction]", Sr$2 = "[object Proxy]";
function Nr$2(r$1) {
	if (!Ar$2(r$1)) return !1;
	var e = Or$2(r$1);
	return e == Hr$1 || e == Er$2 || e == jr$1 || e == Sr$2;
}
var te$3 = Nr$2, re$3 = C$4["__core-js_shared__"], je$3 = function() {
	var r$1 = /[^.]+$/.exec(re$3 && re$3.keys && re$3.keys.IE_PROTO || "");
	return r$1 ? "Symbol(src)_1." + r$1 : "";
}();
function Rr$2(r$1) {
	return !!je$3 && je$3 in r$1;
}
var xr$2 = Rr$2, Ur$2 = Function.prototype.toString;
function Fr$1(r$1) {
	if (r$1 != null) {
		try {
			return Ur$2.call(r$1);
		} catch {}
		try {
			return r$1 + "";
		} catch {}
	}
	return "";
}
var Mr$1 = Fr$1, Gr$2 = te$3, zr$2 = xr$2, kr$1 = $$3, Br$2 = Mr$1, Vr$1 = /[\\^$.*+?()[\]{}|]/g, Jr$2 = /^\[object .+?Constructor\]$/, Kr$1 = Function.prototype, Wr$2 = Object.prototype, Xr$2 = Kr$1.toString, Yr$2 = Wr$2.hasOwnProperty, Zr$1 = RegExp("^" + Xr$2.call(Yr$2).replace(Vr$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function Qr$1(r$1) {
	if (!kr$1(r$1) || zr$2(r$1)) return !1;
	return (Gr$2(r$1) ? Zr$1 : Jr$2).test(Br$2(r$1));
}
var ei$2 = Qr$1;
function ti$2(r$1, e) {
	return r$1?.[e];
}
var ri$2 = ti$2, ii$2 = ei$2, si$2 = ri$2;
function ni$2(r$1, e) {
	var t = si$2(r$1, e);
	return ii$2(t) ? t : void 0;
}
var ie$3 = ni$2, He$3 = ie$3(C$4, "Map"), J$4 = ie$3(Object, "create"), Ee$4 = J$4;
function ui$2() {
	this.__data__ = Ee$4 ? Ee$4(null) : {}, this.size = 0;
}
var li$2 = ui$2;
function di$2(r$1) {
	var e = this.has(r$1) && delete this.__data__[r$1];
	return this.size -= e ? 1 : 0, e;
}
var vi$2 = di$2, fi$2 = J$4, mi$2 = "__lodash_hash_undefined__", Pi$2 = Object.prototype.hasOwnProperty;
function bi$2(r$1) {
	var e = this.__data__;
	if (fi$2) {
		var t = e[r$1];
		return t === mi$2 ? void 0 : t;
	}
	return Pi$2.call(e, r$1) ? e[r$1] : void 0;
}
var $i$1 = bi$2, yi$2 = J$4, _i$1 = Object.prototype.hasOwnProperty;
function Ci$2(r$1) {
	var e = this.__data__;
	return yi$2 ? e[r$1] !== void 0 : _i$1.call(e, r$1);
}
var Ii$1 = Ci$2, Oi$1 = J$4, Ai$1 = "__lodash_hash_undefined__";
function ji$2(r$1, e) {
	var t = this.__data__;
	return this.size += this.has(r$1) ? 0 : 1, t[r$1] = Oi$1 && e === void 0 ? Ai$1 : e, this;
}
var Hi$1 = ji$2, Ei$2 = li$2, Si$1 = vi$2, Ni$1 = $i$1, Ti$1 = Ii$1, Di$2 = Hi$1;
function I$2(r$1) {
	var e = -1, t = r$1 == null ? 0 : r$1.length;
	for (this.clear(); ++e < t;) {
		var i$2 = r$1[e];
		this.set(i$2[0], i$2[1]);
	}
}
I$2.prototype.clear = Ei$2, I$2.prototype.delete = Si$1, I$2.prototype.get = Ni$1, I$2.prototype.has = Ti$1, I$2.prototype.set = Di$2;
var Se$4 = I$2, Ri$2 = B$2, xi$2 = He$3;
function Li$2() {
	this.size = 0, this.__data__ = {
		hash: new Se$4(),
		map: new (xi$2 || Ri$2)(),
		string: new Se$4()
	};
}
var Ui$1 = Li$2;
function Fi$2(r$1) {
	var e = typeof r$1;
	return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? r$1 !== "__proto__" : r$1 === null;
}
var Gi$2 = Fi$2;
function zi$2(r$1, e) {
	var t = r$1.__data__;
	return Gi$2(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
var K$2 = zi$2, ki$2 = K$2;
function Bi$2(r$1) {
	var e = ki$2(this, r$1).delete(r$1);
	return this.size -= e ? 1 : 0, e;
}
var Vi$2 = Bi$2, Ji$1 = K$2;
function Ki$2(r$1) {
	return Ji$1(this, r$1).get(r$1);
}
var Wi$1 = Ki$2, Xi$1 = K$2;
function Yi$2(r$1) {
	return Xi$1(this, r$1).has(r$1);
}
var Zi$1 = Yi$2, Qi$1 = K$2;
function es(r$1, e) {
	var t = Qi$1(this, r$1), i$2 = t.size;
	return t.set(r$1, e), this.size += t.size == i$2 ? 0 : 1, this;
}
var ts$1 = es, rs$1 = Ui$1, is$1 = Vi$2, ss$1 = Wi$1, ns = Zi$1, as$1 = ts$1;
function O$3(r$1) {
	var e = -1, t = r$1 == null ? 0 : r$1.length;
	for (this.clear(); ++e < t;) {
		var i$2 = r$1[e];
		this.set(i$2[0], i$2[1]);
	}
}
O$3.prototype.clear = rs$1, O$3.prototype.delete = is$1, O$3.prototype.get = ss$1, O$3.prototype.has = ns, O$3.prototype.set = as$1;
var os$1 = O$3, cs$2 = B$2, hs$1 = He$3, ps$2 = os$1, us = 200;
function ls$2(r$1, e) {
	var t = this.__data__;
	if (t instanceof cs$2) {
		var i$2 = t.__data__;
		if (!hs$1 || i$2.length < us - 1) return i$2.push([r$1, e]), this.size = ++t.size, this;
		t = this.__data__ = new ps$2(i$2);
	}
	return t.set(r$1, e), this.size = t.size, this;
}
var ds$1 = ls$2, vs$2 = B$2, fs$2 = Qt$2, ms$2 = tr$2, gs$1 = ir$2, Ps$2 = nr$2, bs$2 = ds$1;
function A$3(r$1) {
	this.size = (this.__data__ = new vs$2(r$1)).size;
}
A$3.prototype.clear = fs$2, A$3.prototype.delete = ms$2, A$3.prototype.get = gs$1, A$3.prototype.has = Ps$2, A$3.prototype.set = bs$2;
var $s$1 = A$3, ys$2 = ie$3, Ne$2 = function() {
	try {
		var r$1 = ys$2(Object, "defineProperty");
		return r$1({}, "", {}), r$1;
	} catch {}
}(), Te$3 = Ne$2;
function _s$2(r$1, e, t) {
	e == "__proto__" && Te$3 ? Te$3(r$1, e, {
		configurable: !0,
		enumerable: !0,
		value: t,
		writable: !0
	}) : r$1[e] = t;
}
var se$3 = _s$2, Cs$2 = se$3, Is$2 = z$3;
function Os$2(r$1, e, t) {
	(t !== void 0 && !Is$2(r$1[e], t) || t === void 0 && !(e in r$1)) && Cs$2(r$1, e, t);
}
var De$3 = Os$2;
function As$2(r$1) {
	return function(e, t, i$2) {
		for (var s = -1, n$2 = Object(e), a$1 = i$2(e), o$2 = a$1.length; o$2--;) {
			var c$3 = a$1[r$1 ? o$2 : ++s];
			if (t(n$2[c$3], c$3, n$2) === !1) break;
		}
		return e;
	};
}
var Ss$2 = As$2(), ne$2 = { exports: {} };
(function(r$1, e) {
	var t = C$4, i$2 = e && !e.nodeType && e, s = i$2 && r$1 && !r$1.nodeType && r$1, a$1 = s && s.exports === i$2 ? t.Buffer : void 0, o$2 = a$1 ? a$1.allocUnsafe : void 0;
	function c$3(u$2, l$2) {
		if (l$2) return u$2.slice();
		var P$5 = u$2.length, d$4 = o$2 ? o$2(P$5) : new u$2.constructor(P$5);
		return u$2.copy(d$4), d$4;
	}
	r$1.exports = c$3;
})(ne$2, ne$2.exports);
var qe$4 = C$4.Uint8Array;
function qs$3(r$1) {
	var e = new r$1.constructor(r$1.byteLength);
	return new qe$4(e).set(new qe$4(r$1)), e;
}
var xs$2 = qs$3;
function Ls$2(r$1, e) {
	var t = e ? xs$2(r$1.buffer) : r$1.buffer;
	return new r$1.constructor(t, r$1.byteOffset, r$1.length);
}
var Us$1 = Ls$2;
function Fs$1(r$1, e) {
	var t = -1, i$2 = r$1.length;
	for (e || (e = Array(i$2)); ++t < i$2;) e[t] = r$1[t];
	return e;
}
var Ms$1 = Fs$1, Gs$2 = $$3, Re$2 = Object.create, ks$2 = function() {
	function r$1() {}
	return function(e) {
		if (!Gs$2(e)) return {};
		if (Re$2) return Re$2(e);
		r$1.prototype = e;
		var t = new r$1();
		return r$1.prototype = void 0, t;
	};
}();
function Bs$1(r$1, e) {
	return function(t) {
		return r$1(e(t));
	};
}
var xe$2 = Bs$1(Object.getPrototypeOf, Object), Ws$2 = Object.prototype;
function Xs$2(r$1) {
	var e = r$1 && r$1.constructor;
	return r$1 === (typeof e == "function" && e.prototype || Ws$2);
}
var Le$4 = Xs$2, Ys$2 = ks$2, Zs$2 = xe$2, Qs$2 = Le$4;
function en$2(r$1) {
	return typeof r$1.constructor == "function" && !Qs$2(r$1) ? Ys$2(Zs$2(r$1)) : {};
}
var tn$2 = en$2;
function rn$2(r$1) {
	return r$1 != null && typeof r$1 == "object";
}
var M$3 = rn$2, sn$3 = V$4, nn$2 = M$3, an$2 = "[object Arguments]";
function on$2(r$1) {
	return nn$2(r$1) && sn$3(r$1) == an$2;
}
var Ue$4 = on$2, hn$2 = M$3, Fe$3 = Object.prototype, pn$2 = Fe$3.hasOwnProperty, un$2 = Fe$3.propertyIsEnumerable, Me$4 = Ue$4(function() {
	return arguments;
}()) ? Ue$4 : function(r$1) {
	return hn$2(r$1) && pn$2.call(r$1, "callee") && !un$2.call(r$1, "callee");
}, Ge$4 = Array.isArray, vn$2 = 9007199254740991;
function fn$2(r$1) {
	return typeof r$1 == "number" && r$1 > -1 && r$1 % 1 == 0 && r$1 <= vn$2;
}
var ze$3 = fn$2, mn$2 = te$3, gn$2 = ze$3;
function Pn$1(r$1) {
	return r$1 != null && gn$2(r$1.length) && !mn$2(r$1);
}
var ae$3 = Pn$1, bn$2 = ae$3, $n$1 = M$3;
function yn$1(r$1) {
	return $n$1(r$1) && bn$2(r$1);
}
var wn$2 = yn$1, W$2 = { exports: {} };
function _n$2() {
	return !1;
}
var Cn$2 = _n$2;
(function(r$1, e) {
	var t = C$4, i$2 = Cn$2, s = e && !e.nodeType && e, n$2 = s && r$1 && !r$1.nodeType && r$1, o$2 = n$2 && n$2.exports === s ? t.Buffer : void 0;
	r$1.exports = (o$2 ? o$2.isBuffer : void 0) || i$2;
})(W$2, W$2.exports);
var In$2 = V$4, On$2 = xe$2, An$1 = M$3, jn$2 = "[object Object]", Hn$2 = Function.prototype, En$2 = Object.prototype, ke$4 = Hn$2.toString, Sn$1 = En$2.hasOwnProperty, Nn$1 = ke$4.call(Object);
function Tn$2(r$1) {
	if (!An$1(r$1) || In$2(r$1) != jn$2) return !1;
	var e = On$2(r$1);
	if (e === null) return !0;
	var t = Sn$1.call(e, "constructor") && e.constructor;
	return typeof t == "function" && t instanceof t && ke$4.call(t) == Nn$1;
}
var Dn$2 = Tn$2, qn$2 = V$4, Rn$2 = ze$3, xn$2 = M$3, Ln$2 = "[object Arguments]", Un$2 = "[object Array]", Fn$2 = "[object Boolean]", Mn$2 = "[object Date]", Gn$2 = "[object Error]", zn$2 = "[object Function]", kn$2 = "[object Map]", Bn$2 = "[object Number]", Vn$2 = "[object Object]", Jn$2 = "[object RegExp]", Kn$2 = "[object Set]", Wn$2 = "[object String]", Xn$2 = "[object WeakMap]", Yn$2 = "[object ArrayBuffer]", Zn$2 = "[object DataView]", Qn$2 = "[object Float32Array]", ea = "[object Float64Array]", ta = "[object Int8Array]", ra = "[object Int16Array]", ia = "[object Int32Array]", sa = "[object Uint8Array]", na = "[object Uint8ClampedArray]", aa = "[object Uint16Array]", oa = "[object Uint32Array]", p$2 = {};
p$2[Qn$2] = p$2[ea] = p$2[ta] = p$2[ra] = p$2[ia] = p$2[sa] = p$2[na] = p$2[aa] = p$2[oa] = !0, p$2[Ln$2] = p$2[Un$2] = p$2[Yn$2] = p$2[Fn$2] = p$2[Zn$2] = p$2[Mn$2] = p$2[Gn$2] = p$2[zn$2] = p$2[kn$2] = p$2[Bn$2] = p$2[Vn$2] = p$2[Jn$2] = p$2[Kn$2] = p$2[Wn$2] = p$2[Xn$2] = !1;
function ca(r$1) {
	return xn$2(r$1) && Rn$2(r$1.length) && !!p$2[qn$2(r$1)];
}
var ha = ca;
function pa(r$1) {
	return function(e) {
		return r$1(e);
	};
}
var ua = pa, oe$2 = { exports: {} };
(function(r$1, e) {
	var t = we$3, i$2 = e && !e.nodeType && e, s = i$2 && r$1 && !r$1.nodeType && r$1, a$1 = s && s.exports === i$2 && t.process;
	r$1.exports = function() {
		try {
			return s && s.require && s.require("util").types || a$1 && a$1.binding && a$1.binding("util");
		} catch {}
	}();
})(oe$2, oe$2.exports);
var la = ha, da = ua, Be$4 = oe$2.exports, Ve$3 = Be$4 && Be$4.isTypedArray, Je$2 = Ve$3 ? da(Ve$3) : la;
function fa(r$1, e) {
	if (!(e === "constructor" && typeof r$1[e] == "function") && e != "__proto__") return r$1[e];
}
var Ke$4 = fa, ma = se$3, ga = z$3, ba = Object.prototype.hasOwnProperty;
function $a(r$1, e, t) {
	var i$2 = r$1[e];
	(!(ba.call(r$1, e) && ga(i$2, t)) || t === void 0 && !(e in r$1)) && ma(r$1, e, t);
}
var wa = $a, _a = se$3;
function Ca(r$1, e, t, i$2) {
	var s = !t;
	t || (t = {});
	for (var n$2 = -1, a$1 = e.length; ++n$2 < a$1;) {
		var o$2 = e[n$2], c$3 = i$2 ? i$2(t[o$2], r$1[o$2], o$2, t, r$1) : void 0;
		c$3 === void 0 && (c$3 = r$1[o$2]), s ? _a(t, o$2, c$3) : wa(t, o$2, c$3);
	}
	return t;
}
var Ia = Ca;
function Oa(r$1, e) {
	for (var t = -1, i$2 = Array(r$1); ++t < r$1;) i$2[t] = e(t);
	return i$2;
}
var Aa = Oa, ja = 9007199254740991, Ha = /^(?:0|[1-9]\d*)$/;
function Ea(r$1, e) {
	var t = typeof r$1;
	return e = e ?? ja, !!e && (t == "number" || t != "symbol" && Ha.test(r$1)) && r$1 > -1 && r$1 % 1 == 0 && r$1 < e;
}
var We$4 = Ea, Sa = Aa, Na = Me$4, Ta = Ge$4, Da = W$2.exports, qa = We$4, Ra = Je$2, La = Object.prototype.hasOwnProperty;
function Ua(r$1, e) {
	var t = Ta(r$1), i$2 = !t && Na(r$1), s = !t && !i$2 && Da(r$1), n$2 = !t && !i$2 && !s && Ra(r$1), a$1 = t || i$2 || s || n$2, o$2 = a$1 ? Sa(r$1.length, String) : [], c$3 = o$2.length;
	for (var u$2 in r$1) (e || La.call(r$1, u$2)) && !(a$1 && (u$2 == "length" || s && (u$2 == "offset" || u$2 == "parent") || n$2 && (u$2 == "buffer" || u$2 == "byteLength" || u$2 == "byteOffset") || qa(u$2, c$3))) && o$2.push(u$2);
	return o$2;
}
var Fa = Ua;
function Ma(r$1) {
	var e = [];
	if (r$1 != null) for (var t in Object(r$1)) e.push(t);
	return e;
}
var Ga = Ma, za = $$3, ka = Le$4, Ba = Ga, Ja = Object.prototype.hasOwnProperty;
function Ka(r$1) {
	if (!za(r$1)) return Ba(r$1);
	var e = ka(r$1), t = [];
	for (var i$2 in r$1) i$2 == "constructor" && (e || !Ja.call(r$1, i$2)) || t.push(i$2);
	return t;
}
var Wa = Ka, Xa = Fa, Ya = Wa, Za = ae$3;
function Qa(r$1) {
	return Za(r$1) ? Xa(r$1, !0) : Ya(r$1);
}
var Xe$3 = Qa, eo$1 = Ia, to$1 = Xe$3;
function ro$2(r$1) {
	return eo$1(r$1, to$1(r$1));
}
var io$1 = ro$2, Ye$4 = De$3, so$1 = ne$2.exports, no$1 = Us$1, ao$2 = Ms$1, oo$2 = tn$2, Ze$3 = Me$4, Qe$3 = Ge$4, co$1 = wn$2, ho$2 = W$2.exports, po$2 = te$3, uo$2 = $$3, lo$2 = Dn$2, vo$2 = Je$2, et$2 = Ke$4, fo$2 = io$1;
function mo$2(r$1, e, t, i$2, s, n$2, a$1) {
	var o$2 = et$2(r$1, t), c$3 = et$2(e, t), u$2 = a$1.get(c$3);
	if (u$2) {
		Ye$4(r$1, t, u$2);
		return;
	}
	var l$2 = n$2 ? n$2(o$2, c$3, t + "", r$1, e, a$1) : void 0, P$5 = l$2 === void 0;
	if (P$5) {
		var d$4 = Qe$3(c$3), Q$4 = !d$4 && ho$2(c$3), ve$4 = !d$4 && !Q$4 && vo$2(c$3);
		l$2 = c$3, d$4 || Q$4 || ve$4 ? Qe$3(o$2) ? l$2 = o$2 : co$1(o$2) ? l$2 = ao$2(o$2) : Q$4 ? (P$5 = !1, l$2 = so$1(c$3, !0)) : ve$4 ? (P$5 = !1, l$2 = no$1(c$3, !0)) : l$2 = [] : lo$2(c$3) || Ze$3(c$3) ? (l$2 = o$2, Ze$3(o$2) ? l$2 = fo$2(o$2) : (!uo$2(o$2) || po$2(o$2)) && (l$2 = oo$2(c$3))) : P$5 = !1;
	}
	P$5 && (a$1.set(c$3, l$2), s(l$2, c$3, i$2, n$2, a$1), a$1.delete(c$3)), Ye$4(r$1, t, l$2);
}
var go$2 = mo$2, Po$2 = $s$1, bo$2 = De$3, $o$2 = Ss$2, yo$2 = go$2, wo$2 = $$3, _o$2 = Xe$3, Co$2 = Ke$4;
function tt$3(r$1, e, t, i$2, s) {
	r$1 !== e && $o$2(e, function(n$2, a$1) {
		if (s || (s = new Po$2()), wo$2(n$2)) yo$2(r$1, e, a$1, t, tt$3, i$2, s);
		else {
			var o$2 = i$2 ? i$2(Co$2(r$1, a$1), n$2, a$1 + "", r$1, e, s) : void 0;
			o$2 === void 0 && (o$2 = n$2), bo$2(r$1, a$1, o$2);
		}
	}, _o$2);
}
var Io$2 = tt$3;
function Oo$2(r$1) {
	return r$1;
}
var rt$2 = Oo$2;
function Ao$2(r$1, e, t) {
	switch (t.length) {
		case 0: return r$1.call(e);
		case 1: return r$1.call(e, t[0]);
		case 2: return r$1.call(e, t[0], t[1]);
		case 3: return r$1.call(e, t[0], t[1], t[2]);
	}
	return r$1.apply(e, t);
}
var Ho$2 = Ao$2, it$3 = Math.max;
function Eo$2(r$1, e, t) {
	return e = it$3(e === void 0 ? r$1.length - 1 : e, 0), function() {
		for (var i$2 = arguments, s = -1, n$2 = it$3(i$2.length - e, 0), a$1 = Array(n$2); ++s < n$2;) a$1[s] = i$2[e + s];
		s = -1;
		for (var o$2 = Array(e + 1); ++s < e;) o$2[s] = i$2[s];
		return o$2[e] = t(a$1), Ho$2(r$1, this, o$2);
	};
}
var So$2 = Eo$2;
function No$2(r$1) {
	return function() {
		return r$1;
	};
}
var Do$2 = No$2, st$2 = Ne$2, xo$2 = st$2 ? function(r$1, e) {
	return st$2(r$1, "toString", {
		configurable: !0,
		enumerable: !1,
		value: Do$2(e),
		writable: !0
	});
} : rt$2, Lo$2 = 800, Uo$2 = 16, Fo$2 = Date.now;
function Mo$2(r$1) {
	var e = 0, t = 0;
	return function() {
		var i$2 = Fo$2(), s = Uo$2 - (i$2 - t);
		if (t = i$2, s > 0) {
			if (++e >= Lo$2) return arguments[0];
		} else e = 0;
		return r$1.apply(void 0, arguments);
	};
}
var Vo$2 = Mo$2(xo$2), Jo$2 = rt$2, Ko$2 = So$2, Wo$2 = Vo$2;
function Xo$1(r$1, e) {
	return Wo$2(Ko$2(r$1, e, Jo$2), r$1 + "");
}
var Yo$2 = Xo$1, Zo$1 = z$3, Qo = ae$3, ec$1 = We$4, tc = $$3;
function rc(r$1, e, t) {
	if (!tc(t)) return !1;
	var i$2 = typeof e;
	return (i$2 == "number" ? Qo(t) && ec$1(e, t.length) : i$2 == "string" && e in t) ? Zo$1(t[e], r$1) : !1;
}
var ic = rc, sc = Yo$2, nc = ic;
function ac(r$1) {
	return sc(function(e, t) {
		var i$2 = -1, s = t.length, n$2 = s > 1 ? t[s - 1] : void 0, a$1 = s > 2 ? t[2] : void 0;
		for (n$2 = r$1.length > 3 && typeof n$2 == "function" ? (s--, n$2) : void 0, a$1 && nc(t[0], t[1], a$1) && (n$2 = s < 3 ? void 0 : n$2, s = 1), e = Object(e); ++i$2 < s;) {
			var o$2 = t[i$2];
			o$2 && r$1(e, o$2, i$2, n$2);
		}
		return e;
	});
}
var oc = ac, cc = Io$2, uc = oc(function(r$1, e, t) {
	cc(r$1, e, t);
}), lc = Object.defineProperty, dc = Object.defineProperties, vc = Object.getOwnPropertyDescriptors, nt$1 = Object.getOwnPropertySymbols, fc = Object.prototype.hasOwnProperty, mc = Object.prototype.propertyIsEnumerable, at$2 = (r$1, e, t) => e in r$1 ? lc(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, X = (r$1, e) => {
	for (var t in e || (e = {})) fc.call(e, t) && at$2(r$1, t, e[t]);
	if (nt$1) for (var t of nt$1(e)) mc.call(e, t) && at$2(r$1, t, e[t]);
	return r$1;
}, gc = (r$1, e) => dc(r$1, vc(e));
function v$2(r$1, e, t) {
	var i$2;
	const s = Ye$3(r$1);
	return ((i$2 = e.rpcMap) == null ? void 0 : i$2[s.reference]) || `${ye$2}?chainId=${s.namespace}:${s.reference}&projectId=${t}`;
}
function y$4(r$1) {
	return r$1.includes(":") ? r$1.split(":")[1] : r$1;
}
function ot$2(r$1) {
	return r$1.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function Pc(r$1, e) {
	const t = Object.keys(e.namespaces).filter((s) => s.includes(r$1));
	if (!t.length) return [];
	const i$2 = [];
	return t.forEach((s) => {
		const n$2 = e.namespaces[s].accounts;
		i$2.push(...n$2);
	}), i$2;
}
function ce$3(r$1 = {}, e = {}) {
	return uc(ct$2(r$1), ct$2(e));
}
function ct$2(r$1) {
	var e, t, i$2, s;
	const n$2 = {};
	if (!qe$3(r$1)) return n$2;
	for (const [a$1, o$2] of Object.entries(r$1)) {
		const c$3 = Tt$3(a$1) ? [a$1] : o$2.chains, u$2 = o$2.methods || [], l$2 = o$2.events || [], P$5 = o$2.rpcMap || {}, d$4 = pr$2(a$1);
		n$2[d$4] = gc(X(X({}, n$2[d$4]), o$2), {
			chains: Q$2(c$3, (e = n$2[d$4]) == null ? void 0 : e.chains),
			methods: Q$2(u$2, (t = n$2[d$4]) == null ? void 0 : t.methods),
			events: Q$2(l$2, (i$2 = n$2[d$4]) == null ? void 0 : i$2.events),
			rpcMap: X(X({}, P$5), (s = n$2[d$4]) == null ? void 0 : s.rpcMap)
		});
	}
	return n$2;
}
function bc(r$1) {
	return r$1.includes(":") ? r$1.split(":")[2] : r$1;
}
function ht$3(r$1) {
	const e = {};
	for (const [t, i$2] of Object.entries(r$1)) {
		const s = i$2.methods || [], n$2 = i$2.events || [], a$1 = i$2.accounts || [];
		e[t] = {
			chains: Tt$3(t) ? [t] : i$2.chains ? i$2.chains : ot$2(i$2.accounts),
			methods: s,
			events: n$2,
			accounts: a$1
		};
	}
	return e;
}
function he$2(r$1) {
	return typeof r$1 == "number" ? r$1 : r$1.includes("0x") ? parseInt(r$1, 16) : (r$1 = r$1.includes(":") ? r$1.split(":")[1] : r$1, isNaN(Number(r$1)) ? r$1 : Number(r$1));
}
var pt$3 = {}, h$2 = (r$1) => pt$3[r$1], pe$2 = (r$1, e) => {
	pt$3[r$1] = e;
};
var $c = Object.defineProperty, yc = (r$1, e, t) => e in r$1 ? $c(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, j = (r$1, e, t) => yc(r$1, typeof e != "symbol" ? e + "" : e, t);
var wc = class {
	constructor(e) {
		j(this, "name", "polkadot"), j(this, "client"), j(this, "httpProviders"), j(this, "events"), j(this, "namespace"), j(this, "chainId"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(e) {
		this.namespace = Object.assign(this.namespace, e);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	request(e) {
		return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
	}
	setDefaultChain(e, t) {
		this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
	}
	createHttpProviders() {
		const e = {};
		return this.namespace.chains.forEach((t) => {
			var i$2;
			const s = y$4(t);
			e[s] = this.createHttpProvider(s, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[t]);
		}), e;
	}
	getHttpProvider() {
		const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProvider(e, t) {
		const i$2 = t || v$2(e, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
		return new o(new f(i$2, h$2("disableProviderPing")));
	}
};
var _c = Object.defineProperty, Cc = Object.defineProperties, Ic = Object.getOwnPropertyDescriptors, ut$3 = Object.getOwnPropertySymbols, Oc = Object.prototype.hasOwnProperty, Ac = Object.prototype.propertyIsEnumerable, ue$3 = (r$1, e, t) => e in r$1 ? _c(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, lt$2 = (r$1, e) => {
	for (var t in e || (e = {})) Oc.call(e, t) && ue$3(r$1, t, e[t]);
	if (ut$3) for (var t of ut$3(e)) Ac.call(e, t) && ue$3(r$1, t, e[t]);
	return r$1;
}, dt$3 = (r$1, e) => Cc(r$1, Ic(e)), H$2 = (r$1, e, t) => ue$3(r$1, typeof e != "symbol" ? e + "" : e, t);
var jc = class {
	constructor(e) {
		H$2(this, "name", "eip155"), H$2(this, "client"), H$2(this, "chainId"), H$2(this, "namespace"), H$2(this, "httpProviders"), H$2(this, "events"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
	}
	async request(e) {
		switch (e.request.method) {
			case "eth_requestAccounts": return this.getAccounts();
			case "eth_accounts": return this.getAccounts();
			case "wallet_switchEthereumChain": return await this.handleSwitchChain(e);
			case "eth_chainId": return parseInt(this.getDefaultChain());
			case "wallet_getCapabilities": return await this.getCapabilities(e);
			case "wallet_getCallsStatus": return await this.getCallStatus(e);
		}
		return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);
	}
	updateNamespace(e) {
		this.namespace = Object.assign(this.namespace, e);
	}
	setDefaultChain(e, t) {
		this.httpProviders[e] || this.setHttpProvider(parseInt(e), t), this.chainId = parseInt(e), this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId.toString();
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	createHttpProvider(e, t) {
		const i$2 = t || v$2(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
		return new o(new f(i$2, h$2("disableProviderPing")));
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProviders() {
		const e = {};
		return this.namespace.chains.forEach((t) => {
			var i$2;
			const s = parseInt(y$4(t));
			e[s] = this.createHttpProvider(s, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[t]);
		}), e;
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
	}
	getHttpProvider() {
		const e = this.chainId, t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	async handleSwitchChain(e) {
		var t, i$2;
		let s = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : "0x0";
		s = s.startsWith("0x") ? s : `0x${s}`;
		const n$2 = parseInt(s, 16);
		if (this.isChainApproved(n$2)) this.setDefaultChain(`${n$2}`);
		else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({
			topic: e.topic,
			request: {
				method: e.request.method,
				params: [{ chainId: s }]
			},
			chainId: (i$2 = this.namespace.chains) == null ? void 0 : i$2[0]
		}), this.setDefaultChain(`${n$2}`);
		else throw new Error(`Failed to switch to chain 'eip155:${n$2}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
		return null;
	}
	isChainApproved(e) {
		return this.namespace.chains.includes(`${this.name}:${e}`);
	}
	async getCapabilities(e) {
		var t, i$2, s;
		const n$2 = (i$2 = (t = e.request) == null ? void 0 : t.params) == null ? void 0 : i$2[0];
		if (!n$2) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
		const a$1 = this.client.session.get(e.topic), o$2 = ((s = a$1?.sessionProperties) == null ? void 0 : s.capabilities) || {};
		if (o$2 != null && o$2[n$2]) return o$2?.[n$2];
		const c$3 = await this.client.request(e);
		try {
			await this.client.session.update(e.topic, { sessionProperties: dt$3(lt$2({}, a$1.sessionProperties || {}), { capabilities: dt$3(lt$2({}, o$2 || {}), { [n$2]: c$3 }) }) });
		} catch (u$2) {
			console.warn("Failed to update session with capabilities", u$2);
		}
		return c$3;
	}
	async getCallStatus(e) {
		var t, i$2;
		const s = this.client.session.get(e.topic), n$2 = (t = s.sessionProperties) == null ? void 0 : t.bundler_name;
		if (n$2) {
			const o$2 = this.getBundlerUrl(e.chainId, n$2);
			try {
				return await this.getUserOperationReceipt(o$2, e);
			} catch (c$3) {
				console.warn("Failed to fetch call status from bundler", c$3, o$2);
			}
		}
		const a$1 = (i$2 = s.sessionProperties) == null ? void 0 : i$2.bundler_url;
		if (a$1) try {
			return await this.getUserOperationReceipt(a$1, e);
		} catch (o$2) {
			console.warn("Failed to fetch call status from custom bundler", o$2, a$1);
		}
		if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);
		throw new Error("Fetching call status not approved by the wallet.");
	}
	async getUserOperationReceipt(e, t) {
		var i$2;
		const s = new URL(e), n$2 = await fetch(s, {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i$2 = t.request.params) == null ? void 0 : i$2[0]]))
		});
		if (!n$2.ok) throw new Error(`Failed to fetch user operation receipt - ${n$2.status}`);
		return await n$2.json();
	}
	getBundlerUrl(e, t) {
		return `${Ot$2}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;
	}
};
var Hc = Object.defineProperty, Ec = (r$1, e, t) => e in r$1 ? Hc(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, E$4 = (r$1, e, t) => Ec(r$1, typeof e != "symbol" ? e + "" : e, t);
var Sc = class {
	constructor(e) {
		E$4(this, "name", "solana"), E$4(this, "client"), E$4(this, "httpProviders"), E$4(this, "events"), E$4(this, "namespace"), E$4(this, "chainId"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(e) {
		this.namespace = Object.assign(this.namespace, e);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	request(e) {
		return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
	}
	setDefaultChain(e, t) {
		this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const e = {};
		return this.namespace.chains.forEach((t) => {
			var i$2;
			const s = y$4(t);
			e[s] = this.createHttpProvider(s, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[t]);
		}), e;
	}
	getHttpProvider() {
		const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProvider(e, t) {
		const i$2 = t || v$2(e, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
		return new o(new f(i$2, h$2("disableProviderPing")));
	}
};
var Nc = Object.defineProperty, Tc = (r$1, e, t) => e in r$1 ? Nc(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, S$3 = (r$1, e, t) => Tc(r$1, typeof e != "symbol" ? e + "" : e, t);
var Dc = class {
	constructor(e) {
		S$3(this, "name", "cosmos"), S$3(this, "client"), S$3(this, "httpProviders"), S$3(this, "events"), S$3(this, "namespace"), S$3(this, "chainId"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(e) {
		this.namespace = Object.assign(this.namespace, e);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	request(e) {
		return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
	}
	setDefaultChain(e, t) {
		this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const e = {};
		return this.namespace.chains.forEach((t) => {
			var i$2;
			const s = y$4(t);
			e[s] = this.createHttpProvider(s, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[t]);
		}), e;
	}
	getHttpProvider() {
		const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProvider(e, t) {
		const i$2 = t || v$2(e, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
		return new o(new f(i$2, h$2("disableProviderPing")));
	}
};
var qc = Object.defineProperty, Rc = (r$1, e, t) => e in r$1 ? qc(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, N$2 = (r$1, e, t) => Rc(r$1, typeof e != "symbol" ? e + "" : e, t);
var xc = class {
	constructor(e) {
		N$2(this, "name", "algorand"), N$2(this, "client"), N$2(this, "httpProviders"), N$2(this, "events"), N$2(this, "namespace"), N$2(this, "chainId"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(e) {
		this.namespace = Object.assign(this.namespace, e);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	request(e) {
		return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
	}
	setDefaultChain(e, t) {
		if (!this.httpProviders[e]) {
			const i$2 = t || v$2(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
			if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
			this.setHttpProvider(e, i$2);
		}
		this.chainId = e, this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const e = {};
		return this.namespace.chains.forEach((t) => {
			var i$2;
			e[t] = this.createHttpProvider(t, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[t]);
		}), e;
	}
	getHttpProvider() {
		const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProvider(e, t) {
		const i$2 = t || v$2(e, this.namespace, this.client.core.projectId);
		return typeof i$2 > "u" ? void 0 : new o(new f(i$2, h$2("disableProviderPing")));
	}
};
var Lc = Object.defineProperty, Uc = (r$1, e, t) => e in r$1 ? Lc(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, T = (r$1, e, t) => Uc(r$1, typeof e != "symbol" ? e + "" : e, t);
var Fc = class {
	constructor(e) {
		T(this, "name", "cip34"), T(this, "client"), T(this, "httpProviders"), T(this, "events"), T(this, "namespace"), T(this, "chainId"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(e) {
		this.namespace = Object.assign(this.namespace, e);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	request(e) {
		return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
	}
	setDefaultChain(e, t) {
		this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const e = {};
		return this.namespace.chains.forEach((t) => {
			const i$2 = this.getCardanoRPCUrl(t), s = y$4(t);
			e[s] = this.createHttpProvider(s, i$2);
		}), e;
	}
	getHttpProvider() {
		const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	getCardanoRPCUrl(e) {
		const t = this.namespace.rpcMap;
		if (t) return t[e];
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProvider(e, t) {
		const i$2 = t || this.getCardanoRPCUrl(e);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
		return new o(new f(i$2, h$2("disableProviderPing")));
	}
};
var Mc = Object.defineProperty, Gc = (r$1, e, t) => e in r$1 ? Mc(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, D$1 = (r$1, e, t) => Gc(r$1, typeof e != "symbol" ? e + "" : e, t);
var zc = class {
	constructor(e) {
		D$1(this, "name", "elrond"), D$1(this, "client"), D$1(this, "httpProviders"), D$1(this, "events"), D$1(this, "namespace"), D$1(this, "chainId"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(e) {
		this.namespace = Object.assign(this.namespace, e);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	request(e) {
		return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
	}
	setDefaultChain(e, t) {
		this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const e = {};
		return this.namespace.chains.forEach((t) => {
			var i$2;
			const s = y$4(t);
			e[s] = this.createHttpProvider(s, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[t]);
		}), e;
	}
	getHttpProvider() {
		const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProvider(e, t) {
		const i$2 = t || v$2(e, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
		return new o(new f(i$2, h$2("disableProviderPing")));
	}
};
var kc = Object.defineProperty, Bc = (r$1, e, t) => e in r$1 ? kc(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, q$1 = (r$1, e, t) => Bc(r$1, typeof e != "symbol" ? e + "" : e, t);
var Vc = class {
	constructor(e) {
		q$1(this, "name", "multiversx"), q$1(this, "client"), q$1(this, "httpProviders"), q$1(this, "events"), q$1(this, "namespace"), q$1(this, "chainId"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(e) {
		this.namespace = Object.assign(this.namespace, e);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	request(e) {
		return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
	}
	setDefaultChain(e, t) {
		this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const e = {};
		return this.namespace.chains.forEach((t) => {
			var i$2;
			const s = y$4(t);
			e[s] = this.createHttpProvider(s, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[t]);
		}), e;
	}
	getHttpProvider() {
		const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProvider(e, t) {
		const i$2 = t || v$2(e, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
		return new o(new f(i$2, h$2("disableProviderPing")));
	}
};
var Jc = Object.defineProperty, Kc = (r$1, e, t) => e in r$1 ? Jc(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, R$2 = (r$1, e, t) => Kc(r$1, typeof e != "symbol" ? e + "" : e, t);
var Wc = class {
	constructor(e) {
		R$2(this, "name", "near"), R$2(this, "client"), R$2(this, "httpProviders"), R$2(this, "events"), R$2(this, "namespace"), R$2(this, "chainId"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(e) {
		this.namespace = Object.assign(this.namespace, e);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	request(e) {
		return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
	}
	setDefaultChain(e, t) {
		if (this.chainId = e, !this.httpProviders[e]) {
			const i$2 = t || v$2(`${this.name}:${e}`, this.namespace);
			if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
			this.setHttpProvider(e, i$2);
		}
		this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
	}
	createHttpProviders() {
		const e = {};
		return this.namespace.chains.forEach((t) => {
			var i$2;
			e[t] = this.createHttpProvider(t, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[t]);
		}), e;
	}
	getHttpProvider() {
		const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProvider(e, t) {
		const i$2 = t || v$2(e, this.namespace);
		return typeof i$2 > "u" ? void 0 : new o(new f(i$2, h$2("disableProviderPing")));
	}
};
var Xc = Object.defineProperty, Yc = (r$1, e, t) => e in r$1 ? Xc(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, x$2 = (r$1, e, t) => Yc(r$1, typeof e != "symbol" ? e + "" : e, t);
var Zc = class {
	constructor(e) {
		x$2(this, "name", "tezos"), x$2(this, "client"), x$2(this, "httpProviders"), x$2(this, "events"), x$2(this, "namespace"), x$2(this, "chainId"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(e) {
		this.namespace = Object.assign(this.namespace, e);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	request(e) {
		return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
	}
	setDefaultChain(e, t) {
		if (this.chainId = e, !this.httpProviders[e]) {
			const i$2 = t || v$2(`${this.name}:${e}`, this.namespace);
			if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
			this.setHttpProvider(e, i$2);
		}
		this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
	}
	createHttpProviders() {
		const e = {};
		return this.namespace.chains.forEach((t) => {
			e[t] = this.createHttpProvider(t);
		}), e;
	}
	getHttpProvider() {
		const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProvider(e, t) {
		const i$2 = t || v$2(e, this.namespace);
		return typeof i$2 > "u" ? void 0 : new o(new f(i$2));
	}
};
var Qc = Object.defineProperty, eh = (r$1, e, t) => e in r$1 ? Qc(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, L$2 = (r$1, e, t) => eh(r$1, typeof e != "symbol" ? e + "" : e, t);
var th = class {
	constructor(e) {
		L$2(this, "name", w$2), L$2(this, "client"), L$2(this, "httpProviders"), L$2(this, "events"), L$2(this, "namespace"), L$2(this, "chainId"), this.namespace = e.namespace, this.events = h$2("events"), this.client = h$2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(e) {
		this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();
	}
	requestAccounts() {
		return this.getAccounts();
	}
	request(e) {
		return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);
	}
	setDefaultChain(e, t) {
		this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f$4.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const e = this.namespace.chains[0];
		if (!e) throw new Error("ChainId not found");
		return e.split(":")[1];
	}
	getAccounts() {
		const e = this.namespace.accounts;
		return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
	}
	createHttpProviders() {
		var e, t;
		const i$2 = {};
		return (t = (e = this.namespace) == null ? void 0 : e.accounts) == null || t.forEach((s) => {
			const n$2 = Ye$3(s);
			i$2[`${n$2.namespace}:${n$2.reference}`] = this.createHttpProvider(s);
		}), i$2;
	}
	getHttpProvider(e) {
		const t = this.httpProviders[e];
		if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
		return t;
	}
	setHttpProvider(e, t) {
		const i$2 = this.createHttpProvider(e, t);
		i$2 && (this.httpProviders[e] = i$2);
	}
	createHttpProvider(e, t) {
		const i$2 = t || v$2(e, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${e}`);
		return new o(new f(i$2, h$2("disableProviderPing")));
	}
};
var rh = Object.defineProperty, ih = Object.defineProperties, sh = Object.getOwnPropertyDescriptors, vt$2 = Object.getOwnPropertySymbols, nh = Object.prototype.hasOwnProperty, ah = Object.prototype.propertyIsEnumerable, le$3 = (r$1, e, t) => e in r$1 ? rh(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, Y$2 = (r$1, e) => {
	for (var t in e || (e = {})) nh.call(e, t) && le$3(r$1, t, e[t]);
	if (vt$2) for (var t of vt$2(e)) ah.call(e, t) && le$3(r$1, t, e[t]);
	return r$1;
}, de$4 = (r$1, e) => ih(r$1, sh(e)), g$1 = (r$1, e, t) => le$3(r$1, typeof e != "symbol" ? e + "" : e, t);
var Z$1 = class Z$1 {
	constructor(e) {
		g$1(this, "client"), g$1(this, "namespaces"), g$1(this, "optionalNamespaces"), g$1(this, "sessionProperties"), g$1(this, "events", new import_events$3.default()), g$1(this, "rpcProviders", {}), g$1(this, "session"), g$1(this, "providerOpts"), g$1(this, "logger"), g$1(this, "uri"), g$1(this, "disableProviderPing", !1), this.providerOpts = e, this.logger = typeof e?.logger < "u" && typeof e?.logger != "string" ? e.logger : (0, import_browser.default)(k({ level: e?.logger || be$3 })), this.disableProviderPing = e?.disableProviderPing || !1;
	}
	static async init(e) {
		const t = new Z$1(e);
		return await t.initialize(), t;
	}
	async request(e, t, i$2) {
		const [s, n$2] = this.validateChain(t);
		if (!this.session) throw new Error("Please call connect() before request()");
		return await this.getProvider(s).request({
			request: Y$2({}, e),
			chainId: `${s}:${n$2}`,
			topic: this.session.topic,
			expiry: i$2
		});
	}
	sendAsync(e, t, i$2, s) {
		const n$2 = (/* @__PURE__ */ new Date()).getTime();
		this.request(e, i$2, s).then((a$1) => t(null, formatJsonRpcResult(n$2, a$1))).catch((a$1) => t(a$1, void 0));
	}
	async enable() {
		if (!this.client) throw new Error("Sign Client not initialized");
		return this.session || await this.connect({
			namespaces: this.namespaces,
			optionalNamespaces: this.optionalNamespaces,
			sessionProperties: this.sessionProperties
		}), await this.requestAccounts();
	}
	async disconnect() {
		var e;
		if (!this.session) throw new Error("Please call connect() before enable()");
		await this.client.disconnect({
			topic: (e = this.session) == null ? void 0 : e.topic,
			reason: de$3("USER_DISCONNECTED")
		}), await this.cleanup();
	}
	async connect(e) {
		if (!this.client) throw new Error("Sign Client not initialized");
		if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);
	}
	async authenticate(e, t) {
		if (!this.client) throw new Error("Sign Client not initialized");
		this.setNamespaces(e), await this.cleanupPendingPairings();
		const { uri: i$2, response: s } = await this.client.authenticate(e, t);
		i$2 && (this.uri = i$2, this.events.emit("display_uri", i$2));
		const n$2 = await s();
		if (this.session = n$2.session, this.session) {
			const a$1 = ht$3(this.session.namespaces);
			this.namespaces = ce$3(this.namespaces, a$1), this.persist("namespaces", this.namespaces), this.onConnect();
		}
		return n$2;
	}
	on(e, t) {
		this.events.on(e, t);
	}
	once(e, t) {
		this.events.once(e, t);
	}
	removeListener(e, t) {
		this.events.removeListener(e, t);
	}
	off(e, t) {
		this.events.off(e, t);
	}
	get isWalletConnect() {
		return !0;
	}
	async pair(e) {
		const { uri: t, approval: i$2 } = await this.client.connect({
			pairingTopic: e,
			requiredNamespaces: this.namespaces,
			optionalNamespaces: this.optionalNamespaces,
			sessionProperties: this.sessionProperties
		});
		t && (this.uri = t, this.events.emit("display_uri", t));
		const s = await i$2();
		this.session = s;
		const n$2 = ht$3(s.namespaces);
		return this.namespaces = ce$3(this.namespaces, n$2), this.persist("namespaces", this.namespaces), this.onConnect(), this.session;
	}
	setDefaultChain(e, t) {
		try {
			if (!this.session) return;
			const [i$2, s] = this.validateChain(e), n$2 = this.getProvider(i$2);
			n$2.name === w$2 ? n$2.setDefaultChain(`${i$2}:${s}`, t) : n$2.setDefaultChain(s, t);
		} catch (i$2) {
			if (!/Please call connect/.test(i$2.message)) throw i$2;
		}
	}
	async cleanupPendingPairings(e = {}) {
		this.logger.info("Cleaning up inactive pairings...");
		const t = this.client.pairing.getAll();
		if ($e$3(t)) {
			for (const i$2 of t) e.deletePairings ? this.client.core.expirer.set(i$2.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i$2.topic);
			this.logger.info(`Inactive pairings cleared: ${t.length}`);
		}
	}
	abortPairingAttempt() {
		this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
	}
	async checkStorage() {
		if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
			const e = this.client.session.keys.length - 1;
			this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders();
		}
	}
	async initialize() {
		this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
	}
	async createClient() {
		this.client = this.providerOpts.client || await Se$3.init({
			core: this.providerOpts.core,
			logger: this.providerOpts.logger || be$3,
			relayUrl: this.providerOpts.relayUrl || _t$3,
			projectId: this.providerOpts.projectId,
			metadata: this.providerOpts.metadata,
			storageOptions: this.providerOpts.storageOptions,
			storage: this.providerOpts.storage,
			name: this.providerOpts.name,
			customStoragePrefix: this.providerOpts.customStoragePrefix,
			telemetryEnabled: this.providerOpts.telemetryEnabled
		}), this.logger.trace("SignClient Initialized");
	}
	createProviders() {
		if (!this.client) throw new Error("Sign Client not initialized");
		if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
		const e = [...new Set(Object.keys(this.session.namespaces).map((t) => pr$2(t)))];
		pe$2("client", this.client), pe$2("events", this.events), pe$2("disableProviderPing", this.disableProviderPing), e.forEach((t) => {
			if (!this.session) return;
			const i$2 = Pc(t, this.session), s = ot$2(i$2), a$1 = de$4(Y$2({}, ce$3(this.namespaces, this.optionalNamespaces)[t]), {
				accounts: i$2,
				chains: s
			});
			switch (t) {
				case "eip155":
					this.rpcProviders[t] = new jc({ namespace: a$1 });
					break;
				case "algorand":
					this.rpcProviders[t] = new xc({ namespace: a$1 });
					break;
				case "solana":
					this.rpcProviders[t] = new Sc({ namespace: a$1 });
					break;
				case "cosmos":
					this.rpcProviders[t] = new Dc({ namespace: a$1 });
					break;
				case "polkadot":
					this.rpcProviders[t] = new wc({ namespace: a$1 });
					break;
				case "cip34":
					this.rpcProviders[t] = new Fc({ namespace: a$1 });
					break;
				case "elrond":
					this.rpcProviders[t] = new zc({ namespace: a$1 });
					break;
				case "multiversx":
					this.rpcProviders[t] = new Vc({ namespace: a$1 });
					break;
				case "near":
					this.rpcProviders[t] = new Wc({ namespace: a$1 });
					break;
				case "tezos":
					this.rpcProviders[t] = new Zc({ namespace: a$1 });
					break;
				default: this.rpcProviders[w$2] ? this.rpcProviders[w$2].updateNamespace(a$1) : this.rpcProviders[w$2] = new th({ namespace: a$1 });
			}
		});
	}
	registerEventListeners() {
		if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
		this.client.on("session_ping", (e) => {
			this.events.emit("session_ping", e);
		}), this.client.on("session_event", (e) => {
			const { params: t } = e, { event: i$2 } = t;
			if (i$2.name === "accountsChanged") {
				const s = i$2.data;
				s && $e$3(s) && this.events.emit("accountsChanged", s.map(bc));
			} else if (i$2.name === "chainChanged") {
				const s = t.chainId, n$2 = t.event.data, a$1 = pr$2(s), o$2 = he$2(s) !== he$2(n$2) ? `${a$1}:${he$2(n$2)}` : s;
				this.onChainChanged(o$2);
			} else this.events.emit(i$2.name, i$2.data);
			this.events.emit("session_event", e);
		}), this.client.on("session_update", ({ topic: e, params: t }) => {
			var i$2;
			const { namespaces: s } = t;
			this.session = de$4(Y$2({}, (i$2 = this.client) == null ? void 0 : i$2.session.get(e)), { namespaces: s }), this.onSessionUpdate(), this.events.emit("session_update", {
				topic: e,
				params: t
			});
		}), this.client.on("session_delete", async (e) => {
			await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", de$4(Y$2({}, de$3("USER_DISCONNECTED")), { data: e.topic }));
		}), this.on(f$4.DEFAULT_CHAIN_CHANGED, (e) => {
			this.onChainChanged(e, !0);
		});
	}
	getProvider(e) {
		return this.rpcProviders[e] || this.rpcProviders[w$2];
	}
	onSessionUpdate() {
		Object.keys(this.rpcProviders).forEach((e) => {
			var t;
			this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e]);
		});
	}
	setNamespaces(e) {
		const { namespaces: t, optionalNamespaces: i$2, sessionProperties: s } = e;
		t && Object.keys(t).length && (this.namespaces = t), i$2 && Object.keys(i$2).length && (this.optionalNamespaces = i$2), this.sessionProperties = s, this.persist("namespaces", t), this.persist("optionalNamespaces", i$2);
	}
	validateChain(e) {
		const [t, i$2] = e?.split(":") || ["", ""];
		if (!this.namespaces || !Object.keys(this.namespaces).length) return [t, i$2];
		if (t && !Object.keys(this.namespaces || {}).map((a$1) => pr$2(a$1)).includes(t)) throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);
		if (t && i$2) return [t, i$2];
		const s = pr$2(Object.keys(this.namespaces)[0]);
		return [s, this.rpcProviders[s].getDefaultChain()];
	}
	async requestAccounts() {
		const [e] = this.validateChain();
		return await this.getProvider(e).requestAccounts();
	}
	onChainChanged(e, t = !1) {
		if (!this.namespaces) return;
		const [i$2, s] = this.validateChain(e);
		s && (t || this.getProvider(i$2).setDefaultChain(s), this.namespaces[i$2] ? this.namespaces[i$2].defaultChain = s : this.namespaces[`${i$2}:${s}`] ? this.namespaces[`${i$2}:${s}`].defaultChain = s : this.namespaces[`${i$2}:${s}`] = { defaultChain: s }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", s));
	}
	onConnect() {
		this.createProviders(), this.events.emit("connect", { session: this.session });
	}
	async cleanup() {
		this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: !0 });
	}
	persist(e, t) {
		this.client.core.storage.setItem(`${$e$4}/${e}`, t);
	}
	async getFromStore(e) {
		return await this.client.core.storage.getItem(`${$e$4}/${e}`);
	}
};
var oh = Z$1;

//#endregion
//#region node_modules/@reown/appkit-common/dist/esm/src/utils/ParseUtil.js
const ParseUtil = {
	validateCaipAddress(address) {
		if (address.split(":")?.length !== 3) throw new Error("Invalid CAIP Address");
		return address;
	},
	parseCaipAddress(caipAddress) {
		const parts = caipAddress.split(":");
		if (parts.length !== 3) throw new Error(`Invalid CAIP-10 address: ${caipAddress}`);
		const [chainNamespace, chainId, address] = parts;
		if (!chainNamespace || !chainId || !address) throw new Error(`Invalid CAIP-10 address: ${caipAddress}`);
		return {
			chainNamespace,
			chainId,
			address
		};
	},
	parseCaipNetworkId(caipNetworkId) {
		const parts = caipNetworkId.split(":");
		if (parts.length !== 2) throw new Error(`Invalid CAIP-2 network id: ${caipNetworkId}`);
		const [chainNamespace, chainId] = parts;
		if (!chainNamespace || !chainId) throw new Error(`Invalid CAIP-2 network id: ${caipNetworkId}`);
		return {
			chainNamespace,
			chainId
		};
	}
};

//#endregion
//#region node_modules/viem/_esm/utils/data/isHex.js
function isHex$1(value, { strict = true } = {}) {
	if (!value) return false;
	if (typeof value !== "string") return false;
	return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}

//#endregion
//#region node_modules/viem/_esm/utils/data/size.js
/**
* @description Retrieves the size of the value (in bytes).
*
* @param value The value (hex or byte array) to retrieve the size of.
* @returns The size of the value (in bytes).
*/
function size$2(value) {
	if (isHex$1(value, { strict: false })) return Math.ceil((value.length - 2) / 2);
	return value.length;
}

//#endregion
//#region node_modules/viem/_esm/errors/version.js
const version$1 = "2.43.2";

//#endregion
//#region node_modules/viem/_esm/errors/base.js
var errorConfig$1 = {
	getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
	version: `viem@${version$1}`
};
var BaseError$1 = class BaseError$1 extends Error {
	constructor(shortMessage, args = {}) {
		const details = (() => {
			if (args.cause instanceof BaseError$1) return args.cause.details;
			if (args.cause?.message) return args.cause.message;
			return args.details;
		})();
		const docsPath = (() => {
			if (args.cause instanceof BaseError$1) return args.cause.docsPath || args.docsPath;
			return args.docsPath;
		})();
		const docsUrl = errorConfig$1.getDocsUrl?.({
			...args,
			docsPath
		});
		const message = [
			shortMessage || "An error occurred.",
			"",
			...args.metaMessages ? [...args.metaMessages, ""] : [],
			...docsUrl ? [`Docs: ${docsUrl}`] : [],
			...details ? [`Details: ${details}`] : [],
			...errorConfig$1.version ? [`Version: ${errorConfig$1.version}`] : []
		].join("\n");
		super(message, args.cause ? { cause: args.cause } : void 0);
		Object.defineProperty(this, "details", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "docsPath", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "metaMessages", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "shortMessage", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "version", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "name", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: "BaseError"
		});
		this.details = details;
		this.docsPath = docsPath;
		this.metaMessages = args.metaMessages;
		this.name = args.name ?? this.name;
		this.shortMessage = shortMessage;
		this.version = version$1;
	}
	walk(fn$5) {
		return walk$1(this, fn$5);
	}
};
function walk$1(err, fn$5) {
	if (fn$5?.(err)) return err;
	if (err && typeof err === "object" && "cause" in err && err.cause !== void 0) return walk$1(err.cause, fn$5);
	return fn$5 ? null : err;
}

//#endregion
//#region node_modules/viem/_esm/errors/data.js
var SizeExceedsPaddingSizeError$1 = class extends BaseError$1 {
	constructor({ size: size$4, targetSize, type }) {
		super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size$4}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
	}
};

//#endregion
//#region node_modules/viem/_esm/utils/data/pad.js
function pad$1(hexOrBytes, { dir, size: size$4 = 32 } = {}) {
	if (typeof hexOrBytes === "string") return padHex$1(hexOrBytes, {
		dir,
		size: size$4
	});
	return padBytes$1(hexOrBytes, {
		dir,
		size: size$4
	});
}
function padHex$1(hex_, { dir, size: size$4 = 32 } = {}) {
	if (size$4 === null) return hex_;
	const hex = hex_.replace("0x", "");
	if (hex.length > size$4 * 2) throw new SizeExceedsPaddingSizeError$1({
		size: Math.ceil(hex.length / 2),
		targetSize: size$4,
		type: "hex"
	});
	return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size$4 * 2, "0")}`;
}
function padBytes$1(bytes, { dir, size: size$4 = 32 } = {}) {
	if (size$4 === null) return bytes;
	if (bytes.length > size$4) throw new SizeExceedsPaddingSizeError$1({
		size: bytes.length,
		targetSize: size$4,
		type: "bytes"
	});
	const paddedBytes = new Uint8Array(size$4);
	for (let i$2 = 0; i$2 < size$4; i$2++) {
		const padEnd = dir === "right";
		paddedBytes[padEnd ? i$2 : size$4 - i$2 - 1] = bytes[padEnd ? i$2 : bytes.length - i$2 - 1];
	}
	return paddedBytes;
}

//#endregion
//#region node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError$1 = class extends BaseError$1 {
	constructor({ max, min, signed, size: size$4, value }) {
		super(`Number "${value}" is not in safe ${size$4 ? `${size$4 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
	}
};
var SizeOverflowError$1 = class extends BaseError$1 {
	constructor({ givenSize, maxSize }) {
		super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
	}
};

//#endregion
//#region node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize$1(hexOrBytes, { size: size$4 }) {
	if (size$2(hexOrBytes) > size$4) throw new SizeOverflowError$1({
		givenSize: size$2(hexOrBytes),
		maxSize: size$4
	});
}

//#endregion
//#region node_modules/viem/_esm/utils/encoding/toHex.js
var hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i$2) => i$2.toString(16).padStart(2, "0"));
/**
* Encodes a string, number, bigint, or ByteArray into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex
* - Example: https://viem.sh/docs/utilities/toHex#usage
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { toHex } from 'viem'
* const data = toHex('Hello world')
* // '0x48656c6c6f20776f726c6421'
*
* @example
* import { toHex } from 'viem'
* const data = toHex(420)
* // '0x1a4'
*
* @example
* import { toHex } from 'viem'
* const data = toHex('Hello world', { size: 32 })
* // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'
*/
function toHex(value, opts = {}) {
	if (typeof value === "number" || typeof value === "bigint") return numberToHex$1(value, opts);
	if (typeof value === "string") return stringToHex$1(value, opts);
	if (typeof value === "boolean") return boolToHex$1(value, opts);
	return bytesToHex$1(value, opts);
}
/**
* Encodes a boolean into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#booltohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { boolToHex } from 'viem'
* const data = boolToHex(true)
* // '0x1'
*
* @example
* import { boolToHex } from 'viem'
* const data = boolToHex(false)
* // '0x0'
*
* @example
* import { boolToHex } from 'viem'
* const data = boolToHex(true, { size: 32 })
* // '0x0000000000000000000000000000000000000000000000000000000000000001'
*/
function boolToHex$1(value, opts = {}) {
	const hex = `0x${Number(value)}`;
	if (typeof opts.size === "number") {
		assertSize$1(hex, { size: opts.size });
		return pad$1(hex, { size: opts.size });
	}
	return hex;
}
/**
* Encodes a bytes array into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#bytestohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { bytesToHex } from 'viem'
* const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
* // '0x48656c6c6f20576f726c6421'
*
* @example
* import { bytesToHex } from 'viem'
* const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })
* // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
*/
function bytesToHex$1(value, opts = {}) {
	let string = "";
	for (let i$2 = 0; i$2 < value.length; i$2++) string += hexes$1[value[i$2]];
	const hex = `0x${string}`;
	if (typeof opts.size === "number") {
		assertSize$1(hex, { size: opts.size });
		return pad$1(hex, {
			dir: "right",
			size: opts.size
		});
	}
	return hex;
}
/**
* Encodes a number or bigint into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#numbertohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { numberToHex } from 'viem'
* const data = numberToHex(420)
* // '0x1a4'
*
* @example
* import { numberToHex } from 'viem'
* const data = numberToHex(420, { size: 32 })
* // '0x00000000000000000000000000000000000000000000000000000000000001a4'
*/
function numberToHex$1(value_, opts = {}) {
	const { signed, size: size$4 } = opts;
	const value = BigInt(value_);
	let maxValue;
	if (size$4) if (signed) maxValue = (1n << BigInt(size$4) * 8n - 1n) - 1n;
	else maxValue = 2n ** (BigInt(size$4) * 8n) - 1n;
	else if (typeof value_ === "number") maxValue = BigInt(Number.MAX_SAFE_INTEGER);
	const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
	if (maxValue && value > maxValue || value < minValue) {
		const suffix = typeof value_ === "bigint" ? "n" : "";
		throw new IntegerOutOfRangeError$1({
			max: maxValue ? `${maxValue}${suffix}` : void 0,
			min: `${minValue}${suffix}`,
			signed,
			size: size$4,
			value: `${value_}${suffix}`
		});
	}
	const hex = `0x${(signed && value < 0 ? (1n << BigInt(size$4 * 8)) + BigInt(value) : value).toString(16)}`;
	if (size$4) return pad$1(hex, { size: size$4 });
	return hex;
}
var encoder$2 = /* @__PURE__ */ new TextEncoder();
/**
* Encodes a UTF-8 string into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#stringtohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { stringToHex } from 'viem'
* const data = stringToHex('Hello World!')
* // '0x48656c6c6f20576f726c6421'
*
* @example
* import { stringToHex } from 'viem'
* const data = stringToHex('Hello World!', { size: 32 })
* // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
*/
function stringToHex$1(value_, opts = {}) {
	return bytesToHex$1(encoder$2.encode(value_), opts);
}

//#endregion
//#region node_modules/viem/_esm/utils/lru.js
/**
* Map with a LRU (Least recently used) policy.
*
* @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
*/
var LruMap$1 = class extends Map {
	constructor(size$4) {
		super();
		Object.defineProperty(this, "maxSize", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		this.maxSize = size$4;
	}
	get(key) {
		const value = super.get(key);
		if (super.has(key) && value !== void 0) {
			this.delete(key);
			super.set(key, value);
		}
		return value;
	}
	set(key, value) {
		super.set(key, value);
		if (this.maxSize && this.size > this.maxSize) {
			const firstKey = this.keys().next().value;
			if (firstKey) this.delete(firstKey);
		}
		return this;
	}
};

//#endregion
//#region node_modules/viem/_esm/utils/stringify.js
const stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
	const value$1 = typeof value_ === "bigint" ? value_.toString() : value_;
	return typeof replacer === "function" ? replacer(key, value$1) : value$1;
}, space);

//#endregion
//#region node_modules/viem/_esm/constants/unit.js
const gweiUnits = {
	ether: -9,
	wei: 9
};

//#endregion
//#region node_modules/viem/_esm/utils/unit/formatGwei.js
/**
* Converts numerical wei to a string representation of gwei.
*
* - Docs: https://viem.sh/docs/utilities/formatGwei
*
* @example
* import { formatGwei } from 'viem'
*
* formatGwei(1000000000n)
* // '1'
*/
function formatGwei(wei, unit = "wei") {
	return formatUnits(wei, gweiUnits[unit]);
}

//#endregion
//#region node_modules/viem/_esm/errors/utils.js
const getUrl = (url) => url;

//#endregion
//#region node_modules/viem/_esm/errors/request.js
var HttpRequestError = class extends BaseError$1 {
	constructor({ body, cause, details, headers, status, url }) {
		super("HTTP request failed.", {
			cause,
			details,
			metaMessages: [
				status && `Status: ${status}`,
				`URL: ${getUrl(url)}`,
				body && `Request body: ${stringify(body)}`
			].filter(Boolean),
			name: "HttpRequestError"
		});
		Object.defineProperty(this, "body", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "headers", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "status", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "url", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		this.body = body;
		this.headers = headers;
		this.status = status;
		this.url = url;
	}
};
var RpcRequestError = class extends BaseError$1 {
	constructor({ body, error, url }) {
		super("RPC Request failed.", {
			cause: error,
			details: error.message,
			metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
			name: "RpcRequestError"
		});
		Object.defineProperty(this, "code", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "data", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "url", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		this.code = error.code;
		this.data = error.data;
		this.url = url;
	}
};
var TimeoutError = class extends BaseError$1 {
	constructor({ body, url }) {
		super("The request took too long to respond.", {
			details: "The request timed out.",
			metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
			name: "TimeoutError"
		});
		Object.defineProperty(this, "url", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		this.url = url;
	}
};

//#endregion
//#region node_modules/viem/_esm/errors/rpc.js
var unknownErrorCode = -1;
var RpcError = class extends BaseError$1 {
	constructor(cause, { code, docsPath, metaMessages, name, shortMessage }) {
		super(shortMessage, {
			cause,
			docsPath,
			metaMessages: metaMessages || cause?.metaMessages,
			name: name || "RpcError"
		});
		Object.defineProperty(this, "code", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		this.name = name || cause.name;
		this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
	}
};
var ProviderRpcError = class extends RpcError {
	constructor(cause, options) {
		super(cause, options);
		Object.defineProperty(this, "data", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		this.data = options.data;
	}
};
var ParseRpcError = class ParseRpcError extends RpcError {
	constructor(cause) {
		super(cause, {
			code: ParseRpcError.code,
			name: "ParseRpcError",
			shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
		});
	}
};
Object.defineProperty(ParseRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32700
});
var InvalidRequestRpcError = class InvalidRequestRpcError extends RpcError {
	constructor(cause) {
		super(cause, {
			code: InvalidRequestRpcError.code,
			name: "InvalidRequestRpcError",
			shortMessage: "JSON is not a valid request object."
		});
	}
};
Object.defineProperty(InvalidRequestRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32600
});
var MethodNotFoundRpcError = class MethodNotFoundRpcError extends RpcError {
	constructor(cause, { method } = {}) {
		super(cause, {
			code: MethodNotFoundRpcError.code,
			name: "MethodNotFoundRpcError",
			shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
		});
	}
};
Object.defineProperty(MethodNotFoundRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32601
});
var InvalidParamsRpcError = class InvalidParamsRpcError extends RpcError {
	constructor(cause) {
		super(cause, {
			code: InvalidParamsRpcError.code,
			name: "InvalidParamsRpcError",
			shortMessage: ["Invalid parameters were provided to the RPC method.", "Double check you have provided the correct parameters."].join("\n")
		});
	}
};
Object.defineProperty(InvalidParamsRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32602
});
var InternalRpcError = class InternalRpcError extends RpcError {
	constructor(cause) {
		super(cause, {
			code: InternalRpcError.code,
			name: "InternalRpcError",
			shortMessage: "An internal error was received."
		});
	}
};
Object.defineProperty(InternalRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32603
});
var InvalidInputRpcError = class InvalidInputRpcError extends RpcError {
	constructor(cause) {
		super(cause, {
			code: InvalidInputRpcError.code,
			name: "InvalidInputRpcError",
			shortMessage: ["Missing or invalid parameters.", "Double check you have provided the correct parameters."].join("\n")
		});
	}
};
Object.defineProperty(InvalidInputRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32e3
});
var ResourceNotFoundRpcError = class ResourceNotFoundRpcError extends RpcError {
	constructor(cause) {
		super(cause, {
			code: ResourceNotFoundRpcError.code,
			name: "ResourceNotFoundRpcError",
			shortMessage: "Requested resource not found."
		});
		Object.defineProperty(this, "name", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: "ResourceNotFoundRpcError"
		});
	}
};
Object.defineProperty(ResourceNotFoundRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32001
});
var ResourceUnavailableRpcError = class ResourceUnavailableRpcError extends RpcError {
	constructor(cause) {
		super(cause, {
			code: ResourceUnavailableRpcError.code,
			name: "ResourceUnavailableRpcError",
			shortMessage: "Requested resource not available."
		});
	}
};
Object.defineProperty(ResourceUnavailableRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32002
});
var TransactionRejectedRpcError = class TransactionRejectedRpcError extends RpcError {
	constructor(cause) {
		super(cause, {
			code: TransactionRejectedRpcError.code,
			name: "TransactionRejectedRpcError",
			shortMessage: "Transaction creation failed."
		});
	}
};
Object.defineProperty(TransactionRejectedRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32003
});
var MethodNotSupportedRpcError = class MethodNotSupportedRpcError extends RpcError {
	constructor(cause, { method } = {}) {
		super(cause, {
			code: MethodNotSupportedRpcError.code,
			name: "MethodNotSupportedRpcError",
			shortMessage: `Method${method ? ` "${method}"` : ""} is not supported.`
		});
	}
};
Object.defineProperty(MethodNotSupportedRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32004
});
var LimitExceededRpcError = class LimitExceededRpcError extends RpcError {
	constructor(cause) {
		super(cause, {
			code: LimitExceededRpcError.code,
			name: "LimitExceededRpcError",
			shortMessage: "Request exceeds defined limit."
		});
	}
};
Object.defineProperty(LimitExceededRpcError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32005
});
var JsonRpcVersionUnsupportedError = class JsonRpcVersionUnsupportedError extends RpcError {
	constructor(cause) {
		super(cause, {
			code: JsonRpcVersionUnsupportedError.code,
			name: "JsonRpcVersionUnsupportedError",
			shortMessage: "Version of JSON-RPC protocol is not supported."
		});
	}
};
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: -32006
});
var UserRejectedRequestError = class UserRejectedRequestError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: UserRejectedRequestError.code,
			name: "UserRejectedRequestError",
			shortMessage: "User rejected the request."
		});
	}
};
Object.defineProperty(UserRejectedRequestError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 4001
});
var UnauthorizedProviderError = class UnauthorizedProviderError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: UnauthorizedProviderError.code,
			name: "UnauthorizedProviderError",
			shortMessage: "The requested method and/or account has not been authorized by the user."
		});
	}
};
Object.defineProperty(UnauthorizedProviderError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 4100
});
var UnsupportedProviderMethodError = class UnsupportedProviderMethodError extends ProviderRpcError {
	constructor(cause, { method } = {}) {
		super(cause, {
			code: UnsupportedProviderMethodError.code,
			name: "UnsupportedProviderMethodError",
			shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
		});
	}
};
Object.defineProperty(UnsupportedProviderMethodError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 4200
});
var ProviderDisconnectedError = class ProviderDisconnectedError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: ProviderDisconnectedError.code,
			name: "ProviderDisconnectedError",
			shortMessage: "The Provider is disconnected from all chains."
		});
	}
};
Object.defineProperty(ProviderDisconnectedError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 4900
});
var ChainDisconnectedError = class ChainDisconnectedError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: ChainDisconnectedError.code,
			name: "ChainDisconnectedError",
			shortMessage: "The Provider is not connected to the requested chain."
		});
	}
};
Object.defineProperty(ChainDisconnectedError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 4901
});
var SwitchChainError = class SwitchChainError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: SwitchChainError.code,
			name: "SwitchChainError",
			shortMessage: "An error occurred when attempting to switch chain."
		});
	}
};
Object.defineProperty(SwitchChainError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 4902
});
var UnsupportedNonOptionalCapabilityError = class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: UnsupportedNonOptionalCapabilityError.code,
			name: "UnsupportedNonOptionalCapabilityError",
			shortMessage: "This Wallet does not support a capability that was not marked as optional."
		});
	}
};
Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 5700
});
var UnsupportedChainIdError = class UnsupportedChainIdError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: UnsupportedChainIdError.code,
			name: "UnsupportedChainIdError",
			shortMessage: "This Wallet does not support the requested chain ID."
		});
	}
};
Object.defineProperty(UnsupportedChainIdError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 5710
});
var DuplicateIdError = class DuplicateIdError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: DuplicateIdError.code,
			name: "DuplicateIdError",
			shortMessage: "There is already a bundle submitted with this ID."
		});
	}
};
Object.defineProperty(DuplicateIdError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 5720
});
var UnknownBundleIdError = class UnknownBundleIdError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: UnknownBundleIdError.code,
			name: "UnknownBundleIdError",
			shortMessage: "This bundle id is unknown / has not been submitted"
		});
	}
};
Object.defineProperty(UnknownBundleIdError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 5730
});
var BundleTooLargeError = class BundleTooLargeError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: BundleTooLargeError.code,
			name: "BundleTooLargeError",
			shortMessage: "The call bundle is too large for the Wallet to process."
		});
	}
};
Object.defineProperty(BundleTooLargeError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 5740
});
var AtomicReadyWalletRejectedUpgradeError = class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: AtomicReadyWalletRejectedUpgradeError.code,
			name: "AtomicReadyWalletRejectedUpgradeError",
			shortMessage: "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."
		});
	}
};
Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 5750
});
var AtomicityNotSupportedError = class AtomicityNotSupportedError extends ProviderRpcError {
	constructor(cause) {
		super(cause, {
			code: AtomicityNotSupportedError.code,
			name: "AtomicityNotSupportedError",
			shortMessage: "The wallet does not support atomic execution but the request requires it."
		});
	}
};
Object.defineProperty(AtomicityNotSupportedError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 5760
});
var UnknownRpcError = class extends RpcError {
	constructor(cause) {
		super(cause, {
			name: "UnknownRpcError",
			shortMessage: "An unknown RPC error occurred."
		});
	}
};

//#endregion
//#region node_modules/viem/_esm/errors/node.js
var ExecutionRevertedError = class extends BaseError$1 {
	constructor({ cause, message } = {}) {
		const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
		super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
			cause,
			name: "ExecutionRevertedError"
		});
	}
};
Object.defineProperty(ExecutionRevertedError, "code", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /execution reverted|gas required exceeds allowance/
});
var FeeCapTooHighError = class extends BaseError$1 {
	constructor({ cause, maxFeePerGas } = {}) {
		super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
			cause,
			name: "FeeCapTooHighError"
		});
	}
};
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
var FeeCapTooLowError = class extends BaseError$1 {
	constructor({ cause, maxFeePerGas } = {}) {
		super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
			cause,
			name: "FeeCapTooLowError"
		});
	}
};
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
var NonceTooHighError = class extends BaseError$1 {
	constructor({ cause, nonce } = {}) {
		super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, {
			cause,
			name: "NonceTooHighError"
		});
	}
};
Object.defineProperty(NonceTooHighError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /nonce too high/
});
var NonceTooLowError = class extends BaseError$1 {
	constructor({ cause, nonce } = {}) {
		super([`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`, "Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"), {
			cause,
			name: "NonceTooLowError"
		});
	}
};
Object.defineProperty(NonceTooLowError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /nonce too low|transaction already imported|already known/
});
var NonceMaxValueError = class extends BaseError$1 {
	constructor({ cause, nonce } = {}) {
		super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, {
			cause,
			name: "NonceMaxValueError"
		});
	}
};
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /nonce has max value/
});
var InsufficientFundsError = class extends BaseError$1 {
	constructor({ cause } = {}) {
		super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"), {
			cause,
			metaMessages: [
				"This error could arise when the account does not have enough funds to:",
				" - pay for the total gas fee,",
				" - pay for the value to send.",
				" ",
				"The cost of the transaction is calculated as `gas * gas fee + value`, where:",
				" - `gas` is the amount of gas needed for transaction to execute,",
				" - `gas fee` is the gas fee,",
				" - `value` is the amount of ether to send to the recipient."
			],
			name: "InsufficientFundsError"
		});
	}
};
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /insufficient funds|exceeds transaction sender account balance/
});
var IntrinsicGasTooHighError = class extends BaseError$1 {
	constructor({ cause, gas } = {}) {
		super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
			cause,
			name: "IntrinsicGasTooHighError"
		});
	}
};
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /intrinsic gas too high|gas limit reached/
});
var IntrinsicGasTooLowError = class extends BaseError$1 {
	constructor({ cause, gas } = {}) {
		super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
			cause,
			name: "IntrinsicGasTooLowError"
		});
	}
};
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /intrinsic gas too low/
});
var TransactionTypeNotSupportedError = class extends BaseError$1 {
	constructor({ cause }) {
		super("The transaction type is not supported for this chain.", {
			cause,
			name: "TransactionTypeNotSupportedError"
		});
	}
};
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /transaction type not valid/
});
var TipAboveFeeCapError = class extends BaseError$1 {
	constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
		super([`The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`].join("\n"), {
			cause,
			name: "TipAboveFeeCapError"
		});
	}
};
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
	enumerable: true,
	configurable: true,
	writable: true,
	value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});

//#endregion
//#region node_modules/viem/_esm/utils/promise/withResolvers.js
/** @internal */
function withResolvers() {
	let resolve = () => void 0;
	let reject = () => void 0;
	return {
		promise: new Promise((resolve_, reject_) => {
			resolve = resolve_;
			reject = reject_;
		}),
		resolve,
		reject
	};
}

//#endregion
//#region node_modules/viem/_esm/utils/promise/createBatchScheduler.js
var schedulerCache = /* @__PURE__ */ new Map();
/** @internal */
function createBatchScheduler({ fn: fn$5, id, shouldSplitBatch, wait: wait$1 = 0, sort }) {
	const exec = async () => {
		const scheduler = getScheduler();
		flush();
		const args = scheduler.map(({ args: args$1 }) => args$1);
		if (args.length === 0) return;
		fn$5(args).then((data) => {
			if (sort && Array.isArray(data)) data.sort(sort);
			for (let i$2 = 0; i$2 < scheduler.length; i$2++) {
				const { resolve } = scheduler[i$2];
				resolve?.([data[i$2], data]);
			}
		}).catch((err) => {
			for (let i$2 = 0; i$2 < scheduler.length; i$2++) {
				const { reject } = scheduler[i$2];
				reject?.(err);
			}
		});
	};
	const flush = () => schedulerCache.delete(id);
	const getBatchedArgs = () => getScheduler().map(({ args }) => args);
	const getScheduler = () => schedulerCache.get(id) || [];
	const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
	return {
		flush,
		async schedule(args) {
			const { promise, resolve, reject } = withResolvers();
			if (shouldSplitBatch?.([...getBatchedArgs(), args])) exec();
			if (getScheduler().length > 0) {
				setScheduler({
					args,
					resolve,
					reject
				});
				return promise;
			}
			setScheduler({
				args,
				resolve,
				reject
			});
			setTimeout(exec, wait$1);
			return promise;
		}
	};
}

//#endregion
//#region node_modules/viem/_esm/utils/wait.js
async function wait(time) {
	return new Promise((res) => setTimeout(res, time));
}

//#endregion
//#region node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(fn$5, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry$1 = () => true } = {}) {
	return new Promise((resolve, reject) => {
		const attemptRetry = async ({ count = 0 } = {}) => {
			const retry = async ({ error }) => {
				const delay = typeof delay_ === "function" ? delay_({
					count,
					error
				}) : delay_;
				if (delay) await wait(delay);
				attemptRetry({ count: count + 1 });
			};
			try {
				resolve(await fn$5());
			} catch (err) {
				if (count < retryCount && await shouldRetry$1({
					count,
					error: err
				})) return retry({ error: err });
				reject(err);
			}
		};
		attemptRetry();
	});
}

//#endregion
//#region node_modules/viem/_esm/utils/uid.js
var size$1 = 256;
var index = size$1;
var buffer;
function uid(length = 11) {
	if (!buffer || index + length > size$1 * 2) {
		buffer = "";
		index = 0;
		for (let i$2 = 0; i$2 < size$1; i$2++) buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
	}
	return buffer.substring(index, index++ + length);
}

//#endregion
//#region node_modules/viem/_esm/utils/promise/withDedupe.js
/** @internal */
const promiseCache = /* @__PURE__ */ new LruMap$1(8192);
/** Deduplicates in-flight promises. */
function withDedupe(fn$5, { enabled = true, id }) {
	if (!enabled || !id) return fn$5();
	if (promiseCache.get(id)) return promiseCache.get(id);
	const promise = fn$5().finally(() => promiseCache.delete(id));
	promiseCache.set(id, promise);
	return promise;
}

//#endregion
//#region node_modules/viem/_esm/utils/buildRequest.js
function buildRequest(request, options = {}) {
	return async (args, overrideOptions = {}) => {
		const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid: uid$1 } = {
			...options,
			...overrideOptions
		};
		const { method } = args;
		if (methods?.exclude?.includes(method)) throw new MethodNotSupportedRpcError(/* @__PURE__ */ new Error("method not supported"), { method });
		if (methods?.include && !methods.include.includes(method)) throw new MethodNotSupportedRpcError(/* @__PURE__ */ new Error("method not supported"), { method });
		return withDedupe(() => withRetry(async () => {
			try {
				return await request(args);
			} catch (err_) {
				const err = err_;
				switch (err.code) {
					case ParseRpcError.code: throw new ParseRpcError(err);
					case InvalidRequestRpcError.code: throw new InvalidRequestRpcError(err);
					case MethodNotFoundRpcError.code: throw new MethodNotFoundRpcError(err, { method: args.method });
					case InvalidParamsRpcError.code: throw new InvalidParamsRpcError(err);
					case InternalRpcError.code: throw new InternalRpcError(err);
					case InvalidInputRpcError.code: throw new InvalidInputRpcError(err);
					case ResourceNotFoundRpcError.code: throw new ResourceNotFoundRpcError(err);
					case ResourceUnavailableRpcError.code: throw new ResourceUnavailableRpcError(err);
					case TransactionRejectedRpcError.code: throw new TransactionRejectedRpcError(err);
					case MethodNotSupportedRpcError.code: throw new MethodNotSupportedRpcError(err, { method: args.method });
					case LimitExceededRpcError.code: throw new LimitExceededRpcError(err);
					case JsonRpcVersionUnsupportedError.code: throw new JsonRpcVersionUnsupportedError(err);
					case UserRejectedRequestError.code: throw new UserRejectedRequestError(err);
					case UnauthorizedProviderError.code: throw new UnauthorizedProviderError(err);
					case UnsupportedProviderMethodError.code: throw new UnsupportedProviderMethodError(err);
					case ProviderDisconnectedError.code: throw new ProviderDisconnectedError(err);
					case ChainDisconnectedError.code: throw new ChainDisconnectedError(err);
					case SwitchChainError.code: throw new SwitchChainError(err);
					case UnsupportedNonOptionalCapabilityError.code: throw new UnsupportedNonOptionalCapabilityError(err);
					case UnsupportedChainIdError.code: throw new UnsupportedChainIdError(err);
					case DuplicateIdError.code: throw new DuplicateIdError(err);
					case UnknownBundleIdError.code: throw new UnknownBundleIdError(err);
					case BundleTooLargeError.code: throw new BundleTooLargeError(err);
					case AtomicReadyWalletRejectedUpgradeError.code: throw new AtomicReadyWalletRejectedUpgradeError(err);
					case AtomicityNotSupportedError.code: throw new AtomicityNotSupportedError(err);
					case 5e3: throw new UserRejectedRequestError(err);
					default:
						if (err_ instanceof BaseError$1) throw err_;
						throw new UnknownRpcError(err);
				}
			}
		}, {
			delay: ({ count, error }) => {
				if (error && error instanceof HttpRequestError) {
					const retryAfter = error?.headers?.get("Retry-After");
					if (retryAfter?.match(/\d/)) return Number.parseInt(retryAfter, 10) * 1e3;
				}
				return ~~(1 << count) * retryDelay;
			},
			retryCount,
			shouldRetry: ({ error }) => shouldRetry(error)
		}), {
			enabled: dedupe,
			id: dedupe ? stringToHex$1(`${uid$1}.${stringify(args)}`) : void 0
		});
	};
}
/** @internal */
function shouldRetry(error) {
	if ("code" in error && typeof error.code === "number") {
		if (error.code === -1) return true;
		if (error.code === LimitExceededRpcError.code) return true;
		if (error.code === InternalRpcError.code) return true;
		return false;
	}
	if (error instanceof HttpRequestError && error.status) {
		if (error.status === 403) return true;
		if (error.status === 408) return true;
		if (error.status === 413) return true;
		if (error.status === 429) return true;
		if (error.status === 500) return true;
		if (error.status === 502) return true;
		if (error.status === 503) return true;
		if (error.status === 504) return true;
		return false;
	}
	return true;
}

//#endregion
//#region node_modules/viem/_esm/utils/promise/withTimeout.js
function withTimeout(fn$5, { errorInstance = /* @__PURE__ */ new Error("timed out"), timeout, signal }) {
	return new Promise((resolve, reject) => {
		(async () => {
			let timeoutId;
			try {
				const controller = new AbortController();
				if (timeout > 0) timeoutId = setTimeout(() => {
					if (signal) controller.abort();
					else reject(errorInstance);
				}, timeout);
				resolve(await fn$5({ signal: controller?.signal || null }));
			} catch (err) {
				if (err?.name === "AbortError") reject(errorInstance);
				reject(err);
			} finally {
				clearTimeout(timeoutId);
			}
		})();
	});
}

//#endregion
//#region node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
	return {
		current: 0,
		take() {
			return this.current++;
		},
		reset() {
			this.current = 0;
		}
	};
}
const idCache = /* @__PURE__ */ createIdStore();

//#endregion
//#region node_modules/viem/_esm/utils/rpc/http.js
function getHttpRpcClient(url, options = {}) {
	return { async request(params) {
		const { body, fetchFn = options.fetchFn ?? fetch, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
		const fetchOptions = {
			...options.fetchOptions ?? {},
			...params.fetchOptions ?? {}
		};
		const { headers, method, signal: signal_ } = fetchOptions;
		try {
			const response = await withTimeout(async ({ signal }) => {
				const init = {
					...fetchOptions,
					body: Array.isArray(body) ? stringify(body.map((body$1) => ({
						jsonrpc: "2.0",
						id: body$1.id ?? idCache.take(),
						...body$1
					}))) : stringify({
						jsonrpc: "2.0",
						id: body.id ?? idCache.take(),
						...body
					}),
					headers: {
						"Content-Type": "application/json",
						...headers
					},
					method: method || "POST",
					signal: signal_ || (timeout > 0 ? signal : null)
				};
				const request = new Request(url, init);
				const args = await onRequest?.(request, init) ?? {
					...init,
					url
				};
				return await fetchFn(args.url ?? url, args);
			}, {
				errorInstance: new TimeoutError({
					body,
					url
				}),
				timeout,
				signal: true
			});
			if (onResponse) await onResponse(response);
			let data;
			if (response.headers.get("Content-Type")?.startsWith("application/json")) data = await response.json();
			else {
				data = await response.text();
				try {
					data = JSON.parse(data || "{}");
				} catch (err) {
					if (response.ok) throw err;
					data = { error: data };
				}
			}
			if (!response.ok) throw new HttpRequestError({
				body,
				details: stringify(data.error) || response.statusText,
				headers: response.headers,
				status: response.status,
				url
			});
			return data;
		} catch (err) {
			if (err instanceof HttpRequestError) throw err;
			if (err instanceof TimeoutError) throw err;
			throw new HttpRequestError({
				body,
				cause: err,
				url
			});
		}
	} };
}

//#endregion
//#region node_modules/viem/_esm/clients/transports/createTransport.js
/**
* @description Creates an transport intended to be used with a client.
*/
function createTransport({ key, methods, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
	const uid$1 = uid();
	return {
		config: {
			key,
			methods,
			name,
			request,
			retryCount,
			retryDelay,
			timeout,
			type
		},
		request: buildRequest(request, {
			methods,
			retryCount,
			retryDelay,
			uid: uid$1
		}),
		value
	};
}

//#endregion
//#region node_modules/viem/_esm/clients/transports/fallback.js
function fallback(transports_, config = {}) {
	const { key = "fallback", name = "Fallback", rank = false, shouldThrow: shouldThrow_ = shouldThrow, retryCount, retryDelay } = config;
	return (({ chain, pollingInterval = 4e3, timeout, ...rest }) => {
		let transports = transports_;
		let onResponse = () => {};
		const transport = createTransport({
			key,
			name,
			async request({ method, params }) {
				let includes;
				const fetch$1 = async (i$2 = 0) => {
					const transport$1 = transports[i$2]({
						...rest,
						chain,
						retryCount: 0,
						timeout
					});
					try {
						const response = await transport$1.request({
							method,
							params
						});
						onResponse({
							method,
							params,
							response,
							transport: transport$1,
							status: "success"
						});
						return response;
					} catch (err) {
						onResponse({
							error: err,
							method,
							params,
							transport: transport$1,
							status: "error"
						});
						if (shouldThrow_(err)) throw err;
						if (i$2 === transports.length - 1) throw err;
						includes ??= transports.slice(i$2 + 1).some((transport$2) => {
							const { include, exclude } = transport$2({ chain }).config.methods || {};
							if (include) return include.includes(method);
							if (exclude) return !exclude.includes(method);
							return true;
						});
						if (!includes) throw err;
						return fetch$1(i$2 + 1);
					}
				};
				return fetch$1();
			},
			retryCount,
			retryDelay,
			type: "fallback"
		}, {
			onResponse: (fn$5) => onResponse = fn$5,
			transports: transports.map((fn$5) => fn$5({
				chain,
				retryCount: 0
			}))
		});
		if (rank) {
			const rankOptions = typeof rank === "object" ? rank : {};
			rankTransports({
				chain,
				interval: rankOptions.interval ?? pollingInterval,
				onTransports: (transports_$1) => transports = transports_$1,
				ping: rankOptions.ping,
				sampleCount: rankOptions.sampleCount,
				timeout: rankOptions.timeout,
				transports,
				weights: rankOptions.weights
			});
		}
		return transport;
	});
}
function shouldThrow(error) {
	if ("code" in error && typeof error.code === "number") {
		if (error.code === TransactionRejectedRpcError.code || error.code === UserRejectedRequestError.code || ExecutionRevertedError.nodeMessage.test(error.message) || error.code === 5e3) return true;
	}
	return false;
}
/** @internal */
function rankTransports({ chain, interval = 4e3, onTransports, ping, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
	const { stability: stabilityWeight = .7, latency: latencyWeight = .3 } = weights;
	const samples = [];
	const rankTransports_ = async () => {
		const sample = await Promise.all(transports.map(async (transport) => {
			const transport_ = transport({
				chain,
				retryCount: 0,
				timeout
			});
			const start = Date.now();
			let end;
			let success;
			try {
				await (ping ? ping({ transport: transport_ }) : transport_.request({ method: "net_listening" }));
				success = 1;
			} catch {
				success = 0;
			} finally {
				end = Date.now();
			}
			return {
				latency: end - start,
				success
			};
		}));
		samples.push(sample);
		if (samples.length > sampleCount) samples.shift();
		const maxLatency = Math.max(...samples.map((sample$1) => Math.max(...sample$1.map(({ latency }) => latency))));
		onTransports(transports.map((_$4, i$2) => {
			const latencies = samples.map((sample$1) => sample$1[i$2].latency);
			const latencyScore = 1 - latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length / maxLatency;
			const successes = samples.map((sample$1) => sample$1[i$2].success);
			const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
			if (stabilityScore === 0) return [0, i$2];
			return [latencyWeight * latencyScore + stabilityWeight * stabilityScore, i$2];
		}).sort((a$1, b$3) => b$3[0] - a$1[0]).map(([, i$2]) => transports[i$2]));
		await wait(interval);
		rankTransports_();
	};
	rankTransports_();
}

//#endregion
//#region node_modules/viem/_esm/errors/transport.js
var UrlRequiredError = class extends BaseError$1 {
	constructor() {
		super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
			docsPath: "/docs/clients/intro",
			name: "UrlRequiredError"
		});
	}
};

//#endregion
//#region node_modules/viem/_esm/clients/transports/http.js
/**
* @description Creates a HTTP transport that connects to a JSON-RPC API.
*/
function http(url, config = {}) {
	const { batch, fetchFn, fetchOptions, key = "http", methods, name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay, raw } = config;
	return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
		const { batchSize = 1e3, wait: wait$1 = 0 } = typeof batch === "object" ? batch : {};
		const retryCount = config.retryCount ?? retryCount_;
		const timeout = timeout_ ?? config.timeout ?? 1e4;
		const url_ = url || chain?.rpcUrls.default.http[0];
		if (!url_) throw new UrlRequiredError();
		const rpcClient = getHttpRpcClient(url_, {
			fetchFn,
			fetchOptions,
			onRequest: onFetchRequest,
			onResponse: onFetchResponse,
			timeout
		});
		return createTransport({
			key,
			methods,
			name,
			async request({ method, params }) {
				const body = {
					method,
					params
				};
				const { schedule } = createBatchScheduler({
					id: url_,
					wait: wait$1,
					shouldSplitBatch(requests) {
						return requests.length > batchSize;
					},
					fn: (body$1) => rpcClient.request({ body: body$1 }),
					sort: (a$1, b$3) => a$1.id - b$3.id
				});
				const fn$5 = async (body$1) => batch ? schedule(body$1) : [await rpcClient.request({ body: body$1 })];
				const [{ error, result }] = await fn$5(body);
				if (raw) return {
					error,
					result
				};
				if (error) throw new RpcRequestError({
					body,
					error,
					url: url_
				});
				return result;
			},
			retryCount,
			retryDelay,
			timeout,
			type: "http"
		}, {
			fetchOptions,
			url: url_
		});
	};
}

//#endregion
//#region node_modules/@reown/appkit-controllers/dist/esm/src/utils/EnsUtil.js
var SLIP44_MSB = 2147483648;
const EnsUtil = { convertEVMChainIdToCoinType(chainId) {
	if (chainId >= SLIP44_MSB) throw new Error("Invalid chainId");
	return (SLIP44_MSB | chainId) >>> 0;
} };

//#endregion
//#region node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EnsController.js
var state$1 = proxy({
	suggestions: [],
	loading: false
});
const EnsController = {
	state: state$1,
	subscribe(callback) {
		return subscribe(state$1, () => callback(state$1));
	},
	subscribeKey(key, callback) {
		return subscribeKey(state$1, key, callback);
	},
	async resolveName(name) {
		try {
			return await BlockchainApiController.lookupEnsName(name);
		} catch (e) {
			const error = e;
			throw new Error(error?.reasons?.[0]?.description || "Error resolving name");
		}
	},
	async isNameRegistered(name) {
		try {
			await BlockchainApiController.lookupEnsName(name);
			return true;
		} catch {
			return false;
		}
	},
	async getSuggestions(value) {
		try {
			state$1.loading = true;
			state$1.suggestions = [];
			state$1.suggestions = (await BlockchainApiController.getEnsNameSuggestions(value)).suggestions.map((suggestion) => ({
				...suggestion,
				name: suggestion.name
			})) || [];
			return state$1.suggestions;
		} catch (e) {
			const errorMessage = this.parseEnsApiError(e, "Error fetching name suggestions");
			throw new Error(errorMessage);
		} finally {
			state$1.loading = false;
		}
	},
	async getNamesForAddress(address) {
		try {
			if (!ChainController.state.activeCaipNetwork) return [];
			const cachedEns = StorageUtil.getEnsFromCacheForAddress(address);
			if (cachedEns) return cachedEns;
			const response = await BlockchainApiController.reverseLookupEnsName({ address });
			StorageUtil.updateEnsCache({
				address,
				ens: response,
				timestamp: Date.now()
			});
			return response;
		} catch (e) {
			const errorMessage = this.parseEnsApiError(e, "Error fetching names for address");
			throw new Error(errorMessage);
		}
	},
	async registerName(name) {
		const network = ChainController.state.activeCaipNetwork;
		if (!network) throw new Error("Network not found");
		const address = AccountController.state.address;
		const emailConnector = ConnectorController.getAuthConnector();
		if (!address || !emailConnector) throw new Error("Address or auth connector not found");
		state$1.loading = true;
		try {
			const message = JSON.stringify({
				name,
				attributes: {},
				timestamp: Math.floor(Date.now() / 1e3)
			});
			RouterController.pushTransactionStack({
				view: "RegisterAccountNameSuccess",
				goBack: false,
				replace: true,
				onCancel() {
					state$1.loading = false;
				}
			});
			const signature = await ConnectionController.signMessage(message);
			const networkId = network.id;
			if (!networkId) throw new Error("Network not found");
			const coinType = EnsUtil.convertEVMChainIdToCoinType(Number(networkId));
			await BlockchainApiController.registerEnsName({
				coinType,
				address,
				signature,
				message
			});
			AccountController.setProfileName(name, network.chainNamespace);
			RouterController.replace("RegisterAccountNameSuccess");
		} catch (e) {
			const errorMessage = this.parseEnsApiError(e, `Error registering name ${name}`);
			RouterController.replace("RegisterAccountName");
			throw new Error(errorMessage);
		} finally {
			state$1.loading = false;
		}
	},
	validateName(name) {
		return /^[a-zA-Z0-9-]{4,}$/u.test(name);
	},
	parseEnsApiError(error, defaultError) {
		return error?.reasons?.[0]?.description || defaultError;
	}
};

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
	if (!value) return false;
	if (typeof value !== "string") return false;
	return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/size.js
/**
* @description Retrieves the size of the value (in bytes).
*
* @param value The value (hex or byte array) to retrieve the size of.
* @returns The size of the value (in bytes).
*/
function size(value) {
	if (isHex(value, { strict: false })) return Math.ceil((value.length - 2) / 2);
	return value.length;
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/version.js
const version = "2.23.2";

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/base.js
var errorConfig = {
	getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
	version: `viem@${version}`
};
var BaseError = class BaseError extends Error {
	constructor(shortMessage, args = {}) {
		const details = (() => {
			if (args.cause instanceof BaseError) return args.cause.details;
			if (args.cause?.message) return args.cause.message;
			return args.details;
		})();
		const docsPath = (() => {
			if (args.cause instanceof BaseError) return args.cause.docsPath || args.docsPath;
			return args.docsPath;
		})();
		const docsUrl = errorConfig.getDocsUrl?.({
			...args,
			docsPath
		});
		const message = [
			shortMessage || "An error occurred.",
			"",
			...args.metaMessages ? [...args.metaMessages, ""] : [],
			...docsUrl ? [`Docs: ${docsUrl}`] : [],
			...details ? [`Details: ${details}`] : [],
			...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
		].join("\n");
		super(message, args.cause ? { cause: args.cause } : void 0);
		Object.defineProperty(this, "details", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "docsPath", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "metaMessages", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "shortMessage", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "version", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		Object.defineProperty(this, "name", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: "BaseError"
		});
		this.details = details;
		this.docsPath = docsPath;
		this.metaMessages = args.metaMessages;
		this.name = args.name ?? this.name;
		this.shortMessage = shortMessage;
		this.version = version;
	}
	walk(fn$5) {
		return walk(this, fn$5);
	}
};
function walk(err, fn$5) {
	if (fn$5?.(err)) return err;
	if (err && typeof err === "object" && "cause" in err && err.cause !== void 0) return walk(err.cause, fn$5);
	return fn$5 ? null : err;
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/data.js
var SizeExceedsPaddingSizeError = class extends BaseError {
	constructor({ size: size$4, targetSize, type }) {
		super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size$4}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
	}
};

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/pad.js
function pad(hexOrBytes, { dir, size: size$4 = 32 } = {}) {
	if (typeof hexOrBytes === "string") return padHex(hexOrBytes, {
		dir,
		size: size$4
	});
	return padBytes(hexOrBytes, {
		dir,
		size: size$4
	});
}
function padHex(hex_, { dir, size: size$4 = 32 } = {}) {
	if (size$4 === null) return hex_;
	const hex = hex_.replace("0x", "");
	if (hex.length > size$4 * 2) throw new SizeExceedsPaddingSizeError({
		size: Math.ceil(hex.length / 2),
		targetSize: size$4,
		type: "hex"
	});
	return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size$4 * 2, "0")}`;
}
function padBytes(bytes, { dir, size: size$4 = 32 } = {}) {
	if (size$4 === null) return bytes;
	if (bytes.length > size$4) throw new SizeExceedsPaddingSizeError({
		size: bytes.length,
		targetSize: size$4,
		type: "bytes"
	});
	const paddedBytes = new Uint8Array(size$4);
	for (let i$2 = 0; i$2 < size$4; i$2++) {
		const padEnd = dir === "right";
		paddedBytes[padEnd ? i$2 : size$4 - i$2 - 1] = bytes[padEnd ? i$2 : bytes.length - i$2 - 1];
	}
	return paddedBytes;
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError = class extends BaseError {
	constructor({ max, min, signed, size: size$4, value }) {
		super(`Number "${value}" is not in safe ${size$4 ? `${size$4 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
	}
};
var SizeOverflowError = class extends BaseError {
	constructor({ givenSize, maxSize }) {
		super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
	}
};

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size$4 }) {
	if (size(hexOrBytes) > size$4) throw new SizeOverflowError({
		givenSize: size(hexOrBytes),
		maxSize: size$4
	});
}
/**
* Decodes a hex value into a bigint.
*
* - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint
*
* @param hex Hex value to decode.
* @param opts Options.
* @returns BigInt value.
*
* @example
* import { hexToBigInt } from 'viem'
* const data = hexToBigInt('0x1a4', { signed: true })
* // 420n
*
* @example
* import { hexToBigInt } from 'viem'
* const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
* // 420n
*/
function hexToBigInt(hex, opts = {}) {
	const { signed } = opts;
	if (opts.size) assertSize(hex, { size: opts.size });
	const value = BigInt(hex);
	if (!signed) return value;
	const size$4 = (hex.length - 2) / 2;
	if (value <= (1n << BigInt(size$4) * 8n - 1n) - 1n) return value;
	return value - BigInt(`0x${"f".padStart(size$4 * 2, "f")}`) - 1n;
}
/**
* Decodes a hex string into a number.
*
* - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber
*
* @param hex Hex value to decode.
* @param opts Options.
* @returns Number value.
*
* @example
* import { hexToNumber } from 'viem'
* const data = hexToNumber('0x1a4')
* // 420
*
* @example
* import { hexToNumber } from 'viem'
* const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
* // 420
*/
function hexToNumber(hex, opts = {}) {
	return Number(hexToBigInt(hex, opts));
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toHex.js
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i$2) => i$2.toString(16).padStart(2, "0"));
/**
* Encodes a string, number, bigint, or ByteArray into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex
* - Example: https://viem.sh/docs/utilities/toHex#usage
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { toHex } from 'viem'
* const data = toHex('Hello world')
* // '0x48656c6c6f20776f726c6421'
*
* @example
* import { toHex } from 'viem'
* const data = toHex(420)
* // '0x1a4'
*
* @example
* import { toHex } from 'viem'
* const data = toHex('Hello world', { size: 32 })
* // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'
*/
function toHex$1(value, opts = {}) {
	if (typeof value === "number" || typeof value === "bigint") return numberToHex(value, opts);
	if (typeof value === "string") return stringToHex(value, opts);
	if (typeof value === "boolean") return boolToHex(value, opts);
	return bytesToHex(value, opts);
}
/**
* Encodes a boolean into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#booltohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { boolToHex } from 'viem'
* const data = boolToHex(true)
* // '0x1'
*
* @example
* import { boolToHex } from 'viem'
* const data = boolToHex(false)
* // '0x0'
*
* @example
* import { boolToHex } from 'viem'
* const data = boolToHex(true, { size: 32 })
* // '0x0000000000000000000000000000000000000000000000000000000000000001'
*/
function boolToHex(value, opts = {}) {
	const hex = `0x${Number(value)}`;
	if (typeof opts.size === "number") {
		assertSize(hex, { size: opts.size });
		return pad(hex, { size: opts.size });
	}
	return hex;
}
/**
* Encodes a bytes array into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#bytestohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { bytesToHex } from 'viem'
* const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
* // '0x48656c6c6f20576f726c6421'
*
* @example
* import { bytesToHex } from 'viem'
* const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })
* // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
*/
function bytesToHex(value, opts = {}) {
	let string = "";
	for (let i$2 = 0; i$2 < value.length; i$2++) string += hexes[value[i$2]];
	const hex = `0x${string}`;
	if (typeof opts.size === "number") {
		assertSize(hex, { size: opts.size });
		return pad(hex, {
			dir: "right",
			size: opts.size
		});
	}
	return hex;
}
/**
* Encodes a number or bigint into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#numbertohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { numberToHex } from 'viem'
* const data = numberToHex(420)
* // '0x1a4'
*
* @example
* import { numberToHex } from 'viem'
* const data = numberToHex(420, { size: 32 })
* // '0x00000000000000000000000000000000000000000000000000000000000001a4'
*/
function numberToHex(value_, opts = {}) {
	const { signed, size: size$4 } = opts;
	const value = BigInt(value_);
	let maxValue;
	if (size$4) if (signed) maxValue = (1n << BigInt(size$4) * 8n - 1n) - 1n;
	else maxValue = 2n ** (BigInt(size$4) * 8n) - 1n;
	else if (typeof value_ === "number") maxValue = BigInt(Number.MAX_SAFE_INTEGER);
	const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
	if (maxValue && value > maxValue || value < minValue) {
		const suffix = typeof value_ === "bigint" ? "n" : "";
		throw new IntegerOutOfRangeError({
			max: maxValue ? `${maxValue}${suffix}` : void 0,
			min: `${minValue}${suffix}`,
			signed,
			size: size$4,
			value: `${value_}${suffix}`
		});
	}
	const hex = `0x${(signed && value < 0 ? (1n << BigInt(size$4 * 8)) + BigInt(value) : value).toString(16)}`;
	if (size$4) return pad(hex, { size: size$4 });
	return hex;
}
var encoder$1 = /* @__PURE__ */ new TextEncoder();
/**
* Encodes a UTF-8 string into a hex string
*
* - Docs: https://viem.sh/docs/utilities/toHex#stringtohex
*
* @param value Value to encode.
* @param opts Options.
* @returns Hex value.
*
* @example
* import { stringToHex } from 'viem'
* const data = stringToHex('Hello World!')
* // '0x48656c6c6f20576f726c6421'
*
* @example
* import { stringToHex } from 'viem'
* const data = stringToHex('Hello World!', { size: 32 })
* // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
*/
function stringToHex(value_, opts = {}) {
	return bytesToHex(encoder$1.encode(value_), opts);
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toBytes.js
var encoder = /* @__PURE__ */ new TextEncoder();
/**
* Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.
*
* - Docs: https://viem.sh/docs/utilities/toBytes
* - Example: https://viem.sh/docs/utilities/toBytes#usage
*
* @param value Value to encode.
* @param opts Options.
* @returns Byte array value.
*
* @example
* import { toBytes } from 'viem'
* const data = toBytes('Hello world')
* // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
*
* @example
* import { toBytes } from 'viem'
* const data = toBytes(420)
* // Uint8Array([1, 164])
*
* @example
* import { toBytes } from 'viem'
* const data = toBytes(420, { size: 4 })
* // Uint8Array([0, 0, 1, 164])
*/
function toBytes(value, opts = {}) {
	if (typeof value === "number" || typeof value === "bigint") return numberToBytes(value, opts);
	if (typeof value === "boolean") return boolToBytes(value, opts);
	if (isHex(value)) return hexToBytes(value, opts);
	return stringToBytes(value, opts);
}
/**
* Encodes a boolean into a byte array.
*
* - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes
*
* @param value Boolean value to encode.
* @param opts Options.
* @returns Byte array value.
*
* @example
* import { boolToBytes } from 'viem'
* const data = boolToBytes(true)
* // Uint8Array([1])
*
* @example
* import { boolToBytes } from 'viem'
* const data = boolToBytes(true, { size: 32 })
* // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
*/
function boolToBytes(value, opts = {}) {
	const bytes = new Uint8Array(1);
	bytes[0] = Number(value);
	if (typeof opts.size === "number") {
		assertSize(bytes, { size: opts.size });
		return pad(bytes, { size: opts.size });
	}
	return bytes;
}
var charCodeMap = {
	zero: 48,
	nine: 57,
	A: 65,
	F: 70,
	a: 97,
	f: 102
};
function charCodeToBase16(char) {
	if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;
	if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);
	if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);
}
/**
* Encodes a hex string into a byte array.
*
* - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes
*
* @param hex Hex string to encode.
* @param opts Options.
* @returns Byte array value.
*
* @example
* import { hexToBytes } from 'viem'
* const data = hexToBytes('0x48656c6c6f20776f726c6421')
* // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
*
* @example
* import { hexToBytes } from 'viem'
* const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })
* // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
*/
function hexToBytes(hex_, opts = {}) {
	let hex = hex_;
	if (opts.size) {
		assertSize(hex, { size: opts.size });
		hex = pad(hex, {
			dir: "right",
			size: opts.size
		});
	}
	let hexString = hex.slice(2);
	if (hexString.length % 2) hexString = `0${hexString}`;
	const length = hexString.length / 2;
	const bytes = new Uint8Array(length);
	for (let index$1 = 0, j$2 = 0; index$1 < length; index$1++) {
		const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j$2++));
		const nibbleRight = charCodeToBase16(hexString.charCodeAt(j$2++));
		if (nibbleLeft === void 0 || nibbleRight === void 0) throw new BaseError(`Invalid byte sequence ("${hexString[j$2 - 2]}${hexString[j$2 - 1]}" in "${hexString}").`);
		bytes[index$1] = nibbleLeft * 16 + nibbleRight;
	}
	return bytes;
}
/**
* Encodes a number into a byte array.
*
* - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes
*
* @param value Number to encode.
* @param opts Options.
* @returns Byte array value.
*
* @example
* import { numberToBytes } from 'viem'
* const data = numberToBytes(420)
* // Uint8Array([1, 164])
*
* @example
* import { numberToBytes } from 'viem'
* const data = numberToBytes(420, { size: 4 })
* // Uint8Array([0, 0, 1, 164])
*/
function numberToBytes(value, opts) {
	return hexToBytes(numberToHex(value, opts));
}
/**
* Encodes a UTF-8 string into a byte array.
*
* - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes
*
* @param value String to encode.
* @param opts Options.
* @returns Byte array value.
*
* @example
* import { stringToBytes } from 'viem'
* const data = stringToBytes('Hello world!')
* // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])
*
* @example
* import { stringToBytes } from 'viem'
* const data = stringToBytes('Hello world!', { size: 32 })
* // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
*/
function stringToBytes(value, opts = {}) {
	const bytes = encoder.encode(value);
	if (typeof opts.size === "number") {
		assertSize(bytes, { size: opts.size });
		return pad(bytes, {
			dir: "right",
			size: opts.size
		});
	}
	return bytes;
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@noble/hashes/esm/_u64.js
/**
* Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
* @todo re-check https://issues.chromium.org/issues/42212588
* @module
*/
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n$2, le$7 = false) {
	if (le$7) return {
		h: Number(n$2 & U32_MASK64),
		l: Number(n$2 >> _32n & U32_MASK64)
	};
	return {
		h: Number(n$2 >> _32n & U32_MASK64) | 0,
		l: Number(n$2 & U32_MASK64) | 0
	};
}
function split(lst, le$7 = false) {
	let Ah = new Uint32Array(lst.length);
	let Al = new Uint32Array(lst.length);
	for (let i$2 = 0; i$2 < lst.length; i$2++) {
		const { h: h$4, l: l$2 } = fromBig(lst[i$2], le$7);
		[Ah[i$2], Al[i$2]] = [h$4, l$2];
	}
	return [Ah, Al];
}
var rotlSH = (h$4, l$2, s) => h$4 << s | l$2 >>> 32 - s;
var rotlSL = (h$4, l$2, s) => l$2 << s | h$4 >>> 32 - s;
var rotlBH = (h$4, l$2, s) => l$2 << s - 32 | h$4 >>> 64 - s;
var rotlBL = (h$4, l$2, s) => h$4 << s - 32 | l$2 >>> 64 - s;

//#endregion
//#region node_modules/@reown/appkit/node_modules/@noble/hashes/esm/sha3.js
/**
* SHA3 (keccak) hash function, based on a new "Sponge function" design.
* Different from older hashes, the internal state is bigger than output size.
*
* Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
* [Website](https://keccak.team/keccak.html),
* [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
*
* Check out `sha3-addons` module for cSHAKE, k12, and others.
* @module
*/
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
var _7n = /* @__PURE__ */ BigInt(7);
var _256n = /* @__PURE__ */ BigInt(256);
var _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R$5 = _1n, x$6 = 1, y$6 = 0; round < 24; round++) {
	[x$6, y$6] = [y$6, (2 * x$6 + 3 * y$6) % 5];
	SHA3_PI.push(2 * (5 * y$6 + x$6));
	SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
	let t = _0n;
	for (let j$2 = 0; j$2 < 7; j$2++) {
		R$5 = (R$5 << _1n ^ (R$5 >> _7n) * _0x71n) % _256n;
		if (R$5 & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j$2)) - _1n;
	}
	_SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
var rotlH = (h$4, l$2, s) => s > 32 ? rotlBH(h$4, l$2, s) : rotlSH(h$4, l$2, s);
var rotlL = (h$4, l$2, s) => s > 32 ? rotlBL(h$4, l$2, s) : rotlSL(h$4, l$2, s);
/** `keccakf1600` internal function, additionally allows to adjust round count. */
function keccakP(s, rounds = 24) {
	const B$4 = new Uint32Array(10);
	for (let round = 24 - rounds; round < 24; round++) {
		for (let x$6 = 0; x$6 < 10; x$6++) B$4[x$6] = s[x$6] ^ s[x$6 + 10] ^ s[x$6 + 20] ^ s[x$6 + 30] ^ s[x$6 + 40];
		for (let x$6 = 0; x$6 < 10; x$6 += 2) {
			const idx1 = (x$6 + 8) % 10;
			const idx0 = (x$6 + 2) % 10;
			const B0 = B$4[idx0];
			const B1 = B$4[idx0 + 1];
			const Th = rotlH(B0, B1, 1) ^ B$4[idx1];
			const Tl = rotlL(B0, B1, 1) ^ B$4[idx1 + 1];
			for (let y$6 = 0; y$6 < 50; y$6 += 10) {
				s[x$6 + y$6] ^= Th;
				s[x$6 + y$6 + 1] ^= Tl;
			}
		}
		let curH = s[2];
		let curL = s[3];
		for (let t = 0; t < 24; t++) {
			const shift = SHA3_ROTL[t];
			const Th = rotlH(curH, curL, shift);
			const Tl = rotlL(curH, curL, shift);
			const PI = SHA3_PI[t];
			curH = s[PI];
			curL = s[PI + 1];
			s[PI] = Th;
			s[PI + 1] = Tl;
		}
		for (let y$6 = 0; y$6 < 50; y$6 += 10) {
			for (let x$6 = 0; x$6 < 10; x$6++) B$4[x$6] = s[y$6 + x$6];
			for (let x$6 = 0; x$6 < 10; x$6++) s[y$6 + x$6] ^= ~B$4[(x$6 + 2) % 10] & B$4[(x$6 + 4) % 10];
		}
		s[0] ^= SHA3_IOTA_H[round];
		s[1] ^= SHA3_IOTA_L[round];
	}
	B$4.fill(0);
}
/** Keccak sponge function. */
var Keccak = class Keccak extends Hash {
	constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
		super();
		this.blockLen = blockLen;
		this.suffix = suffix;
		this.outputLen = outputLen;
		this.enableXOF = enableXOF;
		this.rounds = rounds;
		this.pos = 0;
		this.posOut = 0;
		this.finished = false;
		this.destroyed = false;
		anumber(outputLen);
		if (0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
		this.state = new Uint8Array(200);
		this.state32 = u32(this.state);
	}
	keccak() {
		if (!isLE) byteSwap32(this.state32);
		keccakP(this.state32, this.rounds);
		if (!isLE) byteSwap32(this.state32);
		this.posOut = 0;
		this.pos = 0;
	}
	update(data) {
		aexists(this);
		const { blockLen, state: state$2 } = this;
		data = toBytes$1(data);
		const len = data.length;
		for (let pos = 0; pos < len;) {
			const take = Math.min(blockLen - this.pos, len - pos);
			for (let i$2 = 0; i$2 < take; i$2++) state$2[this.pos++] ^= data[pos++];
			if (this.pos === blockLen) this.keccak();
		}
		return this;
	}
	finish() {
		if (this.finished) return;
		this.finished = true;
		const { state: state$2, suffix, pos, blockLen } = this;
		state$2[pos] ^= suffix;
		if ((suffix & 128) !== 0 && pos === blockLen - 1) this.keccak();
		state$2[blockLen - 1] ^= 128;
		this.keccak();
	}
	writeInto(out) {
		aexists(this, false);
		abytes(out);
		this.finish();
		const bufferOut = this.state;
		const { blockLen } = this;
		for (let pos = 0, len = out.length; pos < len;) {
			if (this.posOut >= blockLen) this.keccak();
			const take = Math.min(blockLen - this.posOut, len - pos);
			out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
			this.posOut += take;
			pos += take;
		}
		return out;
	}
	xofInto(out) {
		if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
		return this.writeInto(out);
	}
	xof(bytes) {
		anumber(bytes);
		return this.xofInto(new Uint8Array(bytes));
	}
	digestInto(out) {
		aoutput(out, this);
		if (this.finished) throw new Error("digest() was already called");
		this.writeInto(out);
		this.destroy();
		return out;
	}
	digest() {
		return this.digestInto(new Uint8Array(this.outputLen));
	}
	destroy() {
		this.destroyed = true;
		this.state.fill(0);
	}
	_cloneInto(to$3) {
		const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
		to$3 || (to$3 = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
		to$3.state32.set(this.state32);
		to$3.pos = this.pos;
		to$3.posOut = this.posOut;
		to$3.finished = this.finished;
		to$3.rounds = rounds;
		to$3.suffix = suffix;
		to$3.outputLen = outputLen;
		to$3.enableXOF = enableXOF;
		to$3.destroyed = this.destroyed;
		return to$3;
	}
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */
const sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
/** SHA3-256 hash function. Different from keccak-256. */
const sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
/** SHA3-384 hash function. */
const sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
/** SHA3-512 hash function. */
const sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
/** keccak-224 hash function. */
const keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
/** keccak-256 hash function. Different from SHA3-256. */
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
/** keccak-384 hash function. */
const keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
/** keccak-512 hash function. */
const keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */
const shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
/** SHAKE256 XOF with 256-bit security. */
const shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256(value, to_) {
	const to$3 = to_ || "hex";
	const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
	if (to$3 === "bytes") return bytes;
	return toHex$1(bytes);
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/lru.js
/**
* Map with a LRU (Least recently used) policy.
*
* @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
*/
var LruMap = class extends Map {
	constructor(size$4) {
		super();
		Object.defineProperty(this, "maxSize", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		this.maxSize = size$4;
	}
	get(key) {
		const value = super.get(key);
		if (super.has(key) && value !== void 0) {
			this.delete(key);
			super.set(key, value);
		}
		return value;
	}
	set(key, value) {
		super.set(key, value);
		if (this.maxSize && this.size > this.maxSize) {
			const firstKey = this.keys().next().value;
			if (firstKey) this.delete(firstKey);
		}
		return this;
	}
};

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/getAddress.js
var checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
function checksumAddress(address_, chainId) {
	if (checksumAddressCache.has(`${address_}.${chainId}`)) return checksumAddressCache.get(`${address_}.${chainId}`);
	const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
	const hash = keccak256(stringToBytes(hexAddress), "bytes");
	const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
	for (let i$2 = 0; i$2 < 40; i$2 += 2) {
		if (hash[i$2 >> 1] >> 4 >= 8 && address[i$2]) address[i$2] = address[i$2].toUpperCase();
		if ((hash[i$2 >> 1] & 15) >= 8 && address[i$2 + 1]) address[i$2 + 1] = address[i$2 + 1].toUpperCase();
	}
	const result = `0x${address.join("")}`;
	checksumAddressCache.set(`${address_}.${chainId}`, result);
	return result;
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
/**
* @description Converts an ECDSA public key to an address.
*
* @param publicKey The public key to convert.
*
* @returns The address.
*/
function publicKeyToAddress(publicKey) {
	return checksumAddress(`0x${keccak256(`0x${publicKey.substring(4)}`).substring(26)}`);
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash, signature }) {
	const hashHex = isHex(hash) ? hash : toHex$1(hash);
	const { secp256k1 } = await import("./secp256k1-fssM-rie.js");
	return `0x${(() => {
		if (typeof signature === "object" && "r" in signature && "s" in signature) {
			const { r: r$1, s, v: v$5, yParity } = signature;
			const recoveryBit$1 = toRecoveryBit(Number(yParity ?? v$5));
			return new secp256k1.Signature(hexToBigInt(r$1), hexToBigInt(s)).addRecoveryBit(recoveryBit$1);
		}
		const signatureHex = isHex(signature) ? signature : toHex$1(signature);
		const recoveryBit = toRecoveryBit(hexToNumber(`0x${signatureHex.slice(130)}`));
		return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
	})().recoverPublicKey(hashHex.substring(2)).toHex(false)}`;
}
function toRecoveryBit(yParityOrV) {
	if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV;
	if (yParityOrV === 27) return 0;
	if (yParityOrV === 28) return 1;
	throw new Error("Invalid yParityOrV value");
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash, signature }) {
	return publicKeyToAddress(await recoverPublicKey({
		hash,
		signature
	}));
}

//#endregion
//#region node_modules/@reown/appkit/node_modules/base-x/src/esm/index.js
function base$1(ALPHABET$3) {
	if (ALPHABET$3.length >= 255) throw new TypeError("Alphabet too long");
	const BASE_MAP = new Uint8Array(256);
	for (let j$2 = 0; j$2 < BASE_MAP.length; j$2++) BASE_MAP[j$2] = 255;
	for (let i$2 = 0; i$2 < ALPHABET$3.length; i$2++) {
		const x$6 = ALPHABET$3.charAt(i$2);
		const xc$1 = x$6.charCodeAt(0);
		if (BASE_MAP[xc$1] !== 255) throw new TypeError(x$6 + " is ambiguous");
		BASE_MAP[xc$1] = i$2;
	}
	const BASE = ALPHABET$3.length;
	const LEADER = ALPHABET$3.charAt(0);
	const FACTOR = Math.log(BASE) / Math.log(256);
	const iFACTOR = Math.log(256) / Math.log(BASE);
	function encode(source) {
		if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
		else if (Array.isArray(source)) source = Uint8Array.from(source);
		if (!(source instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
		if (source.length === 0) return "";
		let zeroes = 0;
		let length = 0;
		let pbegin = 0;
		const pend = source.length;
		while (pbegin !== pend && source[pbegin] === 0) {
			pbegin++;
			zeroes++;
		}
		const size$4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
		const b58 = new Uint8Array(size$4);
		while (pbegin !== pend) {
			let carry = source[pbegin];
			let i$2 = 0;
			for (let it1 = size$4 - 1; (carry !== 0 || i$2 < length) && it1 !== -1; it1--, i$2++) {
				carry += 256 * b58[it1] >>> 0;
				b58[it1] = carry % BASE >>> 0;
				carry = carry / BASE >>> 0;
			}
			if (carry !== 0) throw new Error("Non-zero carry");
			length = i$2;
			pbegin++;
		}
		let it2 = size$4 - length;
		while (it2 !== size$4 && b58[it2] === 0) it2++;
		let str = LEADER.repeat(zeroes);
		for (; it2 < size$4; ++it2) str += ALPHABET$3.charAt(b58[it2]);
		return str;
	}
	function decodeUnsafe(source) {
		if (typeof source !== "string") throw new TypeError("Expected String");
		if (source.length === 0) return new Uint8Array();
		let psz = 0;
		let zeroes = 0;
		let length = 0;
		while (source[psz] === LEADER) {
			zeroes++;
			psz++;
		}
		const size$4 = (source.length - psz) * FACTOR + 1 >>> 0;
		const b256 = new Uint8Array(size$4);
		while (psz < source.length) {
			const charCode = source.charCodeAt(psz);
			if (charCode > 255) return;
			let carry = BASE_MAP[charCode];
			if (carry === 255) return;
			let i$2 = 0;
			for (let it3 = size$4 - 1; (carry !== 0 || i$2 < length) && it3 !== -1; it3--, i$2++) {
				carry += BASE * b256[it3] >>> 0;
				b256[it3] = carry % 256 >>> 0;
				carry = carry / 256 >>> 0;
			}
			if (carry !== 0) throw new Error("Non-zero carry");
			length = i$2;
			psz++;
		}
		let it4 = size$4 - length;
		while (it4 !== size$4 && b256[it4] === 0) it4++;
		const vch = new Uint8Array(zeroes + (size$4 - it4));
		let j$2 = zeroes;
		while (it4 !== size$4) vch[j$2++] = b256[it4++];
		return vch;
	}
	function decode(string) {
		const buffer$1 = decodeUnsafe(string);
		if (buffer$1) return buffer$1;
		throw new Error("Non-base" + BASE + " character");
	}
	return {
		encode,
		decodeUnsafe,
		decode
	};
}
var esm_default$3 = base$1;

//#endregion
//#region node_modules/@reown/appkit/node_modules/bs58/src/esm/index.js
var ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default$2 = esm_default$3(ALPHABET$1);

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var import_cjs$3 = require_cjs();
var import_cjs$4 = require_cjs$1();
var import_cjs$5 = require_cjs$2();
var import_elliptic = require_elliptic();
var Pe$2 = ":";
function Ye(e) {
	const [t, n$2] = e.split(Pe$2);
	return {
		namespace: t,
		reference: n$2
	};
}
function Be$3(e, t) {
	return e.includes(":") ? [e] : t.chains || [];
}
var Ft$2 = "ReactNative", H$1 = {
	reactNative: "react-native",
	node: "node",
	browser: "browser",
	unknown: "unknown"
}, Le$3 = " ", Gr$1 = ":", qt$2 = "/", Qe$2 = 2, Wr$1 = 1e3, Gt$2 = "js";
function et$1() {
	return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function ne$1() {
	return !(0, import_cjs$4.getDocument)() && !!(0, import_cjs$4.getNavigator)() && navigator.product === Ft$2;
}
function zr() {
	return ne$1() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function Jr() {
	return ne$1() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Ae$1() {
	return !et$1() && !!(0, import_cjs$4.getNavigator)() && !!(0, import_cjs$4.getDocument)();
}
function ue$2() {
	return ne$1() ? H$1.reactNative : et$1() ? H$1.node : Ae$1() ? H$1.browser : H$1.unknown;
}
function Yr() {
	var e;
	try {
		return ne$1() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
	} catch {
		return;
	}
}
function Wt$2(e, t) {
	const n$2 = new URLSearchParams(e);
	for (const r$1 of Object.keys(t).sort()) if (t.hasOwnProperty(r$1)) {
		const o$2 = t[r$1];
		o$2 !== void 0 && n$2.set(r$1, o$2);
	}
	return n$2.toString();
}
function Xr() {
	return (0, import_cjs$5.getWindowMetadata)() || {
		name: "",
		description: "",
		url: "",
		icons: [""]
	};
}
function zt$2() {
	if (ue$2() === H$1.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
		const { OS: n$2, Version: r$1 } = global.Platform;
		return [n$2, r$1].join("-");
	}
	const e = detect();
	if (e === null) return "unknown";
	const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
	return e.type === "browser" ? [
		t,
		e.name,
		e.version
	].join("-") : [t, e.version].join("-");
}
function Jt$2() {
	var e;
	const t = ue$2();
	return t === H$1.browser ? [t, ((e = (0, import_cjs$4.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : t;
}
function Yt$1(e, t, n$2) {
	const r$1 = zt$2(), o$2 = Jt$2();
	return [
		[e, t].join("-"),
		[Gt$2, n$2].join("-"),
		r$1,
		o$2
	].join("/");
}
function Qr({ protocol: e, version: t, relayUrl: n$2, sdkVersion: r$1, auth: o$2, projectId: s, useOnCloseEvent: i$2, bundleId: c$3, packageName: u$2 }) {
	const a$1 = n$2.split("?"), f$7 = {
		auth: o$2,
		ua: Yt$1(e, t, r$1),
		projectId: s,
		useOnCloseEvent: i$2 || void 0,
		packageName: u$2 || void 0,
		bundleId: c$3 || void 0
	}, d$4 = Wt$2(a$1[1] || "", f$7);
	return a$1[0] + "?" + d$4;
}
function re$2(e, t) {
	return e.filter((n$2) => t.includes(n$2)).length === e.length;
}
function ro(e) {
	return Object.fromEntries(e.entries());
}
function oo(e) {
	return new Map(Object.entries(e));
}
function ao(e = import_cjs$3.FIVE_MINUTES, t) {
	const n$2 = (0, import_cjs$3.toMiliseconds)(e || import_cjs$3.FIVE_MINUTES);
	let r$1, o$2, s, i$2;
	return {
		resolve: (c$3) => {
			s && r$1 && (clearTimeout(s), r$1(c$3), i$2 = Promise.resolve(c$3));
		},
		reject: (c$3) => {
			s && o$2 && (clearTimeout(s), o$2(c$3));
		},
		done: () => new Promise((c$3, u$2) => {
			if (i$2) return c$3(i$2);
			s = setTimeout(() => {
				const a$1 = new Error(t);
				i$2 = Promise.reject(a$1), u$2(a$1);
			}, n$2), r$1 = c$3, o$2 = u$2;
		})
	};
}
function uo(e, t, n$2) {
	return new Promise(async (r$1, o$2) => {
		const s = setTimeout(() => o$2(new Error(n$2)), t);
		try {
			r$1(await e);
		} catch (i$2) {
			o$2(i$2);
		}
		clearTimeout(s);
	});
}
function tt$2(e, t) {
	if (typeof t == "string" && t.startsWith(`${e}:`)) return t;
	if (e.toLowerCase() === "topic") {
		if (typeof t != "string") throw new Error("Value must be \"string\" for expirer target type: topic");
		return `topic:${t}`;
	} else if (e.toLowerCase() === "id") {
		if (typeof t != "number") throw new Error("Value must be \"number\" for expirer target type: id");
		return `id:${t}`;
	}
	throw new Error(`Unknown expirer target type: ${e}`);
}
function fo(e) {
	return tt$2("topic", e);
}
function lo(e) {
	return tt$2("id", e);
}
function ho(e) {
	const [t, n$2] = e.split(":"), r$1 = {
		id: void 0,
		topic: void 0
	};
	if (t === "topic" && typeof n$2 == "string") r$1.topic = n$2;
	else if (t === "id" && Number.isInteger(Number(n$2))) r$1.id = Number(n$2);
	else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n$2}`);
	return r$1;
}
function po(e, t) {
	return (0, import_cjs$3.fromMiliseconds)((t || Date.now()) + (0, import_cjs$3.toMiliseconds)(e));
}
function go(e) {
	return Date.now() >= (0, import_cjs$3.toMiliseconds)(e);
}
function yo(e, t) {
	return `${e}${t ? `:${t}` : ""}`;
}
function Q(e = [], t = []) {
	return [...new Set([...e, ...t])];
}
async function mo({ id: e, topic: t, wcDeepLink: n$2 }) {
	var r$1;
	try {
		if (!n$2) return;
		const s = (typeof n$2 == "string" ? JSON.parse(n$2) : n$2)?.href;
		if (typeof s != "string") return;
		const i$2 = en$1(s, e, t), c$3 = ue$2();
		if (c$3 === H$1.browser) {
			if (!((r$1 = (0, import_cjs$4.getDocument)()) != null && r$1.hasFocus())) {
				console.warn("Document does not have focus, skipping deeplink.");
				return;
			}
			tn$1(i$2);
		} else c$3 === H$1.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i$2);
	} catch (o$2) {
		console.error(o$2);
	}
}
function en$1(e, t, n$2) {
	const r$1 = `requestId=${t}&sessionTopic=${n$2}`;
	e.endsWith("/") && (e = e.slice(0, -1));
	let o$2 = `${e}`;
	if (e.startsWith("https://t.me")) {
		const s = e.includes("?") ? "&startapp=" : "?startapp=";
		o$2 = `${o$2}${s}${on$1(r$1, !0)}`;
	} else o$2 = `${o$2}/wc?${r$1}`;
	return o$2;
}
function tn$1(e) {
	let t = "_self";
	rn$1() ? t = "_top" : (nn$1() || e.startsWith("https://") || e.startsWith("http://")) && (t = "_blank"), window.open(e, t, "noreferrer noopener");
}
async function bo(e, t) {
	let n$2 = "";
	try {
		if (Ae$1() && (n$2 = localStorage.getItem(t), n$2)) return n$2;
		n$2 = await e.getItem(t);
	} catch (r$1) {
		console.error(r$1);
	}
	return n$2;
}
function wo(e, t) {
	if (!e.includes(t)) return null;
	const n$2 = e.split(/([&,?,=])/);
	return n$2[n$2.indexOf(t) + 2];
}
function Eo() {
	return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
		const t = Math.random() * 16 | 0;
		return (e === "x" ? t : t & 3 | 8).toString(16);
	});
}
function vo() {
	return typeof process < "u" && process.env.IS_VITEST === "true";
}
function nn$1() {
	return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function rn$1() {
	try {
		return window.self !== window.top;
	} catch {
		return !1;
	}
}
function on$1(e, t = !1) {
	const n$2 = Buffer.from(e).toString("base64");
	return t ? n$2.replace(/[=]/g, "") : n$2;
}
function rt$1(e) {
	return Buffer.from(e, "base64").toString("utf-8");
}
function xo(e) {
	return new Promise((t) => setTimeout(t, e));
}
function Ne$1(e) {
	if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function Io$1(e) {
	return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function je$2(e, ...t) {
	if (!Io$1(e)) throw new Error("Uint8Array expected");
	if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function ot$1(e) {
	if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
	Ne$1(e.outputLen), Ne$1(e.blockLen);
}
function me$2(e, t = !0) {
	if (e.destroyed) throw new Error("Hash instance has been destroyed");
	if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function sn$2(e, t) {
	je$2(e);
	const n$2 = t.outputLen;
	if (e.length < n$2) throw new Error("digestInto() expects output buffer of length at least " + n$2);
}
var Ce$2 = BigInt(2 ** 32 - 1), cn$1 = BigInt(32);
function Oo$1(e, t = !1) {
	return t ? {
		h: Number(e & Ce$2),
		l: Number(e >> cn$1 & Ce$2)
	} : {
		h: Number(e >> cn$1 & Ce$2) | 0,
		l: Number(e & Ce$2) | 0
	};
}
function Ao$1(e, t = !1) {
	let n$2 = new Uint32Array(e.length), r$1 = new Uint32Array(e.length);
	for (let o$2 = 0; o$2 < e.length; o$2++) {
		const { h: s, l: i$2 } = Oo$1(e[o$2], t);
		[n$2[o$2], r$1[o$2]] = [s, i$2];
	}
	return [n$2, r$1];
}
var No$1 = (e, t, n$2) => e << n$2 | t >>> 32 - n$2, So$1 = (e, t, n$2) => t << n$2 | e >>> 32 - n$2, Uo$1 = (e, t, n$2) => t << n$2 - 32 | e >>> 64 - n$2, _o$1 = (e, t, n$2) => e << n$2 - 32 | t >>> 64 - n$2, be$2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function To$1(e) {
	return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
}
function st$1(e) {
	return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function J$3(e, t) {
	return e << 32 - t | e >>> t;
}
var an$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function $o$1(e) {
	return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
}
function un$1(e) {
	for (let t = 0; t < e.length; t++) e[t] = $o$1(e[t]);
}
function Ro$1(e) {
	if (typeof e != "string") throw new Error("utf8ToBytes expected string, got " + typeof e);
	return new Uint8Array(new TextEncoder().encode(e));
}
function we$2(e) {
	return typeof e == "string" && (e = Ro$1(e)), je$2(e), e;
}
var it$2 = class {
	clone() {
		return this._cloneInto();
	}
};
function fn$1(e) {
	const t = (r$1) => e().update(we$2(r$1)).digest(), n$2 = e();
	return t.outputLen = n$2.outputLen, t.blockLen = n$2.blockLen, t.create = () => e(), t;
}
function Se$2(e = 32) {
	if (be$2 && typeof be$2.getRandomValues == "function") return be$2.getRandomValues(new Uint8Array(e));
	if (be$2 && typeof be$2.randomBytes == "function") return be$2.randomBytes(e);
	throw new Error("crypto.getRandomValues must be defined");
}
var ln$1 = [], dn$1 = [], hn$1 = [], Po$1 = BigInt(0), Ue$3 = BigInt(1), Bo$1 = BigInt(2), Lo$1 = BigInt(7), jo$1 = BigInt(256), Co$1 = BigInt(113);
for (let e = 0, t = Ue$3, n$2 = 1, r$1 = 0; e < 24; e++) {
	[n$2, r$1] = [r$1, (2 * n$2 + 3 * r$1) % 5], ln$1.push(2 * (5 * r$1 + n$2)), dn$1.push((e + 1) * (e + 2) / 2 % 64);
	let o$2 = Po$1;
	for (let s = 0; s < 7; s++) t = (t << Ue$3 ^ (t >> Lo$1) * Co$1) % jo$1, t & Bo$1 && (o$2 ^= Ue$3 << (Ue$3 << BigInt(s)) - Ue$3);
	hn$1.push(o$2);
}
var [ko$1, Do$1] = Ao$1(hn$1, !0), pn$1 = (e, t, n$2) => n$2 > 32 ? Uo$1(e, t, n$2) : No$1(e, t, n$2), gn$1 = (e, t, n$2) => n$2 > 32 ? _o$1(e, t, n$2) : So$1(e, t, n$2);
function Mo$1(e, t = 24) {
	const n$2 = new Uint32Array(10);
	for (let r$1 = 24 - t; r$1 < 24; r$1++) {
		for (let i$2 = 0; i$2 < 10; i$2++) n$2[i$2] = e[i$2] ^ e[i$2 + 10] ^ e[i$2 + 20] ^ e[i$2 + 30] ^ e[i$2 + 40];
		for (let i$2 = 0; i$2 < 10; i$2 += 2) {
			const c$3 = (i$2 + 8) % 10, u$2 = (i$2 + 2) % 10, a$1 = n$2[u$2], l$2 = n$2[u$2 + 1], f$7 = pn$1(a$1, l$2, 1) ^ n$2[c$3], d$4 = gn$1(a$1, l$2, 1) ^ n$2[c$3 + 1];
			for (let g$2 = 0; g$2 < 50; g$2 += 10) e[i$2 + g$2] ^= f$7, e[i$2 + g$2 + 1] ^= d$4;
		}
		let o$2 = e[2], s = e[3];
		for (let i$2 = 0; i$2 < 24; i$2++) {
			const c$3 = dn$1[i$2], u$2 = pn$1(o$2, s, c$3), a$1 = gn$1(o$2, s, c$3), l$2 = ln$1[i$2];
			o$2 = e[l$2], s = e[l$2 + 1], e[l$2] = u$2, e[l$2 + 1] = a$1;
		}
		for (let i$2 = 0; i$2 < 50; i$2 += 10) {
			for (let c$3 = 0; c$3 < 10; c$3++) n$2[c$3] = e[i$2 + c$3];
			for (let c$3 = 0; c$3 < 10; c$3++) e[i$2 + c$3] ^= ~n$2[(c$3 + 2) % 10] & n$2[(c$3 + 4) % 10];
		}
		e[0] ^= ko$1[r$1], e[1] ^= Do$1[r$1];
	}
	n$2.fill(0);
}
var Lt$2 = class Lt$2 extends it$2 {
	constructor(t, n$2, r$1, o$2 = !1, s = 24) {
		if (super(), this.blockLen = t, this.suffix = n$2, this.outputLen = r$1, this.enableXOF = o$2, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Ne$1(r$1), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
		this.state = new Uint8Array(200), this.state32 = To$1(this.state);
	}
	keccak() {
		an$1 || un$1(this.state32), Mo$1(this.state32, this.rounds), an$1 || un$1(this.state32), this.posOut = 0, this.pos = 0;
	}
	update(t) {
		me$2(this);
		const { blockLen: n$2, state: r$1 } = this;
		t = we$2(t);
		const o$2 = t.length;
		for (let s = 0; s < o$2;) {
			const i$2 = Math.min(n$2 - this.pos, o$2 - s);
			for (let c$3 = 0; c$3 < i$2; c$3++) r$1[this.pos++] ^= t[s++];
			this.pos === n$2 && this.keccak();
		}
		return this;
	}
	finish() {
		if (this.finished) return;
		this.finished = !0;
		const { state: t, suffix: n$2, pos: r$1, blockLen: o$2 } = this;
		t[r$1] ^= n$2, n$2 & 128 && r$1 === o$2 - 1 && this.keccak(), t[o$2 - 1] ^= 128, this.keccak();
	}
	writeInto(t) {
		me$2(this, !1), je$2(t), this.finish();
		const n$2 = this.state, { blockLen: r$1 } = this;
		for (let o$2 = 0, s = t.length; o$2 < s;) {
			this.posOut >= r$1 && this.keccak();
			const i$2 = Math.min(r$1 - this.posOut, s - o$2);
			t.set(n$2.subarray(this.posOut, this.posOut + i$2), o$2), this.posOut += i$2, o$2 += i$2;
		}
		return t;
	}
	xofInto(t) {
		if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
		return this.writeInto(t);
	}
	xof(t) {
		return Ne$1(t), this.xofInto(new Uint8Array(t));
	}
	digestInto(t) {
		if (sn$2(t, this), this.finished) throw new Error("digest() was already called");
		return this.writeInto(t), this.destroy(), t;
	}
	digest() {
		return this.digestInto(new Uint8Array(this.outputLen));
	}
	destroy() {
		this.destroyed = !0, this.state.fill(0);
	}
	_cloneInto(t) {
		const { blockLen: n$2, suffix: r$1, outputLen: o$2, rounds: s, enableXOF: i$2 } = this;
		return t || (t = new Lt$2(n$2, r$1, o$2, i$2, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = r$1, t.outputLen = o$2, t.enableXOF = i$2, t.destroyed = this.destroyed, t;
	}
};
var Vo$1 = (e, t, n$2) => fn$1(() => new Lt$2(t, e, n$2)), Ho$1 = Vo$1(1, 136, 256 / 8), Ko$1 = "https://rpc.walletconnect.org/v1";
function ct$1(e) {
	const t = `Ethereum Signed Message:
${e.length}`, n$2 = new TextEncoder().encode(t + e);
	return "0x" + Buffer.from(Ho$1(n$2)).toString("hex");
}
async function yn(e, t, n$2, r$1, o$2, s) {
	switch (n$2.t) {
		case "eip191": return await mn$1(e, t, n$2.s);
		case "eip1271": return await bn$1(e, t, n$2.s, r$1, o$2, s);
		default: throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n$2.t}`);
	}
}
async function mn$1(e, t, n$2) {
	return (await recoverAddress({
		hash: ct$1(t),
		signature: n$2
	})).toLowerCase() === e.toLowerCase();
}
async function bn$1(e, t, n$2, r$1, o$2, s) {
	const i$2 = Ye(r$1);
	if (!i$2.namespace || !i$2.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r$1}`);
	try {
		const c$3 = "0x1626ba7e", u$2 = "0000000000000000000000000000000000000000000000000000000000000040", a$1 = "0000000000000000000000000000000000000000000000000000000000000041", l$2 = n$2.substring(2), d$4 = c$3 + ct$1(t).substring(2) + u$2 + a$1 + l$2, { result: y$6 } = await (await fetch(`${s || Ko$1}/?chainId=${r$1}&projectId=${o$2}`, {
			method: "POST",
			body: JSON.stringify({
				id: Fo$1(),
				jsonrpc: "2.0",
				method: "eth_call",
				params: [{
					to: e,
					data: d$4
				}, "latest"]
			})
		})).json();
		return y$6 ? y$6.slice(0, 10).toLowerCase() === c$3.toLowerCase() : !1;
	} catch (c$3) {
		return console.error("isValidEip1271Signature: ", c$3), !1;
	}
}
function Fo$1() {
	return Date.now() + Math.floor(Math.random() * 1e3);
}
function qo(e) {
	const t = atob(e), n$2 = new Uint8Array(t.length);
	for (let i$2 = 0; i$2 < t.length; i$2++) n$2[i$2] = t.charCodeAt(i$2);
	const r$1 = n$2[0];
	if (r$1 === 0) throw new Error("No signatures found");
	const o$2 = 1 + r$1 * 64;
	if (n$2.length < o$2) throw new Error("Transaction data too short for claimed signature count");
	if (n$2.length < 100) throw new Error("Transaction too short");
	const s = Buffer.from(e, "base64").slice(1, 65);
	return esm_default$2.encode(s);
}
var Go$1 = Object.defineProperty, Wo$1 = Object.defineProperties, zo$1 = Object.getOwnPropertyDescriptors, wn$1 = Object.getOwnPropertySymbols, Jo$1 = Object.prototype.hasOwnProperty, Yo$1 = Object.prototype.propertyIsEnumerable, En$1 = (e, t, n$2) => t in e ? Go$1(e, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: n$2
}) : e[t] = n$2, at$1 = (e, t) => {
	for (var n$2 in t || (t = {})) Jo$1.call(t, n$2) && En$1(e, n$2, t[n$2]);
	if (wn$1) for (var n$2 of wn$1(t)) Yo$1.call(t, n$2) && En$1(e, n$2, t[n$2]);
	return e;
}, vn$1 = (e, t) => Wo$1(e, zo$1(t));
var Xo = "did:pkh:", ke$3 = (e) => e?.split(":"), xn$1 = (e) => {
	const t = e && ke$3(e);
	if (t) return e.includes(Xo) ? t[3] : t[1];
}, In = (e) => {
	const t = e && ke$3(e);
	if (t) return t[2] + ":" + t[3];
}, ut$1 = (e) => {
	const t = e && ke$3(e);
	if (t) return t.pop();
};
async function Zo(e) {
	const { cacao: t, projectId: n$2 } = e, { s: r$1, p: o$2 } = t, s = On(o$2, o$2.iss);
	return await yn(ut$1(o$2.iss), s, r$1, In(o$2.iss), n$2);
}
var On = (e, t) => {
	const n$2 = `${e.domain} wants you to sign in with your Ethereum account:`, r$1 = ut$1(t);
	if (!e.aud && !e.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
	let o$2 = e.statement || void 0;
	const s = `URI: ${e.aud || e.uri}`, i$2 = `Version: ${e.version}`, c$3 = `Chain ID: ${xn$1(t)}`, u$2 = `Nonce: ${e.nonce}`, a$1 = `Issued At: ${e.iat}`, l$2 = e.exp ? `Expiration Time: ${e.exp}` : void 0, f$7 = e.nbf ? `Not Before: ${e.nbf}` : void 0, d$4 = e.requestId ? `Request ID: ${e.requestId}` : void 0, g$2 = e.resources ? `Resources:${e.resources.map((h$4) => `
- ${h$4}`).join("")}` : void 0, y$6 = Me$1(e.resources);
	if (y$6) {
		const h$4 = oe$1(y$6);
		o$2 = dt$2(o$2, h$4);
	}
	return [
		n$2,
		r$1,
		"",
		o$2,
		"",
		s,
		i$2,
		c$3,
		u$2,
		a$1,
		l$2,
		f$7,
		d$4,
		g$2
	].filter((h$4) => h$4 != null).join(`
`);
};
function Un$1(e) {
	return Buffer.from(JSON.stringify(e)).toString("base64");
}
function _n$1(e) {
	return JSON.parse(Buffer.from(e, "base64").toString("utf-8"));
}
function Y$1(e) {
	if (!e) throw new Error("No recap provided, value is undefined");
	if (!e.att) throw new Error("No `att` property found");
	const t = Object.keys(e.att);
	if (!(t != null && t.length)) throw new Error("No resources found in `att` property");
	t.forEach((n$2) => {
		const r$1 = e.att[n$2];
		if (Array.isArray(r$1)) throw new Error(`Resource must be an object: ${n$2}`);
		if (typeof r$1 != "object") throw new Error(`Resource must be an object: ${n$2}`);
		if (!Object.keys(r$1).length) throw new Error(`Resource object is empty: ${n$2}`);
		Object.keys(r$1).forEach((o$2) => {
			const s = r$1[o$2];
			if (!Array.isArray(s)) throw new Error(`Ability limits ${o$2} must be an array of objects, found: ${s}`);
			if (!s.length) throw new Error(`Value of ${o$2} is empty array, must be an array with objects`);
			s.forEach((i$2) => {
				if (typeof i$2 != "object") throw new Error(`Ability limits (${o$2}) must be an array of objects, found: ${i$2}`);
			});
		});
	});
}
function Tn$1(e, t, n$2, r$1 = {}) {
	return n$2?.sort((o$2, s) => o$2.localeCompare(s)), { att: { [e]: ft$2(t, n$2, r$1) } };
}
function ft$2(e, t, n$2 = {}) {
	t = t?.sort((o$2, s) => o$2.localeCompare(s));
	const r$1 = t.map((o$2) => ({ [`${e}/${o$2}`]: [n$2] }));
	return Object.assign({}, ...r$1);
}
function De$2(e) {
	return Y$1(e), `urn:recap:${Un$1(e).replace(/=/g, "")}`;
}
function oe$1(e) {
	const t = _n$1(e.replace("urn:recap:", ""));
	return Y$1(t), t;
}
function rs(e, t, n$2) {
	return De$2(Tn$1(e, t, n$2));
}
function lt$1(e) {
	return e && e.includes("urn:recap:");
}
function os(e, t) {
	return De$2(Rn$1(oe$1(e), oe$1(t)));
}
function Rn$1(e, t) {
	Y$1(e), Y$1(t);
	const n$2 = Object.keys(e.att).concat(Object.keys(t.att)).sort((o$2, s) => o$2.localeCompare(s)), r$1 = { att: {} };
	return n$2.forEach((o$2) => {
		var s, i$2;
		Object.keys(((s = e.att) == null ? void 0 : s[o$2]) || {}).concat(Object.keys(((i$2 = t.att) == null ? void 0 : i$2[o$2]) || {})).sort((c$3, u$2) => c$3.localeCompare(u$2)).forEach((c$3) => {
			var u$2, a$1;
			r$1.att[o$2] = vn$1(at$1({}, r$1.att[o$2]), { [c$3]: ((u$2 = e.att[o$2]) == null ? void 0 : u$2[c$3]) || ((a$1 = t.att[o$2]) == null ? void 0 : a$1[c$3]) });
		});
	}), r$1;
}
function dt$2(e = "", t) {
	Y$1(t);
	const n$2 = "I further authorize the stated URI to perform the following actions on my behalf: ";
	if (e.includes(n$2)) return e;
	const r$1 = [];
	let o$2 = 0;
	Object.keys(t.att).forEach((c$3) => {
		const u$2 = Object.keys(t.att[c$3]).map((f$7) => ({
			ability: f$7.split("/")[0],
			action: f$7.split("/")[1]
		}));
		u$2.sort((f$7, d$4) => f$7.action.localeCompare(d$4.action));
		const a$1 = {};
		u$2.forEach((f$7) => {
			a$1[f$7.ability] || (a$1[f$7.ability] = []), a$1[f$7.ability].push(f$7.action);
		});
		const l$2 = Object.keys(a$1).map((f$7) => (o$2++, `(${o$2}) '${f$7}': '${a$1[f$7].join("', '")}' for '${c$3}'.`));
		r$1.push(l$2.join(", ").replace(".,", "."));
	});
	const i$2 = `${n$2}${r$1.join(" ")}`;
	return `${e ? e + " " : ""}${i$2}`;
}
function ss(e) {
	var t;
	const n$2 = oe$1(e);
	Y$1(n$2);
	const r$1 = (t = n$2.att) == null ? void 0 : t.eip155;
	return r$1 ? Object.keys(r$1).map((o$2) => o$2.split("/")[1]) : [];
}
function is(e) {
	const t = oe$1(e);
	Y$1(t);
	const n$2 = [];
	return Object.values(t.att).forEach((r$1) => {
		Object.values(r$1).forEach((o$2) => {
			var s;
			(s = o$2?.[0]) != null && s.chains && n$2.push(o$2[0].chains);
		});
	}), [...new Set(n$2.flat())];
}
function Me$1(e) {
	if (!e) return;
	const t = e?.[e.length - 1];
	return lt$1(t) ? t : void 0;
}
function ht$2(e) {
	if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function Bn$1(e) {
	return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function F$2(e, ...t) {
	if (!Bn$1(e)) throw new Error("Uint8Array expected");
	if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function Ln$1(e, t = !0) {
	if (e.destroyed) throw new Error("Hash instance has been destroyed");
	if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function cs$1(e, t) {
	F$2(e);
	const n$2 = t.outputLen;
	if (e.length < n$2) throw new Error("digestInto() expects output buffer of length at least " + n$2);
}
function jn$1(e) {
	if (typeof e != "boolean") throw new Error(`boolean expected, not ${e}`);
}
var se$2 = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), as = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
if (!(new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)) throw new Error("Non little-endian hardware is not supported");
function fs$1(e) {
	if (typeof e != "string") throw new Error("string expected");
	return new Uint8Array(new TextEncoder().encode(e));
}
function pt$2(e) {
	if (typeof e == "string") e = fs$1(e);
	else if (Bn$1(e)) e = gt$2(e);
	else throw new Error("Uint8Array expected, got " + typeof e);
	return e;
}
function ls$1(e, t) {
	if (t == null || typeof t != "object") throw new Error("options must be defined");
	return Object.assign(e, t);
}
function ds(e, t) {
	if (e.length !== t.length) return !1;
	let n$2 = 0;
	for (let r$1 = 0; r$1 < e.length; r$1++) n$2 |= e[r$1] ^ t[r$1];
	return n$2 === 0;
}
var hs = (e, t) => {
	function n$2(r$1, ...o$2) {
		if (F$2(r$1), e.nonceLength !== void 0) {
			const l$2 = o$2[0];
			if (!l$2) throw new Error("nonce / iv required");
			e.varSizeNonce ? F$2(l$2) : F$2(l$2, e.nonceLength);
		}
		const s = e.tagLength;
		s && o$2[1] !== void 0 && F$2(o$2[1]);
		const i$2 = t(r$1, ...o$2), c$3 = (l$2, f$7) => {
			if (f$7 !== void 0) {
				if (l$2 !== 2) throw new Error("cipher output not supported");
				F$2(f$7);
			}
		};
		let u$2 = !1;
		return {
			encrypt(l$2, f$7) {
				if (u$2) throw new Error("cannot encrypt() twice with same key + nonce");
				return u$2 = !0, F$2(l$2), c$3(i$2.encrypt.length, f$7), i$2.encrypt(l$2, f$7);
			},
			decrypt(l$2, f$7) {
				if (F$2(l$2), s && l$2.length < s) throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
				return c$3(i$2.decrypt.length, f$7), i$2.decrypt(l$2, f$7);
			}
		};
	}
	return Object.assign(n$2, e), n$2;
};
function Cn$1(e, t, n$2 = !0) {
	if (t === void 0) return new Uint8Array(e);
	if (t.length !== e) throw new Error("invalid output length, expected " + e + ", got: " + t.length);
	if (n$2 && !ps$1(t)) throw new Error("invalid output, must be aligned");
	return t;
}
function kn$1(e, t, n$2, r$1) {
	if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n$2, r$1);
	const o$2 = BigInt(32), s = BigInt(4294967295), i$2 = Number(n$2 >> o$2 & s), c$3 = Number(n$2 & s), u$2 = r$1 ? 4 : 0, a$1 = r$1 ? 0 : 4;
	e.setUint32(t + u$2, i$2, r$1), e.setUint32(t + a$1, c$3, r$1);
}
function ps$1(e) {
	return e.byteOffset % 4 === 0;
}
function gt$2(e) {
	return Uint8Array.from(e);
}
function Ee$3(...e) {
	for (let t = 0; t < e.length; t++) e[t].fill(0);
}
var Dn$1 = (e) => Uint8Array.from(e.split("").map((t) => t.charCodeAt(0))), gs = Dn$1("expand 16-byte k"), ys$1 = Dn$1("expand 32-byte k"), ms$1 = se$2(gs), bs$1 = se$2(ys$1);
function x$1(e, t) {
	return e << t | e >>> 32 - t;
}
function yt$2(e) {
	return e.byteOffset % 4 === 0;
}
var Ve$2 = 64, ws$1 = 16, Mn$1 = 2 ** 32 - 1, Vn$1 = new Uint32Array();
function Es$1(e, t, n$2, r$1, o$2, s, i$2, c$3) {
	const u$2 = o$2.length, a$1 = new Uint8Array(Ve$2), l$2 = se$2(a$1), f$7 = yt$2(o$2) && yt$2(s), d$4 = f$7 ? se$2(o$2) : Vn$1, g$2 = f$7 ? se$2(s) : Vn$1;
	for (let y$6 = 0; y$6 < u$2; i$2++) {
		if (e(t, n$2, r$1, l$2, i$2, c$3), i$2 >= Mn$1) throw new Error("arx: counter overflow");
		const h$4 = Math.min(Ve$2, u$2 - y$6);
		if (f$7 && h$4 === Ve$2) {
			const m$2 = y$6 / 4;
			if (y$6 % 4 !== 0) throw new Error("arx: invalid block position");
			for (let L$4 = 0, b$3; L$4 < ws$1; L$4++) b$3 = m$2 + L$4, g$2[b$3] = d$4[b$3] ^ l$2[L$4];
			y$6 += Ve$2;
			continue;
		}
		for (let m$2 = 0, L$4; m$2 < h$4; m$2++) L$4 = y$6 + m$2, s[L$4] = o$2[L$4] ^ a$1[m$2];
		y$6 += h$4;
	}
}
function vs$1(e, t) {
	const { allowShortKeys: n$2, extendNonceFn: r$1, counterLength: o$2, counterRight: s, rounds: i$2 } = ls$1({
		allowShortKeys: !1,
		counterLength: 8,
		counterRight: !1,
		rounds: 20
	}, t);
	if (typeof e != "function") throw new Error("core must be a function");
	return ht$2(o$2), ht$2(i$2), jn$1(s), jn$1(n$2), (c$3, u$2, a$1, l$2, f$7 = 0) => {
		F$2(c$3), F$2(u$2), F$2(a$1);
		const d$4 = a$1.length;
		if (l$2 === void 0 && (l$2 = new Uint8Array(d$4)), F$2(l$2), ht$2(f$7), f$7 < 0 || f$7 >= Mn$1) throw new Error("arx: counter overflow");
		if (l$2.length < d$4) throw new Error(`arx: output (${l$2.length}) is shorter than data (${d$4})`);
		const g$2 = [];
		let y$6 = c$3.length, h$4, m$2;
		if (y$6 === 32) g$2.push(h$4 = gt$2(c$3)), m$2 = bs$1;
		else if (y$6 === 16 && n$2) h$4 = new Uint8Array(32), h$4.set(c$3), h$4.set(c$3, 16), m$2 = ms$1, g$2.push(h$4);
		else throw new Error(`arx: invalid 32-byte key, got length=${y$6}`);
		yt$2(u$2) || g$2.push(u$2 = gt$2(u$2));
		const L$4 = se$2(h$4);
		if (r$1) {
			if (u$2.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
			r$1(m$2, L$4, se$2(u$2.subarray(0, 16)), L$4), u$2 = u$2.subarray(16);
		}
		const b$3 = 16 - o$2;
		if (b$3 !== u$2.length) throw new Error(`arx: nonce must be ${b$3} or 16 bytes`);
		if (b$3 !== 12) {
			const O$5 = new Uint8Array(12);
			O$5.set(u$2, s ? 0 : 12 - u$2.length), u$2 = O$5, g$2.push(u$2);
		}
		const _$4 = se$2(u$2);
		return Es$1(e, m$2, L$4, _$4, a$1, l$2, f$7, i$2), Ee$3(...g$2), l$2;
	};
}
var M$2 = (e, t) => e[t++] & 255 | (e[t++] & 255) << 8;
var xs$1 = class {
	constructor(t) {
		this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, t = pt$2(t), F$2(t, 32);
		const n$2 = M$2(t, 0), r$1 = M$2(t, 2), o$2 = M$2(t, 4), s = M$2(t, 6), i$2 = M$2(t, 8), c$3 = M$2(t, 10), u$2 = M$2(t, 12), a$1 = M$2(t, 14);
		this.r[0] = n$2 & 8191, this.r[1] = (n$2 >>> 13 | r$1 << 3) & 8191, this.r[2] = (r$1 >>> 10 | o$2 << 6) & 7939, this.r[3] = (o$2 >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | i$2 << 12) & 255, this.r[5] = i$2 >>> 1 & 8190, this.r[6] = (i$2 >>> 14 | c$3 << 2) & 8191, this.r[7] = (c$3 >>> 11 | u$2 << 5) & 8065, this.r[8] = (u$2 >>> 8 | a$1 << 8) & 8191, this.r[9] = a$1 >>> 5 & 127;
		for (let l$2 = 0; l$2 < 8; l$2++) this.pad[l$2] = M$2(t, 16 + 2 * l$2);
	}
	process(t, n$2, r$1 = !1) {
		const o$2 = r$1 ? 0 : 2048, { h: s, r: i$2 } = this, c$3 = i$2[0], u$2 = i$2[1], a$1 = i$2[2], l$2 = i$2[3], f$7 = i$2[4], d$4 = i$2[5], g$2 = i$2[6], y$6 = i$2[7], h$4 = i$2[8], m$2 = i$2[9], L$4 = M$2(t, n$2 + 0), b$3 = M$2(t, n$2 + 2), _$4 = M$2(t, n$2 + 4), O$5 = M$2(t, n$2 + 6), k$5 = M$2(t, n$2 + 8), E$6 = M$2(t, n$2 + 10), B$4 = M$2(t, n$2 + 12), j$2 = M$2(t, n$2 + 14);
		let v$5 = s[0] + (L$4 & 8191), I$4 = s[1] + ((L$4 >>> 13 | b$3 << 3) & 8191), w$3 = s[2] + ((b$3 >>> 10 | _$4 << 6) & 8191), R$5 = s[3] + ((_$4 >>> 7 | O$5 << 9) & 8191), A$5 = s[4] + ((O$5 >>> 4 | k$5 << 12) & 8191), T$3 = s[5] + (k$5 >>> 1 & 8191), N$4 = s[6] + ((k$5 >>> 14 | E$6 << 2) & 8191), S$6 = s[7] + ((E$6 >>> 11 | B$4 << 5) & 8191), U$1 = s[8] + ((B$4 >>> 8 | j$2 << 8) & 8191), $$6 = s[9] + (j$2 >>> 5 | o$2), p$5 = 0, C$6 = p$5 + v$5 * c$3 + I$4 * (5 * m$2) + w$3 * (5 * h$4) + R$5 * (5 * y$6) + A$5 * (5 * g$2);
		p$5 = C$6 >>> 13, C$6 &= 8191, C$6 += T$3 * (5 * d$4) + N$4 * (5 * f$7) + S$6 * (5 * l$2) + U$1 * (5 * a$1) + $$6 * (5 * u$2), p$5 += C$6 >>> 13, C$6 &= 8191;
		let D$3 = p$5 + v$5 * u$2 + I$4 * c$3 + w$3 * (5 * m$2) + R$5 * (5 * h$4) + A$5 * (5 * y$6);
		p$5 = D$3 >>> 13, D$3 &= 8191, D$3 += T$3 * (5 * g$2) + N$4 * (5 * d$4) + S$6 * (5 * f$7) + U$1 * (5 * l$2) + $$6 * (5 * a$1), p$5 += D$3 >>> 13, D$3 &= 8191;
		let P$5 = p$5 + v$5 * a$1 + I$4 * u$2 + w$3 * c$3 + R$5 * (5 * m$2) + A$5 * (5 * h$4);
		p$5 = P$5 >>> 13, P$5 &= 8191, P$5 += T$3 * (5 * y$6) + N$4 * (5 * g$2) + S$6 * (5 * d$4) + U$1 * (5 * f$7) + $$6 * (5 * l$2), p$5 += P$5 >>> 13, P$5 &= 8191;
		let G$4 = p$5 + v$5 * l$2 + I$4 * a$1 + w$3 * u$2 + R$5 * c$3 + A$5 * (5 * m$2);
		p$5 = G$4 >>> 13, G$4 &= 8191, G$4 += T$3 * (5 * h$4) + N$4 * (5 * y$6) + S$6 * (5 * g$2) + U$1 * (5 * d$4) + $$6 * (5 * f$7), p$5 += G$4 >>> 13, G$4 &= 8191;
		let X$1 = p$5 + v$5 * f$7 + I$4 * l$2 + w$3 * a$1 + R$5 * u$2 + A$5 * c$3;
		p$5 = X$1 >>> 13, X$1 &= 8191, X$1 += T$3 * (5 * m$2) + N$4 * (5 * h$4) + S$6 * (5 * y$6) + U$1 * (5 * g$2) + $$6 * (5 * d$4), p$5 += X$1 >>> 13, X$1 &= 8191;
		let Z$3 = p$5 + v$5 * d$4 + I$4 * f$7 + w$3 * l$2 + R$5 * a$1 + A$5 * u$2;
		p$5 = Z$3 >>> 13, Z$3 &= 8191, Z$3 += T$3 * c$3 + N$4 * (5 * m$2) + S$6 * (5 * h$4) + U$1 * (5 * y$6) + $$6 * (5 * g$2), p$5 += Z$3 >>> 13, Z$3 &= 8191;
		let he$4 = p$5 + v$5 * g$2 + I$4 * d$4 + w$3 * f$7 + R$5 * l$2 + A$5 * a$1;
		p$5 = he$4 >>> 13, he$4 &= 8191, he$4 += T$3 * u$2 + N$4 * c$3 + S$6 * (5 * m$2) + U$1 * (5 * h$4) + $$6 * (5 * y$6), p$5 += he$4 >>> 13, he$4 &= 8191;
		let pe$4 = p$5 + v$5 * y$6 + I$4 * g$2 + w$3 * d$4 + R$5 * f$7 + A$5 * l$2;
		p$5 = pe$4 >>> 13, pe$4 &= 8191, pe$4 += T$3 * a$1 + N$4 * u$2 + S$6 * c$3 + U$1 * (5 * m$2) + $$6 * (5 * h$4), p$5 += pe$4 >>> 13, pe$4 &= 8191;
		let ge$2 = p$5 + v$5 * h$4 + I$4 * y$6 + w$3 * g$2 + R$5 * d$4 + A$5 * f$7;
		p$5 = ge$2 >>> 13, ge$2 &= 8191, ge$2 += T$3 * l$2 + N$4 * a$1 + S$6 * u$2 + U$1 * c$3 + $$6 * (5 * m$2), p$5 += ge$2 >>> 13, ge$2 &= 8191;
		let ye$4 = p$5 + v$5 * m$2 + I$4 * h$4 + w$3 * y$6 + R$5 * g$2 + A$5 * d$4;
		p$5 = ye$4 >>> 13, ye$4 &= 8191, ye$4 += T$3 * f$7 + N$4 * l$2 + S$6 * a$1 + U$1 * u$2 + $$6 * c$3, p$5 += ye$4 >>> 13, ye$4 &= 8191, p$5 = (p$5 << 2) + p$5 | 0, p$5 = p$5 + C$6 | 0, C$6 = p$5 & 8191, p$5 = p$5 >>> 13, D$3 += p$5, s[0] = C$6, s[1] = D$3, s[2] = P$5, s[3] = G$4, s[4] = X$1, s[5] = Z$3, s[6] = he$4, s[7] = pe$4, s[8] = ge$2, s[9] = ye$4;
	}
	finalize() {
		const { h: t, pad: n$2 } = this, r$1 = new Uint16Array(10);
		let o$2 = t[1] >>> 13;
		t[1] &= 8191;
		for (let c$3 = 2; c$3 < 10; c$3++) t[c$3] += o$2, o$2 = t[c$3] >>> 13, t[c$3] &= 8191;
		t[0] += o$2 * 5, o$2 = t[0] >>> 13, t[0] &= 8191, t[1] += o$2, o$2 = t[1] >>> 13, t[1] &= 8191, t[2] += o$2, r$1[0] = t[0] + 5, o$2 = r$1[0] >>> 13, r$1[0] &= 8191;
		for (let c$3 = 1; c$3 < 10; c$3++) r$1[c$3] = t[c$3] + o$2, o$2 = r$1[c$3] >>> 13, r$1[c$3] &= 8191;
		r$1[9] -= 8192;
		let s = (o$2 ^ 1) - 1;
		for (let c$3 = 0; c$3 < 10; c$3++) r$1[c$3] &= s;
		s = ~s;
		for (let c$3 = 0; c$3 < 10; c$3++) t[c$3] = t[c$3] & s | r$1[c$3];
		t[0] = (t[0] | t[1] << 13) & 65535, t[1] = (t[1] >>> 3 | t[2] << 10) & 65535, t[2] = (t[2] >>> 6 | t[3] << 7) & 65535, t[3] = (t[3] >>> 9 | t[4] << 4) & 65535, t[4] = (t[4] >>> 12 | t[5] << 1 | t[6] << 14) & 65535, t[5] = (t[6] >>> 2 | t[7] << 11) & 65535, t[6] = (t[7] >>> 5 | t[8] << 8) & 65535, t[7] = (t[8] >>> 8 | t[9] << 5) & 65535;
		let i$2 = t[0] + n$2[0];
		t[0] = i$2 & 65535;
		for (let c$3 = 1; c$3 < 8; c$3++) i$2 = (t[c$3] + n$2[c$3] | 0) + (i$2 >>> 16) | 0, t[c$3] = i$2 & 65535;
		Ee$3(r$1);
	}
	update(t) {
		Ln$1(this);
		const { buffer: n$2, blockLen: r$1 } = this;
		t = pt$2(t);
		const o$2 = t.length;
		for (let s = 0; s < o$2;) {
			const i$2 = Math.min(r$1 - this.pos, o$2 - s);
			if (i$2 === r$1) {
				for (; r$1 <= o$2 - s; s += r$1) this.process(t, s);
				continue;
			}
			n$2.set(t.subarray(s, s + i$2), this.pos), this.pos += i$2, s += i$2, this.pos === r$1 && (this.process(n$2, 0, !1), this.pos = 0);
		}
		return this;
	}
	destroy() {
		Ee$3(this.h, this.r, this.buffer, this.pad);
	}
	digestInto(t) {
		Ln$1(this), cs$1(t, this), this.finished = !0;
		const { buffer: n$2, h: r$1 } = this;
		let { pos: o$2 } = this;
		if (o$2) {
			for (n$2[o$2++] = 1; o$2 < 16; o$2++) n$2[o$2] = 0;
			this.process(n$2, 0, !0);
		}
		this.finalize();
		let s = 0;
		for (let i$2 = 0; i$2 < 8; i$2++) t[s++] = r$1[i$2] >>> 0, t[s++] = r$1[i$2] >>> 8;
		return t;
	}
	digest() {
		const { buffer: t, outputLen: n$2 } = this;
		this.digestInto(t);
		const r$1 = t.slice(0, n$2);
		return this.destroy(), r$1;
	}
};
function Is$1(e) {
	const t = (r$1, o$2) => e(o$2).update(pt$2(r$1)).digest(), n$2 = e(new Uint8Array(32));
	return t.outputLen = n$2.outputLen, t.blockLen = n$2.blockLen, t.create = (r$1) => e(r$1), t;
}
var Os$1 = Is$1((e) => new xs$1(e));
function As$1(e, t, n$2, r$1, o$2, s = 20) {
	let i$2 = e[0], c$3 = e[1], u$2 = e[2], a$1 = e[3], l$2 = t[0], f$7 = t[1], d$4 = t[2], g$2 = t[3], y$6 = t[4], h$4 = t[5], m$2 = t[6], L$4 = t[7], b$3 = o$2, _$4 = n$2[0], O$5 = n$2[1], k$5 = n$2[2], E$6 = i$2, B$4 = c$3, j$2 = u$2, v$5 = a$1, I$4 = l$2, w$3 = f$7, R$5 = d$4, A$5 = g$2, T$3 = y$6, N$4 = h$4, S$6 = m$2, U$1 = L$4, $$6 = b$3, p$5 = _$4, C$6 = O$5, D$3 = k$5;
	for (let G$4 = 0; G$4 < s; G$4 += 2) E$6 = E$6 + I$4 | 0, $$6 = x$1($$6 ^ E$6, 16), T$3 = T$3 + $$6 | 0, I$4 = x$1(I$4 ^ T$3, 12), E$6 = E$6 + I$4 | 0, $$6 = x$1($$6 ^ E$6, 8), T$3 = T$3 + $$6 | 0, I$4 = x$1(I$4 ^ T$3, 7), B$4 = B$4 + w$3 | 0, p$5 = x$1(p$5 ^ B$4, 16), N$4 = N$4 + p$5 | 0, w$3 = x$1(w$3 ^ N$4, 12), B$4 = B$4 + w$3 | 0, p$5 = x$1(p$5 ^ B$4, 8), N$4 = N$4 + p$5 | 0, w$3 = x$1(w$3 ^ N$4, 7), j$2 = j$2 + R$5 | 0, C$6 = x$1(C$6 ^ j$2, 16), S$6 = S$6 + C$6 | 0, R$5 = x$1(R$5 ^ S$6, 12), j$2 = j$2 + R$5 | 0, C$6 = x$1(C$6 ^ j$2, 8), S$6 = S$6 + C$6 | 0, R$5 = x$1(R$5 ^ S$6, 7), v$5 = v$5 + A$5 | 0, D$3 = x$1(D$3 ^ v$5, 16), U$1 = U$1 + D$3 | 0, A$5 = x$1(A$5 ^ U$1, 12), v$5 = v$5 + A$5 | 0, D$3 = x$1(D$3 ^ v$5, 8), U$1 = U$1 + D$3 | 0, A$5 = x$1(A$5 ^ U$1, 7), E$6 = E$6 + w$3 | 0, D$3 = x$1(D$3 ^ E$6, 16), S$6 = S$6 + D$3 | 0, w$3 = x$1(w$3 ^ S$6, 12), E$6 = E$6 + w$3 | 0, D$3 = x$1(D$3 ^ E$6, 8), S$6 = S$6 + D$3 | 0, w$3 = x$1(w$3 ^ S$6, 7), B$4 = B$4 + R$5 | 0, $$6 = x$1($$6 ^ B$4, 16), U$1 = U$1 + $$6 | 0, R$5 = x$1(R$5 ^ U$1, 12), B$4 = B$4 + R$5 | 0, $$6 = x$1($$6 ^ B$4, 8), U$1 = U$1 + $$6 | 0, R$5 = x$1(R$5 ^ U$1, 7), j$2 = j$2 + A$5 | 0, p$5 = x$1(p$5 ^ j$2, 16), T$3 = T$3 + p$5 | 0, A$5 = x$1(A$5 ^ T$3, 12), j$2 = j$2 + A$5 | 0, p$5 = x$1(p$5 ^ j$2, 8), T$3 = T$3 + p$5 | 0, A$5 = x$1(A$5 ^ T$3, 7), v$5 = v$5 + I$4 | 0, C$6 = x$1(C$6 ^ v$5, 16), N$4 = N$4 + C$6 | 0, I$4 = x$1(I$4 ^ N$4, 12), v$5 = v$5 + I$4 | 0, C$6 = x$1(C$6 ^ v$5, 8), N$4 = N$4 + C$6 | 0, I$4 = x$1(I$4 ^ N$4, 7);
	let P$5 = 0;
	r$1[P$5++] = i$2 + E$6 | 0, r$1[P$5++] = c$3 + B$4 | 0, r$1[P$5++] = u$2 + j$2 | 0, r$1[P$5++] = a$1 + v$5 | 0, r$1[P$5++] = l$2 + I$4 | 0, r$1[P$5++] = f$7 + w$3 | 0, r$1[P$5++] = d$4 + R$5 | 0, r$1[P$5++] = g$2 + A$5 | 0, r$1[P$5++] = y$6 + T$3 | 0, r$1[P$5++] = h$4 + N$4 | 0, r$1[P$5++] = m$2 + S$6 | 0, r$1[P$5++] = L$4 + U$1 | 0, r$1[P$5++] = b$3 + $$6 | 0, r$1[P$5++] = _$4 + p$5 | 0, r$1[P$5++] = O$5 + C$6 | 0, r$1[P$5++] = k$5 + D$3 | 0;
}
var Ns$1 = vs$1(As$1, {
	counterRight: !1,
	counterLength: 4,
	allowShortKeys: !1
}), Ss$1 = new Uint8Array(16), Hn$1 = (e, t) => {
	e.update(t);
	const n$2 = t.length % 16;
	n$2 && e.update(Ss$1.subarray(n$2));
}, Us = new Uint8Array(32);
function Kn$1(e, t, n$2, r$1, o$2) {
	const s = e(t, n$2, Us), i$2 = Os$1.create(s);
	o$2 && Hn$1(i$2, o$2), Hn$1(i$2, r$1);
	const c$3 = new Uint8Array(16), u$2 = as(c$3);
	kn$1(u$2, 0, BigInt(o$2 ? o$2.length : 0), !0), kn$1(u$2, 8, BigInt(r$1.length), !0), i$2.update(c$3);
	const a$1 = i$2.digest();
	return Ee$3(s, c$3), a$1;
}
var _s$1 = (e) => (t, n$2, r$1) => ({
	encrypt(s, i$2) {
		const c$3 = s.length;
		i$2 = Cn$1(c$3 + 16, i$2, !1), i$2.set(s);
		const u$2 = i$2.subarray(0, -16);
		e(t, n$2, u$2, u$2, 1);
		const a$1 = Kn$1(e, t, n$2, u$2, r$1);
		return i$2.set(a$1, c$3), Ee$3(a$1), i$2;
	},
	decrypt(s, i$2) {
		i$2 = Cn$1(s.length - 16, i$2, !1);
		const c$3 = s.subarray(0, -16), u$2 = s.subarray(-16), a$1 = Kn$1(e, t, n$2, c$3, r$1);
		if (!ds(u$2, a$1)) throw new Error("invalid tag");
		return i$2.set(s.subarray(0, -16)), e(t, n$2, i$2, i$2, 1), Ee$3(a$1), i$2;
	}
}), Fn$1 = hs({
	blockSize: 64,
	nonceLength: 12,
	tagLength: 16
}, _s$1(Ns$1));
var qn$1 = class extends it$2 {
	constructor(t, n$2) {
		super(), this.finished = !1, this.destroyed = !1, ot$1(t);
		const r$1 = we$2(n$2);
		if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
		this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
		const o$2 = this.blockLen, s = new Uint8Array(o$2);
		s.set(r$1.length > o$2 ? t.create().update(r$1).digest() : r$1);
		for (let i$2 = 0; i$2 < s.length; i$2++) s[i$2] ^= 54;
		this.iHash.update(s), this.oHash = t.create();
		for (let i$2 = 0; i$2 < s.length; i$2++) s[i$2] ^= 106;
		this.oHash.update(s), s.fill(0);
	}
	update(t) {
		return me$2(this), this.iHash.update(t), this;
	}
	digestInto(t) {
		me$2(this), je$2(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
	}
	digest() {
		const t = new Uint8Array(this.oHash.outputLen);
		return this.digestInto(t), t;
	}
	_cloneInto(t) {
		t || (t = Object.create(Object.getPrototypeOf(this), {}));
		const { oHash: n$2, iHash: r$1, finished: o$2, destroyed: s, blockLen: i$2, outputLen: c$3 } = this;
		return t = t, t.finished = o$2, t.destroyed = s, t.blockLen = i$2, t.outputLen = c$3, t.oHash = n$2._cloneInto(t.oHash), t.iHash = r$1._cloneInto(t.iHash), t;
	}
	destroy() {
		this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
	}
};
var mt$2 = (e, t, n$2) => new qn$1(e, t).update(n$2).digest();
mt$2.create = (e, t) => new qn$1(e, t);
function Ts$1(e, t, n$2) {
	return ot$1(e), n$2 === void 0 && (n$2 = new Uint8Array(e.outputLen)), mt$2(e, we$2(n$2), we$2(t));
}
var bt = new Uint8Array([0]), Gn$1 = new Uint8Array();
function $s(e, t, n$2, r$1 = 32) {
	if (ot$1(e), Ne$1(r$1), r$1 > 255 * e.outputLen) throw new Error("Length should be <= 255*HashLen");
	const o$2 = Math.ceil(r$1 / e.outputLen);
	n$2 === void 0 && (n$2 = Gn$1);
	const s = new Uint8Array(o$2 * e.outputLen), i$2 = mt$2.create(e, t), c$3 = i$2._cloneInto(), u$2 = new Uint8Array(i$2.outputLen);
	for (let a$1 = 0; a$1 < o$2; a$1++) bt[0] = a$1 + 1, c$3.update(a$1 === 0 ? Gn$1 : u$2).update(n$2).update(bt).digestInto(u$2), s.set(u$2, e.outputLen * a$1), i$2._cloneInto(c$3);
	return i$2.destroy(), c$3.destroy(), u$2.fill(0), bt.fill(0), s.slice(0, r$1);
}
var Rs$1 = (e, t, n$2, r$1, o$2) => $s(e, Ts$1(e, t, n$2), r$1, o$2);
function Ps$1(e, t, n$2, r$1) {
	if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n$2, r$1);
	const o$2 = BigInt(32), s = BigInt(4294967295), i$2 = Number(n$2 >> o$2 & s), c$3 = Number(n$2 & s), u$2 = r$1 ? 4 : 0, a$1 = r$1 ? 0 : 4;
	e.setUint32(t + u$2, i$2, r$1), e.setUint32(t + a$1, c$3, r$1);
}
function Bs(e, t, n$2) {
	return e & t ^ ~e & n$2;
}
function Ls$1(e, t, n$2) {
	return e & t ^ e & n$2 ^ t & n$2;
}
var js = class extends it$2 {
	constructor(t, n$2, r$1, o$2) {
		super(), this.blockLen = t, this.outputLen = n$2, this.padOffset = r$1, this.isLE = o$2, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = st$1(this.buffer);
	}
	update(t) {
		me$2(this);
		const { view: n$2, buffer: r$1, blockLen: o$2 } = this;
		t = we$2(t);
		const s = t.length;
		for (let i$2 = 0; i$2 < s;) {
			const c$3 = Math.min(o$2 - this.pos, s - i$2);
			if (c$3 === o$2) {
				const u$2 = st$1(t);
				for (; o$2 <= s - i$2; i$2 += o$2) this.process(u$2, i$2);
				continue;
			}
			r$1.set(t.subarray(i$2, i$2 + c$3), this.pos), this.pos += c$3, i$2 += c$3, this.pos === o$2 && (this.process(n$2, 0), this.pos = 0);
		}
		return this.length += t.length, this.roundClean(), this;
	}
	digestInto(t) {
		me$2(this), sn$2(t, this), this.finished = !0;
		const { buffer: n$2, view: r$1, blockLen: o$2, isLE: s } = this;
		let { pos: i$2 } = this;
		n$2[i$2++] = 128, this.buffer.subarray(i$2).fill(0), this.padOffset > o$2 - i$2 && (this.process(r$1, 0), i$2 = 0);
		for (let f$7 = i$2; f$7 < o$2; f$7++) n$2[f$7] = 0;
		Ps$1(r$1, o$2 - 8, BigInt(this.length * 8), s), this.process(r$1, 0);
		const c$3 = st$1(t), u$2 = this.outputLen;
		if (u$2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
		const a$1 = u$2 / 4, l$2 = this.get();
		if (a$1 > l$2.length) throw new Error("_sha2: outputLen bigger than state");
		for (let f$7 = 0; f$7 < a$1; f$7++) c$3.setUint32(4 * f$7, l$2[f$7], s);
	}
	digest() {
		const { buffer: t, outputLen: n$2 } = this;
		this.digestInto(t);
		const r$1 = t.slice(0, n$2);
		return this.destroy(), r$1;
	}
	_cloneInto(t) {
		t || (t = new this.constructor()), t.set(...this.get());
		const { blockLen: n$2, buffer: r$1, length: o$2, finished: s, destroyed: i$2, pos: c$3 } = this;
		return t.length = o$2, t.pos = c$3, t.finished = s, t.destroyed = i$2, o$2 % n$2 && t.buffer.set(r$1), t;
	}
};
var Cs$1 = new Uint32Array([
	1116352408,
	1899447441,
	3049323471,
	3921009573,
	961987163,
	1508970993,
	2453635748,
	2870763221,
	3624381080,
	310598401,
	607225278,
	1426881987,
	1925078388,
	2162078206,
	2614888103,
	3248222580,
	3835390401,
	4022224774,
	264347078,
	604807628,
	770255983,
	1249150122,
	1555081692,
	1996064986,
	2554220882,
	2821834349,
	2952996808,
	3210313671,
	3336571891,
	3584528711,
	113926993,
	338241895,
	666307205,
	773529912,
	1294757372,
	1396182291,
	1695183700,
	1986661051,
	2177026350,
	2456956037,
	2730485921,
	2820302411,
	3259730800,
	3345764771,
	3516065817,
	3600352804,
	4094571909,
	275423344,
	430227734,
	506948616,
	659060556,
	883997877,
	958139571,
	1322822218,
	1537002063,
	1747873779,
	1955562222,
	2024104815,
	2227730452,
	2361852424,
	2428436474,
	2756734187,
	3204031479,
	3329325298
]), ie$2 = new Uint32Array([
	1779033703,
	3144134277,
	1013904242,
	2773480762,
	1359893119,
	2600822924,
	528734635,
	1541459225
]), ce$2 = new Uint32Array(64);
var ks$1 = class extends js {
	constructor() {
		super(64, 32, 8, !1), this.A = ie$2[0] | 0, this.B = ie$2[1] | 0, this.C = ie$2[2] | 0, this.D = ie$2[3] | 0, this.E = ie$2[4] | 0, this.F = ie$2[5] | 0, this.G = ie$2[6] | 0, this.H = ie$2[7] | 0;
	}
	get() {
		const { A: t, B: n$2, C: r$1, D: o$2, E: s, F: i$2, G: c$3, H: u$2 } = this;
		return [
			t,
			n$2,
			r$1,
			o$2,
			s,
			i$2,
			c$3,
			u$2
		];
	}
	set(t, n$2, r$1, o$2, s, i$2, c$3, u$2) {
		this.A = t | 0, this.B = n$2 | 0, this.C = r$1 | 0, this.D = o$2 | 0, this.E = s | 0, this.F = i$2 | 0, this.G = c$3 | 0, this.H = u$2 | 0;
	}
	process(t, n$2) {
		for (let f$7 = 0; f$7 < 16; f$7++, n$2 += 4) ce$2[f$7] = t.getUint32(n$2, !1);
		for (let f$7 = 16; f$7 < 64; f$7++) {
			const d$4 = ce$2[f$7 - 15], g$2 = ce$2[f$7 - 2], y$6 = J$3(d$4, 7) ^ J$3(d$4, 18) ^ d$4 >>> 3;
			ce$2[f$7] = (J$3(g$2, 17) ^ J$3(g$2, 19) ^ g$2 >>> 10) + ce$2[f$7 - 7] + y$6 + ce$2[f$7 - 16] | 0;
		}
		let { A: r$1, B: o$2, C: s, D: i$2, E: c$3, F: u$2, G: a$1, H: l$2 } = this;
		for (let f$7 = 0; f$7 < 64; f$7++) {
			const d$4 = J$3(c$3, 6) ^ J$3(c$3, 11) ^ J$3(c$3, 25), g$2 = l$2 + d$4 + Bs(c$3, u$2, a$1) + Cs$1[f$7] + ce$2[f$7] | 0, h$4 = (J$3(r$1, 2) ^ J$3(r$1, 13) ^ J$3(r$1, 22)) + Ls$1(r$1, o$2, s) | 0;
			l$2 = a$1, a$1 = u$2, u$2 = c$3, c$3 = i$2 + g$2 | 0, i$2 = s, s = o$2, o$2 = r$1, r$1 = g$2 + h$4 | 0;
		}
		r$1 = r$1 + this.A | 0, o$2 = o$2 + this.B | 0, s = s + this.C | 0, i$2 = i$2 + this.D | 0, c$3 = c$3 + this.E | 0, u$2 = u$2 + this.F | 0, a$1 = a$1 + this.G | 0, l$2 = l$2 + this.H | 0, this.set(r$1, o$2, s, i$2, c$3, u$2, a$1, l$2);
	}
	roundClean() {
		ce$2.fill(0);
	}
	destroy() {
		this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
	}
};
var He$2 = fn$1(() => new ks$1());
var Wn$1 = BigInt(0);
function wt$2(e) {
	return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function zn$1(e) {
	if (!wt$2(e)) throw new Error("Uint8Array expected");
}
var Ds$1 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ms(e) {
	zn$1(e);
	let t = "";
	for (let n$2 = 0; n$2 < e.length; n$2++) t += Ds$1[e[n$2]];
	return t;
}
function Vs$2(e) {
	if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
	return e === "" ? Wn$1 : BigInt("0x" + e);
}
var ee$2 = {
	_0: 48,
	_9: 57,
	A: 65,
	F: 70,
	a: 97,
	f: 102
};
function Jn$1(e) {
	if (e >= ee$2._0 && e <= ee$2._9) return e - ee$2._0;
	if (e >= ee$2.A && e <= ee$2.F) return e - (ee$2.A - 10);
	if (e >= ee$2.a && e <= ee$2.f) return e - (ee$2.a - 10);
}
function Yn$1(e) {
	if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
	const t = e.length, n$2 = t / 2;
	if (t % 2) throw new Error("hex string expected, got unpadded hex of length " + t);
	const r$1 = new Uint8Array(n$2);
	for (let o$2 = 0, s = 0; o$2 < n$2; o$2++, s += 2) {
		const i$2 = Jn$1(e.charCodeAt(s)), c$3 = Jn$1(e.charCodeAt(s + 1));
		if (i$2 === void 0 || c$3 === void 0) {
			const u$2 = e[s] + e[s + 1];
			throw new Error("hex string expected, got non-hex character \"" + u$2 + "\" at index " + s);
		}
		r$1[o$2] = i$2 * 16 + c$3;
	}
	return r$1;
}
function Xn$1(e) {
	return zn$1(e), Vs$2(Ms(Uint8Array.from(e).reverse()));
}
function Hs$1(e, t) {
	return Yn$1(e.toString(16).padStart(t * 2, "0"));
}
function Ks(e, t) {
	return Hs$1(e, t).reverse();
}
function Zn$1(e, t, n$2) {
	let r$1;
	if (typeof t == "string") try {
		r$1 = Yn$1(t);
	} catch (s) {
		throw new Error(e + " must be hex string or Uint8Array, cause: " + s);
	}
	else if (wt$2(t)) r$1 = Uint8Array.from(t);
	else throw new Error(e + " must be hex string or Uint8Array");
	const o$2 = r$1.length;
	if (typeof n$2 == "number" && o$2 !== n$2) throw new Error(e + " of length " + n$2 + " expected, got " + o$2);
	return r$1;
}
var Et$2 = (e) => typeof e == "bigint" && Wn$1 <= e;
function Fs(e, t, n$2) {
	return Et$2(e) && Et$2(t) && Et$2(n$2) && t <= e && e < n$2;
}
function Qn$1(e, t, n$2, r$1) {
	if (!Fs(t, n$2, r$1)) throw new Error("expected valid " + e + ": " + n$2 + " <= n < " + r$1 + ", got " + t);
}
var qs$2 = {
	bigint: (e) => typeof e == "bigint",
	function: (e) => typeof e == "function",
	boolean: (e) => typeof e == "boolean",
	string: (e) => typeof e == "string",
	stringOrUint8Array: (e) => typeof e == "string" || wt$2(e),
	isSafeInteger: (e) => Number.isSafeInteger(e),
	array: (e) => Array.isArray(e),
	field: (e, t) => t.Fp.isValid(e),
	hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function Gs$1(e, t, n$2 = {}) {
	const r$1 = (o$2, s, i$2) => {
		const c$3 = qs$2[s];
		if (typeof c$3 != "function") throw new Error("invalid validator function");
		const u$2 = e[o$2];
		if (!(i$2 && u$2 === void 0) && !c$3(u$2, e)) throw new Error("param " + String(o$2) + " is invalid. Expected " + s + ", got " + u$2);
	};
	for (const [o$2, s] of Object.entries(t)) r$1(o$2, s, !1);
	for (const [o$2, s] of Object.entries(n$2)) r$1(o$2, s, !0);
	return e;
}
var ve$1 = BigInt(0), Ke$3 = BigInt(1);
function er$1(e, t) {
	const n$2 = e % t;
	return n$2 >= ve$1 ? n$2 : t + n$2;
}
function Ws$1(e, t, n$2) {
	if (t < ve$1) throw new Error("invalid exponent, negatives unsupported");
	if (n$2 <= ve$1) throw new Error("invalid modulus");
	if (n$2 === Ke$3) return ve$1;
	let r$1 = Ke$3;
	for (; t > ve$1;) t & Ke$3 && (r$1 = r$1 * e % n$2), e = e * e % n$2, t >>= Ke$3;
	return r$1;
}
function z$2(e, t, n$2) {
	let r$1 = e;
	for (; t-- > ve$1;) r$1 *= r$1, r$1 %= n$2;
	return r$1;
}
var xe$1 = BigInt(0), vt$1 = BigInt(1);
function zs(e) {
	return Gs$1(e, { a: "bigint" }, {
		montgomeryBits: "isSafeInteger",
		nByteLength: "isSafeInteger",
		adjustScalarBytes: "function",
		domain: "function",
		powPminus2: "function",
		Gu: "bigint"
	}), Object.freeze({ ...e });
}
function Js$1(e) {
	const t = zs(e), { P: n$2 } = t, r$1 = (b$3) => er$1(b$3, n$2), o$2 = t.montgomeryBits, s = Math.ceil(o$2 / 8), i$2 = t.nByteLength, c$3 = t.adjustScalarBytes || ((b$3) => b$3), u$2 = t.powPminus2 || ((b$3) => Ws$1(b$3, n$2 - BigInt(2), n$2));
	function a$1(b$3, _$4, O$5) {
		const k$5 = r$1(b$3 * (_$4 - O$5));
		return _$4 = r$1(_$4 - k$5), O$5 = r$1(O$5 + k$5), [_$4, O$5];
	}
	const l$2 = (t.a - BigInt(2)) / BigInt(4);
	function f$7(b$3, _$4) {
		Qn$1("u", b$3, xe$1, n$2), Qn$1("scalar", _$4, xe$1, n$2);
		const O$5 = _$4, k$5 = b$3;
		let E$6 = vt$1, B$4 = xe$1, j$2 = b$3, v$5 = vt$1, I$4 = xe$1, w$3;
		for (let A$5 = BigInt(o$2 - 1); A$5 >= xe$1; A$5--) {
			const T$3 = O$5 >> A$5 & vt$1;
			I$4 ^= T$3, w$3 = a$1(I$4, E$6, j$2), E$6 = w$3[0], j$2 = w$3[1], w$3 = a$1(I$4, B$4, v$5), B$4 = w$3[0], v$5 = w$3[1], I$4 = T$3;
			const N$4 = E$6 + B$4, S$6 = r$1(N$4 * N$4), U$1 = E$6 - B$4, $$6 = r$1(U$1 * U$1), p$5 = S$6 - $$6, C$6 = j$2 + v$5, P$5 = r$1((j$2 - v$5) * N$4), G$4 = r$1(C$6 * U$1), X$1 = P$5 + G$4, Z$3 = P$5 - G$4;
			j$2 = r$1(X$1 * X$1), v$5 = r$1(k$5 * r$1(Z$3 * Z$3)), E$6 = r$1(S$6 * $$6), B$4 = r$1(p$5 * (S$6 + r$1(l$2 * p$5)));
		}
		w$3 = a$1(I$4, E$6, j$2), E$6 = w$3[0], j$2 = w$3[1], w$3 = a$1(I$4, B$4, v$5), B$4 = w$3[0], v$5 = w$3[1];
		const R$5 = u$2(B$4);
		return r$1(E$6 * R$5);
	}
	function d$4(b$3) {
		return Ks(r$1(b$3), s);
	}
	function g$2(b$3) {
		const _$4 = Zn$1("u coordinate", b$3, s);
		return i$2 === 32 && (_$4[31] &= 127), Xn$1(_$4);
	}
	function y$6(b$3) {
		const _$4 = Zn$1("scalar", b$3), O$5 = _$4.length;
		if (O$5 !== s && O$5 !== i$2) {
			let k$5 = "" + s + " or " + i$2;
			throw new Error("invalid scalar, expected " + k$5 + " bytes, got " + O$5);
		}
		return Xn$1(c$3(_$4));
	}
	function h$4(b$3, _$4) {
		const E$6 = f$7(g$2(_$4), y$6(b$3));
		if (E$6 === xe$1) throw new Error("invalid private or public key received");
		return d$4(E$6);
	}
	const m$2 = d$4(t.Gu);
	function L$4(b$3) {
		return h$4(b$3, m$2);
	}
	return {
		scalarMult: h$4,
		scalarMultBase: L$4,
		getSharedSecret: (b$3, _$4) => h$4(b$3, _$4),
		getPublicKey: (b$3) => L$4(b$3),
		utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) },
		GuBytes: m$2
	};
}
var xt$2 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var Ys$1 = BigInt(1), tr$1 = BigInt(2), Xs$1 = BigInt(3), Zs$1 = BigInt(5);
function Qs$1(e) {
	const t = BigInt(10), n$2 = BigInt(20), r$1 = BigInt(40), o$2 = BigInt(80), s = xt$2, c$3 = e * e % s * e % s, a$1 = z$2(z$2(c$3, tr$1, s) * c$3 % s, Ys$1, s) * e % s, l$2 = z$2(a$1, Zs$1, s) * a$1 % s, f$7 = z$2(l$2, t, s) * l$2 % s, d$4 = z$2(f$7, n$2, s) * f$7 % s, g$2 = z$2(d$4, r$1, s) * d$4 % s;
	return {
		pow_p_5_8: z$2(z$2(z$2(z$2(g$2, o$2, s) * g$2 % s, o$2, s) * g$2 % s, t, s) * l$2 % s, tr$1, s) * e % s,
		b2: c$3
	};
}
function ei$1(e) {
	return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;
}
var It$1 = Js$1({
	P: xt$2,
	a: BigInt(486662),
	montgomeryBits: 255,
	nByteLength: 32,
	Gu: BigInt(9),
	powPminus2: (e) => {
		const t = xt$2, { pow_p_5_8: n$2, b2: r$1 } = Qs$1(e);
		return er$1(z$2(n$2, Xs$1, t) * r$1, t);
	},
	adjustScalarBytes: ei$1,
	randomBytes: Se$2
}), Ot$1 = "base10", V$2 = "base16", At$1 = "base64pad", ti = "base64url", Ie$2 = "utf8", Nt$2 = 0, Oe$2 = 1, _e$1 = 2, ni$1 = 0, nr$1 = 1, Te$2 = 12, St$2 = 32;
function ri() {
	const e = It$1.utils.randomPrivateKey(), t = It$1.getPublicKey(e);
	return {
		privateKey: toString(e, V$2),
		publicKey: toString(t, V$2)
	};
}
function oi() {
	return toString(Se$2(St$2), V$2);
}
function si(e, t) {
	return toString(Rs$1(He$2, It$1.getSharedSecret(fromString(e, V$2), fromString(t, V$2)), void 0, void 0, St$2), V$2);
}
function ii(e) {
	return toString(He$2(fromString(e, V$2)), V$2);
}
function ci(e) {
	return toString(He$2(fromString(e, Ie$2)), V$2);
}
function Ut$2(e) {
	return fromString(`${e}`, Ot$1);
}
function fe$2(e) {
	return Number(toString(e, Ot$1));
}
function ai(e) {
	const t = Ut$2(typeof e.type < "u" ? e.type : Nt$2);
	if (fe$2(t) === Oe$2 && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
	const n$2 = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, V$2) : void 0, r$1 = typeof e.iv < "u" ? fromString(e.iv, V$2) : Se$2(Te$2);
	return _t$2({
		type: t,
		sealed: Fn$1(fromString(e.symKey, V$2), r$1).encrypt(fromString(e.message, Ie$2)),
		iv: r$1,
		senderPublicKey: n$2,
		encoding: e.encoding
	});
}
function ui(e) {
	const t = fromString(e.symKey, V$2), { sealed: n$2, iv: r$1 } = Fe$1(e), o$2 = Fn$1(t, r$1).decrypt(n$2);
	if (o$2 === null) throw new Error("Failed to decrypt");
	return toString(o$2, Ie$2);
}
function fi(e, t) {
	const n$2 = Ut$2(_e$1), r$1 = Se$2(Te$2);
	return _t$2({
		type: n$2,
		sealed: fromString(e, Ie$2),
		iv: r$1,
		encoding: t
	});
}
function li(e, t) {
	const { sealed: n$2 } = Fe$1({
		encoded: e,
		encoding: t
	});
	return toString(n$2, Ie$2);
}
function _t$2(e) {
	const { encoding: t = At$1 } = e;
	if (fe$2(e.type) === _e$1) return toString(concat([e.type, e.sealed]), t);
	if (fe$2(e.type) === Oe$2) {
		if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
		return toString(concat([
			e.type,
			e.senderPublicKey,
			e.iv,
			e.sealed
		]), t);
	}
	return toString(concat([
		e.type,
		e.iv,
		e.sealed
	]), t);
}
function Fe$1(e) {
	const { encoded: t, encoding: n$2 = At$1 } = e, r$1 = fromString(t, n$2), o$2 = r$1.slice(ni$1, nr$1), s = nr$1;
	if (fe$2(o$2) === Oe$2) {
		const a$1 = s + St$2, l$2 = a$1 + Te$2, f$7 = r$1.slice(s, a$1), d$4 = r$1.slice(a$1, l$2);
		return {
			type: o$2,
			sealed: r$1.slice(l$2),
			iv: d$4,
			senderPublicKey: f$7
		};
	}
	if (fe$2(o$2) === _e$1) return {
		type: o$2,
		sealed: r$1.slice(s),
		iv: Se$2(Te$2)
	};
	const i$2 = s + Te$2, c$3 = r$1.slice(s, i$2);
	return {
		type: o$2,
		sealed: r$1.slice(i$2),
		iv: c$3
	};
}
function di(e, t) {
	const n$2 = Fe$1({
		encoded: e,
		encoding: t?.encoding
	});
	return rr({
		type: fe$2(n$2.type),
		senderPublicKey: typeof n$2.senderPublicKey < "u" ? toString(n$2.senderPublicKey, V$2) : void 0,
		receiverPublicKey: t?.receiverPublicKey
	});
}
function rr(e) {
	const t = e?.type || Nt$2;
	if (t === Oe$2) {
		if (typeof e?.senderPublicKey > "u") throw new Error("missing sender public key");
		if (typeof e?.receiverPublicKey > "u") throw new Error("missing receiver public key");
	}
	return {
		type: t,
		senderPublicKey: e?.senderPublicKey,
		receiverPublicKey: e?.receiverPublicKey
	};
}
function hi(e) {
	return e.type === Oe$2 && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function pi(e) {
	return e.type === _e$1;
}
function or$1(e) {
	return new import_elliptic.ec("p256").keyFromPublic({
		x: Buffer.from(e.x, "base64").toString("hex"),
		y: Buffer.from(e.y, "base64").toString("hex")
	}, "hex");
}
function gi$1(e) {
	let t = e.replace(/-/g, "+").replace(/_/g, "/");
	const n$2 = t.length % 4;
	return n$2 > 0 && (t += "=".repeat(4 - n$2)), t;
}
function yi$1(e) {
	return Buffer.from(gi$1(e), "base64");
}
function mi(e, t) {
	const [n$2, r$1, o$2] = e.split("."), s = yi$1(o$2);
	if (s.length !== 64) throw new Error("Invalid signature length");
	const i$2 = s.slice(0, 32).toString("hex"), c$3 = s.slice(32, 64).toString("hex"), a$1 = He$2(`${n$2}.${r$1}`), l$2 = or$1(t), f$7 = toString(a$1, V$2);
	if (!l$2.verify(f$7, {
		r: i$2,
		s: c$3
	})) throw new Error("Invalid signature");
	return sn(e).payload;
}
var sr$1 = "irn";
function bi(e) {
	return e?.relay || { protocol: sr$1 };
}
function wi(e) {
	const t = C$3[e];
	if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${e}`);
	return t;
}
function ir$1(e, t = "-") {
	const n$2 = {}, r$1 = "relay" + t;
	return Object.keys(e).forEach((o$2) => {
		if (o$2.startsWith(r$1)) {
			const s = o$2.replace(r$1, "");
			n$2[s] = e[o$2];
		}
	}), n$2;
}
function Ei(e) {
	if (!e.includes("wc:")) {
		const a$1 = rt$1(e);
		a$1 != null && a$1.includes("wc:") && (e = a$1);
	}
	e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
	const t = e.indexOf(":"), n$2 = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r$1 = e.substring(0, t), o$2 = e.substring(t + 1, n$2).split("@"), s = typeof n$2 < "u" ? e.substring(n$2) : "", i$2 = new URLSearchParams(s), c$3 = {};
	i$2.forEach((a$1, l$2) => {
		c$3[l$2] = a$1;
	});
	const u$2 = typeof c$3.methods == "string" ? c$3.methods.split(",") : void 0;
	return {
		protocol: r$1,
		topic: cr$1(o$2[0]),
		version: parseInt(o$2[1], 10),
		symKey: c$3.symKey,
		relay: ir$1(c$3),
		methods: u$2,
		expiryTimestamp: c$3.expiryTimestamp ? parseInt(c$3.expiryTimestamp, 10) : void 0
	};
}
function cr$1(e) {
	return e.startsWith("//") ? e.substring(2) : e;
}
function ar$1(e, t = "-") {
	const n$2 = "relay", r$1 = {};
	return Object.keys(e).forEach((o$2) => {
		const s = o$2, i$2 = n$2 + t + s;
		e[s] && (r$1[i$2] = e[s]);
	}), r$1;
}
function vi(e) {
	const t = new URLSearchParams(), n$2 = ar$1(e.relay);
	Object.keys(n$2).sort().forEach((o$2) => {
		t.set(o$2, n$2[o$2]);
	}), t.set("symKey", e.symKey), e.expiryTimestamp && t.set("expiryTimestamp", e.expiryTimestamp.toString()), e.methods && t.set("methods", e.methods.join(","));
	const r$1 = t.toString();
	return `${e.protocol}:${e.topic}@${e.version}?${r$1}`;
}
function xi(e, t, n$2) {
	return `${e}?wc_ev=${n$2}&topic=${t}`;
}
function le$2(e) {
	const t = [];
	return e.forEach((n$2) => {
		const [r$1, o$2] = n$2.split(":");
		t.push(`${r$1}:${o$2}`);
	}), t;
}
function lr$1(e) {
	const t = [];
	return Object.values(e).forEach((n$2) => {
		t.push(...le$2(n$2.accounts));
	}), t;
}
function dr$1(e, t) {
	const n$2 = [];
	return Object.values(e).forEach((r$1) => {
		le$2(r$1.accounts).includes(t) && n$2.push(...r$1.methods);
	}), n$2;
}
function hr$1(e, t) {
	const n$2 = [];
	return Object.values(e).forEach((r$1) => {
		le$2(r$1.accounts).includes(t) && n$2.push(...r$1.events);
	}), n$2;
}
function Tt(e) {
	return e.includes(":");
}
function pr(e) {
	return Tt(e) ? e.split(":")[0] : e;
}
function gr$1(e) {
	const t = {};
	return e?.forEach((n$2) => {
		var r$1;
		const [o$2, s] = n$2.split(":");
		t[o$2] || (t[o$2] = {
			accounts: [],
			chains: [],
			events: [],
			methods: []
		}), t[o$2].accounts.push(n$2), (r$1 = t[o$2].chains) == null || r$1.push(`${o$2}:${s}`);
	}), t;
}
function Ri(e, t) {
	t = t.map((r$1) => r$1.replace("did:pkh:", ""));
	const n$2 = gr$1(t);
	for (const [r$1, o$2] of Object.entries(n$2)) o$2.methods ? o$2.methods = Q(o$2.methods, e) : o$2.methods = e, o$2.events = ["chainChanged", "accountsChanged"];
	return n$2;
}
var yr$1 = {
	INVALID_METHOD: {
		message: "Invalid method.",
		code: 1001
	},
	INVALID_EVENT: {
		message: "Invalid event.",
		code: 1002
	},
	INVALID_UPDATE_REQUEST: {
		message: "Invalid update request.",
		code: 1003
	},
	INVALID_EXTEND_REQUEST: {
		message: "Invalid extend request.",
		code: 1004
	},
	INVALID_SESSION_SETTLE_REQUEST: {
		message: "Invalid session settle request.",
		code: 1005
	},
	UNAUTHORIZED_METHOD: {
		message: "Unauthorized method.",
		code: 3001
	},
	UNAUTHORIZED_EVENT: {
		message: "Unauthorized event.",
		code: 3002
	},
	UNAUTHORIZED_UPDATE_REQUEST: {
		message: "Unauthorized update request.",
		code: 3003
	},
	UNAUTHORIZED_EXTEND_REQUEST: {
		message: "Unauthorized extend request.",
		code: 3004
	},
	USER_REJECTED: {
		message: "User rejected.",
		code: 5e3
	},
	USER_REJECTED_CHAINS: {
		message: "User rejected chains.",
		code: 5001
	},
	USER_REJECTED_METHODS: {
		message: "User rejected methods.",
		code: 5002
	},
	USER_REJECTED_EVENTS: {
		message: "User rejected events.",
		code: 5003
	},
	UNSUPPORTED_CHAINS: {
		message: "Unsupported chains.",
		code: 5100
	},
	UNSUPPORTED_METHODS: {
		message: "Unsupported methods.",
		code: 5101
	},
	UNSUPPORTED_EVENTS: {
		message: "Unsupported events.",
		code: 5102
	},
	UNSUPPORTED_ACCOUNTS: {
		message: "Unsupported accounts.",
		code: 5103
	},
	UNSUPPORTED_NAMESPACE_KEY: {
		message: "Unsupported namespace key.",
		code: 5104
	},
	USER_DISCONNECTED: {
		message: "User disconnected.",
		code: 6e3
	},
	SESSION_SETTLEMENT_FAILED: {
		message: "Session settlement failed.",
		code: 7e3
	},
	WC_METHOD_UNSUPPORTED: {
		message: "Unsupported wc_ method.",
		code: 10001
	}
}, mr$1 = {
	NOT_INITIALIZED: {
		message: "Not initialized.",
		code: 1
	},
	NO_MATCHING_KEY: {
		message: "No matching key.",
		code: 2
	},
	RESTORE_WILL_OVERRIDE: {
		message: "Restore will override.",
		code: 3
	},
	RESUBSCRIBED: {
		message: "Resubscribed.",
		code: 4
	},
	MISSING_OR_INVALID: {
		message: "Missing or invalid.",
		code: 5
	},
	EXPIRED: {
		message: "Expired.",
		code: 6
	},
	UNKNOWN_TYPE: {
		message: "Unknown type.",
		code: 7
	},
	MISMATCHED_TOPIC: {
		message: "Mismatched topic.",
		code: 8
	},
	NON_CONFORMING_NAMESPACES: {
		message: "Non conforming namespaces.",
		code: 9
	}
};
function te$1(e, t) {
	const { message: n$2, code: r$1 } = mr$1[e];
	return {
		message: t ? `${n$2} ${t}` : n$2,
		code: r$1
	};
}
function de(e, t) {
	const { message: n$2, code: r$1 } = yr$1[e];
	return {
		message: t ? `${n$2} ${t}` : n$2,
		code: r$1
	};
}
function $e(e, t) {
	return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : !0 : !1;
}
function qe(e) {
	return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function ae$1(e) {
	return typeof e > "u";
}
function q(e, t) {
	return t && ae$1(e) ? !0 : typeof e == "string" && !!e.trim().length;
}
function Ge$3(e, t) {
	return t && ae$1(e) ? !0 : typeof e == "number" && !isNaN(e);
}
function Pi(e, t) {
	const { requiredNamespaces: n$2 } = t, r$1 = Object.keys(e.namespaces), o$2 = Object.keys(n$2);
	let s = !0;
	return re$2(o$2, r$1) ? (r$1.forEach((i$2) => {
		const { accounts: c$3, methods: u$2, events: a$1 } = e.namespaces[i$2], l$2 = le$2(c$3), f$7 = n$2[i$2];
		(!re$2(Be$3(i$2, f$7), l$2) || !re$2(f$7.methods, u$2) || !re$2(f$7.events, a$1)) && (s = !1);
	}), s) : !1;
}
function Re$1(e) {
	return q(e, !1) && e.includes(":") ? e.split(":").length === 2 : !1;
}
function br$1(e) {
	if (q(e, !1) && e.includes(":")) {
		const t = e.split(":");
		if (t.length === 3) {
			const n$2 = t[0] + ":" + t[1];
			return !!t[2] && Re$1(n$2);
		}
	}
	return !1;
}
function Bi(e) {
	function t(n$2) {
		try {
			return typeof new URL(n$2) < "u";
		} catch {
			return !1;
		}
	}
	try {
		if (q(e, !1)) {
			if (t(e)) return !0;
			return t(rt$1(e));
		}
	} catch {}
	return !1;
}
function Li(e) {
	var t;
	return (t = e?.proposer) == null ? void 0 : t.publicKey;
}
function ji(e) {
	return e?.topic;
}
function Ci(e, t) {
	let n$2 = null;
	return q(e?.publicKey, !1) || (n$2 = te$1("MISSING_OR_INVALID", `${t} controller public key should be a string`)), n$2;
}
function Rt$2(e) {
	let t = !0;
	return $e(e) ? e.length && (t = e.every((n$2) => q(n$2, !1))) : t = !1, t;
}
function wr$1(e, t, n$2) {
	let r$1 = null;
	return $e(t) && t.length ? t.forEach((o$2) => {
		r$1 || Re$1(o$2) || (r$1 = de("UNSUPPORTED_CHAINS", `${n$2}, chain ${o$2} should be a string and conform to "namespace:chainId" format`));
	}) : Re$1(e) || (r$1 = de("UNSUPPORTED_CHAINS", `${n$2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r$1;
}
function Er$1(e, t, n$2) {
	let r$1 = null;
	return Object.entries(e).forEach(([o$2, s]) => {
		if (r$1) return;
		const i$2 = wr$1(o$2, Be$3(o$2, s), `${t} ${n$2}`);
		i$2 && (r$1 = i$2);
	}), r$1;
}
function vr$1(e, t) {
	let n$2 = null;
	return $e(e) ? e.forEach((r$1) => {
		n$2 || br$1(r$1) || (n$2 = de("UNSUPPORTED_ACCOUNTS", `${t}, account ${r$1} should be a string and conform to "namespace:chainId:address" format`));
	}) : n$2 = de("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n$2;
}
function xr$1(e, t) {
	let n$2 = null;
	return Object.values(e).forEach((r$1) => {
		if (n$2) return;
		const o$2 = vr$1(r$1?.accounts, `${t} namespace`);
		o$2 && (n$2 = o$2);
	}), n$2;
}
function Ir$1(e, t) {
	let n$2 = null;
	return Rt$2(e?.methods) ? Rt$2(e?.events) || (n$2 = de("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : n$2 = de("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), n$2;
}
function Pt$2(e, t) {
	let n$2 = null;
	return Object.values(e).forEach((r$1) => {
		if (n$2) return;
		const o$2 = Ir$1(r$1, `${t}, namespace`);
		o$2 && (n$2 = o$2);
	}), n$2;
}
function ki(e, t, n$2) {
	let r$1 = null;
	if (e && qe(e)) {
		const o$2 = Pt$2(e, t);
		o$2 && (r$1 = o$2);
		const s = Er$1(e, t, n$2);
		s && (r$1 = s);
	} else r$1 = te$1("MISSING_OR_INVALID", `${t}, ${n$2} should be an object with data`);
	return r$1;
}
function Or(e, t) {
	let n$2 = null;
	if (e && qe(e)) {
		const r$1 = Pt$2(e, t);
		r$1 && (n$2 = r$1);
		const o$2 = xr$1(e, t);
		o$2 && (n$2 = o$2);
	} else n$2 = te$1("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
	return n$2;
}
function Ar(e) {
	return q(e.protocol, !0);
}
function Di(e, t) {
	let n$2 = !1;
	return t && !e ? n$2 = !0 : e && $e(e) && e.length && e.forEach((r$1) => {
		n$2 = Ar(r$1);
	}), n$2;
}
function Mi(e) {
	return typeof e == "number";
}
function Vi(e) {
	return typeof e < "u" && true;
}
function Hi(e) {
	return !(!e || typeof e != "object" || !e.code || !Ge$3(e.code, !1) || !e.message || !q(e.message, !1));
}
function Ki(e) {
	return !(ae$1(e) || !q(e.method, !1));
}
function Fi(e) {
	return !(ae$1(e) || ae$1(e.result) && ae$1(e.error) || !Ge$3(e.id, !1) || !q(e.jsonrpc, !1));
}
function qi(e) {
	return !(ae$1(e) || !q(e.name, !1));
}
function Gi(e, t) {
	return !(!Re$1(t) || !lr$1(e).includes(t));
}
function Wi(e, t, n$2) {
	return q(n$2, !1) ? dr$1(e, t).includes(n$2) : !1;
}
function zi$1(e, t, n$2) {
	return q(n$2, !1) ? hr$1(e, t).includes(n$2) : !1;
}
function Nr(e, t, n$2) {
	let r$1 = null;
	const o$2 = Ji(e), s = Yi$1(t), i$2 = Object.keys(o$2), c$3 = Object.keys(s), u$2 = Sr$1(Object.keys(e)), a$1 = Sr$1(Object.keys(t)), l$2 = u$2.filter((f$7) => !a$1.includes(f$7));
	return l$2.length && (r$1 = te$1("NON_CONFORMING_NAMESPACES", `${n$2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l$2.toString()}
      Received: ${Object.keys(t).toString()}`)), re$2(i$2, c$3) || (r$1 = te$1("NON_CONFORMING_NAMESPACES", `${n$2} namespaces chains don't satisfy required namespaces.
      Required: ${i$2.toString()}
      Approved: ${c$3.toString()}`)), Object.keys(t).forEach((f$7) => {
		if (!f$7.includes(":") || r$1) return;
		const d$4 = le$2(t[f$7].accounts);
		d$4.includes(f$7) || (r$1 = te$1("NON_CONFORMING_NAMESPACES", `${n$2} namespaces accounts don't satisfy namespace accounts for ${f$7}
        Required: ${f$7}
        Approved: ${d$4.toString()}`));
	}), i$2.forEach((f$7) => {
		r$1 || (re$2(o$2[f$7].methods, s[f$7].methods) ? re$2(o$2[f$7].events, s[f$7].events) || (r$1 = te$1("NON_CONFORMING_NAMESPACES", `${n$2} namespaces events don't satisfy namespace events for ${f$7}`)) : r$1 = te$1("NON_CONFORMING_NAMESPACES", `${n$2} namespaces methods don't satisfy namespace methods for ${f$7}`));
	}), r$1;
}
function Ji(e) {
	const t = {};
	return Object.keys(e).forEach((n$2) => {
		var r$1;
		n$2.includes(":") ? t[n$2] = e[n$2] : (r$1 = e[n$2].chains) == null || r$1.forEach((o$2) => {
			t[o$2] = {
				methods: e[n$2].methods,
				events: e[n$2].events
			};
		});
	}), t;
}
function Sr$1(e) {
	return [...new Set(e.map((t) => t.includes(":") ? t.split(":")[0] : t))];
}
function Yi$1(e) {
	const t = {};
	return Object.keys(e).forEach((n$2) => {
		if (n$2.includes(":")) t[n$2] = e[n$2];
		else le$2(e[n$2].accounts)?.forEach((o$2) => {
			t[o$2] = {
				accounts: e[n$2].accounts.filter((s) => s.includes(`${o$2}:`)),
				methods: e[n$2].methods,
				events: e[n$2].events
			};
		});
	}), t;
}
function Xi(e, t) {
	return Ge$3(e, !1) && e <= t.max && e >= t.min;
}
function Zi() {
	const e = ue$2();
	return new Promise((t) => {
		switch (e) {
			case H$1.browser:
				t(Ur$1());
				break;
			case H$1.reactNative:
				t(_r$1());
				break;
			case H$1.node:
				t(Tr$1());
				break;
			default: t(!0);
		}
	});
}
function Ur$1() {
	return Ae$1() && navigator?.onLine;
}
async function _r$1() {
	if (ne$1() && typeof global < "u" && global != null && global.NetInfo) return (await (global == null ? void 0 : global.NetInfo.fetch()))?.isConnected;
	return !0;
}
function Tr$1() {
	return !0;
}
function Qi(e) {
	switch (ue$2()) {
		case H$1.browser:
			$r$1(e);
			break;
		case H$1.reactNative:
			Rr$1(e);
			break;
		case H$1.node: break;
	}
}
function $r$1(e) {
	!ne$1() && Ae$1() && (window.addEventListener("online", () => e(!0)), window.addEventListener("offline", () => e(!1)));
}
function Rr$1(e) {
	ne$1() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((t) => e(t?.isConnected));
}
var Bt$2 = {};
var ec = class {
	static get(t) {
		return Bt$2[t];
	}
	static set(t, n$2) {
		Bt$2[t] = n$2;
	}
	static delete(t) {
		delete Bt$2[t];
	}
};

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_events$2 = /* @__PURE__ */ __toESM(require_events());
var import_cjs$1 = require_cjs();
var import_cjs$2 = require_cjs$1();
var ze$1 = "wc", Le$2 = 2, he$1 = "core", B$1 = `${ze$1}@2:${he$1}:`, Et$1 = {
	name: he$1,
	logger: "error"
}, It = { database: ":memory:" }, Tt$2 = "crypto", ke$2 = "client_ed25519_seed", Ct$1 = import_cjs$1.ONE_DAY, Pt$1 = "keychain", St$1 = "0.3", Rt$1 = "messages", Ot = "0.3", je$1 = import_cjs$1.SIX_HOURS, At$2 = "publisher", xt$1 = "irn", Nt$1 = "error", Ue$2 = "wss://relay.walletconnect.org", $t$1 = "relayer", C$1 = {
	message: "relayer_message",
	message_ack: "relayer_message_ack",
	connect: "relayer_connect",
	disconnect: "relayer_disconnect",
	error: "relayer_error",
	connection_stalled: "relayer_connection_stalled",
	transport_closed: "relayer_transport_closed",
	publish: "relayer_publish"
}, zt$1 = "_subscription", L$1 = {
	payload: "payload",
	connect: "connect",
	disconnect: "disconnect",
	error: "error"
}, Lt$1 = .1, qs$1 = { database: ":memory:" }, _e$3 = "2.19.1", Gs = 1e4, Q$1 = {
	link_mode: "link_mode",
	relay: "relay"
}, le$1 = {
	inbound: "inbound",
	outbound: "outbound"
}, kt$2 = "0.3", jt$1 = "WALLETCONNECT_CLIENT_ID", Me$3 = "WALLETCONNECT_LINK_MODE_APPS", $$2 = {
	created: "subscription_created",
	deleted: "subscription_deleted",
	expired: "subscription_expired",
	disabled: "subscription_disabled",
	sync: "subscription_sync",
	resubscribed: "subscription_resubscribed"
}, Ws = import_cjs$1.THIRTY_DAYS, Ut$1 = "subscription", Mt$1 = "0.3", Hs = import_cjs$1.FIVE_SECONDS * 1e3, Ft$1 = "pairing", Kt$1 = "0.3", Ys = import_cjs$1.THIRTY_DAYS, ie$1 = {
	wc_pairingDelete: {
		req: {
			ttl: import_cjs$1.ONE_DAY,
			prompt: !1,
			tag: 1e3
		},
		res: {
			ttl: import_cjs$1.ONE_DAY,
			prompt: !1,
			tag: 1001
		}
	},
	wc_pairingPing: {
		req: {
			ttl: import_cjs$1.THIRTY_SECONDS,
			prompt: !1,
			tag: 1002
		},
		res: {
			ttl: import_cjs$1.THIRTY_SECONDS,
			prompt: !1,
			tag: 1003
		}
	},
	unregistered_method: {
		req: {
			ttl: import_cjs$1.ONE_DAY,
			prompt: !1,
			tag: 0
		},
		res: {
			ttl: import_cjs$1.ONE_DAY,
			prompt: !1,
			tag: 0
		}
	}
}, se$1 = {
	create: "pairing_create",
	expire: "pairing_expire",
	delete: "pairing_delete",
	ping: "pairing_ping"
}, M$1 = {
	created: "history_created",
	updated: "history_updated",
	deleted: "history_deleted",
	sync: "history_sync"
}, Bt$1 = "history", Vt$1 = "0.3", qt$1 = "expirer", F$1 = {
	created: "expirer_created",
	deleted: "expirer_deleted",
	expired: "expirer_expired",
	sync: "expirer_sync"
}, Gt$1 = "0.3", Js = import_cjs$1.ONE_DAY, Wt$1 = "verify-api", Xs = "https://verify.walletconnect.com", Ht = "https://verify.walletconnect.org", ue$1 = Ht, Yt$2 = `${ue$1}/v3`, Jt$1 = [Xs, Ht], Xt$1 = "echo", Zt$1 = "https://echo.walletconnect.com", Zs = "event-client", G$1 = {
	pairing_started: "pairing_started",
	pairing_uri_validation_success: "pairing_uri_validation_success",
	pairing_uri_not_expired: "pairing_uri_not_expired",
	store_new_pairing: "store_new_pairing",
	subscribing_pairing_topic: "subscribing_pairing_topic",
	subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
	existing_pairing: "existing_pairing",
	pairing_not_expired: "pairing_not_expired",
	emit_inactive_pairing: "emit_inactive_pairing",
	emit_session_proposal: "emit_session_proposal",
	subscribing_to_pairing_topic: "subscribing_to_pairing_topic"
}, Y = {
	no_wss_connection: "no_wss_connection",
	no_internet_connection: "no_internet_connection",
	malformed_pairing_uri: "malformed_pairing_uri",
	active_pairing_already_exists: "active_pairing_already_exists",
	subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
	pairing_expired: "pairing_expired",
	proposal_expired: "proposal_expired",
	proposal_listener_not_found: "proposal_listener_not_found"
}, Qs = {
	session_approve_started: "session_approve_started",
	proposal_not_expired: "proposal_not_expired",
	session_namespaces_validation_success: "session_namespaces_validation_success",
	create_session_topic: "create_session_topic",
	subscribing_session_topic: "subscribing_session_topic",
	subscribe_session_topic_success: "subscribe_session_topic_success",
	publishing_session_approve: "publishing_session_approve",
	session_approve_publish_success: "session_approve_publish_success",
	store_session: "store_session",
	publishing_session_settle: "publishing_session_settle",
	session_settle_publish_success: "session_settle_publish_success"
}, er = {
	no_internet_connection: "no_internet_connection",
	no_wss_connection: "no_wss_connection",
	proposal_expired: "proposal_expired",
	subscribe_session_topic_failure: "subscribe_session_topic_failure",
	session_approve_publish_failure: "session_approve_publish_failure",
	session_settle_publish_failure: "session_settle_publish_failure",
	session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure",
	proposal_not_found: "proposal_not_found"
}, tr = {
	authenticated_session_approve_started: "authenticated_session_approve_started",
	authenticated_session_not_expired: "authenticated_session_not_expired",
	chains_caip2_compliant: "chains_caip2_compliant",
	chains_evm_compliant: "chains_evm_compliant",
	create_authenticated_session_topic: "create_authenticated_session_topic",
	cacaos_verified: "cacaos_verified",
	store_authenticated_session: "store_authenticated_session",
	subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic",
	subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success",
	publishing_authenticated_session_approve: "publishing_authenticated_session_approve",
	authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success"
}, ir = {
	no_internet_connection: "no_internet_connection",
	no_wss_connection: "no_wss_connection",
	missing_session_authenticate_request: "missing_session_authenticate_request",
	session_authenticate_request_expired: "session_authenticate_request_expired",
	chains_caip2_compliant_failure: "chains_caip2_compliant_failure",
	chains_evm_compliant_failure: "chains_evm_compliant_failure",
	invalid_cacao: "invalid_cacao",
	subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure",
	authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure",
	authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found"
}, Qt$1 = .1, ei = "event-client", ti$1 = 86400, ii$1 = "https://pulse.walletconnect.org/batch";
function sr(r$1, e) {
	if (r$1.length >= 255) throw new TypeError("Alphabet too long");
	for (var t = new Uint8Array(256), s = 0; s < t.length; s++) t[s] = 255;
	for (var i$2 = 0; i$2 < r$1.length; i$2++) {
		var n$2 = r$1.charAt(i$2), o$2 = n$2.charCodeAt(0);
		if (t[o$2] !== 255) throw new TypeError(n$2 + " is ambiguous");
		t[o$2] = i$2;
	}
	var a$1 = r$1.length, c$3 = r$1.charAt(0), h$4 = Math.log(a$1) / Math.log(256), u$2 = Math.log(256) / Math.log(a$1);
	function d$4(l$2) {
		if (l$2 instanceof Uint8Array || (ArrayBuffer.isView(l$2) ? l$2 = new Uint8Array(l$2.buffer, l$2.byteOffset, l$2.byteLength) : Array.isArray(l$2) && (l$2 = Uint8Array.from(l$2))), !(l$2 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
		if (l$2.length === 0) return "";
		for (var b$3 = 0, x$6 = 0, I$4 = 0, D$3 = l$2.length; I$4 !== D$3 && l$2[I$4] === 0;) I$4++, b$3++;
		for (var j$2 = (D$3 - I$4) * u$2 + 1 >>> 0, T$3 = new Uint8Array(j$2); I$4 !== D$3;) {
			for (var q$4 = l$2[I$4], J$8 = 0, K$4 = j$2 - 1; (q$4 !== 0 || J$8 < x$6) && K$4 !== -1; K$4--, J$8++) q$4 += 256 * T$3[K$4] >>> 0, T$3[K$4] = q$4 % a$1 >>> 0, q$4 = q$4 / a$1 >>> 0;
			if (q$4 !== 0) throw new Error("Non-zero carry");
			x$6 = J$8, I$4++;
		}
		for (var H$5 = j$2 - x$6; H$5 !== j$2 && T$3[H$5] === 0;) H$5++;
		for (var me$6 = c$3.repeat(b$3); H$5 < j$2; ++H$5) me$6 += r$1.charAt(T$3[H$5]);
		return me$6;
	}
	function g$2(l$2) {
		if (typeof l$2 != "string") throw new TypeError("Expected String");
		if (l$2.length === 0) return new Uint8Array();
		var b$3 = 0;
		if (l$2[b$3] !== " ") {
			for (var x$6 = 0, I$4 = 0; l$2[b$3] === c$3;) x$6++, b$3++;
			for (var D$3 = (l$2.length - b$3) * h$4 + 1 >>> 0, j$2 = new Uint8Array(D$3); l$2[b$3];) {
				var T$3 = t[l$2.charCodeAt(b$3)];
				if (T$3 === 255) return;
				for (var q$4 = 0, J$8 = D$3 - 1; (T$3 !== 0 || q$4 < I$4) && J$8 !== -1; J$8--, q$4++) T$3 += a$1 * j$2[J$8] >>> 0, j$2[J$8] = T$3 % 256 >>> 0, T$3 = T$3 / 256 >>> 0;
				if (T$3 !== 0) throw new Error("Non-zero carry");
				I$4 = q$4, b$3++;
			}
			if (l$2[b$3] !== " ") {
				for (var K$4 = D$3 - I$4; K$4 !== D$3 && j$2[K$4] === 0;) K$4++;
				for (var H$5 = new Uint8Array(x$6 + (D$3 - K$4)), me$6 = x$6; K$4 !== D$3;) H$5[me$6++] = j$2[K$4++];
				return H$5;
			}
		}
	}
	function _$4(l$2) {
		var b$3 = g$2(l$2);
		if (b$3) return b$3;
		throw new Error(`Non-${e} character`);
	}
	return {
		encode: d$4,
		decodeUnsafe: g$2,
		decode: _$4
	};
}
var nr = sr;
var si$1 = (r$1) => {
	if (r$1 instanceof Uint8Array && r$1.constructor.name === "Uint8Array") return r$1;
	if (r$1 instanceof ArrayBuffer) return new Uint8Array(r$1);
	if (ArrayBuffer.isView(r$1)) return new Uint8Array(r$1.buffer, r$1.byteOffset, r$1.byteLength);
	throw new Error("Unknown type, must be binary type");
}, or = (r$1) => new TextEncoder().encode(r$1), ar = (r$1) => new TextDecoder().decode(r$1);
var cr = class {
	constructor(e, t, s) {
		this.name = e, this.prefix = t, this.baseEncode = s;
	}
	encode(e) {
		if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
		throw Error("Unknown type, must be binary type");
	}
};
var hr = class {
	constructor(e, t, s) {
		if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
		this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;
	}
	decode(e) {
		if (typeof e == "string") {
			if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
			return this.baseDecode(e.slice(this.prefix.length));
		} else throw Error("Can only multibase decode strings");
	}
	or(e) {
		return ri$1(this, e);
	}
};
var lr = class {
	constructor(e) {
		this.decoders = e;
	}
	or(e) {
		return ri$1(this, e);
	}
	decode(e) {
		const t = e[0], s = this.decoders[t];
		if (s) return s.decode(e);
		throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
	}
};
var ri$1 = (r$1, e) => new lr({
	...r$1.decoders || { [r$1.prefix]: r$1 },
	...e.decoders || { [e.prefix]: e }
});
var ur = class {
	constructor(e, t, s, i$2) {
		this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = i$2, this.encoder = new cr(e, t, s), this.decoder = new hr(e, t, i$2);
	}
	encode(e) {
		return this.encoder.encode(e);
	}
	decode(e) {
		return this.decoder.decode(e);
	}
};
var Ee$2 = ({ name: r$1, prefix: e, encode: t, decode: s }) => new ur(r$1, e, t, s), de$2 = ({ prefix: r$1, name: e, alphabet: t }) => {
	const { encode: s, decode: i$2 } = nr(t, e);
	return Ee$2({
		prefix: r$1,
		name: e,
		encode: s,
		decode: (n$2) => si$1(i$2(n$2))
	});
}, dr = (r$1, e, t, s) => {
	const i$2 = {};
	for (let u$2 = 0; u$2 < e.length; ++u$2) i$2[e[u$2]] = u$2;
	let n$2 = r$1.length;
	for (; r$1[n$2 - 1] === "=";) --n$2;
	const o$2 = new Uint8Array(n$2 * t / 8 | 0);
	let a$1 = 0, c$3 = 0, h$4 = 0;
	for (let u$2 = 0; u$2 < n$2; ++u$2) {
		const d$4 = i$2[r$1[u$2]];
		if (d$4 === void 0) throw new SyntaxError(`Non-${s} character`);
		c$3 = c$3 << t | d$4, a$1 += t, a$1 >= 8 && (a$1 -= 8, o$2[h$4++] = 255 & c$3 >> a$1);
	}
	if (a$1 >= t || 255 & c$3 << 8 - a$1) throw new SyntaxError("Unexpected end of data");
	return o$2;
}, gr = (r$1, e, t) => {
	const s = e[e.length - 1] === "=", i$2 = (1 << t) - 1;
	let n$2 = "", o$2 = 0, a$1 = 0;
	for (let c$3 = 0; c$3 < r$1.length; ++c$3) for (a$1 = a$1 << 8 | r$1[c$3], o$2 += 8; o$2 > t;) o$2 -= t, n$2 += e[i$2 & a$1 >> o$2];
	if (o$2 && (n$2 += e[i$2 & a$1 << t - o$2]), s) for (; n$2.length * t & 7;) n$2 += "=";
	return n$2;
}, P$2 = ({ name: r$1, prefix: e, bitsPerChar: t, alphabet: s }) => Ee$2({
	prefix: e,
	name: r$1,
	encode(i$2) {
		return gr(i$2, s, t);
	},
	decode(i$2) {
		return dr(i$2, s, t, r$1);
	}
}), pr$1 = Ee$2({
	prefix: "\0",
	name: "identity",
	encode: (r$1) => ar(r$1),
	decode: (r$1) => or(r$1)
});
var yr = Object.freeze({
	__proto__: null,
	identity: pr$1
});
var br = P$2({
	prefix: "0",
	name: "base2",
	alphabet: "01",
	bitsPerChar: 1
});
var mr = Object.freeze({
	__proto__: null,
	base2: br
});
var fr = P$2({
	prefix: "7",
	name: "base8",
	alphabet: "01234567",
	bitsPerChar: 3
});
var Dr = Object.freeze({
	__proto__: null,
	base8: fr
});
var vr = de$2({
	prefix: "9",
	name: "base10",
	alphabet: "0123456789"
});
var wr = Object.freeze({
	__proto__: null,
	base10: vr
});
var _r = P$2({
	prefix: "f",
	name: "base16",
	alphabet: "0123456789abcdef",
	bitsPerChar: 4
}), Er = P$2({
	prefix: "F",
	name: "base16upper",
	alphabet: "0123456789ABCDEF",
	bitsPerChar: 4
});
var Ir = Object.freeze({
	__proto__: null,
	base16: _r,
	base16upper: Er
});
var Tr = P$2({
	prefix: "b",
	name: "base32",
	alphabet: "abcdefghijklmnopqrstuvwxyz234567",
	bitsPerChar: 5
}), Cr = P$2({
	prefix: "B",
	name: "base32upper",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
	bitsPerChar: 5
}), Pr = P$2({
	prefix: "c",
	name: "base32pad",
	alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
	bitsPerChar: 5
}), Sr = P$2({
	prefix: "C",
	name: "base32padupper",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
	bitsPerChar: 5
}), Rr = P$2({
	prefix: "v",
	name: "base32hex",
	alphabet: "0123456789abcdefghijklmnopqrstuv",
	bitsPerChar: 5
}), Or$1 = P$2({
	prefix: "V",
	name: "base32hexupper",
	alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
	bitsPerChar: 5
}), Ar$1 = P$2({
	prefix: "t",
	name: "base32hexpad",
	alphabet: "0123456789abcdefghijklmnopqrstuv=",
	bitsPerChar: 5
}), xr = P$2({
	prefix: "T",
	name: "base32hexpadupper",
	alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
	bitsPerChar: 5
}), Nr$1 = P$2({
	prefix: "h",
	name: "base32z",
	alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
	bitsPerChar: 5
});
var $r = Object.freeze({
	__proto__: null,
	base32: Tr,
	base32upper: Cr,
	base32pad: Pr,
	base32padupper: Sr,
	base32hex: Rr,
	base32hexupper: Or$1,
	base32hexpad: Ar$1,
	base32hexpadupper: xr,
	base32z: Nr$1
});
var zr$1 = de$2({
	prefix: "k",
	name: "base36",
	alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), Lr = de$2({
	prefix: "K",
	name: "base36upper",
	alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var kr = Object.freeze({
	__proto__: null,
	base36: zr$1,
	base36upper: Lr
});
var jr = de$2({
	name: "base58btc",
	prefix: "z",
	alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), Ur = de$2({
	name: "base58flickr",
	prefix: "Z",
	alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var Mr = Object.freeze({
	__proto__: null,
	base58btc: jr,
	base58flickr: Ur
});
var Fr = P$2({
	prefix: "m",
	name: "base64",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	bitsPerChar: 6
}), Kr = P$2({
	prefix: "M",
	name: "base64pad",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
	bitsPerChar: 6
}), Br = P$2({
	prefix: "u",
	name: "base64url",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
	bitsPerChar: 6
}), Vr = P$2({
	prefix: "U",
	name: "base64urlpad",
	alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
	bitsPerChar: 6
});
var qr = Object.freeze({
	__proto__: null,
	base64: Fr,
	base64pad: Kr,
	base64url: Br,
	base64urlpad: Vr
});
var ni = Array.from(""), Gr = ni.reduce((r$1, e, t) => (r$1[t] = e, r$1), []), Wr = ni.reduce((r$1, e, t) => (r$1[e.codePointAt(0)] = t, r$1), []);
function Hr(r$1) {
	return r$1.reduce((e, t) => (e += Gr[t], e), "");
}
function Yr$1(r$1) {
	const e = [];
	for (const t of r$1) {
		const s = Wr[t.codePointAt(0)];
		if (s === void 0) throw new Error(`Non-base256emoji character: ${t}`);
		e.push(s);
	}
	return new Uint8Array(e);
}
var Jr$1 = Ee$2({
	prefix: "",
	name: "base256emoji",
	encode: Hr,
	decode: Yr$1
});
var Xr$1 = Object.freeze({
	__proto__: null,
	base256emoji: Jr$1
}), Zr = ai$1, oi$1 = 128, en = -128, tn = Math.pow(2, 31);
function ai$1(r$1, e, t) {
	e = e || [], t = t || 0;
	for (var s = t; r$1 >= tn;) e[t++] = r$1 & 255 | oi$1, r$1 /= 128;
	for (; r$1 & en;) e[t++] = r$1 & 255 | oi$1, r$1 >>>= 7;
	return e[t] = r$1 | 0, ai$1.bytes = t - s + 1, e;
}
var sn$1 = Fe$2, rn = 128, ci$1 = 127;
function Fe$2(r$1, s) {
	var t = 0, s = s || 0, i$2 = 0, n$2 = s, o$2, a$1 = r$1.length;
	do {
		if (n$2 >= a$1) throw Fe$2.bytes = 0, /* @__PURE__ */ new RangeError("Could not decode varint");
		o$2 = r$1[n$2++], t += i$2 < 28 ? (o$2 & ci$1) << i$2 : (o$2 & ci$1) * Math.pow(2, i$2), i$2 += 7;
	} while (o$2 >= rn);
	return Fe$2.bytes = n$2 - s, t;
}
var nn = Math.pow(2, 7), on = Math.pow(2, 14), an = Math.pow(2, 21), cn = Math.pow(2, 28), hn = Math.pow(2, 35), ln = Math.pow(2, 42), un = Math.pow(2, 49), dn = Math.pow(2, 56), gn = Math.pow(2, 63), pn = function(r$1) {
	return r$1 < nn ? 1 : r$1 < on ? 2 : r$1 < an ? 3 : r$1 < cn ? 4 : r$1 < hn ? 5 : r$1 < ln ? 6 : r$1 < un ? 7 : r$1 < dn ? 8 : r$1 < gn ? 9 : 10;
}, hi$1 = {
	encode: Zr,
	decode: sn$1,
	encodingLength: pn
};
var li$1 = (r$1, e, t = 0) => (hi$1.encode(r$1, e, t), e), ui$1 = (r$1) => hi$1.encodingLength(r$1), Ke$2 = (r$1, e) => {
	const t = e.byteLength, s = ui$1(r$1), i$2 = s + ui$1(t), n$2 = new Uint8Array(i$2 + t);
	return li$1(r$1, n$2, 0), li$1(t, n$2, s), n$2.set(e, i$2), new bn(r$1, t, e, n$2);
};
var bn = class {
	constructor(e, t, s, i$2) {
		this.code = e, this.size = t, this.digest = s, this.bytes = i$2;
	}
};
var di$1 = ({ name: r$1, code: e, encode: t }) => new mn(r$1, e, t);
var mn = class {
	constructor(e, t, s) {
		this.name = e, this.code = t, this.encode = s;
	}
	digest(e) {
		if (e instanceof Uint8Array) {
			const t = this.encode(e);
			return t instanceof Uint8Array ? Ke$2(this.code, t) : t.then((s) => Ke$2(this.code, s));
		} else throw Error("Unknown type, must be binary type");
	}
};
var gi = (r$1) => async (e) => new Uint8Array(await crypto.subtle.digest(r$1, e)), fn = di$1({
	name: "sha2-256",
	code: 18,
	encode: gi("SHA-256")
}), Dn = di$1({
	name: "sha2-512",
	code: 19,
	encode: gi("SHA-512")
});
var vn = Object.freeze({
	__proto__: null,
	sha256: fn,
	sha512: Dn
});
var pi$1 = 0, wn = "identity", yi = si$1, _n = (r$1) => Ke$2(pi$1, yi(r$1)), En = {
	code: pi$1,
	name: wn,
	encode: yi,
	digest: _n
};
var In$1 = Object.freeze({
	__proto__: null,
	identity: En
});
new TextEncoder(), new TextDecoder();
var bi$1 = {
	...yr,
	...mr,
	...Dr,
	...wr,
	...Ir,
	...$r,
	...kr,
	...Mr,
	...qr,
	...Xr$1
};
({
	...vn,
	...In$1
});
function Tn(r$1 = 0) {
	return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r$1) : new Uint8Array(r$1);
}
function mi$1(r$1, e, t, s) {
	return {
		name: r$1,
		prefix: e,
		encoder: {
			name: r$1,
			prefix: e,
			encode: t
		},
		decoder: { decode: s }
	};
}
var fi$1 = mi$1("utf8", "u", (r$1) => "u" + new TextDecoder("utf8").decode(r$1), (r$1) => new TextEncoder().encode(r$1.substring(1))), Be$2 = mi$1("ascii", "a", (r$1) => {
	let e = "a";
	for (let t = 0; t < r$1.length; t++) e += String.fromCharCode(r$1[t]);
	return e;
}, (r$1) => {
	r$1 = r$1.substring(1);
	const e = Tn(r$1.length);
	for (let t = 0; t < r$1.length; t++) e[t] = r$1.charCodeAt(t);
	return e;
}), Cn = {
	utf8: fi$1,
	"utf-8": fi$1,
	hex: bi$1.base16,
	latin1: Be$2,
	ascii: Be$2,
	binary: Be$2,
	...bi$1
};
function Pn(r$1, e = "utf8") {
	const t = Cn[e];
	if (!t) throw new Error(`Unsupported encoding "${e}"`);
	return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r$1, "utf8") : t.decoder.decode(`${t.prefix}${r$1}`);
}
var Sn = Object.defineProperty, Rn = (r$1, e, t) => e in r$1 ? Sn(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, W$1 = (r$1, e, t) => Rn(r$1, typeof e != "symbol" ? e + "" : e, t);
var Di$1 = class {
	constructor(e, t) {
		this.core = e, this.logger = t, W$1(this, "keychain", /* @__PURE__ */ new Map()), W$1(this, "name", Pt$1), W$1(this, "version", St$1), W$1(this, "initialized", !1), W$1(this, "storagePrefix", B$1), W$1(this, "init", async () => {
			if (!this.initialized) {
				const s = await this.getKeyChain();
				typeof s < "u" && (this.keychain = s), this.initialized = !0;
			}
		}), W$1(this, "has", (s) => (this.isInitialized(), this.keychain.has(s))), W$1(this, "set", async (s, i$2) => {
			this.isInitialized(), this.keychain.set(s, i$2), await this.persist();
		}), W$1(this, "get", (s) => {
			this.isInitialized();
			const i$2 = this.keychain.get(s);
			if (typeof i$2 > "u") {
				const { message: n$2 } = te$1("NO_MATCHING_KEY", `${this.name}: ${s}`);
				throw new Error(n$2);
			}
			return i$2;
		}), W$1(this, "del", async (s) => {
			this.isInitialized(), this.keychain.delete(s), await this.persist();
		}), this.core = e, this.logger = E$1(t, this.name);
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
	}
	async setKeyChain(e) {
		await this.core.storage.setItem(this.storageKey, ro(e));
	}
	async getKeyChain() {
		const e = await this.core.storage.getItem(this.storageKey);
		return typeof e < "u" ? oo(e) : void 0;
	}
	async persist() {
		await this.setKeyChain(this.keychain);
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$1("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var On$1 = Object.defineProperty, An = (r$1, e, t) => e in r$1 ? On$1(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, S$2 = (r$1, e, t) => An(r$1, typeof e != "symbol" ? e + "" : e, t);
var vi$1 = class {
	constructor(e, t, s) {
		this.core = e, this.logger = t, S$2(this, "name", Tt$2), S$2(this, "keychain"), S$2(this, "randomSessionIdentifier", oi()), S$2(this, "initialized", !1), S$2(this, "init", async () => {
			this.initialized || (await this.keychain.init(), this.initialized = !0);
		}), S$2(this, "hasKeys", (i$2) => (this.isInitialized(), this.keychain.has(i$2))), S$2(this, "getClientId", async () => {
			this.isInitialized();
			const i$2 = await this.getClientSeed(), n$2 = Po$4(i$2);
			return Qe$5(n$2.publicKey);
		}), S$2(this, "generateKeyPair", () => {
			this.isInitialized();
			const i$2 = ri();
			return this.setPrivateKey(i$2.publicKey, i$2.privateKey);
		}), S$2(this, "signJWT", async (i$2) => {
			this.isInitialized();
			const n$2 = await this.getClientSeed(), o$2 = Po$4(n$2), a$1 = this.randomSessionIdentifier, c$3 = Ct$1;
			return await Qo$1(a$1, i$2, c$3, o$2);
		}), S$2(this, "generateSharedKey", (i$2, n$2, o$2) => {
			this.isInitialized();
			const c$3 = si(this.getPrivateKey(i$2), n$2);
			return this.setSymKey(c$3, o$2);
		}), S$2(this, "setSymKey", async (i$2, n$2) => {
			this.isInitialized();
			const o$2 = n$2 || ii(i$2);
			return await this.keychain.set(o$2, i$2), o$2;
		}), S$2(this, "deleteKeyPair", async (i$2) => {
			this.isInitialized(), await this.keychain.del(i$2);
		}), S$2(this, "deleteSymKey", async (i$2) => {
			this.isInitialized(), await this.keychain.del(i$2);
		}), S$2(this, "encode", async (i$2, n$2, o$2) => {
			this.isInitialized();
			const a$1 = rr(o$2), c$3 = safeJsonStringify(n$2);
			if (pi(a$1)) return fi(c$3, o$2?.encoding);
			if (hi(a$1)) {
				const g$2 = a$1.senderPublicKey, _$4 = a$1.receiverPublicKey;
				i$2 = await this.generateSharedKey(g$2, _$4);
			}
			const h$4 = this.getSymKey(i$2), { type: u$2, senderPublicKey: d$4 } = a$1;
			return ai({
				type: u$2,
				symKey: h$4,
				message: c$3,
				senderPublicKey: d$4,
				encoding: o$2?.encoding
			});
		}), S$2(this, "decode", async (i$2, n$2, o$2) => {
			this.isInitialized();
			const a$1 = di(n$2, o$2);
			if (pi(a$1)) return safeJsonParse(li(n$2, o$2?.encoding));
			if (hi(a$1)) {
				const c$3 = a$1.receiverPublicKey, h$4 = a$1.senderPublicKey;
				i$2 = await this.generateSharedKey(c$3, h$4);
			}
			try {
				return safeJsonParse(ui({
					symKey: this.getSymKey(i$2),
					encoded: n$2,
					encoding: o$2?.encoding
				}));
			} catch (c$3) {
				this.logger.error(`Failed to decode message from topic: '${i$2}', clientId: '${await this.getClientId()}'`), this.logger.error(c$3);
			}
		}), S$2(this, "getPayloadType", (i$2, n$2 = At$1) => {
			return fe$2(Fe$1({
				encoded: i$2,
				encoding: n$2
			}).type);
		}), S$2(this, "getPayloadSenderPublicKey", (i$2, n$2 = At$1) => {
			const o$2 = Fe$1({
				encoded: i$2,
				encoding: n$2
			});
			return o$2.senderPublicKey ? toString(o$2.senderPublicKey, V$2) : void 0;
		}), this.core = e, this.logger = E$1(t, this.name), this.keychain = s || new Di$1(this.core, this.logger);
	}
	get context() {
		return y$1(this.logger);
	}
	async setPrivateKey(e, t) {
		return await this.keychain.set(e, t), e;
	}
	getPrivateKey(e) {
		return this.keychain.get(e);
	}
	async getClientSeed() {
		let e = "";
		try {
			e = this.keychain.get(ke$2);
		} catch {
			e = oi(), await this.keychain.set(ke$2, e);
		}
		return Pn(e, "base16");
	}
	getSymKey(e) {
		return this.keychain.get(e);
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$1("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var xn = Object.defineProperty, Nn = Object.defineProperties, $n = Object.getOwnPropertyDescriptors, wi$1 = Object.getOwnPropertySymbols, zn = Object.prototype.hasOwnProperty, Ln = Object.prototype.propertyIsEnumerable, Ve$1 = (r$1, e, t) => e in r$1 ? xn(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, kn = (r$1, e) => {
	for (var t in e || (e = {})) zn.call(e, t) && Ve$1(r$1, t, e[t]);
	if (wi$1) for (var t of wi$1(e)) Ln.call(e, t) && Ve$1(r$1, t, e[t]);
	return r$1;
}, jn = (r$1, e) => Nn(r$1, $n(e)), k$2 = (r$1, e, t) => Ve$1(r$1, typeof e != "symbol" ? e + "" : e, t);
var _i = class extends y$2 {
	constructor(e, t) {
		super(e, t), this.logger = e, this.core = t, k$2(this, "messages", /* @__PURE__ */ new Map()), k$2(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k$2(this, "name", Rt$1), k$2(this, "version", Ot), k$2(this, "initialized", !1), k$2(this, "storagePrefix", B$1), k$2(this, "init", async () => {
			if (!this.initialized) {
				this.logger.trace("Initialized");
				try {
					const s = await this.getRelayerMessages();
					typeof s < "u" && (this.messages = s);
					const i$2 = await this.getRelayerMessagesWithoutClientAck();
					typeof i$2 < "u" && (this.messagesWithoutClientAck = i$2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
						type: "method",
						method: "restore",
						size: this.messages.size
					});
				} catch (s) {
					this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);
				} finally {
					this.initialized = !0;
				}
			}
		}), k$2(this, "set", async (s, i$2, n$2) => {
			this.isInitialized();
			const o$2 = ci(i$2);
			let a$1 = this.messages.get(s);
			if (typeof a$1 > "u" && (a$1 = {}), typeof a$1[o$2] < "u") return o$2;
			if (a$1[o$2] = i$2, this.messages.set(s, a$1), n$2 === le$1.inbound) {
				const c$3 = this.messagesWithoutClientAck.get(s) || {};
				this.messagesWithoutClientAck.set(s, jn(kn({}, c$3), { [o$2]: i$2 }));
			}
			return await this.persist(), o$2;
		}), k$2(this, "get", (s) => {
			this.isInitialized();
			let i$2 = this.messages.get(s);
			return typeof i$2 > "u" && (i$2 = {}), i$2;
		}), k$2(this, "getWithoutAck", (s) => {
			this.isInitialized();
			const i$2 = {};
			for (const n$2 of s) {
				const o$2 = this.messagesWithoutClientAck.get(n$2) || {};
				i$2[n$2] = Object.values(o$2);
			}
			return i$2;
		}), k$2(this, "has", (s, i$2) => {
			this.isInitialized();
			return typeof this.get(s)[ci(i$2)] < "u";
		}), k$2(this, "ack", async (s, i$2) => {
			this.isInitialized();
			const n$2 = this.messagesWithoutClientAck.get(s);
			if (typeof n$2 > "u") return;
			const o$2 = ci(i$2);
			delete n$2[o$2], Object.keys(n$2).length === 0 ? this.messagesWithoutClientAck.delete(s) : this.messagesWithoutClientAck.set(s, n$2), await this.persist();
		}), k$2(this, "del", async (s) => {
			this.isInitialized(), this.messages.delete(s), this.messagesWithoutClientAck.delete(s), await this.persist();
		}), this.logger = E$1(e, this.name), this.core = t;
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
	}
	get storageKeyWithoutClientAck() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
	}
	async setRelayerMessages(e) {
		await this.core.storage.setItem(this.storageKey, ro(e));
	}
	async setRelayerMessagesWithoutClientAck(e) {
		await this.core.storage.setItem(this.storageKeyWithoutClientAck, ro(e));
	}
	async getRelayerMessages() {
		const e = await this.core.storage.getItem(this.storageKey);
		return typeof e < "u" ? oo(e) : void 0;
	}
	async getRelayerMessagesWithoutClientAck() {
		const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
		return typeof e < "u" ? oo(e) : void 0;
	}
	async persist() {
		await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$1("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var Un = Object.defineProperty, Mn = Object.defineProperties, Fn = Object.getOwnPropertyDescriptors, Ei$1 = Object.getOwnPropertySymbols, Kn = Object.prototype.hasOwnProperty, Bn = Object.prototype.propertyIsEnumerable, qe$2 = (r$1, e, t) => e in r$1 ? Un(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, Ie$1 = (r$1, e) => {
	for (var t in e || (e = {})) Kn.call(e, t) && qe$2(r$1, t, e[t]);
	if (Ei$1) for (var t of Ei$1(e)) Bn.call(e, t) && qe$2(r$1, t, e[t]);
	return r$1;
}, Ge$2 = (r$1, e) => Mn(r$1, Fn(e)), V$3 = (r$1, e, t) => qe$2(r$1, typeof e != "symbol" ? e + "" : e, t);
var Vn = class extends m {
	constructor(e, t) {
		super(e, t), this.relayer = e, this.logger = t, V$3(this, "events", new import_events$2.EventEmitter()), V$3(this, "name", At$2), V$3(this, "queue", /* @__PURE__ */ new Map()), V$3(this, "publishTimeout", (0, import_cjs$1.toMiliseconds)(import_cjs$1.ONE_MINUTE)), V$3(this, "initialPublishTimeout", (0, import_cjs$1.toMiliseconds)(import_cjs$1.ONE_SECOND * 15)), V$3(this, "needsTransportRestart", !1), V$3(this, "publish", async (s, i$2, n$2) => {
			var o$2;
			this.logger.debug("Publishing Payload"), this.logger.trace({
				type: "method",
				method: "publish",
				params: {
					topic: s,
					message: i$2,
					opts: n$2
				}
			});
			const a$1 = n$2?.ttl || je$1, c$3 = bi(n$2), h$4 = n$2?.prompt || !1, u$2 = n$2?.tag || 0, d$4 = n$2?.id || getBigIntRpcId().toString(), g$2 = {
				topic: s,
				message: i$2,
				opts: {
					ttl: a$1,
					relay: c$3,
					prompt: h$4,
					tag: u$2,
					id: d$4,
					attestation: n$2?.attestation,
					tvf: n$2?.tvf
				}
			}, _$4 = `Failed to publish payload, please try again. id:${d$4} tag:${u$2}`;
			try {
				const l$2 = new Promise(async (b$3) => {
					const x$6 = ({ id: D$3 }) => {
						g$2.opts.id === D$3 && (this.removeRequestFromQueue(D$3), this.relayer.events.removeListener(C$1.publish, x$6), b$3(g$2));
					};
					this.relayer.events.on(C$1.publish, x$6);
					const I$4 = uo(new Promise((D$3, j$2) => {
						this.rpcPublish({
							topic: s,
							message: i$2,
							ttl: a$1,
							prompt: h$4,
							tag: u$2,
							id: d$4,
							attestation: n$2?.attestation,
							tvf: n$2?.tvf
						}).then(D$3).catch((T$3) => {
							this.logger.warn(T$3, T$3?.message), j$2(T$3);
						});
					}), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d$4} tag:${u$2}`);
					try {
						await I$4, this.events.removeListener(C$1.publish, x$6);
					} catch (D$3) {
						this.queue.set(d$4, Ge$2(Ie$1({}, g$2), { attempt: 1 })), this.logger.warn(D$3, D$3?.message);
					}
				});
				this.logger.trace({
					type: "method",
					method: "publish",
					params: {
						id: d$4,
						topic: s,
						message: i$2,
						opts: n$2
					}
				}), await uo(l$2, this.publishTimeout, _$4);
			} catch (l$2) {
				if (this.logger.debug("Failed to Publish Payload"), this.logger.error(l$2), (o$2 = n$2?.internal) != null && o$2.throwOnFailedPublish) throw l$2;
			} finally {
				this.queue.delete(d$4);
			}
		}), V$3(this, "on", (s, i$2) => {
			this.events.on(s, i$2);
		}), V$3(this, "once", (s, i$2) => {
			this.events.once(s, i$2);
		}), V$3(this, "off", (s, i$2) => {
			this.events.off(s, i$2);
		}), V$3(this, "removeListener", (s, i$2) => {
			this.events.removeListener(s, i$2);
		}), this.relayer = e, this.logger = E$1(t, this.name), this.registerEventListeners();
	}
	get context() {
		return y$1(this.logger);
	}
	async rpcPublish(e) {
		var t, s, i$2, n$2;
		const { topic: o$2, message: a$1, ttl: c$3 = je$1, prompt: h$4, tag: u$2, id: d$4, attestation: g$2, tvf: _$4 } = e, l$2 = {
			method: wi(bi().protocol).publish,
			params: Ie$1({
				topic: o$2,
				message: a$1,
				ttl: c$3,
				prompt: h$4,
				tag: u$2,
				attestation: g$2
			}, _$4),
			id: d$4
		};
		ae$1((t = l$2.params) == null ? void 0 : t.prompt) && ((s = l$2.params) == null || delete s.prompt), ae$1((i$2 = l$2.params) == null ? void 0 : i$2.tag) && ((n$2 = l$2.params) == null || delete n$2.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
			type: "message",
			direction: "outgoing",
			request: l$2
		});
		const b$3 = await this.relayer.request(l$2);
		return this.relayer.events.emit(C$1.publish, e), this.logger.debug("Successfully Published Payload"), b$3;
	}
	removeRequestFromQueue(e) {
		this.queue.delete(e);
	}
	checkQueue() {
		this.queue.forEach(async (e, t) => {
			const s = e.attempt + 1;
			this.queue.set(t, Ge$2(Ie$1({}, e), { attempt: s }));
			const { topic: i$2, message: n$2, opts: o$2, attestation: a$1 } = e;
			this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s}`), await this.rpcPublish(Ge$2(Ie$1({}, e), {
				topic: i$2,
				message: n$2,
				ttl: o$2.ttl,
				prompt: o$2.prompt,
				tag: o$2.tag,
				id: o$2.id,
				attestation: a$1,
				tvf: o$2.tvf
			})), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
		});
	}
	registerEventListeners() {
		this.relayer.core.heartbeat.on(r.pulse, () => {
			if (this.needsTransportRestart) {
				this.needsTransportRestart = !1, this.relayer.events.emit(C$1.connection_stalled);
				return;
			}
			this.checkQueue();
		}), this.relayer.on(C$1.message_ack, (e) => {
			this.removeRequestFromQueue(e.id.toString());
		});
	}
};
var qn = Object.defineProperty, Gn = (r$1, e, t) => e in r$1 ? qn(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, re$1 = (r$1, e, t) => Gn(r$1, typeof e != "symbol" ? e + "" : e, t);
var Wn = class {
	constructor() {
		re$1(this, "map", /* @__PURE__ */ new Map()), re$1(this, "set", (e, t) => {
			const s = this.get(e);
			this.exists(e, t) || this.map.set(e, [...s, t]);
		}), re$1(this, "get", (e) => this.map.get(e) || []), re$1(this, "exists", (e, t) => this.get(e).includes(t)), re$1(this, "delete", (e, t) => {
			if (typeof t > "u") {
				this.map.delete(e);
				return;
			}
			if (!this.map.has(e)) return;
			const s = this.get(e);
			if (!this.exists(e, t)) return;
			const i$2 = s.filter((n$2) => n$2 !== t);
			if (!i$2.length) {
				this.map.delete(e);
				return;
			}
			this.map.set(e, i$2);
		}), re$1(this, "clear", () => {
			this.map.clear();
		});
	}
	get topics() {
		return Array.from(this.map.keys());
	}
};
var Hn = Object.defineProperty, Yn = Object.defineProperties, Jn = Object.getOwnPropertyDescriptors, Ii = Object.getOwnPropertySymbols, Xn = Object.prototype.hasOwnProperty, Zn = Object.prototype.propertyIsEnumerable, We$2 = (r$1, e, t) => e in r$1 ? Hn(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, ge$1 = (r$1, e) => {
	for (var t in e || (e = {})) Xn.call(e, t) && We$2(r$1, t, e[t]);
	if (Ii) for (var t of Ii(e)) Zn.call(e, t) && We$2(r$1, t, e[t]);
	return r$1;
}, He$1 = (r$1, e) => Yn(r$1, Jn(e)), f$3 = (r$1, e, t) => We$2(r$1, typeof e != "symbol" ? e + "" : e, t);
var Ti = class extends P$1 {
	constructor(e, t) {
		super(e, t), this.relayer = e, this.logger = t, f$3(this, "subscriptions", /* @__PURE__ */ new Map()), f$3(this, "topicMap", new Wn()), f$3(this, "events", new import_events$2.EventEmitter()), f$3(this, "name", Ut$1), f$3(this, "version", Mt$1), f$3(this, "pending", /* @__PURE__ */ new Map()), f$3(this, "cached", []), f$3(this, "initialized", !1), f$3(this, "storagePrefix", B$1), f$3(this, "subscribeTimeout", (0, import_cjs$1.toMiliseconds)(import_cjs$1.ONE_MINUTE)), f$3(this, "initialSubscribeTimeout", (0, import_cjs$1.toMiliseconds)(import_cjs$1.ONE_SECOND * 15)), f$3(this, "clientId"), f$3(this, "batchSubscribeTopicsLimit", 500), f$3(this, "init", async () => {
			this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = !0;
		}), f$3(this, "subscribe", async (s, i$2) => {
			this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({
				type: "method",
				method: "subscribe",
				params: {
					topic: s,
					opts: i$2
				}
			});
			try {
				const n$2 = bi(i$2), o$2 = {
					topic: s,
					relay: n$2,
					transportType: i$2?.transportType
				};
				this.pending.set(s, o$2);
				const a$1 = await this.rpcSubscribe(s, n$2, i$2);
				return typeof a$1 == "string" && (this.onSubscribe(a$1, o$2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({
					type: "method",
					method: "subscribe",
					params: {
						topic: s,
						opts: i$2
					}
				})), a$1;
			} catch (n$2) {
				throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n$2), n$2;
			}
		}), f$3(this, "unsubscribe", async (s, i$2) => {
			this.isInitialized(), typeof i$2?.id < "u" ? await this.unsubscribeById(s, i$2.id, i$2) : await this.unsubscribeByTopic(s, i$2);
		}), f$3(this, "isSubscribed", (s) => new Promise((i$2) => {
			i$2(this.topicMap.topics.includes(s));
		})), f$3(this, "isKnownTopic", (s) => new Promise((i$2) => {
			i$2(this.topicMap.topics.includes(s) || this.pending.has(s) || this.cached.some((n$2) => n$2.topic === s));
		})), f$3(this, "on", (s, i$2) => {
			this.events.on(s, i$2);
		}), f$3(this, "once", (s, i$2) => {
			this.events.once(s, i$2);
		}), f$3(this, "off", (s, i$2) => {
			this.events.off(s, i$2);
		}), f$3(this, "removeListener", (s, i$2) => {
			this.events.removeListener(s, i$2);
		}), f$3(this, "start", async () => {
			await this.onConnect();
		}), f$3(this, "stop", async () => {
			await this.onDisconnect();
		}), f$3(this, "restart", async () => {
			await this.restore(), await this.onRestart();
		}), f$3(this, "checkPending", async () => {
			if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
			const s = [];
			this.pending.forEach((i$2) => {
				s.push(i$2);
			}), await this.batchSubscribe(s);
		}), f$3(this, "registerEventListeners", () => {
			this.relayer.core.heartbeat.on(r.pulse, async () => {
				await this.checkPending();
			}), this.events.on($$2.created, async (s) => {
				const i$2 = $$2.created;
				this.logger.info(`Emitting ${i$2}`), this.logger.debug({
					type: "event",
					event: i$2,
					data: s
				}), await this.persist();
			}), this.events.on($$2.deleted, async (s) => {
				const i$2 = $$2.deleted;
				this.logger.info(`Emitting ${i$2}`), this.logger.debug({
					type: "event",
					event: i$2,
					data: s
				}), await this.persist();
			});
		}), this.relayer = e, this.logger = E$1(t, this.name), this.clientId = "";
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
	}
	get length() {
		return this.subscriptions.size;
	}
	get ids() {
		return Array.from(this.subscriptions.keys());
	}
	get values() {
		return Array.from(this.subscriptions.values());
	}
	get topics() {
		return this.topicMap.topics;
	}
	get hasAnyTopics() {
		return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
	}
	hasSubscription(e, t) {
		let s = !1;
		try {
			s = this.getSubscription(e).topic === t;
		} catch {}
		return s;
	}
	reset() {
		this.cached = [], this.initialized = !0;
	}
	onDisable() {
		this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
	}
	async unsubscribeByTopic(e, t) {
		const s = this.topicMap.get(e);
		await Promise.all(s.map(async (i$2) => await this.unsubscribeById(e, i$2, t)));
	}
	async unsubscribeById(e, t, s) {
		this.logger.debug("Unsubscribing Topic"), this.logger.trace({
			type: "method",
			method: "unsubscribe",
			params: {
				topic: e,
				id: t,
				opts: s
			}
		});
		try {
			const i$2 = bi(s);
			await this.restartToComplete({
				topic: e,
				id: t,
				relay: i$2
			}), await this.rpcUnsubscribe(e, t, i$2);
			const n$2 = de("USER_DISCONNECTED", `${this.name}, ${e}`);
			await this.onUnsubscribe(e, t, n$2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({
				type: "method",
				method: "unsubscribe",
				params: {
					topic: e,
					id: t,
					opts: s
				}
			});
		} catch (i$2) {
			throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i$2), i$2;
		}
	}
	async rpcSubscribe(e, t, s) {
		var i$2;
		(!s || s?.transportType === Q$1.relay) && await this.restartToComplete({
			topic: e,
			id: e,
			relay: t
		});
		const n$2 = {
			method: wi(t.protocol).subscribe,
			params: { topic: e }
		};
		this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
			type: "payload",
			direction: "outgoing",
			request: n$2
		});
		const o$2 = (i$2 = s?.internal) == null ? void 0 : i$2.throwOnFailedPublish;
		try {
			const a$1 = await this.getSubscriptionId(e);
			if (s?.transportType === Q$1.link_mode) return setTimeout(() => {
				(this.relayer.connected || this.relayer.connecting) && this.relayer.request(n$2).catch((u$2) => this.logger.warn(u$2));
			}, (0, import_cjs$1.toMiliseconds)(import_cjs$1.ONE_SECOND)), a$1;
			const h$4 = await uo(new Promise(async (u$2) => {
				const d$4 = (g$2) => {
					g$2.topic === e && (this.events.removeListener($$2.created, d$4), u$2(g$2.id));
				};
				this.events.on($$2.created, d$4);
				try {
					const g$2 = await uo(new Promise((_$4, l$2) => {
						this.relayer.request(n$2).catch((b$3) => {
							this.logger.warn(b$3, b$3?.message), l$2(b$3);
						}).then(_$4);
					}), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
					this.events.removeListener($$2.created, d$4), u$2(g$2);
				} catch {}
			}), this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
			if (!h$4 && o$2) throw new Error(`Subscribing to ${e} failed, please try again`);
			return h$4 ? a$1 : null;
		} catch (a$1) {
			if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C$1.connection_stalled), o$2) throw a$1;
		}
		return null;
	}
	async rpcBatchSubscribe(e) {
		if (!e.length) return;
		const t = e[0].relay, s = {
			method: wi(t.protocol).batchSubscribe,
			params: { topics: e.map((i$2) => i$2.topic) }
		};
		this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
			type: "payload",
			direction: "outgoing",
			request: s
		});
		try {
			await await uo(new Promise((i$2) => {
				this.relayer.request(s).catch((n$2) => this.logger.warn(n$2)).then(i$2);
			}), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
		} catch {
			this.relayer.events.emit(C$1.connection_stalled);
		}
	}
	async rpcBatchFetchMessages(e) {
		if (!e.length) return;
		const t = e[0].relay, s = {
			method: wi(t.protocol).batchFetchMessages,
			params: { topics: e.map((n$2) => n$2.topic) }
		};
		this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
			type: "payload",
			direction: "outgoing",
			request: s
		});
		let i$2;
		try {
			i$2 = await await uo(new Promise((n$2, o$2) => {
				this.relayer.request(s).catch((a$1) => {
					this.logger.warn(a$1), o$2(a$1);
				}).then(n$2);
			}), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
		} catch {
			this.relayer.events.emit(C$1.connection_stalled);
		}
		return i$2;
	}
	rpcUnsubscribe(e, t, s) {
		const i$2 = {
			method: wi(s.protocol).unsubscribe,
			params: {
				topic: e,
				id: t
			}
		};
		return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
			type: "payload",
			direction: "outgoing",
			request: i$2
		}), this.relayer.request(i$2);
	}
	onSubscribe(e, t) {
		this.setSubscription(e, He$1(ge$1({}, t), { id: e })), this.pending.delete(t.topic);
	}
	onBatchSubscribe(e) {
		e.length && e.forEach((t) => {
			this.setSubscription(t.id, ge$1({}, t)), this.pending.delete(t.topic);
		});
	}
	async onUnsubscribe(e, t, s) {
		this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e);
	}
	async setRelayerSubscriptions(e) {
		await this.relayer.core.storage.setItem(this.storageKey, e);
	}
	async getRelayerSubscriptions() {
		return await this.relayer.core.storage.getItem(this.storageKey);
	}
	setSubscription(e, t) {
		this.logger.debug("Setting subscription"), this.logger.trace({
			type: "method",
			method: "setSubscription",
			id: e,
			subscription: t
		}), this.addSubscription(e, t);
	}
	addSubscription(e, t) {
		this.subscriptions.set(e, ge$1({}, t)), this.topicMap.set(t.topic, e), this.events.emit($$2.created, t);
	}
	getSubscription(e) {
		this.logger.debug("Getting subscription"), this.logger.trace({
			type: "method",
			method: "getSubscription",
			id: e
		});
		const t = this.subscriptions.get(e);
		if (!t) {
			const { message: s } = te$1("NO_MATCHING_KEY", `${this.name}: ${e}`);
			throw new Error(s);
		}
		return t;
	}
	deleteSubscription(e, t) {
		this.logger.debug("Deleting subscription"), this.logger.trace({
			type: "method",
			method: "deleteSubscription",
			id: e,
			reason: t
		});
		const s = this.getSubscription(e);
		this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit($$2.deleted, He$1(ge$1({}, s), { reason: t }));
	}
	async persist() {
		await this.setRelayerSubscriptions(this.values), this.events.emit($$2.sync);
	}
	async onRestart() {
		if (this.cached.length) {
			const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
			for (let s = 0; s < t; s++) {
				const i$2 = e.splice(0, this.batchSubscribeTopicsLimit);
				await this.batchSubscribe(i$2);
			}
		}
		this.events.emit($$2.resubscribed);
	}
	async restore() {
		try {
			const e = await this.getRelayerSubscriptions();
			if (typeof e > "u" || !e.length) return;
			if (this.subscriptions.size) {
				const { message: t } = te$1("RESTORE_WILL_OVERRIDE", this.name);
				throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
			}
			this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({
				type: "method",
				method: "restore",
				subscriptions: this.values
			});
		} catch (e) {
			this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
		}
	}
	async batchSubscribe(e) {
		e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => He$1(ge$1({}, t), { id: await this.getSubscriptionId(t.topic) })))));
	}
	async batchFetchMessages(e) {
		if (!e.length) return;
		this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
		const t = await this.rpcBatchFetchMessages(e);
		t && t.messages && (await xo((0, import_cjs$1.toMiliseconds)(import_cjs$1.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
	}
	async onConnect() {
		await this.restart(), this.reset();
	}
	onDisconnect() {
		this.onDisable();
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$1("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
	async restartToComplete(e) {
		!this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
	}
	async getClientId() {
		return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
	}
	async getSubscriptionId(e) {
		return ci(e + await this.getClientId());
	}
};
var Qn = Object.defineProperty, Ci$1 = Object.getOwnPropertySymbols, eo = Object.prototype.hasOwnProperty, to = Object.prototype.propertyIsEnumerable, Ye$2 = (r$1, e, t) => e in r$1 ? Qn(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, Pi$1 = (r$1, e) => {
	for (var t in e || (e = {})) eo.call(e, t) && Ye$2(r$1, t, e[t]);
	if (Ci$1) for (var t of Ci$1(e)) to.call(e, t) && Ye$2(r$1, t, e[t]);
	return r$1;
}, y$3 = (r$1, e, t) => Ye$2(r$1, typeof e != "symbol" ? e + "" : e, t);
var Si = class extends d$1 {
	constructor(e) {
		super(e), y$3(this, "protocol", "wc"), y$3(this, "version", 2), y$3(this, "core"), y$3(this, "logger"), y$3(this, "events", new import_events$2.EventEmitter()), y$3(this, "provider"), y$3(this, "messages"), y$3(this, "subscriber"), y$3(this, "publisher"), y$3(this, "name", $t$1), y$3(this, "transportExplicitlyClosed", !1), y$3(this, "initialized", !1), y$3(this, "connectionAttemptInProgress", !1), y$3(this, "relayUrl"), y$3(this, "projectId"), y$3(this, "packageName"), y$3(this, "bundleId"), y$3(this, "hasExperiencedNetworkDisruption", !1), y$3(this, "pingTimeout"), y$3(this, "heartBeatTimeout", (0, import_cjs$1.toMiliseconds)(import_cjs$1.THIRTY_SECONDS + import_cjs$1.FIVE_SECONDS)), y$3(this, "reconnectTimeout"), y$3(this, "connectPromise"), y$3(this, "reconnectInProgress", !1), y$3(this, "requestsInFlight", []), y$3(this, "connectTimeout", (0, import_cjs$1.toMiliseconds)(import_cjs$1.ONE_SECOND * 15)), y$3(this, "request", async (t) => {
			var s, i$2;
			this.logger.debug("Publishing Request Payload");
			const n$2 = t.id || getBigIntRpcId().toString();
			await this.toEstablishConnection();
			try {
				this.logger.trace({
					id: n$2,
					method: t.method,
					topic: (s = t.params) == null ? void 0 : s.topic
				}, "relayer.request - publishing...");
				const o$2 = `${n$2}:${((i$2 = t.params) == null ? void 0 : i$2.tag) || ""}`;
				this.requestsInFlight.push(o$2);
				const a$1 = await this.provider.request(t);
				return this.requestsInFlight = this.requestsInFlight.filter((c$3) => c$3 !== o$2), a$1;
			} catch (o$2) {
				throw this.logger.debug(`Failed to Publish Request: ${n$2}`), o$2;
			}
		}), y$3(this, "resetPingTimeout", () => {
			et$1() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
				var t, s, i$2, n$2;
				try {
					this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n$2 = (i$2 = (s = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s.socket) == null ? void 0 : i$2.terminate) == null || n$2.call(i$2);
				} catch (o$2) {
					this.logger.warn(o$2, o$2?.message);
				}
			}, this.heartBeatTimeout));
		}), y$3(this, "onPayloadHandler", (t) => {
			this.onProviderPayload(t), this.resetPingTimeout();
		}), y$3(this, "onConnectHandler", () => {
			this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(C$1.connect);
		}), y$3(this, "onDisconnectHandler", () => {
			this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
		}), y$3(this, "onProviderErrorHandler", (t) => {
			this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(C$1.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
		}), y$3(this, "registerProviderListeners", () => {
			this.provider.on(L$1.payload, this.onPayloadHandler), this.provider.on(L$1.connect, this.onConnectHandler), this.provider.on(L$1.disconnect, this.onDisconnectHandler), this.provider.on(L$1.error, this.onProviderErrorHandler);
		}), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E$1(e.logger, this.name) : (0, import_browser.default)(k({ level: e.logger || Nt$1 })), this.messages = new _i(this.logger, e.core), this.subscriber = new Ti(this, this.logger), this.publisher = new Vn(this, this.logger), this.relayUrl = e?.relayUrl || Ue$2, this.projectId = e.projectId, zr() ? this.packageName = Yr() : Jr() && (this.bundleId = Yr()), this.provider = {};
	}
	async init() {
		if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.hasAnyTopics) try {
			await this.transportOpen();
		} catch (e) {
			this.logger.warn(e, e?.message);
		}
	}
	get context() {
		return y$1(this.logger);
	}
	get connected() {
		var e, t, s;
		return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 1 || !1;
	}
	get connecting() {
		var e, t, s;
		return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 0 || this.connectPromise !== void 0 || !1;
	}
	async publish(e, t, s) {
		this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({
			topic: e,
			message: t,
			publishedAt: Date.now(),
			transportType: Q$1.relay
		}, le$1.outbound);
	}
	async subscribe(e, t) {
		var s, i$2, n$2;
		this.isInitialized(), (!(t != null && t.transportType) || t?.transportType === "relay") && await this.toEstablishConnection();
		const o$2 = typeof ((s = t?.internal) == null ? void 0 : s.throwOnFailedPublish) > "u" ? !0 : (i$2 = t?.internal) == null ? void 0 : i$2.throwOnFailedPublish;
		let a$1 = ((n$2 = this.subscriber.topicMap.get(e)) == null ? void 0 : n$2[0]) || "", c$3;
		const h$4 = (u$2) => {
			u$2.topic === e && (this.subscriber.off($$2.created, h$4), c$3());
		};
		return await Promise.all([new Promise((u$2) => {
			c$3 = u$2, this.subscriber.on($$2.created, h$4);
		}), new Promise(async (u$2, d$4) => {
			a$1 = await this.subscriber.subscribe(e, Pi$1({ internal: { throwOnFailedPublish: o$2 } }, t)).catch((g$2) => {
				o$2 && d$4(g$2);
			}) || a$1, u$2();
		})]), a$1;
	}
	async unsubscribe(e, t) {
		this.isInitialized(), await this.subscriber.unsubscribe(e, t);
	}
	on(e, t) {
		this.events.on(e, t);
	}
	once(e, t) {
		this.events.once(e, t);
	}
	off(e, t) {
		this.events.off(e, t);
	}
	removeListener(e, t) {
		this.events.removeListener(e, t);
	}
	async transportDisconnect() {
		this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await uo(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
	}
	async transportClose() {
		this.transportExplicitlyClosed = !0, await this.transportDisconnect();
	}
	async transportOpen(e) {
		if (!this.subscriber.hasAnyTopics) {
			this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
			return;
		}
		if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, s) => {
			await this.connect(e).then(t).catch(s).finally(() => {
				this.connectPromise = void 0;
			});
		}), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
	}
	async restartTransport(e) {
		this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
	}
	async confirmOnlineStateOrThrow() {
		if (!await Zi()) throw new Error("No internet connection detected. Please restart your network and try again.");
	}
	async handleBatchMessageEvents(e) {
		if (e?.length === 0) {
			this.logger.trace("Batch message events is empty. Ignoring...");
			return;
		}
		const t = e.sort((s, i$2) => s.publishedAt - i$2.publishedAt);
		this.logger.debug(`Batch of ${t.length} message events sorted`);
		for (const s of t) try {
			await this.onMessageEvent(s);
		} catch (i$2) {
			this.logger.warn(i$2, "Error while processing batch message event: " + i$2?.message);
		}
		this.logger.trace(`Batch of ${t.length} message events processed`);
	}
	async onLinkMessageEvent(e, t) {
		const { topic: s } = e;
		if (!t.sessionExists) {
			const n$2 = {
				topic: s,
				expiry: po(import_cjs$1.FIVE_MINUTES),
				relay: { protocol: "irn" },
				active: !1
			};
			await this.core.pairing.pairings.set(s, n$2);
		}
		this.events.emit(C$1.message, e), await this.recordMessageEvent(e, le$1.inbound);
	}
	async connect(e) {
		await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
		let t = 1;
		for (; t < 6;) {
			try {
				if (this.transportExplicitlyClosed) break;
				this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (s, i$2) => {
					const n$2 = () => {
						i$2(/* @__PURE__ */ new Error("Connection interrupted while trying to subscribe"));
					};
					this.provider.once(L$1.disconnect, n$2), await uo(new Promise((o$2, a$1) => {
						this.provider.connect().then(o$2).catch(a$1);
					}), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o$2) => {
						i$2(o$2);
					}).finally(() => {
						this.provider.off(L$1.disconnect, n$2), clearTimeout(this.reconnectTimeout);
					}), await new Promise(async (o$2, a$1) => {
						const c$3 = () => {
							a$1(/* @__PURE__ */ new Error("Connection interrupted while trying to subscribe"));
						};
						this.provider.once(L$1.disconnect, c$3), await this.subscriber.start().then(o$2).catch(a$1).finally(() => {
							this.provider.off(L$1.disconnect, c$3);
						});
					}), this.hasExperiencedNetworkDisruption = !1, s();
				});
			} catch (s) {
				await this.subscriber.stop();
				const i$2 = s;
				this.logger.warn({}, i$2.message), this.hasExperiencedNetworkDisruption = !0;
			} finally {
				this.connectionAttemptInProgress = !1;
			}
			if (this.connected) {
				this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
				break;
			}
			await new Promise((s) => setTimeout(s, (0, import_cjs$1.toMiliseconds)(t * 1))), t++;
		}
	}
	startPingTimeout() {
		var e, t, s, i$2, n$2;
		if (et$1()) try {
			(t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((n$2 = (i$2 = (s = this.provider) == null ? void 0 : s.connection) == null ? void 0 : i$2.socket) == null || n$2.on("ping", () => {
				this.resetPingTimeout();
			})), this.resetPingTimeout();
		} catch (o$2) {
			this.logger.warn(o$2, o$2?.message);
		}
	}
	async createProvider() {
		this.provider.connection && this.unregisterProviderListeners();
		const e = await this.core.crypto.signJWT(this.relayUrl);
		this.provider = new o(new f$2(Qr({
			sdkVersion: _e$3,
			protocol: this.protocol,
			version: this.version,
			relayUrl: this.relayUrl,
			projectId: this.projectId,
			auth: e,
			useOnCloseEvent: !0,
			bundleId: this.bundleId,
			packageName: this.packageName
		}))), this.registerProviderListeners();
	}
	async recordMessageEvent(e, t) {
		const { topic: s, message: i$2 } = e;
		await this.messages.set(s, i$2, t);
	}
	async shouldIgnoreMessageEvent(e) {
		const { topic: t, message: s } = e;
		if (!s || s.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${s}`), !0;
		if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), !0;
		const i$2 = this.messages.has(t, s);
		return i$2 && this.logger.warn(`Ignoring duplicate message: ${s}`), i$2;
	}
	async onProviderPayload(e) {
		if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({
			type: "payload",
			direction: "incoming",
			payload: e
		}), isJsonRpcRequest(e)) {
			if (!e.method.endsWith(zt$1)) return;
			const t = e.params, { topic: s, message: i$2, publishedAt: n$2, attestation: o$2 } = t.data, a$1 = {
				topic: s,
				message: i$2,
				publishedAt: n$2,
				transportType: Q$1.relay,
				attestation: o$2
			};
			this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Pi$1({
				type: "event",
				event: t.id
			}, a$1)), this.events.emit(t.id, a$1), await this.acknowledgePayload(e), await this.onMessageEvent(a$1);
		} else isJsonRpcResponse(e) && this.events.emit(C$1.message_ack, e);
	}
	async onMessageEvent(e) {
		await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, le$1.inbound), this.events.emit(C$1.message, e));
	}
	async acknowledgePayload(e) {
		const t = formatJsonRpcResult(e.id, !0);
		await this.provider.connection.send(t);
	}
	unregisterProviderListeners() {
		this.provider.off(L$1.payload, this.onPayloadHandler), this.provider.off(L$1.connect, this.onConnectHandler), this.provider.off(L$1.disconnect, this.onDisconnectHandler), this.provider.off(L$1.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
	}
	async registerEventListeners() {
		let e = await Zi();
		Qi(async (t) => {
			e !== t && (e = t, t ? await this.transportOpen().catch((s) => this.logger.error(s, s?.message)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
		});
	}
	async onProviderDisconnect() {
		clearTimeout(this.pingTimeout), this.events.emit(C$1.disconnect), this.connectionAttemptInProgress = !1, !this.reconnectInProgress && (this.reconnectInProgress = !0, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
			await this.transportOpen().catch((e) => this.logger.error(e, e?.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = !1;
		}, (0, import_cjs$1.toMiliseconds)(Lt$1)))));
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$1("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
	async toEstablishConnection() {
		await this.confirmOnlineStateOrThrow(), !this.connected && await this.connect();
	}
};
function io() {}
function Ri$1(r$1) {
	if (!r$1 || typeof r$1 != "object") return !1;
	const e = Object.getPrototypeOf(r$1);
	return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r$1) === "[object Object]" : !1;
}
function Oi(r$1) {
	return Object.getOwnPropertySymbols(r$1).filter((e) => Object.prototype.propertyIsEnumerable.call(r$1, e));
}
function Ai(r$1) {
	return r$1 == null ? r$1 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r$1);
}
var so = "[object RegExp]", ro$1 = "[object String]", no = "[object Number]", oo$1 = "[object Boolean]", xi$1 = "[object Arguments]", ao$1 = "[object Symbol]", co = "[object Date]", ho$1 = "[object Map]", lo$1 = "[object Set]", uo$1 = "[object Array]", go$1 = "[object Function]", po$1 = "[object ArrayBuffer]", Je$1 = "[object Object]", yo$1 = "[object Error]", bo$1 = "[object DataView]", mo$1 = "[object Uint8Array]", fo$1 = "[object Uint8ClampedArray]", Do = "[object Uint16Array]", vo$1 = "[object Uint32Array]", wo$1 = "[object BigUint64Array]", _o = "[object Int8Array]", Eo$1 = "[object Int16Array]", Io = "[object Int32Array]", To = "[object BigInt64Array]", Co = "[object Float32Array]", Po = "[object Float64Array]";
function So(r$1, e) {
	return r$1 === e || Number.isNaN(r$1) && Number.isNaN(e);
}
function Ro(r$1, e, t) {
	return pe$1(r$1, e, void 0, void 0, void 0, void 0, t);
}
function pe$1(r$1, e, t, s, i$2, n$2, o$2) {
	const a$1 = o$2(r$1, e, t, s, i$2, n$2);
	if (a$1 !== void 0) return a$1;
	if (typeof r$1 == typeof e) switch (typeof r$1) {
		case "bigint":
		case "string":
		case "boolean":
		case "symbol":
		case "undefined": return r$1 === e;
		case "number": return r$1 === e || Object.is(r$1, e);
		case "function": return r$1 === e;
		case "object": return ye$1(r$1, e, n$2, o$2);
	}
	return ye$1(r$1, e, n$2, o$2);
}
function ye$1(r$1, e, t, s) {
	if (Object.is(r$1, e)) return !0;
	let i$2 = Ai(r$1), n$2 = Ai(e);
	if (i$2 === xi$1 && (i$2 = Je$1), n$2 === xi$1 && (n$2 = Je$1), i$2 !== n$2) return !1;
	switch (i$2) {
		case ro$1: return r$1.toString() === e.toString();
		case no: return So(r$1.valueOf(), e.valueOf());
		case oo$1:
		case co:
		case ao$1: return Object.is(r$1.valueOf(), e.valueOf());
		case so: return r$1.source === e.source && r$1.flags === e.flags;
		case go$1: return r$1 === e;
	}
	t = t ?? /* @__PURE__ */ new Map();
	const o$2 = t.get(r$1), a$1 = t.get(e);
	if (o$2 != null && a$1 != null) return o$2 === e;
	t.set(r$1, e), t.set(e, r$1);
	try {
		switch (i$2) {
			case ho$1:
				if (r$1.size !== e.size) return !1;
				for (const [c$3, h$4] of r$1.entries()) if (!e.has(c$3) || !pe$1(h$4, e.get(c$3), c$3, r$1, e, t, s)) return !1;
				return !0;
			case lo$1: {
				if (r$1.size !== e.size) return !1;
				const c$3 = Array.from(r$1.values()), h$4 = Array.from(e.values());
				for (let u$2 = 0; u$2 < c$3.length; u$2++) {
					const d$4 = c$3[u$2], g$2 = h$4.findIndex((_$4) => pe$1(d$4, _$4, void 0, r$1, e, t, s));
					if (g$2 === -1) return !1;
					h$4.splice(g$2, 1);
				}
				return !0;
			}
			case uo$1:
			case mo$1:
			case fo$1:
			case Do:
			case vo$1:
			case wo$1:
			case _o:
			case Eo$1:
			case Io:
			case To:
			case Co:
			case Po:
				if (typeof Buffer < "u" && Buffer.isBuffer(r$1) !== Buffer.isBuffer(e) || r$1.length !== e.length) return !1;
				for (let c$3 = 0; c$3 < r$1.length; c$3++) if (!pe$1(r$1[c$3], e[c$3], c$3, r$1, e, t, s)) return !1;
				return !0;
			case po$1: return r$1.byteLength !== e.byteLength ? !1 : ye$1(new Uint8Array(r$1), new Uint8Array(e), t, s);
			case bo$1: return r$1.byteLength !== e.byteLength || r$1.byteOffset !== e.byteOffset ? !1 : ye$1(new Uint8Array(r$1), new Uint8Array(e), t, s);
			case yo$1: return r$1.name === e.name && r$1.message === e.message;
			case Je$1: {
				if (!(ye$1(r$1.constructor, e.constructor, t, s) || Ri$1(r$1) && Ri$1(e))) return !1;
				const h$4 = [...Object.keys(r$1), ...Oi(r$1)], u$2 = [...Object.keys(e), ...Oi(e)];
				if (h$4.length !== u$2.length) return !1;
				for (let d$4 = 0; d$4 < h$4.length; d$4++) {
					const g$2 = h$4[d$4], _$4 = r$1[g$2];
					if (!Object.hasOwn(e, g$2)) return !1;
					const l$2 = e[g$2];
					if (!pe$1(_$4, l$2, g$2, r$1, e, t, s)) return !1;
				}
				return !0;
			}
			default: return !1;
		}
	} finally {
		t.delete(r$1), t.delete(e);
	}
}
function Oo(r$1, e) {
	return Ro(r$1, e, io);
}
var Ao = Object.defineProperty, Ni = Object.getOwnPropertySymbols, xo$1 = Object.prototype.hasOwnProperty, No = Object.prototype.propertyIsEnumerable, Xe$2 = (r$1, e, t) => e in r$1 ? Ao(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, $i = (r$1, e) => {
	for (var t in e || (e = {})) xo$1.call(e, t) && Xe$2(r$1, t, e[t]);
	if (Ni) for (var t of Ni(e)) No.call(e, t) && Xe$2(r$1, t, e[t]);
	return r$1;
}, z$1 = (r$1, e, t) => Xe$2(r$1, typeof e != "symbol" ? e + "" : e, t);
var zi = class extends f$1 {
	constructor(e, t, s, i$2 = B$1, n$2 = void 0) {
		super(e, t, s, i$2), this.core = e, this.logger = t, this.name = s, z$1(this, "map", /* @__PURE__ */ new Map()), z$1(this, "version", kt$2), z$1(this, "cached", []), z$1(this, "initialized", !1), z$1(this, "getKey"), z$1(this, "storagePrefix", B$1), z$1(this, "recentlyDeleted", []), z$1(this, "recentlyDeletedLimit", 200), z$1(this, "init", async () => {
			this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o$2) => {
				this.getKey && o$2 !== null && !ae$1(o$2) ? this.map.set(this.getKey(o$2), o$2) : Li(o$2) ? this.map.set(o$2.id, o$2) : ji(o$2) && this.map.set(o$2.topic, o$2);
			}), this.cached = [], this.initialized = !0);
		}), z$1(this, "set", async (o$2, a$1) => {
			this.isInitialized(), this.map.has(o$2) ? await this.update(o$2, a$1) : (this.logger.debug("Setting value"), this.logger.trace({
				type: "method",
				method: "set",
				key: o$2,
				value: a$1
			}), this.map.set(o$2, a$1), await this.persist());
		}), z$1(this, "get", (o$2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({
			type: "method",
			method: "get",
			key: o$2
		}), this.getData(o$2))), z$1(this, "getAll", (o$2) => (this.isInitialized(), o$2 ? this.values.filter((a$1) => Object.keys(o$2).every((c$3) => Oo(a$1[c$3], o$2[c$3]))) : this.values)), z$1(this, "update", async (o$2, a$1) => {
			this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({
				type: "method",
				method: "update",
				key: o$2,
				update: a$1
			});
			const c$3 = $i($i({}, this.getData(o$2)), a$1);
			this.map.set(o$2, c$3), await this.persist();
		}), z$1(this, "delete", async (o$2, a$1) => {
			this.isInitialized(), this.map.has(o$2) && (this.logger.debug("Deleting value"), this.logger.trace({
				type: "method",
				method: "delete",
				key: o$2,
				reason: a$1
			}), this.map.delete(o$2), this.addToRecentlyDeleted(o$2), await this.persist());
		}), this.logger = E$1(t, this.name), this.storagePrefix = i$2, this.getKey = n$2;
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
	}
	get length() {
		return this.map.size;
	}
	get keys() {
		return Array.from(this.map.keys());
	}
	get values() {
		return Array.from(this.map.values());
	}
	addToRecentlyDeleted(e) {
		this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
	}
	async setDataStore(e) {
		await this.core.storage.setItem(this.storageKey, e);
	}
	async getDataStore() {
		return await this.core.storage.getItem(this.storageKey);
	}
	getData(e) {
		const t = this.map.get(e);
		if (!t) {
			if (this.recentlyDeleted.includes(e)) {
				const { message: i$2 } = te$1("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
				throw this.logger.error(i$2), new Error(i$2);
			}
			const { message: s } = te$1("NO_MATCHING_KEY", `${this.name}: ${e}`);
			throw this.logger.error(s), new Error(s);
		}
		return t;
	}
	async persist() {
		await this.setDataStore(this.values);
	}
	async restore() {
		try {
			const e = await this.getDataStore();
			if (typeof e > "u" || !e.length) return;
			if (this.map.size) {
				const { message: t } = te$1("RESTORE_WILL_OVERRIDE", this.name);
				throw this.logger.error(t), new Error(t);
			}
			this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({
				type: "method",
				method: "restore",
				value: this.values
			});
		} catch (e) {
			this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
		}
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$1("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var $o = Object.defineProperty, zo = (r$1, e, t) => e in r$1 ? $o(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, p$1 = (r$1, e, t) => zo(r$1, typeof e != "symbol" ? e + "" : e, t);
var Li$1 = class {
	constructor(e, t) {
		this.core = e, this.logger = t, p$1(this, "name", Ft$1), p$1(this, "version", Kt$1), p$1(this, "events", new import_events$2.default()), p$1(this, "pairings"), p$1(this, "initialized", !1), p$1(this, "storagePrefix", B$1), p$1(this, "ignoredPayloadTypes", [Oe$2]), p$1(this, "registeredMethods", []), p$1(this, "init", async () => {
			this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
		}), p$1(this, "register", ({ methods: s }) => {
			this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...s])];
		}), p$1(this, "create", async (s) => {
			this.isInitialized();
			const i$2 = oi(), n$2 = await this.core.crypto.setSymKey(i$2), o$2 = po(import_cjs$1.FIVE_MINUTES), a$1 = { protocol: xt$1 }, c$3 = {
				topic: n$2,
				expiry: o$2,
				relay: a$1,
				active: !1,
				methods: s?.methods
			}, h$4 = vi({
				protocol: this.core.protocol,
				version: this.core.version,
				topic: n$2,
				symKey: i$2,
				relay: a$1,
				expiryTimestamp: o$2,
				methods: s?.methods
			});
			return this.events.emit(se$1.create, c$3), this.core.expirer.set(n$2, o$2), await this.pairings.set(n$2, c$3), await this.core.relayer.subscribe(n$2, { transportType: s?.transportType }), {
				topic: n$2,
				uri: h$4
			};
		}), p$1(this, "pair", async (s) => {
			this.isInitialized();
			const i$2 = this.core.eventClient.createEvent({ properties: {
				topic: s?.uri,
				trace: [G$1.pairing_started]
			} });
			this.isValidPair(s, i$2);
			const { topic: n$2, symKey: o$2, relay: a$1, expiryTimestamp: c$3, methods: h$4 } = Ei(s.uri);
			i$2.props.properties.topic = n$2, i$2.addTrace(G$1.pairing_uri_validation_success), i$2.addTrace(G$1.pairing_uri_not_expired);
			let u$2;
			if (this.pairings.keys.includes(n$2)) {
				if (u$2 = this.pairings.get(n$2), i$2.addTrace(G$1.existing_pairing), u$2.active) throw i$2.setError(Y.active_pairing_already_exists), /* @__PURE__ */ new Error(`Pairing already exists: ${n$2}. Please try again with a new connection URI.`);
				i$2.addTrace(G$1.pairing_not_expired);
			}
			const d$4 = c$3 || po(import_cjs$1.FIVE_MINUTES), g$2 = {
				topic: n$2,
				relay: a$1,
				expiry: d$4,
				active: !1,
				methods: h$4
			};
			this.core.expirer.set(n$2, d$4), await this.pairings.set(n$2, g$2), i$2.addTrace(G$1.store_new_pairing), s.activatePairing && await this.activate({ topic: n$2 }), this.events.emit(se$1.create, g$2), i$2.addTrace(G$1.emit_inactive_pairing), this.core.crypto.keychain.has(n$2) || await this.core.crypto.setSymKey(o$2, n$2), i$2.addTrace(G$1.subscribing_pairing_topic);
			try {
				await this.core.relayer.confirmOnlineStateOrThrow();
			} catch {
				i$2.setError(Y.no_internet_connection);
			}
			try {
				await this.core.relayer.subscribe(n$2, { relay: a$1 });
			} catch (_$4) {
				throw i$2.setError(Y.subscribe_pairing_topic_failure), _$4;
			}
			return i$2.addTrace(G$1.subscribe_pairing_topic_success), g$2;
		}), p$1(this, "activate", async ({ topic: s }) => {
			this.isInitialized();
			const i$2 = po(import_cjs$1.FIVE_MINUTES);
			this.core.expirer.set(s, i$2), await this.pairings.update(s, {
				active: !0,
				expiry: i$2
			});
		}), p$1(this, "ping", async (s) => {
			this.isInitialized(), await this.isValidPing(s), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
			const { topic: i$2 } = s;
			if (this.pairings.keys.includes(i$2)) {
				const n$2 = await this.sendRequest(i$2, "wc_pairingPing", {}), { done: o$2, resolve: a$1, reject: c$3 } = ao();
				this.events.once(yo("pairing_ping", n$2), ({ error: h$4 }) => {
					h$4 ? c$3(h$4) : a$1();
				}), await o$2();
			}
		}), p$1(this, "updateExpiry", async ({ topic: s, expiry: i$2 }) => {
			this.isInitialized(), await this.pairings.update(s, { expiry: i$2 });
		}), p$1(this, "updateMetadata", async ({ topic: s, metadata: i$2 }) => {
			this.isInitialized(), await this.pairings.update(s, { peerMetadata: i$2 });
		}), p$1(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p$1(this, "disconnect", async (s) => {
			this.isInitialized(), await this.isValidDisconnect(s);
			const { topic: i$2 } = s;
			this.pairings.keys.includes(i$2) && (await this.sendRequest(i$2, "wc_pairingDelete", de("USER_DISCONNECTED")), await this.deletePairing(i$2));
		}), p$1(this, "formatUriFromPairing", (s) => {
			this.isInitialized();
			const { topic: i$2, relay: n$2, expiry: o$2, methods: a$1 } = s, c$3 = this.core.crypto.keychain.get(i$2);
			return vi({
				protocol: this.core.protocol,
				version: this.core.version,
				topic: i$2,
				symKey: c$3,
				relay: n$2,
				expiryTimestamp: o$2,
				methods: a$1
			});
		}), p$1(this, "sendRequest", async (s, i$2, n$2) => {
			const o$2 = formatJsonRpcRequest(i$2, n$2), a$1 = await this.core.crypto.encode(s, o$2), c$3 = ie$1[i$2].req;
			return this.core.history.set(s, o$2), this.core.relayer.publish(s, a$1, c$3), o$2.id;
		}), p$1(this, "sendResult", async (s, i$2, n$2) => {
			const o$2 = formatJsonRpcResult(s, n$2), a$1 = await this.core.crypto.encode(i$2, o$2), h$4 = ie$1[(await this.core.history.get(i$2, s)).request.method].res;
			await this.core.relayer.publish(i$2, a$1, h$4), await this.core.history.resolve(o$2);
		}), p$1(this, "sendError", async (s, i$2, n$2) => {
			const o$2 = formatJsonRpcError(s, n$2), a$1 = await this.core.crypto.encode(i$2, o$2), c$3 = (await this.core.history.get(i$2, s)).request.method, h$4 = ie$1[c$3] ? ie$1[c$3].res : ie$1.unregistered_method.res;
			await this.core.relayer.publish(i$2, a$1, h$4), await this.core.history.resolve(o$2);
		}), p$1(this, "deletePairing", async (s, i$2) => {
			await this.core.relayer.unsubscribe(s), await Promise.all([
				this.pairings.delete(s, de("USER_DISCONNECTED")),
				this.core.crypto.deleteSymKey(s),
				i$2 ? Promise.resolve() : this.core.expirer.del(s)
			]);
		}), p$1(this, "cleanup", async () => {
			const s = this.pairings.getAll().filter((i$2) => go(i$2.expiry));
			await Promise.all(s.map((i$2) => this.deletePairing(i$2.topic)));
		}), p$1(this, "onRelayEventRequest", async (s) => {
			const { topic: i$2, payload: n$2 } = s;
			switch (n$2.method) {
				case "wc_pairingPing": return await this.onPairingPingRequest(i$2, n$2);
				case "wc_pairingDelete": return await this.onPairingDeleteRequest(i$2, n$2);
				default: return await this.onUnknownRpcMethodRequest(i$2, n$2);
			}
		}), p$1(this, "onRelayEventResponse", async (s) => {
			const { topic: i$2, payload: n$2 } = s, o$2 = (await this.core.history.get(i$2, n$2.id)).request.method;
			switch (o$2) {
				case "wc_pairingPing": return this.onPairingPingResponse(i$2, n$2);
				default: return this.onUnknownRpcMethodResponse(o$2);
			}
		}), p$1(this, "onPairingPingRequest", async (s, i$2) => {
			const { id: n$2 } = i$2;
			try {
				this.isValidPing({ topic: s }), await this.sendResult(n$2, s, !0), this.events.emit(se$1.ping, {
					id: n$2,
					topic: s
				});
			} catch (o$2) {
				await this.sendError(n$2, s, o$2), this.logger.error(o$2);
			}
		}), p$1(this, "onPairingPingResponse", (s, i$2) => {
			const { id: n$2 } = i$2;
			setTimeout(() => {
				isJsonRpcResult(i$2) ? this.events.emit(yo("pairing_ping", n$2), {}) : isJsonRpcError(i$2) && this.events.emit(yo("pairing_ping", n$2), { error: i$2.error });
			}, 500);
		}), p$1(this, "onPairingDeleteRequest", async (s, i$2) => {
			const { id: n$2 } = i$2;
			try {
				this.isValidDisconnect({ topic: s }), await this.deletePairing(s), this.events.emit(se$1.delete, {
					id: n$2,
					topic: s
				});
			} catch (o$2) {
				await this.sendError(n$2, s, o$2), this.logger.error(o$2);
			}
		}), p$1(this, "onUnknownRpcMethodRequest", async (s, i$2) => {
			const { id: n$2, method: o$2 } = i$2;
			try {
				if (this.registeredMethods.includes(o$2)) return;
				const a$1 = de("WC_METHOD_UNSUPPORTED", o$2);
				await this.sendError(n$2, s, a$1), this.logger.error(a$1);
			} catch (a$1) {
				await this.sendError(n$2, s, a$1), this.logger.error(a$1);
			}
		}), p$1(this, "onUnknownRpcMethodResponse", (s) => {
			this.registeredMethods.includes(s) || this.logger.error(de("WC_METHOD_UNSUPPORTED", s));
		}), p$1(this, "isValidPair", (s, i$2) => {
			var n$2;
			if (!Vi(s)) {
				const { message: a$1 } = te$1("MISSING_OR_INVALID", `pair() params: ${s}`);
				throw i$2.setError(Y.malformed_pairing_uri), new Error(a$1);
			}
			if (!Bi(s.uri)) {
				const { message: a$1 } = te$1("MISSING_OR_INVALID", `pair() uri: ${s.uri}`);
				throw i$2.setError(Y.malformed_pairing_uri), new Error(a$1);
			}
			const o$2 = Ei(s?.uri);
			if (!((n$2 = o$2?.relay) != null && n$2.protocol)) {
				const { message: a$1 } = te$1("MISSING_OR_INVALID", "pair() uri#relay-protocol");
				throw i$2.setError(Y.malformed_pairing_uri), new Error(a$1);
			}
			if (!(o$2 != null && o$2.symKey)) {
				const { message: a$1 } = te$1("MISSING_OR_INVALID", "pair() uri#symKey");
				throw i$2.setError(Y.malformed_pairing_uri), new Error(a$1);
			}
			if (o$2 != null && o$2.expiryTimestamp && (0, import_cjs$1.toMiliseconds)(o$2?.expiryTimestamp) < Date.now()) {
				i$2.setError(Y.pairing_expired);
				const { message: a$1 } = te$1("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
				throw new Error(a$1);
			}
		}), p$1(this, "isValidPing", async (s) => {
			if (!Vi(s)) {
				const { message: n$2 } = te$1("MISSING_OR_INVALID", `ping() params: ${s}`);
				throw new Error(n$2);
			}
			const { topic: i$2 } = s;
			await this.isValidPairingTopic(i$2);
		}), p$1(this, "isValidDisconnect", async (s) => {
			if (!Vi(s)) {
				const { message: n$2 } = te$1("MISSING_OR_INVALID", `disconnect() params: ${s}`);
				throw new Error(n$2);
			}
			const { topic: i$2 } = s;
			await this.isValidPairingTopic(i$2);
		}), p$1(this, "isValidPairingTopic", async (s) => {
			if (!q(s, !1)) {
				const { message: i$2 } = te$1("MISSING_OR_INVALID", `pairing topic should be a string: ${s}`);
				throw new Error(i$2);
			}
			if (!this.pairings.keys.includes(s)) {
				const { message: i$2 } = te$1("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s}`);
				throw new Error(i$2);
			}
			if (go(this.pairings.get(s).expiry)) {
				await this.deletePairing(s);
				const { message: i$2 } = te$1("EXPIRED", `pairing topic: ${s}`);
				throw new Error(i$2);
			}
		}), this.core = e, this.logger = E$1(t, this.name), this.pairings = new zi(this.core, this.logger, this.name, this.storagePrefix);
	}
	get context() {
		return y$1(this.logger);
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$1("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
	registerRelayerEvents() {
		this.core.relayer.on(C$1.message, async (e) => {
			const { topic: t, message: s, transportType: i$2 } = e;
			if (this.pairings.keys.includes(t) && i$2 !== Q$1.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s))) try {
				const n$2 = await this.core.crypto.decode(t, s);
				isJsonRpcRequest(n$2) ? (this.core.history.set(t, n$2), await this.onRelayEventRequest({
					topic: t,
					payload: n$2
				})) : isJsonRpcResponse(n$2) && (await this.core.history.resolve(n$2), await this.onRelayEventResponse({
					topic: t,
					payload: n$2
				}), this.core.history.delete(t, n$2.id)), await this.core.relayer.messages.ack(t, s);
			} catch (n$2) {
				this.logger.error(n$2);
			}
		});
	}
	registerExpirerEvents() {
		this.core.expirer.on(F$1.expired, async (e) => {
			const { topic: t } = ho(e.target);
			t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(se$1.expire, { topic: t }));
		});
	}
};
var Lo = Object.defineProperty, ko = (r$1, e, t) => e in r$1 ? Lo(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, R$1 = (r$1, e, t) => ko(r$1, typeof e != "symbol" ? e + "" : e, t);
var ki$1 = class extends I$1 {
	constructor(e, t) {
		super(e, t), this.core = e, this.logger = t, R$1(this, "records", /* @__PURE__ */ new Map()), R$1(this, "events", new import_events$2.EventEmitter()), R$1(this, "name", Bt$1), R$1(this, "version", Vt$1), R$1(this, "cached", []), R$1(this, "initialized", !1), R$1(this, "storagePrefix", B$1), R$1(this, "init", async () => {
			this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s) => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
		}), R$1(this, "set", (s, i$2, n$2) => {
			if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({
				type: "method",
				method: "set",
				topic: s,
				request: i$2,
				chainId: n$2
			}), this.records.has(i$2.id)) return;
			const o$2 = {
				id: i$2.id,
				topic: s,
				request: {
					method: i$2.method,
					params: i$2.params || null
				},
				chainId: n$2,
				expiry: po(import_cjs$1.THIRTY_DAYS)
			};
			this.records.set(o$2.id, o$2), this.persist(), this.events.emit(M$1.created, o$2);
		}), R$1(this, "resolve", async (s) => {
			if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({
				type: "method",
				method: "update",
				response: s
			}), !this.records.has(s.id)) return;
			const i$2 = await this.getRecord(s.id);
			typeof i$2.response > "u" && (i$2.response = isJsonRpcError(s) ? { error: s.error } : { result: s.result }, this.records.set(i$2.id, i$2), this.persist(), this.events.emit(M$1.updated, i$2));
		}), R$1(this, "get", async (s, i$2) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({
			type: "method",
			method: "get",
			topic: s,
			id: i$2
		}), await this.getRecord(i$2))), R$1(this, "delete", (s, i$2) => {
			this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({
				type: "method",
				method: "delete",
				id: i$2
			}), this.values.forEach((n$2) => {
				if (n$2.topic === s) {
					if (typeof i$2 < "u" && n$2.id !== i$2) return;
					this.records.delete(n$2.id), this.events.emit(M$1.deleted, n$2);
				}
			}), this.persist();
		}), R$1(this, "exists", async (s, i$2) => (this.isInitialized(), this.records.has(i$2) ? (await this.getRecord(i$2)).topic === s : !1)), R$1(this, "on", (s, i$2) => {
			this.events.on(s, i$2);
		}), R$1(this, "once", (s, i$2) => {
			this.events.once(s, i$2);
		}), R$1(this, "off", (s, i$2) => {
			this.events.off(s, i$2);
		}), R$1(this, "removeListener", (s, i$2) => {
			this.events.removeListener(s, i$2);
		}), this.logger = E$1(t, this.name);
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
	}
	get size() {
		return this.records.size;
	}
	get keys() {
		return Array.from(this.records.keys());
	}
	get values() {
		return Array.from(this.records.values());
	}
	get pending() {
		const e = [];
		return this.values.forEach((t) => {
			if (typeof t.response < "u") return;
			const s = {
				topic: t.topic,
				request: formatJsonRpcRequest(t.request.method, t.request.params, t.id),
				chainId: t.chainId
			};
			return e.push(s);
		}), e;
	}
	async setJsonRpcRecords(e) {
		await this.core.storage.setItem(this.storageKey, e);
	}
	async getJsonRpcRecords() {
		return await this.core.storage.getItem(this.storageKey);
	}
	getRecord(e) {
		this.isInitialized();
		const t = this.records.get(e);
		if (!t) {
			const { message: s } = te$1("NO_MATCHING_KEY", `${this.name}: ${e}`);
			throw new Error(s);
		}
		return t;
	}
	async persist() {
		await this.setJsonRpcRecords(this.values), this.events.emit(M$1.sync);
	}
	async restore() {
		try {
			const e = await this.getJsonRpcRecords();
			if (typeof e > "u" || !e.length) return;
			if (this.records.size) {
				const { message: t } = te$1("RESTORE_WILL_OVERRIDE", this.name);
				throw this.logger.error(t), new Error(t);
			}
			this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
				type: "method",
				method: "restore",
				records: this.values
			});
		} catch (e) {
			this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
		}
	}
	registerEventListeners() {
		this.events.on(M$1.created, (e) => {
			const t = M$1.created;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				record: e
			});
		}), this.events.on(M$1.updated, (e) => {
			const t = M$1.updated;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				record: e
			});
		}), this.events.on(M$1.deleted, (e) => {
			const t = M$1.deleted;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				record: e
			});
		}), this.core.heartbeat.on(r.pulse, () => {
			this.cleanup();
		});
	}
	cleanup() {
		try {
			this.isInitialized();
			let e = !1;
			this.records.forEach((t) => {
				(0, import_cjs$1.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(M$1.deleted, t, !1), e = !0);
			}), e && this.persist();
		} catch (e) {
			this.logger.warn(e);
		}
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$1("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var jo = Object.defineProperty, Uo = (r$1, e, t) => e in r$1 ? jo(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, A$2 = (r$1, e, t) => Uo(r$1, typeof e != "symbol" ? e + "" : e, t);
var ji$1 = class extends S$1 {
	constructor(e, t) {
		super(e, t), this.core = e, this.logger = t, A$2(this, "expirations", /* @__PURE__ */ new Map()), A$2(this, "events", new import_events$2.EventEmitter()), A$2(this, "name", qt$1), A$2(this, "version", Gt$1), A$2(this, "cached", []), A$2(this, "initialized", !1), A$2(this, "storagePrefix", B$1), A$2(this, "init", async () => {
			this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s) => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
		}), A$2(this, "has", (s) => {
			try {
				const i$2 = this.formatTarget(s);
				return typeof this.getExpiration(i$2) < "u";
			} catch {
				return !1;
			}
		}), A$2(this, "set", (s, i$2) => {
			this.isInitialized();
			const n$2 = this.formatTarget(s), o$2 = {
				target: n$2,
				expiry: i$2
			};
			this.expirations.set(n$2, o$2), this.checkExpiry(n$2, o$2), this.events.emit(F$1.created, {
				target: n$2,
				expiration: o$2
			});
		}), A$2(this, "get", (s) => {
			this.isInitialized();
			const i$2 = this.formatTarget(s);
			return this.getExpiration(i$2);
		}), A$2(this, "del", (s) => {
			if (this.isInitialized(), this.has(s)) {
				const i$2 = this.formatTarget(s), n$2 = this.getExpiration(i$2);
				this.expirations.delete(i$2), this.events.emit(F$1.deleted, {
					target: i$2,
					expiration: n$2
				});
			}
		}), A$2(this, "on", (s, i$2) => {
			this.events.on(s, i$2);
		}), A$2(this, "once", (s, i$2) => {
			this.events.once(s, i$2);
		}), A$2(this, "off", (s, i$2) => {
			this.events.off(s, i$2);
		}), A$2(this, "removeListener", (s, i$2) => {
			this.events.removeListener(s, i$2);
		}), this.logger = E$1(t, this.name);
	}
	get context() {
		return y$1(this.logger);
	}
	get storageKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
	}
	get length() {
		return this.expirations.size;
	}
	get keys() {
		return Array.from(this.expirations.keys());
	}
	get values() {
		return Array.from(this.expirations.values());
	}
	formatTarget(e) {
		if (typeof e == "string") return fo(e);
		if (typeof e == "number") return lo(e);
		const { message: t } = te$1("UNKNOWN_TYPE", `Target type: ${typeof e}`);
		throw new Error(t);
	}
	async setExpirations(e) {
		await this.core.storage.setItem(this.storageKey, e);
	}
	async getExpirations() {
		return await this.core.storage.getItem(this.storageKey);
	}
	async persist() {
		await this.setExpirations(this.values), this.events.emit(F$1.sync);
	}
	async restore() {
		try {
			const e = await this.getExpirations();
			if (typeof e > "u" || !e.length) return;
			if (this.expirations.size) {
				const { message: t } = te$1("RESTORE_WILL_OVERRIDE", this.name);
				throw this.logger.error(t), new Error(t);
			}
			this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({
				type: "method",
				method: "restore",
				expirations: this.values
			});
		} catch (e) {
			this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
		}
	}
	getExpiration(e) {
		const t = this.expirations.get(e);
		if (!t) {
			const { message: s } = te$1("NO_MATCHING_KEY", `${this.name}: ${e}`);
			throw this.logger.warn(s), new Error(s);
		}
		return t;
	}
	checkExpiry(e, t) {
		const { expiry: s } = t;
		(0, import_cjs$1.toMiliseconds)(s) - Date.now() <= 0 && this.expire(e, t);
	}
	expire(e, t) {
		this.expirations.delete(e), this.events.emit(F$1.expired, {
			target: e,
			expiration: t
		});
	}
	checkExpirations() {
		this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
	}
	registerEventListeners() {
		this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(F$1.created, (e) => {
			const t = F$1.created;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				data: e
			}), this.persist();
		}), this.events.on(F$1.expired, (e) => {
			const t = F$1.expired;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				data: e
			}), this.persist();
		}), this.events.on(F$1.deleted, (e) => {
			const t = F$1.deleted;
			this.logger.info(`Emitting ${t}`), this.logger.debug({
				type: "event",
				event: t,
				data: e
			}), this.persist();
		});
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: e } = te$1("NOT_INITIALIZED", this.name);
			throw new Error(e);
		}
	}
};
var Mo = Object.defineProperty, Fo = (r$1, e, t) => e in r$1 ? Mo(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, w$1 = (r$1, e, t) => Fo(r$1, typeof e != "symbol" ? e + "" : e, t);
var Ui = class extends M {
	constructor(e, t, s) {
		super(e, t, s), this.core = e, this.logger = t, this.store = s, w$1(this, "name", Wt$1), w$1(this, "abortController"), w$1(this, "isDevEnv"), w$1(this, "verifyUrlV3", Yt$2), w$1(this, "storagePrefix", B$1), w$1(this, "version", Le$2), w$1(this, "publicKey"), w$1(this, "fetchPromise"), w$1(this, "init", async () => {
			var i$2;
			this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_cjs$1.toMiliseconds)((i$2 = this.publicKey) == null ? void 0 : i$2.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
		}), w$1(this, "register", async (i$2) => {
			if (!Ae$1() || this.isDevEnv) return;
			const n$2 = window.location.origin, { id: o$2, decryptedId: a$1 } = i$2, c$3 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n$2}&id=${o$2}&decryptedId=${a$1}`;
			try {
				const h$4 = (0, import_cjs$2.getDocument)(), u$2 = this.startAbortTimer(import_cjs$1.ONE_SECOND * 5), d$4 = await new Promise((g$2, _$4) => {
					const l$2 = () => {
						window.removeEventListener("message", x$6), h$4.body.removeChild(b$3), _$4("attestation aborted");
					};
					this.abortController.signal.addEventListener("abort", l$2);
					const b$3 = h$4.createElement("iframe");
					b$3.src = c$3, b$3.style.display = "none", b$3.addEventListener("error", l$2, { signal: this.abortController.signal });
					const x$6 = (I$4) => {
						if (I$4.data && typeof I$4.data == "string") try {
							const D$3 = JSON.parse(I$4.data);
							if (D$3.type === "verify_attestation") {
								if (sn(D$3.attestation).payload.id !== o$2) return;
								clearInterval(u$2), h$4.body.removeChild(b$3), this.abortController.signal.removeEventListener("abort", l$2), window.removeEventListener("message", x$6), g$2(D$3.attestation === null ? "" : D$3.attestation);
							}
						} catch (D$3) {
							this.logger.warn(D$3);
						}
					};
					h$4.body.appendChild(b$3), window.addEventListener("message", x$6, { signal: this.abortController.signal });
				});
				return this.logger.debug("jwt attestation", d$4), d$4;
			} catch (h$4) {
				this.logger.warn(h$4);
			}
			return "";
		}), w$1(this, "resolve", async (i$2) => {
			if (this.isDevEnv) return "";
			const { attestationId: n$2, hash: o$2, encryptedId: a$1 } = i$2;
			if (n$2 === "") {
				this.logger.debug("resolve: attestationId is empty, skipping");
				return;
			}
			if (n$2) {
				if (sn(n$2).payload.id !== a$1) return;
				const h$4 = await this.isValidJwtAttestation(n$2);
				if (h$4) {
					if (!h$4.isVerified) {
						this.logger.warn("resolve: jwt attestation: origin url not verified");
						return;
					}
					return h$4;
				}
			}
			if (!o$2) return;
			const c$3 = this.getVerifyUrl(i$2?.verifyUrl);
			return this.fetchAttestation(o$2, c$3);
		}), w$1(this, "fetchAttestation", async (i$2, n$2) => {
			this.logger.debug(`resolving attestation: ${i$2} from url: ${n$2}`);
			const o$2 = this.startAbortTimer(import_cjs$1.ONE_SECOND * 5), a$1 = await fetch(`${n$2}/attestation/${i$2}?v2Supported=true`, { signal: this.abortController.signal });
			return clearTimeout(o$2), a$1.status === 200 ? await a$1.json() : void 0;
		}), w$1(this, "getVerifyUrl", (i$2) => {
			let n$2 = i$2 || ue$1;
			return Jt$1.includes(n$2) || (this.logger.info(`verify url: ${n$2}, not included in trusted list, assigning default: ${ue$1}`), n$2 = ue$1), n$2;
		}), w$1(this, "fetchPublicKey", async () => {
			try {
				this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
				const i$2 = this.startAbortTimer(import_cjs$1.FIVE_SECONDS), n$2 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
				return clearTimeout(i$2), await n$2.json();
			} catch (i$2) {
				this.logger.warn(i$2);
			}
		}), w$1(this, "persistPublicKey", async (i$2) => {
			this.logger.debug("persisting public key to local storage", i$2), await this.store.setItem(this.storeKey, i$2), this.publicKey = i$2;
		}), w$1(this, "removePublicKey", async () => {
			this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
		}), w$1(this, "isValidJwtAttestation", async (i$2) => {
			const n$2 = await this.getPublicKey();
			try {
				if (n$2) return this.validateAttestation(i$2, n$2);
			} catch (a$1) {
				this.logger.error(a$1), this.logger.warn("error validating attestation");
			}
			const o$2 = await this.fetchAndPersistPublicKey();
			try {
				if (o$2) return this.validateAttestation(i$2, o$2);
			} catch (a$1) {
				this.logger.error(a$1), this.logger.warn("error validating attestation");
			}
		}), w$1(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w$1(this, "fetchAndPersistPublicKey", async () => {
			if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
			this.fetchPromise = new Promise(async (n$2) => {
				const o$2 = await this.fetchPublicKey();
				o$2 && (await this.persistPublicKey(o$2), n$2(o$2));
			});
			const i$2 = await this.fetchPromise;
			return this.fetchPromise = void 0, i$2;
		}), w$1(this, "validateAttestation", (i$2, n$2) => {
			const o$2 = mi(i$2, n$2.publicKey), a$1 = {
				hasExpired: (0, import_cjs$1.toMiliseconds)(o$2.exp) < Date.now(),
				payload: o$2
			};
			if (a$1.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), /* @__PURE__ */ new Error("JWT attestation expired");
			return {
				origin: a$1.payload.origin,
				isScam: a$1.payload.isScam,
				isVerified: a$1.payload.isVerified
			};
		}), this.logger = E$1(t, this.name), this.abortController = new AbortController(), this.isDevEnv = vo(), this.init();
	}
	get storeKey() {
		return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
	}
	get context() {
		return y$1(this.logger);
	}
	startAbortTimer(e) {
		return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_cjs$1.toMiliseconds)(e));
	}
};
var Ko = Object.defineProperty, Bo = (r$1, e, t) => e in r$1 ? Ko(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, Mi$1 = (r$1, e, t) => Bo(r$1, typeof e != "symbol" ? e + "" : e, t);
var Fi$1 = class extends O$1 {
	constructor(e, t) {
		super(e, t), this.projectId = e, this.logger = t, Mi$1(this, "context", Xt$1), Mi$1(this, "registerDeviceToken", async (s) => {
			const { clientId: i$2, token: n$2, notificationType: o$2, enableEncrypted: a$1 = !1 } = s, c$3 = `${Zt$1}/${this.projectId}/clients`;
			await fetch(c$3, {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({
					client_id: i$2,
					type: o$2,
					token: n$2,
					always_raw: a$1
				})
			});
		}), this.logger = E$1(t, this.context);
	}
};
var Vo = Object.defineProperty, Ki$1 = Object.getOwnPropertySymbols, qo$1 = Object.prototype.hasOwnProperty, Go = Object.prototype.propertyIsEnumerable, Ze$2 = (r$1, e, t) => e in r$1 ? Vo(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, be$1 = (r$1, e) => {
	for (var t in e || (e = {})) qo$1.call(e, t) && Ze$2(r$1, t, e[t]);
	if (Ki$1) for (var t of Ki$1(e)) Go.call(e, t) && Ze$2(r$1, t, e[t]);
	return r$1;
}, E$3 = (r$1, e, t) => Ze$2(r$1, typeof e != "symbol" ? e + "" : e, t);
var Bi$1 = class extends R {
	constructor(e, t, s = !0) {
		super(e, t, s), this.core = e, this.logger = t, E$3(this, "context", ei), E$3(this, "storagePrefix", B$1), E$3(this, "storageVersion", Qt$1), E$3(this, "events", /* @__PURE__ */ new Map()), E$3(this, "shouldPersist", !1), E$3(this, "init", async () => {
			if (!vo()) try {
				const i$2 = {
					eventId: Eo(),
					timestamp: Date.now(),
					domain: this.getAppDomain(),
					props: {
						event: "INIT",
						type: "",
						properties: {
							client_id: await this.core.crypto.getClientId(),
							user_agent: Yt$1(this.core.relayer.protocol, this.core.relayer.version, _e$3)
						}
					}
				};
				await this.sendEvent([i$2]);
			} catch (i$2) {
				this.logger.warn(i$2);
			}
		}), E$3(this, "createEvent", (i$2) => {
			const { event: n$2 = "ERROR", type: o$2 = "", properties: { topic: a$1, trace: c$3 } } = i$2, h$4 = Eo(), u$2 = this.core.projectId || "", g$2 = be$1({
				eventId: h$4,
				timestamp: Date.now(),
				props: {
					event: n$2,
					type: o$2,
					properties: {
						topic: a$1,
						trace: c$3
					}
				},
				bundleId: u$2,
				domain: this.getAppDomain()
			}, this.setMethods(h$4));
			return this.telemetryEnabled && (this.events.set(h$4, g$2), this.shouldPersist = !0), g$2;
		}), E$3(this, "getEvent", (i$2) => {
			const { eventId: n$2, topic: o$2 } = i$2;
			if (n$2) return this.events.get(n$2);
			const a$1 = Array.from(this.events.values()).find((c$3) => c$3.props.properties.topic === o$2);
			if (a$1) return be$1(be$1({}, a$1), this.setMethods(a$1.eventId));
		}), E$3(this, "deleteEvent", (i$2) => {
			const { eventId: n$2 } = i$2;
			this.events.delete(n$2), this.shouldPersist = !0;
		}), E$3(this, "setEventListeners", () => {
			this.core.heartbeat.on(r.pulse, async () => {
				this.shouldPersist && await this.persist(), this.events.forEach((i$2) => {
					(0, import_cjs$1.fromMiliseconds)(Date.now()) - (0, import_cjs$1.fromMiliseconds)(i$2.timestamp) > ti$1 && (this.events.delete(i$2.eventId), this.shouldPersist = !0);
				});
			});
		}), E$3(this, "setMethods", (i$2) => ({
			addTrace: (n$2) => this.addTrace(i$2, n$2),
			setError: (n$2) => this.setError(i$2, n$2)
		})), E$3(this, "addTrace", (i$2, n$2) => {
			const o$2 = this.events.get(i$2);
			o$2 && (o$2.props.properties.trace.push(n$2), this.events.set(i$2, o$2), this.shouldPersist = !0);
		}), E$3(this, "setError", (i$2, n$2) => {
			const o$2 = this.events.get(i$2);
			o$2 && (o$2.props.type = n$2, o$2.timestamp = Date.now(), this.events.set(i$2, o$2), this.shouldPersist = !0);
		}), E$3(this, "persist", async () => {
			await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
		}), E$3(this, "restore", async () => {
			try {
				const i$2 = await this.core.storage.getItem(this.storageKey) || [];
				if (!i$2.length) return;
				i$2.forEach((n$2) => {
					this.events.set(n$2.eventId, be$1(be$1({}, n$2), this.setMethods(n$2.eventId)));
				});
			} catch (i$2) {
				this.logger.warn(i$2);
			}
		}), E$3(this, "submit", async () => {
			if (!this.telemetryEnabled || this.events.size === 0) return;
			const i$2 = [];
			for (const [n$2, o$2] of this.events) o$2.props.type && i$2.push(o$2);
			if (i$2.length !== 0) try {
				if ((await this.sendEvent(i$2)).ok) for (const n$2 of i$2) this.events.delete(n$2.eventId), this.shouldPersist = !0;
			} catch (n$2) {
				this.logger.warn(n$2);
			}
		}), E$3(this, "sendEvent", async (i$2) => {
			const n$2 = this.getAppDomain() ? "" : "&sp=desktop";
			return await fetch(`${ii$1}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e$3}${n$2}`, {
				method: "POST",
				body: JSON.stringify(i$2)
			});
		}), E$3(this, "getAppDomain", () => Xr().url), this.logger = E$1(t, this.context), this.telemetryEnabled = s, s ? this.restore().then(async () => {
			await this.submit(), this.setEventListeners();
		}) : this.persist();
	}
	get storageKey() {
		return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
	}
};
var Wo = Object.defineProperty, Vi$1 = Object.getOwnPropertySymbols, Ho = Object.prototype.hasOwnProperty, Yo = Object.prototype.propertyIsEnumerable, Qe$1 = (r$1, e, t) => e in r$1 ? Wo(r$1, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r$1[e] = t, qi$1 = (r$1, e) => {
	for (var t in e || (e = {})) Ho.call(e, t) && Qe$1(r$1, t, e[t]);
	if (Vi$1) for (var t of Vi$1(e)) Yo.call(e, t) && Qe$1(r$1, t, e[t]);
	return r$1;
}, v$1 = (r$1, e, t) => Qe$1(r$1, typeof e != "symbol" ? e + "" : e, t);
var Te$1 = class Te$1 extends h$1 {
	constructor(e) {
		var t;
		super(e), v$1(this, "protocol", ze$1), v$1(this, "version", Le$2), v$1(this, "name", he$1), v$1(this, "relayUrl"), v$1(this, "projectId"), v$1(this, "customStoragePrefix"), v$1(this, "events", new import_events$2.EventEmitter()), v$1(this, "logger"), v$1(this, "heartbeat"), v$1(this, "relayer"), v$1(this, "crypto"), v$1(this, "storage"), v$1(this, "history"), v$1(this, "expirer"), v$1(this, "pairing"), v$1(this, "verify"), v$1(this, "echoClient"), v$1(this, "linkModeSupportedApps"), v$1(this, "eventClient"), v$1(this, "initialized", !1), v$1(this, "logChunkController"), v$1(this, "on", (o$2, a$1) => this.events.on(o$2, a$1)), v$1(this, "once", (o$2, a$1) => this.events.once(o$2, a$1)), v$1(this, "off", (o$2, a$1) => this.events.off(o$2, a$1)), v$1(this, "removeListener", (o$2, a$1) => this.events.removeListener(o$2, a$1)), v$1(this, "dispatchEnvelope", ({ topic: o$2, message: a$1, sessionExists: c$3 }) => {
			if (!o$2 || !a$1) return;
			const h$4 = {
				topic: o$2,
				message: a$1,
				publishedAt: Date.now(),
				transportType: Q$1.link_mode
			};
			this.relayer.onLinkMessageEvent(h$4, { sessionExists: c$3 });
		}), this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || Ue$2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
		const { logger: i$2, chunkLoggerController: n$2 } = A({
			opts: k({
				level: typeof e?.logger == "string" && e.logger ? e.logger : Et$1.logger,
				name: he$1
			}),
			maxSizeInBytes: e?.maxLogBlobSizeInBytes,
			loggerOverride: e?.logger
		});
		this.logChunkController = n$2, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
			var o$2, a$1;
			(o$2 = this.logChunkController) != null && o$2.downloadLogsBlobInBrowser && ((a$1 = this.logChunkController) == null || a$1.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
		}), this.logger = E$1(i$2, this.name), this.heartbeat = new i(), this.crypto = new vi$1(this, this.logger, e?.keychain), this.history = new ki$1(this, this.logger), this.expirer = new ji$1(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(qi$1(qi$1({}, It), e?.storageOptions)), this.relayer = new Si({
			core: this,
			logger: this.logger,
			relayUrl: this.relayUrl,
			projectId: this.projectId
		}), this.pairing = new Li$1(this, this.logger), this.verify = new Ui(this, this.logger, this.storage), this.echoClient = new Fi$1(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Bi$1(this, this.logger, e?.telemetryEnabled);
	}
	static async init(e) {
		const t = new Te$1(e);
		await t.initialize();
		const s = await t.crypto.getClientId();
		return await t.storage.setItem(jt$1, s), t;
	}
	get context() {
		return y$1(this.logger);
	}
	async start() {
		this.initialized || await this.initialize();
	}
	async getLogsBlob() {
		var e;
		return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
	}
	async addLinkModeSupportedApp(e) {
		this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Me$3, this.linkModeSupportedApps));
	}
	async initialize() {
		this.logger.trace("Initialized");
		try {
			await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Me$3) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
		} catch (e) {
			throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
		}
	}
};
var Jo = Te$1;

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_cjs = require_cjs();
var import_events$1 = /* @__PURE__ */ __toESM(require_events());
var De$1 = "wc", Le$1 = 2, ke$1 = "client", we$1 = `${De$1}@${Le$1}:${ke$1}:`, me$1 = {
	name: ke$1,
	logger: "error",
	controller: !1,
	relayUrl: "wss://relay.walletconnect.org"
}, ys = {
	session_proposal: "session_proposal",
	session_update: "session_update",
	session_extend: "session_extend",
	session_ping: "session_ping",
	session_delete: "session_delete",
	session_expire: "session_expire",
	session_request: "session_request",
	session_request_sent: "session_request_sent",
	session_event: "session_event",
	proposal_expire: "proposal_expire",
	session_authenticate: "session_authenticate",
	session_request_expire: "session_request_expire",
	session_connect: "session_connect"
}, ws = { database: ":memory:" }, Me$2 = "WALLETCONNECT_DEEPLINK_CHOICE", ms = {
	created: "history_created",
	updated: "history_updated",
	deleted: "history_deleted",
	sync: "history_sync"
}, _s = "history", Es = "0.3", pt$1 = "proposal", fs = import_cjs.THIRTY_DAYS, $e$2 = "Proposal expired", ht$1 = "session", J$2 = import_cjs.SEVEN_DAYS, dt$1 = "engine", N$1 = {
	wc_sessionPropose: {
		req: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !0,
			tag: 1100
		},
		res: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !1,
			tag: 1101
		},
		reject: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !1,
			tag: 1120
		},
		autoReject: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !1,
			tag: 1121
		}
	},
	wc_sessionSettle: {
		req: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !1,
			tag: 1102
		},
		res: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !1,
			tag: 1103
		}
	},
	wc_sessionUpdate: {
		req: {
			ttl: import_cjs.ONE_DAY,
			prompt: !1,
			tag: 1104
		},
		res: {
			ttl: import_cjs.ONE_DAY,
			prompt: !1,
			tag: 1105
		}
	},
	wc_sessionExtend: {
		req: {
			ttl: import_cjs.ONE_DAY,
			prompt: !1,
			tag: 1106
		},
		res: {
			ttl: import_cjs.ONE_DAY,
			prompt: !1,
			tag: 1107
		}
	},
	wc_sessionRequest: {
		req: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !0,
			tag: 1108
		},
		res: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !1,
			tag: 1109
		}
	},
	wc_sessionEvent: {
		req: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !0,
			tag: 1110
		},
		res: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !1,
			tag: 1111
		}
	},
	wc_sessionDelete: {
		req: {
			ttl: import_cjs.ONE_DAY,
			prompt: !1,
			tag: 1112
		},
		res: {
			ttl: import_cjs.ONE_DAY,
			prompt: !1,
			tag: 1113
		}
	},
	wc_sessionPing: {
		req: {
			ttl: import_cjs.ONE_DAY,
			prompt: !1,
			tag: 1114
		},
		res: {
			ttl: import_cjs.ONE_DAY,
			prompt: !1,
			tag: 1115
		}
	},
	wc_sessionAuthenticate: {
		req: {
			ttl: import_cjs.ONE_HOUR,
			prompt: !0,
			tag: 1116
		},
		res: {
			ttl: import_cjs.ONE_HOUR,
			prompt: !1,
			tag: 1117
		},
		reject: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !1,
			tag: 1118
		},
		autoReject: {
			ttl: import_cjs.FIVE_MINUTES,
			prompt: !1,
			tag: 1119
		}
	}
}, _e$2 = {
	min: import_cjs.FIVE_MINUTES,
	max: import_cjs.SEVEN_DAYS
}, $$1 = {
	idle: "IDLE",
	active: "ACTIVE"
}, Ue$1 = {
	eth_sendTransaction: { key: "" },
	eth_sendRawTransaction: { key: "" },
	wallet_sendCalls: { key: "" },
	solana_signTransaction: { key: "signature" },
	solana_signAllTransactions: { key: "transactions" },
	solana_signAndSendTransaction: { key: "signature" }
}, ut$2 = "request", gt$1 = [
	"wc_sessionPropose",
	"wc_sessionRequest",
	"wc_authRequest",
	"wc_sessionAuthenticate"
], yt$1 = "wc", Ss = 1.5, wt$1 = "auth", mt$1 = "authKeys", _t$1 = "pairingTopics", Et = "requests", ae$2 = `${yt$1}@1.5:${wt$1}:`, ce$1 = `${ae$2}:PUB_KEY`;
var Rs = Object.defineProperty, vs = Object.defineProperties, Is = Object.getOwnPropertyDescriptors, ft$1 = Object.getOwnPropertySymbols, Ts = Object.prototype.hasOwnProperty, qs = Object.prototype.propertyIsEnumerable, Ke$1 = (S$6, n$2, e) => n$2 in S$6 ? Rs(S$6, n$2, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : S$6[n$2] = e, v = (S$6, n$2) => {
	for (var e in n$2 || (n$2 = {})) Ts.call(n$2, e) && Ke$1(S$6, e, n$2[e]);
	if (ft$1) for (var e of ft$1(n$2)) qs.call(n$2, e) && Ke$1(S$6, e, n$2[e]);
	return S$6;
}, b$1 = (S$6, n$2) => vs(S$6, Is(n$2)), c = (S$6, n$2, e) => Ke$1(S$6, typeof n$2 != "symbol" ? n$2 + "" : n$2, e);
var Ps = class extends V$1 {
	constructor(n$2) {
		super(n$2), c(this, "name", dt$1), c(this, "events", new import_events$1.default()), c(this, "initialized", !1), c(this, "requestQueue", {
			state: $$1.idle,
			queue: []
		}), c(this, "sessionRequestQueue", {
			state: $$1.idle,
			queue: []
		}), c(this, "requestQueueDelay", import_cjs.ONE_SECOND), c(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c(this, "recentlyDeletedLimit", 200), c(this, "relayMessageCache", []), c(this, "pendingSessions", /* @__PURE__ */ new Map()), c(this, "init", async () => {
			this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N$1) }), this.initialized = !0, setTimeout(async () => {
				await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
			}, (0, import_cjs.toMiliseconds)(this.requestQueueDelay)));
		}), c(this, "connect", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			const t = b$1(v({}, e), {
				requiredNamespaces: e.requiredNamespaces || {},
				optionalNamespaces: e.optionalNamespaces || {}
			});
			await this.isValidConnect(t);
			const { pairingTopic: s, requiredNamespaces: i$2, optionalNamespaces: r$1, sessionProperties: o$2, scopedProperties: a$1, relays: l$2 } = t;
			let p$5 = s, h$4, u$2 = !1;
			try {
				if (p$5) {
					const T$3 = this.client.core.pairing.pairings.get(p$5);
					this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u$2 = T$3.active;
				}
			} catch (T$3) {
				throw this.client.logger.error(`connect() -> pairing.get(${p$5}) failed`), T$3;
			}
			if (!p$5 || !u$2) {
				const { topic: T$3, uri: U$1 } = await this.client.core.pairing.create();
				p$5 = T$3, h$4 = U$1;
			}
			if (!p$5) {
				const { message: T$3 } = te$1("NO_MATCHING_KEY", `connect() pairing topic: ${p$5}`);
				throw new Error(T$3);
			}
			const d$4 = await this.client.core.crypto.generateKeyPair(), w$3 = N$1.wc_sessionPropose.req.ttl || import_cjs.FIVE_MINUTES, m$2 = po(w$3), f$7 = b$1(v(v({
				requiredNamespaces: i$2,
				optionalNamespaces: r$1,
				relays: l$2 ?? [{ protocol: xt$1 }],
				proposer: {
					publicKey: d$4,
					metadata: this.client.metadata
				},
				expiryTimestamp: m$2,
				pairingTopic: p$5
			}, o$2 && { sessionProperties: o$2 }), a$1 && { scopedProperties: a$1 }), { id: payloadId() }), _$4 = yo("session_connect", f$7.id), { reject: g$2, resolve: A$5, done: D$3 } = ao(w$3, $e$2), I$4 = ({ id: T$3 }) => {
				T$3 === f$7.id && (this.client.events.off("proposal_expire", I$4), this.pendingSessions.delete(f$7.id), this.events.emit(_$4, { error: {
					message: $e$2,
					code: 0
				} }));
			};
			return this.client.events.on("proposal_expire", I$4), this.events.once(_$4, ({ error: T$3, session: U$1 }) => {
				this.client.events.off("proposal_expire", I$4), T$3 ? g$2(T$3) : U$1 && A$5(U$1);
			}), await this.sendRequest({
				topic: p$5,
				method: "wc_sessionPropose",
				params: f$7,
				throwOnFailedPublish: !0,
				clientRpcId: f$7.id
			}), await this.setProposal(f$7.id, f$7), {
				uri: h$4,
				approval: D$3
			};
		}), c(this, "pair", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			try {
				return await this.client.core.pairing.pair(e);
			} catch (t) {
				throw this.client.logger.error("pair() failed"), t;
			}
		}), c(this, "approve", async (e) => {
			var t, s, i$2;
			const r$1 = this.client.core.eventClient.createEvent({ properties: {
				topic: (t = e?.id) == null ? void 0 : t.toString(),
				trace: [Qs.session_approve_started]
			} });
			try {
				this.isInitialized(), await this.confirmOnlineStateOrThrow();
			} catch (q$4) {
				throw r$1.setError(er.no_internet_connection), q$4;
			}
			try {
				await this.isValidProposalId(e?.id);
			} catch (q$4) {
				throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`), r$1.setError(er.proposal_not_found), q$4;
			}
			try {
				await this.isValidApprove(e);
			} catch (q$4) {
				throw this.client.logger.error("approve() -> isValidApprove() failed"), r$1.setError(er.session_approve_namespace_validation_failure), q$4;
			}
			const { id: o$2, relayProtocol: a$1, namespaces: l$2, sessionProperties: p$5, scopedProperties: h$4, sessionConfig: u$2 } = e, d$4 = this.client.proposal.get(o$2);
			this.client.core.eventClient.deleteEvent({ eventId: r$1.eventId });
			const { pairingTopic: w$3, proposer: m$2, requiredNamespaces: f$7, optionalNamespaces: _$4 } = d$4;
			let g$2 = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: w$3 });
			g$2 || (g$2 = (i$2 = this.client.core.eventClient) == null ? void 0 : i$2.createEvent({
				type: Qs.session_approve_started,
				properties: {
					topic: w$3,
					trace: [Qs.session_approve_started, Qs.session_namespaces_validation_success]
				}
			}));
			const A$5 = await this.client.core.crypto.generateKeyPair(), D$3 = m$2.publicKey, I$4 = await this.client.core.crypto.generateSharedKey(A$5, D$3), T$3 = v(v(v({
				relay: { protocol: a$1 ?? "irn" },
				namespaces: l$2,
				controller: {
					publicKey: A$5,
					metadata: this.client.metadata
				},
				expiry: po(J$2)
			}, p$5 && { sessionProperties: p$5 }), h$4 && { scopedProperties: h$4 }), u$2 && { sessionConfig: u$2 }), U$1 = Q$1.relay;
			g$2.addTrace(Qs.subscribing_session_topic);
			try {
				await this.client.core.relayer.subscribe(I$4, { transportType: U$1 });
			} catch (q$4) {
				throw g$2.setError(er.subscribe_session_topic_failure), q$4;
			}
			g$2.addTrace(Qs.subscribe_session_topic_success);
			const fe$5 = b$1(v({}, T$3), {
				topic: I$4,
				requiredNamespaces: f$7,
				optionalNamespaces: _$4,
				pairingTopic: w$3,
				acknowledged: !1,
				self: T$3.controller,
				peer: {
					publicKey: m$2.publicKey,
					metadata: m$2.metadata
				},
				controller: A$5,
				transportType: Q$1.relay
			});
			await this.client.session.set(I$4, fe$5), g$2.addTrace(Qs.store_session);
			try {
				g$2.addTrace(Qs.publishing_session_settle), await this.sendRequest({
					topic: I$4,
					method: "wc_sessionSettle",
					params: T$3,
					throwOnFailedPublish: !0
				}).catch((q$4) => {
					throw g$2?.setError(er.session_settle_publish_failure), q$4;
				}), g$2.addTrace(Qs.session_settle_publish_success), g$2.addTrace(Qs.publishing_session_approve), await this.sendResult({
					id: o$2,
					topic: w$3,
					result: {
						relay: { protocol: a$1 ?? "irn" },
						responderPublicKey: A$5
					},
					throwOnFailedPublish: !0
				}).catch((q$4) => {
					throw g$2?.setError(er.session_approve_publish_failure), q$4;
				}), g$2.addTrace(Qs.session_approve_publish_success);
			} catch (q$4) {
				throw this.client.logger.error(q$4), this.client.session.delete(I$4, de("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(I$4), q$4;
			}
			return this.client.core.eventClient.deleteEvent({ eventId: g$2.eventId }), await this.client.core.pairing.updateMetadata({
				topic: w$3,
				metadata: m$2.metadata
			}), await this.client.proposal.delete(o$2, de("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: w$3 }), await this.setExpiry(I$4, po(J$2)), {
				topic: I$4,
				acknowledged: () => Promise.resolve(this.client.session.get(I$4))
			};
		}), c(this, "reject", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			try {
				await this.isValidReject(e);
			} catch (r$1) {
				throw this.client.logger.error("reject() -> isValidReject() failed"), r$1;
			}
			const { id: t, reason: s } = e;
			let i$2;
			try {
				i$2 = this.client.proposal.get(t).pairingTopic;
			} catch (r$1) {
				throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r$1;
			}
			i$2 && (await this.sendError({
				id: t,
				topic: i$2,
				error: s,
				rpcOpts: N$1.wc_sessionPropose.reject
			}), await this.client.proposal.delete(t, de("USER_DISCONNECTED")));
		}), c(this, "update", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			try {
				await this.isValidUpdate(e);
			} catch (h$4) {
				throw this.client.logger.error("update() -> isValidUpdate() failed"), h$4;
			}
			const { topic: t, namespaces: s } = e, { done: i$2, resolve: r$1, reject: o$2 } = ao(), a$1 = payloadId(), l$2 = getBigIntRpcId().toString(), p$5 = this.client.session.get(t).namespaces;
			return this.events.once(yo("session_update", a$1), ({ error: h$4 }) => {
				h$4 ? o$2(h$4) : r$1();
			}), await this.client.session.update(t, { namespaces: s }), await this.sendRequest({
				topic: t,
				method: "wc_sessionUpdate",
				params: { namespaces: s },
				throwOnFailedPublish: !0,
				clientRpcId: a$1,
				relayRpcId: l$2
			}).catch((h$4) => {
				this.client.logger.error(h$4), this.client.session.update(t, { namespaces: p$5 }), o$2(h$4);
			}), { acknowledged: i$2 };
		}), c(this, "extend", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			try {
				await this.isValidExtend(e);
			} catch (a$1) {
				throw this.client.logger.error("extend() -> isValidExtend() failed"), a$1;
			}
			const { topic: t } = e, s = payloadId(), { done: i$2, resolve: r$1, reject: o$2 } = ao();
			return this.events.once(yo("session_extend", s), ({ error: a$1 }) => {
				a$1 ? o$2(a$1) : r$1();
			}), await this.setExpiry(t, po(J$2)), this.sendRequest({
				topic: t,
				method: "wc_sessionExtend",
				params: {},
				clientRpcId: s,
				throwOnFailedPublish: !0
			}).catch((a$1) => {
				o$2(a$1);
			}), { acknowledged: i$2 };
		}), c(this, "request", async (e) => {
			this.isInitialized();
			try {
				await this.isValidRequest(e);
			} catch (_$4) {
				throw this.client.logger.error("request() -> isValidRequest() failed"), _$4;
			}
			const { chainId: t, request: s, topic: i$2, expiry: r$1 = N$1.wc_sessionRequest.req.ttl } = e, o$2 = this.client.session.get(i$2);
			o$2?.transportType === Q$1.relay && await this.confirmOnlineStateOrThrow();
			const a$1 = payloadId(), l$2 = getBigIntRpcId().toString(), { done: p$5, resolve: h$4, reject: u$2 } = ao(r$1, "Request expired. Please try again.");
			this.events.once(yo("session_request", a$1), ({ error: _$4, result: g$2 }) => {
				_$4 ? u$2(_$4) : h$4(g$2);
			});
			const d$4 = "wc_sessionRequest", w$3 = this.getAppLinkIfEnabled(o$2.peer.metadata, o$2.transportType);
			if (w$3) return await this.sendRequest({
				clientRpcId: a$1,
				relayRpcId: l$2,
				topic: i$2,
				method: d$4,
				params: {
					request: b$1(v({}, s), { expiryTimestamp: po(r$1) }),
					chainId: t
				},
				expiry: r$1,
				throwOnFailedPublish: !0,
				appLink: w$3
			}).catch((_$4) => u$2(_$4)), this.client.events.emit("session_request_sent", {
				topic: i$2,
				request: s,
				chainId: t,
				id: a$1
			}), await p$5();
			const m$2 = {
				request: b$1(v({}, s), { expiryTimestamp: po(r$1) }),
				chainId: t
			}, f$7 = this.shouldSetTVF(d$4, m$2);
			return await Promise.all([
				new Promise(async (_$4) => {
					await this.sendRequest(v({
						clientRpcId: a$1,
						relayRpcId: l$2,
						topic: i$2,
						method: d$4,
						params: m$2,
						expiry: r$1,
						throwOnFailedPublish: !0
					}, f$7 && { tvf: this.getTVFParams(a$1, m$2) })).catch((g$2) => u$2(g$2)), this.client.events.emit("session_request_sent", {
						topic: i$2,
						request: s,
						chainId: t,
						id: a$1
					}), _$4();
				}),
				new Promise(async (_$4) => {
					var g$2;
					if (!((g$2 = o$2.sessionConfig) != null && g$2.disableDeepLink)) await mo({
						id: a$1,
						topic: i$2,
						wcDeepLink: await bo(this.client.core.storage, Me$2)
					});
					_$4();
				}),
				p$5()
			]).then((_$4) => _$4[2]);
		}), c(this, "respond", async (e) => {
			this.isInitialized(), await this.isValidRespond(e);
			const { topic: t, response: s } = e, { id: i$2 } = s, r$1 = this.client.session.get(t);
			r$1.transportType === Q$1.relay && await this.confirmOnlineStateOrThrow();
			const o$2 = this.getAppLinkIfEnabled(r$1.peer.metadata, r$1.transportType);
			isJsonRpcResult(s) ? await this.sendResult({
				id: i$2,
				topic: t,
				result: s.result,
				throwOnFailedPublish: !0,
				appLink: o$2
			}) : isJsonRpcError(s) && await this.sendError({
				id: i$2,
				topic: t,
				error: s.error,
				appLink: o$2
			}), this.cleanupAfterResponse(e);
		}), c(this, "ping", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow();
			try {
				await this.isValidPing(e);
			} catch (s) {
				throw this.client.logger.error("ping() -> isValidPing() failed"), s;
			}
			const { topic: t } = e;
			if (this.client.session.keys.includes(t)) {
				const s = payloadId(), i$2 = getBigIntRpcId().toString(), { done: r$1, resolve: o$2, reject: a$1 } = ao();
				this.events.once(yo("session_ping", s), ({ error: l$2 }) => {
					l$2 ? a$1(l$2) : o$2();
				}), await Promise.all([this.sendRequest({
					topic: t,
					method: "wc_sessionPing",
					params: {},
					throwOnFailedPublish: !0,
					clientRpcId: s,
					relayRpcId: i$2
				}), r$1()]);
			} else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t }));
		}), c(this, "emit", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
			const { topic: t, event: s, chainId: i$2 } = e, r$1 = getBigIntRpcId().toString(), o$2 = payloadId();
			await this.sendRequest({
				topic: t,
				method: "wc_sessionEvent",
				params: {
					event: s,
					chainId: i$2
				},
				throwOnFailedPublish: !0,
				relayRpcId: r$1,
				clientRpcId: o$2
			});
		}), c(this, "disconnect", async (e) => {
			this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
			const { topic: t } = e;
			if (this.client.session.keys.includes(t)) await this.sendRequest({
				topic: t,
				method: "wc_sessionDelete",
				params: de("USER_DISCONNECTED"),
				throwOnFailedPublish: !0
			}), await this.deleteSession({
				topic: t,
				emitEvent: !1
			});
			else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
			else {
				const { message: s } = te$1("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
				throw new Error(s);
			}
		}), c(this, "find", (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => Pi(t, e)))), c(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c(this, "authenticate", async (e, t) => {
			var s;
			this.isInitialized(), this.isValidAuthenticate(e);
			const i$2 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), r$1 = i$2 ? Q$1.link_mode : Q$1.relay;
			r$1 === Q$1.relay && await this.confirmOnlineStateOrThrow();
			const { chains: o$2, statement: a$1 = "", uri: l$2, domain: p$5, nonce: h$4, type: u$2, exp: d$4, nbf: w$3, methods: m$2 = [], expiry: f$7 } = e, _$4 = [...e.resources || []], { topic: g$2, uri: A$5 } = await this.client.core.pairing.create({
				methods: ["wc_sessionAuthenticate"],
				transportType: r$1
			});
			this.client.logger.info({
				message: "Generated new pairing",
				pairing: {
					topic: g$2,
					uri: A$5
				}
			});
			const D$3 = await this.client.core.crypto.generateKeyPair(), I$4 = ii(D$3);
			if (await Promise.all([this.client.auth.authKeys.set(ce$1, {
				responseTopic: I$4,
				publicKey: D$3
			}), this.client.auth.pairingTopics.set(I$4, {
				topic: I$4,
				pairingTopic: g$2
			})]), await this.client.core.relayer.subscribe(I$4, { transportType: r$1 }), this.client.logger.info(`sending request to new pairing topic: ${g$2}`), m$2.length > 0) {
				const { namespace: x$6 } = Ye(o$2[0]);
				let L$4 = rs(x$6, "request", m$2);
				Me$1(_$4) && (L$4 = os(L$4, _$4.pop())), _$4.push(L$4);
			}
			const T$3 = f$7 && f$7 > N$1.wc_sessionAuthenticate.req.ttl ? f$7 : N$1.wc_sessionAuthenticate.req.ttl, U$1 = {
				authPayload: {
					type: u$2 ?? "caip122",
					chains: o$2,
					statement: a$1,
					aud: l$2,
					domain: p$5,
					version: "1",
					nonce: h$4,
					iat: (/* @__PURE__ */ new Date()).toISOString(),
					exp: d$4,
					nbf: w$3,
					resources: _$4
				},
				requester: {
					publicKey: D$3,
					metadata: this.client.metadata
				},
				expiryTimestamp: po(T$3)
			}, q$4 = {
				requiredNamespaces: {},
				optionalNamespaces: { eip155: {
					chains: o$2,
					methods: [...new Set(["personal_sign", ...m$2])],
					events: ["chainChanged", "accountsChanged"]
				} },
				relays: [{ protocol: "irn" }],
				pairingTopic: g$2,
				proposer: {
					publicKey: D$3,
					metadata: this.client.metadata
				},
				expiryTimestamp: po(N$1.wc_sessionPropose.req.ttl),
				id: payloadId()
			}, { done: Rt$7, resolve: je$6, reject: Se$6 } = ao(T$3, "Request expired"), te$6 = payloadId(), le$7 = yo("session_connect", q$4.id), Re$4 = yo("session_request", te$6), pe$4 = async ({ error: x$6, session: L$4 }) => {
				this.events.off(Re$4, ve$4), x$6 ? Se$6(x$6) : L$4 && je$6({ session: L$4 });
			}, ve$4 = async (x$6) => {
				var L$4, Fe$6, Qe$6;
				if (await this.deletePendingAuthRequest(te$6, {
					message: "fulfilled",
					code: 0
				}), x$6.error) {
					const ie$6 = de("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
					return x$6.error.code === ie$6.code ? void 0 : (this.events.off(le$7, pe$4), Se$6(x$6.error.message));
				}
				await this.deleteProposal(q$4.id), this.events.off(le$7, pe$4);
				const { cacaos: He$5, responder: Q$4 } = x$6.result, Te$5 = [], ze$6 = [];
				for (const ie$6 of He$5) {
					await Zo({
						cacao: ie$6,
						projectId: this.client.core.projectId
					}) || (this.client.logger.error(ie$6, "Signature verification failed"), Se$6(de("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
					const { p: qe$6 } = ie$6, Pe$4 = Me$1(qe$6.resources), Ye$6 = [In(qe$6.iss)], vt$5 = ut$1(qe$6.iss);
					if (Pe$4) {
						const Ne$5 = ss(Pe$4), It$4 = is(Pe$4);
						Te$5.push(...Ne$5), Ye$6.push(...It$4);
					}
					for (const Ne$5 of Ye$6) ze$6.push(`${Ne$5}:${vt$5}`);
				}
				const se$6 = await this.client.core.crypto.generateSharedKey(D$3, Q$4.publicKey);
				let he$4;
				Te$5.length > 0 && (he$4 = {
					topic: se$6,
					acknowledged: !0,
					self: {
						publicKey: D$3,
						metadata: this.client.metadata
					},
					peer: Q$4,
					controller: Q$4.publicKey,
					expiry: po(J$2),
					requiredNamespaces: {},
					optionalNamespaces: {},
					relay: { protocol: "irn" },
					pairingTopic: g$2,
					namespaces: Ri([...new Set(Te$5)], [...new Set(ze$6)]),
					transportType: r$1
				}, await this.client.core.relayer.subscribe(se$6, { transportType: r$1 }), await this.client.session.set(se$6, he$4), g$2 && await this.client.core.pairing.updateMetadata({
					topic: g$2,
					metadata: Q$4.metadata
				}), he$4 = this.client.session.get(se$6)), (L$4 = this.client.metadata.redirect) != null && L$4.linkMode && (Fe$6 = Q$4.metadata.redirect) != null && Fe$6.linkMode && (Qe$6 = Q$4.metadata.redirect) != null && Qe$6.universal && t && (this.client.core.addLinkModeSupportedApp(Q$4.metadata.redirect.universal), this.client.session.update(se$6, { transportType: Q$1.link_mode })), je$6({
					auths: He$5,
					session: he$4
				});
			};
			this.events.once(le$7, pe$4), this.events.once(Re$4, ve$4);
			let Ie$6;
			try {
				if (i$2) {
					const x$6 = formatJsonRpcRequest("wc_sessionAuthenticate", U$1, te$6);
					this.client.core.history.set(g$2, x$6);
					Ie$6 = xi(t, g$2, await this.client.core.crypto.encode("", x$6, {
						type: _e$1,
						encoding: ti
					}));
				} else await Promise.all([this.sendRequest({
					topic: g$2,
					method: "wc_sessionAuthenticate",
					params: U$1,
					expiry: e.expiry,
					throwOnFailedPublish: !0,
					clientRpcId: te$6
				}), this.sendRequest({
					topic: g$2,
					method: "wc_sessionPropose",
					params: q$4,
					expiry: N$1.wc_sessionPropose.req.ttl,
					throwOnFailedPublish: !0,
					clientRpcId: q$4.id
				})]);
			} catch (x$6) {
				throw this.events.off(le$7, pe$4), this.events.off(Re$4, ve$4), x$6;
			}
			return await this.setProposal(q$4.id, q$4), await this.setAuthRequest(te$6, {
				request: b$1(v({}, U$1), { verifyContext: {} }),
				pairingTopic: g$2,
				transportType: r$1
			}), {
				uri: Ie$6 ?? A$5,
				response: Rt$7
			};
		}), c(this, "approveSessionAuthenticate", async (e) => {
			const { id: t, auths: s } = e, i$2 = this.client.core.eventClient.createEvent({ properties: {
				topic: t.toString(),
				trace: [tr.authenticated_session_approve_started]
			} });
			try {
				this.isInitialized();
			} catch (f$7) {
				throw i$2.setError(ir.no_internet_connection), f$7;
			}
			const r$1 = this.getPendingAuthRequest(t);
			if (!r$1) throw i$2.setError(ir.authenticated_session_pending_request_not_found), /* @__PURE__ */ new Error(`Could not find pending auth request with id ${t}`);
			const o$2 = r$1.transportType || Q$1.relay;
			o$2 === Q$1.relay && await this.confirmOnlineStateOrThrow();
			const a$1 = r$1.requester.publicKey, l$2 = await this.client.core.crypto.generateKeyPair(), p$5 = ii(a$1), h$4 = {
				type: Oe$2,
				receiverPublicKey: a$1,
				senderPublicKey: l$2
			}, u$2 = [], d$4 = [];
			for (const f$7 of s) {
				if (!await Zo({
					cacao: f$7,
					projectId: this.client.core.projectId
				})) {
					i$2.setError(ir.invalid_cacao);
					const I$4 = de("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
					throw await this.sendError({
						id: t,
						topic: p$5,
						error: I$4,
						encodeOpts: h$4
					}), new Error(I$4.message);
				}
				i$2.addTrace(tr.cacaos_verified);
				const { p: _$4 } = f$7, g$2 = Me$1(_$4.resources), A$5 = [In(_$4.iss)], D$3 = ut$1(_$4.iss);
				if (g$2) {
					const I$4 = ss(g$2), T$3 = is(g$2);
					u$2.push(...I$4), A$5.push(...T$3);
				}
				for (const I$4 of A$5) d$4.push(`${I$4}:${D$3}`);
			}
			const w$3 = await this.client.core.crypto.generateSharedKey(l$2, a$1);
			i$2.addTrace(tr.create_authenticated_session_topic);
			let m$2;
			if (u$2?.length > 0) {
				m$2 = {
					topic: w$3,
					acknowledged: !0,
					self: {
						publicKey: l$2,
						metadata: this.client.metadata
					},
					peer: {
						publicKey: a$1,
						metadata: r$1.requester.metadata
					},
					controller: a$1,
					expiry: po(J$2),
					authentication: s,
					requiredNamespaces: {},
					optionalNamespaces: {},
					relay: { protocol: "irn" },
					pairingTopic: r$1.pairingTopic,
					namespaces: Ri([...new Set(u$2)], [...new Set(d$4)]),
					transportType: o$2
				}, i$2.addTrace(tr.subscribing_authenticated_session_topic);
				try {
					await this.client.core.relayer.subscribe(w$3, { transportType: o$2 });
				} catch (f$7) {
					throw i$2.setError(ir.subscribe_authenticated_session_topic_failure), f$7;
				}
				i$2.addTrace(tr.subscribe_authenticated_session_topic_success), await this.client.session.set(w$3, m$2), i$2.addTrace(tr.store_authenticated_session), await this.client.core.pairing.updateMetadata({
					topic: r$1.pairingTopic,
					metadata: r$1.requester.metadata
				});
			}
			i$2.addTrace(tr.publishing_authenticated_session_approve);
			try {
				await this.sendResult({
					topic: p$5,
					id: t,
					result: {
						cacaos: s,
						responder: {
							publicKey: l$2,
							metadata: this.client.metadata
						}
					},
					encodeOpts: h$4,
					throwOnFailedPublish: !0,
					appLink: this.getAppLinkIfEnabled(r$1.requester.metadata, o$2)
				});
			} catch (f$7) {
				throw i$2.setError(ir.authenticated_session_approve_publish_failure), f$7;
			}
			return await this.client.auth.requests.delete(t, {
				message: "fulfilled",
				code: 0
			}), await this.client.core.pairing.activate({ topic: r$1.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i$2.eventId }), { session: m$2 };
		}), c(this, "rejectSessionAuthenticate", async (e) => {
			this.isInitialized();
			const { id: t, reason: s } = e, i$2 = this.getPendingAuthRequest(t);
			if (!i$2) throw new Error(`Could not find pending auth request with id ${t}`);
			i$2.transportType === Q$1.relay && await this.confirmOnlineStateOrThrow();
			const r$1 = i$2.requester.publicKey, o$2 = await this.client.core.crypto.generateKeyPair(), a$1 = ii(r$1), l$2 = {
				type: Oe$2,
				receiverPublicKey: r$1,
				senderPublicKey: o$2
			};
			await this.sendError({
				id: t,
				topic: a$1,
				error: s,
				encodeOpts: l$2,
				rpcOpts: N$1.wc_sessionAuthenticate.reject,
				appLink: this.getAppLinkIfEnabled(i$2.requester.metadata, i$2.transportType)
			}), await this.client.auth.requests.delete(t, {
				message: "rejected",
				code: 0
			}), await this.client.proposal.delete(t, de("USER_DISCONNECTED"));
		}), c(this, "formatAuthMessage", (e) => {
			this.isInitialized();
			const { request: t, iss: s } = e;
			return On(t, s);
		}), c(this, "processRelayMessageCache", () => {
			setTimeout(async () => {
				if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0;) try {
					const e = this.relayMessageCache.shift();
					e && await this.onRelayMessage(e);
				} catch (e) {
					this.client.logger.error(e);
				}
			}, 50);
		}), c(this, "cleanupDuplicatePairings", async (e) => {
			if (e.pairingTopic) try {
				const t = this.client.core.pairing.pairings.get(e.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((i$2) => {
					var r$1, o$2;
					return ((r$1 = i$2.peerMetadata) == null ? void 0 : r$1.url) && ((o$2 = i$2.peerMetadata) == null ? void 0 : o$2.url) === e.peer.metadata.url && i$2.topic && i$2.topic !== t.topic;
				});
				if (s.length === 0) return;
				this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((i$2) => this.client.core.pairing.disconnect({ topic: i$2.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
			} catch (t) {
				this.client.logger.error(t);
			}
		}), c(this, "deleteSession", async (e) => {
			var t;
			const { topic: s, expirerHasDeleted: i$2 = !1, emitEvent: r$1 = !0, id: o$2 = 0 } = e, { self: a$1 } = this.client.session.get(s);
			await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, de("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(a$1.publicKey) && await this.client.core.crypto.deleteKeyPair(a$1.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), i$2 || this.client.core.expirer.del(s), this.client.core.storage.removeItem(Me$2).catch((l$2) => this.client.logger.warn(l$2)), this.getPendingSessionRequests().forEach((l$2) => {
				l$2.topic === s && this.deletePendingSessionRequest(l$2.id, de("USER_DISCONNECTED"));
			}), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $$1.idle), r$1 && this.client.events.emit("session_delete", {
				id: o$2,
				topic: s
			});
		}), c(this, "deleteProposal", async (e, t) => {
			if (t) try {
				const s = this.client.proposal.get(e);
				this.client.core.eventClient.getEvent({ topic: s.pairingTopic })?.setError(er.proposal_expired);
			} catch {}
			await Promise.all([this.client.proposal.delete(e, de("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
		}), c(this, "deletePendingSessionRequest", async (e, t, s = !1) => {
			await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i$2) => i$2.id !== e), s && (this.sessionRequestQueue.state = $$1.idle, this.client.events.emit("session_request_expire", { id: e }));
		}), c(this, "deletePendingAuthRequest", async (e, t, s = !1) => {
			await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
		}), c(this, "setExpiry", async (e, t) => {
			this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
		}), c(this, "setProposal", async (e, t) => {
			this.client.core.expirer.set(e, po(N$1.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
		}), c(this, "setAuthRequest", async (e, t) => {
			const { request: s, pairingTopic: i$2, transportType: r$1 = Q$1.relay } = t;
			this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, {
				authPayload: s.authPayload,
				requester: s.requester,
				expiryTimestamp: s.expiryTimestamp,
				id: e,
				pairingTopic: i$2,
				verifyContext: s.verifyContext,
				transportType: r$1
			});
		}), c(this, "setPendingSessionRequest", async (e) => {
			const { id: t, topic: s, params: i$2, verifyContext: r$1 } = e, o$2 = i$2.request.expiryTimestamp || po(N$1.wc_sessionRequest.req.ttl);
			this.client.core.expirer.set(t, o$2), await this.client.pendingRequest.set(t, {
				id: t,
				topic: s,
				params: i$2,
				verifyContext: r$1
			});
		}), c(this, "sendRequest", async (e) => {
			const { topic: t, method: s, params: i$2, expiry: r$1, relayRpcId: o$2, clientRpcId: a$1, throwOnFailedPublish: l$2, appLink: p$5, tvf: h$4 } = e, u$2 = formatJsonRpcRequest(s, i$2, a$1);
			let d$4;
			const w$3 = !!p$5;
			try {
				const _$4 = w$3 ? ti : At$1;
				d$4 = await this.client.core.crypto.encode(t, u$2, { encoding: _$4 });
			} catch (_$4) {
				throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), _$4;
			}
			let m$2;
			if (gt$1.includes(s)) {
				const _$4 = ci(JSON.stringify(u$2)), g$2 = ci(d$4);
				m$2 = await this.client.core.verify.register({
					id: g$2,
					decryptedId: _$4
				});
			}
			const f$7 = N$1[s].req;
			if (f$7.attestation = m$2, r$1 && (f$7.ttl = r$1), o$2 && (f$7.id = o$2), this.client.core.history.set(t, u$2), w$3) {
				const _$4 = xi(p$5, t, d$4);
				await global.Linking.openURL(_$4, this.client.name);
			} else {
				const _$4 = N$1[s].req;
				r$1 && (_$4.ttl = r$1), o$2 && (_$4.id = o$2), _$4.tvf = b$1(v({}, h$4), { correlationId: u$2.id }), l$2 ? (_$4.internal = b$1(v({}, _$4.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(t, d$4, _$4)) : this.client.core.relayer.publish(t, d$4, _$4).catch((g$2) => this.client.logger.error(g$2));
			}
			return u$2.id;
		}), c(this, "sendResult", async (e) => {
			const { id: t, topic: s, result: i$2, throwOnFailedPublish: r$1, encodeOpts: o$2, appLink: a$1 } = e, l$2 = formatJsonRpcResult(t, i$2);
			let p$5;
			const h$4 = a$1 && typeof (global == null ? void 0 : global.Linking) < "u";
			try {
				const w$3 = h$4 ? ti : At$1;
				p$5 = await this.client.core.crypto.encode(s, l$2, b$1(v({}, o$2 || {}), { encoding: w$3 }));
			} catch (w$3) {
				throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), w$3;
			}
			let u$2, d$4;
			try {
				u$2 = await this.client.core.history.get(s, t);
				const w$3 = u$2.request;
				try {
					this.shouldSetTVF(w$3.method, w$3.params) && (d$4 = this.getTVFParams(t, w$3.params, i$2));
				} catch (m$2) {
					this.client.logger.warn("sendResult() -> getTVFParams() failed", m$2);
				}
			} catch (w$3) {
				throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), w$3;
			}
			if (h$4) {
				const w$3 = xi(a$1, s, p$5);
				await global.Linking.openURL(w$3, this.client.name);
			} else {
				const m$2 = N$1[u$2.request.method].res;
				m$2.tvf = b$1(v({}, d$4), { correlationId: t }), r$1 ? (m$2.internal = b$1(v({}, m$2.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(s, p$5, m$2)) : this.client.core.relayer.publish(s, p$5, m$2).catch((f$7) => this.client.logger.error(f$7));
			}
			await this.client.core.history.resolve(l$2);
		}), c(this, "sendError", async (e) => {
			const { id: t, topic: s, error: i$2, encodeOpts: r$1, rpcOpts: o$2, appLink: a$1 } = e, l$2 = formatJsonRpcError(t, i$2);
			let p$5;
			const h$4 = a$1 && typeof (global == null ? void 0 : global.Linking) < "u";
			try {
				const d$4 = h$4 ? ti : At$1;
				p$5 = await this.client.core.crypto.encode(s, l$2, b$1(v({}, r$1 || {}), { encoding: d$4 }));
			} catch (d$4) {
				throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), d$4;
			}
			let u$2;
			try {
				u$2 = await this.client.core.history.get(s, t);
			} catch (d$4) {
				throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), d$4;
			}
			if (h$4) {
				const d$4 = xi(a$1, s, p$5);
				await global.Linking.openURL(d$4, this.client.name);
			} else {
				const d$4 = u$2.request.method, w$3 = o$2 || N$1[d$4].res;
				this.client.core.relayer.publish(s, p$5, w$3);
			}
			await this.client.core.history.resolve(l$2);
		}), c(this, "cleanup", async () => {
			const e = [], t = [];
			this.client.session.getAll().forEach((s) => {
				let i$2 = !1;
				go(s.expiry) && (i$2 = !0), this.client.core.crypto.keychain.has(s.topic) || (i$2 = !0), i$2 && e.push(s.topic);
			}), this.client.proposal.getAll().forEach((s) => {
				go(s.expiryTimestamp) && t.push(s.id);
			}), await Promise.all([...e.map((s) => this.deleteSession({ topic: s })), ...t.map((s) => this.deleteProposal(s))]);
		}), c(this, "onProviderMessageEvent", async (e) => {
			!this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : await this.onRelayMessage(e);
		}), c(this, "onRelayEventRequest", async (e) => {
			this.requestQueue.queue.push(e), await this.processRequestsQueue();
		}), c(this, "processRequestsQueue", async () => {
			if (this.requestQueue.state === $$1.active) {
				this.client.logger.info("Request queue already active, skipping...");
				return;
			}
			for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
				this.requestQueue.state = $$1.active;
				const e = this.requestQueue.queue.shift();
				if (e) try {
					await this.processRequest(e);
				} catch (t) {
					this.client.logger.warn(t);
				}
			}
			this.requestQueue.state = $$1.idle;
		}), c(this, "processRequest", async (e) => {
			const { topic: t, payload: s, attestation: i$2, transportType: r$1, encryptedId: o$2 } = e, a$1 = s.method;
			if (!this.shouldIgnorePairingRequest({
				topic: t,
				requestMethod: a$1
			})) switch (a$1) {
				case "wc_sessionPropose": return await this.onSessionProposeRequest({
					topic: t,
					payload: s,
					attestation: i$2,
					encryptedId: o$2
				});
				case "wc_sessionSettle": return await this.onSessionSettleRequest(t, s);
				case "wc_sessionUpdate": return await this.onSessionUpdateRequest(t, s);
				case "wc_sessionExtend": return await this.onSessionExtendRequest(t, s);
				case "wc_sessionPing": return await this.onSessionPingRequest(t, s);
				case "wc_sessionDelete": return await this.onSessionDeleteRequest(t, s);
				case "wc_sessionRequest": return await this.onSessionRequest({
					topic: t,
					payload: s,
					attestation: i$2,
					encryptedId: o$2,
					transportType: r$1
				});
				case "wc_sessionEvent": return await this.onSessionEventRequest(t, s);
				case "wc_sessionAuthenticate": return await this.onSessionAuthenticateRequest({
					topic: t,
					payload: s,
					attestation: i$2,
					encryptedId: o$2,
					transportType: r$1
				});
				default: return this.client.logger.info(`Unsupported request method ${a$1}`);
			}
		}), c(this, "onRelayEventResponse", async (e) => {
			const { topic: t, payload: s, transportType: i$2 } = e, r$1 = (await this.client.core.history.get(t, s.id)).request.method;
			switch (r$1) {
				case "wc_sessionPropose": return this.onSessionProposeResponse(t, s, i$2);
				case "wc_sessionSettle": return this.onSessionSettleResponse(t, s);
				case "wc_sessionUpdate": return this.onSessionUpdateResponse(t, s);
				case "wc_sessionExtend": return this.onSessionExtendResponse(t, s);
				case "wc_sessionPing": return this.onSessionPingResponse(t, s);
				case "wc_sessionRequest": return this.onSessionRequestResponse(t, s);
				case "wc_sessionAuthenticate": return this.onSessionAuthenticateResponse(t, s);
				default: return this.client.logger.info(`Unsupported response method ${r$1}`);
			}
		}), c(this, "onRelayEventUnknownPayload", (e) => {
			const { topic: t } = e, { message: s } = te$1("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
			throw new Error(s);
		}), c(this, "shouldIgnorePairingRequest", (e) => {
			const { topic: t, requestMethod: s } = e, i$2 = this.expectedPairingMethodMap.get(t);
			return !i$2 || i$2.includes(s) ? !1 : !!(i$2.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
		}), c(this, "onSessionProposeRequest", async (e) => {
			const { topic: t, payload: s, attestation: i$2, encryptedId: r$1 } = e, { params: o$2, id: a$1 } = s;
			try {
				const l$2 = this.client.core.eventClient.getEvent({ topic: t });
				this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l$2?.setError(Y.proposal_listener_not_found)), this.isValidConnect(v({}, s.params));
				const h$4 = v({
					id: a$1,
					pairingTopic: t,
					expiryTimestamp: o$2.expiryTimestamp || po(N$1.wc_sessionPropose.req.ttl)
				}, o$2);
				await this.setProposal(a$1, h$4);
				const u$2 = await this.getVerifyContext({
					attestationId: i$2,
					hash: ci(JSON.stringify(s)),
					encryptedId: r$1,
					metadata: h$4.proposer.metadata
				});
				l$2?.addTrace(G$1.emit_session_proposal), this.client.events.emit("session_proposal", {
					id: a$1,
					params: h$4,
					verifyContext: u$2
				});
			} catch (l$2) {
				await this.sendError({
					id: a$1,
					topic: t,
					error: l$2,
					rpcOpts: N$1.wc_sessionPropose.autoReject
				}), this.client.logger.error(l$2);
			}
		}), c(this, "onSessionProposeResponse", async (e, t, s) => {
			const { id: i$2 } = t;
			if (isJsonRpcResult(t)) {
				const { result: r$1 } = t;
				this.client.logger.trace({
					type: "method",
					method: "onSessionProposeResponse",
					result: r$1
				});
				const o$2 = this.client.proposal.get(i$2);
				this.client.logger.trace({
					type: "method",
					method: "onSessionProposeResponse",
					proposal: o$2
				});
				const a$1 = o$2.proposer.publicKey;
				this.client.logger.trace({
					type: "method",
					method: "onSessionProposeResponse",
					selfPublicKey: a$1
				});
				const l$2 = r$1.responderPublicKey;
				this.client.logger.trace({
					type: "method",
					method: "onSessionProposeResponse",
					peerPublicKey: l$2
				});
				const p$5 = await this.client.core.crypto.generateSharedKey(a$1, l$2);
				this.pendingSessions.set(i$2, {
					sessionTopic: p$5,
					pairingTopic: e,
					proposalId: i$2,
					publicKey: a$1
				});
				const h$4 = await this.client.core.relayer.subscribe(p$5, { transportType: s });
				this.client.logger.trace({
					type: "method",
					method: "onSessionProposeResponse",
					subscriptionId: h$4
				}), await this.client.core.pairing.activate({ topic: e });
			} else if (isJsonRpcError(t)) {
				await this.client.proposal.delete(i$2, de("USER_DISCONNECTED"));
				const r$1 = yo("session_connect", i$2);
				if (this.events.listenerCount(r$1) === 0) throw new Error(`emitting ${r$1} without any listeners, 954`);
				this.events.emit(r$1, { error: t.error });
			}
		}), c(this, "onSessionSettleRequest", async (e, t) => {
			const { id: s, params: i$2 } = t;
			try {
				this.isValidSessionSettleRequest(i$2);
				const { relay: r$1, controller: o$2, expiry: a$1, namespaces: l$2, sessionProperties: p$5, scopedProperties: h$4, sessionConfig: u$2 } = t.params, d$4 = [...this.pendingSessions.values()].find((f$7) => f$7.sessionTopic === e);
				if (!d$4) return this.client.logger.error(`Pending session not found for topic ${e}`);
				const w$3 = this.client.proposal.get(d$4.proposalId), m$2 = b$1(v(v(v({
					topic: e,
					relay: r$1,
					expiry: a$1,
					namespaces: l$2,
					acknowledged: !0,
					pairingTopic: d$4.pairingTopic,
					requiredNamespaces: w$3.requiredNamespaces,
					optionalNamespaces: w$3.optionalNamespaces,
					controller: o$2.publicKey,
					self: {
						publicKey: d$4.publicKey,
						metadata: this.client.metadata
					},
					peer: {
						publicKey: o$2.publicKey,
						metadata: o$2.metadata
					}
				}, p$5 && { sessionProperties: p$5 }), h$4 && { scopedProperties: h$4 }), u$2 && { sessionConfig: u$2 }), { transportType: Q$1.relay });
				await this.client.session.set(m$2.topic, m$2), await this.setExpiry(m$2.topic, m$2.expiry), await this.client.core.pairing.updateMetadata({
					topic: d$4.pairingTopic,
					metadata: m$2.peer.metadata
				}), this.client.events.emit("session_connect", { session: m$2 }), this.events.emit(yo("session_connect", d$4.proposalId), { session: m$2 }), this.pendingSessions.delete(d$4.proposalId), this.deleteProposal(d$4.proposalId, !1), this.cleanupDuplicatePairings(m$2), await this.sendResult({
					id: t.id,
					topic: e,
					result: !0,
					throwOnFailedPublish: !0
				});
			} catch (r$1) {
				await this.sendError({
					id: s,
					topic: e,
					error: r$1
				}), this.client.logger.error(r$1);
			}
		}), c(this, "onSessionSettleResponse", async (e, t) => {
			const { id: s } = t;
			isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: !0 }), this.events.emit(yo("session_approve", s), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, de("USER_DISCONNECTED")), this.events.emit(yo("session_approve", s), { error: t.error }));
		}), c(this, "onSessionUpdateRequest", async (e, t) => {
			const { params: s, id: i$2 } = t;
			try {
				const r$1 = `${e}_session_update`, o$2 = ec.get(r$1);
				if (o$2 && this.isRequestOutOfSync(o$2, i$2)) {
					this.client.logger.warn(`Discarding out of sync request - ${i$2}`), this.sendError({
						id: i$2,
						topic: e,
						error: de("INVALID_UPDATE_REQUEST")
					});
					return;
				}
				this.isValidUpdate(v({ topic: e }, s));
				try {
					ec.set(r$1, i$2), await this.client.session.update(e, { namespaces: s.namespaces }), await this.sendResult({
						id: i$2,
						topic: e,
						result: !0,
						throwOnFailedPublish: !0
					});
				} catch (a$1) {
					throw ec.delete(r$1), a$1;
				}
				this.client.events.emit("session_update", {
					id: i$2,
					topic: e,
					params: s
				});
			} catch (r$1) {
				await this.sendError({
					id: i$2,
					topic: e,
					error: r$1
				}), this.client.logger.error(r$1);
			}
		}), c(this, "isRequestOutOfSync", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c(this, "onSessionUpdateResponse", (e, t) => {
			const { id: s } = t, i$2 = yo("session_update", s);
			if (this.events.listenerCount(i$2) === 0) throw new Error(`emitting ${i$2} without any listeners`);
			isJsonRpcResult(t) ? this.events.emit(yo("session_update", s), {}) : isJsonRpcError(t) && this.events.emit(yo("session_update", s), { error: t.error });
		}), c(this, "onSessionExtendRequest", async (e, t) => {
			const { id: s } = t;
			try {
				this.isValidExtend({ topic: e }), await this.setExpiry(e, po(J$2)), await this.sendResult({
					id: s,
					topic: e,
					result: !0,
					throwOnFailedPublish: !0
				}), this.client.events.emit("session_extend", {
					id: s,
					topic: e
				});
			} catch (i$2) {
				await this.sendError({
					id: s,
					topic: e,
					error: i$2
				}), this.client.logger.error(i$2);
			}
		}), c(this, "onSessionExtendResponse", (e, t) => {
			const { id: s } = t, i$2 = yo("session_extend", s);
			if (this.events.listenerCount(i$2) === 0) throw new Error(`emitting ${i$2} without any listeners`);
			isJsonRpcResult(t) ? this.events.emit(yo("session_extend", s), {}) : isJsonRpcError(t) && this.events.emit(yo("session_extend", s), { error: t.error });
		}), c(this, "onSessionPingRequest", async (e, t) => {
			const { id: s } = t;
			try {
				this.isValidPing({ topic: e }), await this.sendResult({
					id: s,
					topic: e,
					result: !0,
					throwOnFailedPublish: !0
				}), this.client.events.emit("session_ping", {
					id: s,
					topic: e
				});
			} catch (i$2) {
				await this.sendError({
					id: s,
					topic: e,
					error: i$2
				}), this.client.logger.error(i$2);
			}
		}), c(this, "onSessionPingResponse", (e, t) => {
			const { id: s } = t, i$2 = yo("session_ping", s);
			setTimeout(() => {
				if (this.events.listenerCount(i$2) === 0) throw new Error(`emitting ${i$2} without any listeners 2176`);
				isJsonRpcResult(t) ? this.events.emit(yo("session_ping", s), {}) : isJsonRpcError(t) && this.events.emit(yo("session_ping", s), { error: t.error });
			}, 500);
		}), c(this, "onSessionDeleteRequest", async (e, t) => {
			const { id: s } = t;
			try {
				this.isValidDisconnect({
					topic: e,
					reason: t.params
				}), Promise.all([
					new Promise((i$2) => {
						this.client.core.relayer.once(C$1.publish, async () => {
							i$2(await this.deleteSession({
								topic: e,
								id: s
							}));
						});
					}),
					this.sendResult({
						id: s,
						topic: e,
						result: !0,
						throwOnFailedPublish: !0
					}),
					this.cleanupPendingSentRequestsForTopic({
						topic: e,
						error: de("USER_DISCONNECTED")
					})
				]).catch((i$2) => this.client.logger.error(i$2));
			} catch (i$2) {
				this.client.logger.error(i$2);
			}
		}), c(this, "onSessionRequest", async (e) => {
			var t, s, i$2;
			const { topic: r$1, payload: o$2, attestation: a$1, encryptedId: l$2, transportType: p$5 } = e, { id: h$4, params: u$2 } = o$2;
			try {
				await this.isValidRequest(v({ topic: r$1 }, u$2));
				const d$4 = this.client.session.get(r$1), m$2 = {
					id: h$4,
					topic: r$1,
					params: u$2,
					verifyContext: await this.getVerifyContext({
						attestationId: a$1,
						hash: ci(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u$2, h$4))),
						encryptedId: l$2,
						metadata: d$4.peer.metadata,
						transportType: p$5
					})
				};
				await this.setPendingSessionRequest(m$2), p$5 === Q$1.link_mode && (t = d$4.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = d$4.peer.metadata.redirect) == null ? void 0 : s.universal), (i$2 = this.client.signConfig) != null && i$2.disableRequestQueue ? this.emitSessionRequest(m$2) : (this.addSessionRequestToSessionRequestQueue(m$2), this.processSessionRequestQueue());
			} catch (d$4) {
				await this.sendError({
					id: h$4,
					topic: r$1,
					error: d$4
				}), this.client.logger.error(d$4);
			}
		}), c(this, "onSessionRequestResponse", (e, t) => {
			const { id: s } = t, i$2 = yo("session_request", s);
			if (this.events.listenerCount(i$2) === 0) throw new Error(`emitting ${i$2} without any listeners`);
			isJsonRpcResult(t) ? this.events.emit(yo("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(yo("session_request", s), { error: t.error });
		}), c(this, "onSessionEventRequest", async (e, t) => {
			const { id: s, params: i$2 } = t;
			try {
				const r$1 = `${e}_session_event_${i$2.event.name}`, o$2 = ec.get(r$1);
				if (o$2 && this.isRequestOutOfSync(o$2, s)) {
					this.client.logger.info(`Discarding out of sync request - ${s}`);
					return;
				}
				this.isValidEmit(v({ topic: e }, i$2)), this.client.events.emit("session_event", {
					id: s,
					topic: e,
					params: i$2
				}), ec.set(r$1, s);
			} catch (r$1) {
				await this.sendError({
					id: s,
					topic: e,
					error: r$1
				}), this.client.logger.error(r$1);
			}
		}), c(this, "onSessionAuthenticateResponse", (e, t) => {
			const { id: s } = t;
			this.client.logger.trace({
				type: "method",
				method: "onSessionAuthenticateResponse",
				topic: e,
				payload: t
			}), isJsonRpcResult(t) ? this.events.emit(yo("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(yo("session_request", s), { error: t.error });
		}), c(this, "onSessionAuthenticateRequest", async (e) => {
			var t;
			const { topic: s, payload: i$2, attestation: r$1, encryptedId: o$2, transportType: a$1 } = e;
			try {
				const { requester: l$2, authPayload: p$5, expiryTimestamp: h$4 } = i$2.params, u$2 = await this.getVerifyContext({
					attestationId: r$1,
					hash: ci(JSON.stringify(i$2)),
					encryptedId: o$2,
					metadata: l$2.metadata,
					transportType: a$1
				}), d$4 = {
					requester: l$2,
					pairingTopic: s,
					id: i$2.id,
					authPayload: p$5,
					verifyContext: u$2,
					expiryTimestamp: h$4
				};
				await this.setAuthRequest(i$2.id, {
					request: d$4,
					pairingTopic: s,
					transportType: a$1
				}), a$1 === Q$1.link_mode && (t = l$2.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l$2.metadata.redirect.universal), this.client.events.emit("session_authenticate", {
					topic: s,
					params: i$2.params,
					id: i$2.id,
					verifyContext: u$2
				});
			} catch (l$2) {
				this.client.logger.error(l$2);
				const p$5 = i$2.params.requester.publicKey, h$4 = await this.client.core.crypto.generateKeyPair(), u$2 = this.getAppLinkIfEnabled(i$2.params.requester.metadata, a$1), d$4 = {
					type: Oe$2,
					receiverPublicKey: p$5,
					senderPublicKey: h$4
				};
				await this.sendError({
					id: i$2.id,
					topic: s,
					error: l$2,
					encodeOpts: d$4,
					rpcOpts: N$1.wc_sessionAuthenticate.autoReject,
					appLink: u$2
				});
			}
		}), c(this, "addSessionRequestToSessionRequestQueue", (e) => {
			this.sessionRequestQueue.queue.push(e);
		}), c(this, "cleanupAfterResponse", (e) => {
			this.deletePendingSessionRequest(e.response.id, {
				message: "fulfilled",
				code: 0
			}), setTimeout(() => {
				this.sessionRequestQueue.state = $$1.idle, this.processSessionRequestQueue();
			}, (0, import_cjs.toMiliseconds)(this.requestQueueDelay));
		}), c(this, "cleanupPendingSentRequestsForTopic", ({ topic: e, error: t }) => {
			const s = this.client.core.history.pending;
			s.length > 0 && s.filter((i$2) => i$2.topic === e && i$2.request.method === "wc_sessionRequest").forEach((i$2) => {
				const r$1 = i$2.request.id, o$2 = yo("session_request", r$1);
				if (this.events.listenerCount(o$2) === 0) throw new Error(`emitting ${o$2} without any listeners`);
				this.events.emit(yo("session_request", i$2.request.id), { error: t });
			});
		}), c(this, "processSessionRequestQueue", () => {
			if (this.sessionRequestQueue.state === $$1.active) {
				this.client.logger.info("session request queue is already active.");
				return;
			}
			const e = this.sessionRequestQueue.queue[0];
			if (!e) {
				this.client.logger.info("session request queue is empty.");
				return;
			}
			try {
				this.sessionRequestQueue.state = $$1.active, this.emitSessionRequest(e);
			} catch (t) {
				this.client.logger.error(t);
			}
		}), c(this, "emitSessionRequest", (e) => {
			this.client.events.emit("session_request", e);
		}), c(this, "onPairingCreated", (e) => {
			if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
			const t = this.client.proposal.getAll().find((s) => s.pairingTopic === e.topic);
			t && this.onSessionProposeRequest({
				topic: e.topic,
				payload: formatJsonRpcRequest("wc_sessionPropose", b$1(v({}, t), {
					requiredNamespaces: t.requiredNamespaces,
					optionalNamespaces: t.optionalNamespaces,
					relays: t.relays,
					proposer: t.proposer,
					sessionProperties: t.sessionProperties,
					scopedProperties: t.scopedProperties
				}), t.id)
			});
		}), c(this, "isValidConnect", async (e) => {
			if (!Vi(e)) {
				const { message: l$2 } = te$1("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
				throw new Error(l$2);
			}
			const { pairingTopic: t, requiredNamespaces: s, optionalNamespaces: i$2, sessionProperties: r$1, scopedProperties: o$2, relays: a$1 } = e;
			if (ae$1(t) || await this.isValidPairingTopic(t), !Di(a$1, !0)) {
				const { message: l$2 } = te$1("MISSING_OR_INVALID", `connect() relays: ${a$1}`);
				throw new Error(l$2);
			}
			if (!ae$1(s) && qe(s) !== 0 && this.validateNamespaces(s, "requiredNamespaces"), !ae$1(i$2) && qe(i$2) !== 0 && this.validateNamespaces(i$2, "optionalNamespaces"), ae$1(r$1) || this.validateSessionProps(r$1, "sessionProperties"), !ae$1(o$2)) {
				this.validateSessionProps(o$2, "scopedProperties");
				const l$2 = Object.keys(s || {}).concat(Object.keys(i$2 || {}));
				if (!Object.keys(o$2).every((p$5) => l$2.includes(p$5))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o$2)}, required/optional namespaces: ${JSON.stringify(l$2)}`);
			}
		}), c(this, "validateNamespaces", (e, t) => {
			const s = ki(e, "connect()", t);
			if (s) throw new Error(s.message);
		}), c(this, "isValidApprove", async (e) => {
			if (!Vi(e)) throw new Error(te$1("MISSING_OR_INVALID", `approve() params: ${e}`).message);
			const { id: t, namespaces: s, relayProtocol: i$2, sessionProperties: r$1, scopedProperties: o$2 } = e;
			this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
			const a$1 = this.client.proposal.get(t), l$2 = Or(s, "approve()");
			if (l$2) throw new Error(l$2.message);
			const p$5 = Nr(a$1.requiredNamespaces, s, "approve()");
			if (p$5) throw new Error(p$5.message);
			if (!q(i$2, !0)) {
				const { message: h$4 } = te$1("MISSING_OR_INVALID", `approve() relayProtocol: ${i$2}`);
				throw new Error(h$4);
			}
			if (ae$1(r$1) || this.validateSessionProps(r$1, "sessionProperties"), !ae$1(o$2)) {
				this.validateSessionProps(o$2, "scopedProperties");
				const h$4 = new Set(Object.keys(s));
				if (!Object.keys(o$2).every((u$2) => h$4.has(u$2))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o$2)}, approved namespaces: ${Array.from(h$4).join(", ")}`);
			}
		}), c(this, "isValidReject", async (e) => {
			if (!Vi(e)) {
				const { message: i$2 } = te$1("MISSING_OR_INVALID", `reject() params: ${e}`);
				throw new Error(i$2);
			}
			const { id: t, reason: s } = e;
			if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !Hi(s)) {
				const { message: i$2 } = te$1("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
				throw new Error(i$2);
			}
		}), c(this, "isValidSessionSettleRequest", (e) => {
			if (!Vi(e)) {
				const { message: l$2 } = te$1("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
				throw new Error(l$2);
			}
			const { relay: t, controller: s, namespaces: i$2, expiry: r$1 } = e;
			if (!Ar(t)) {
				const { message: l$2 } = te$1("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
				throw new Error(l$2);
			}
			const o$2 = Ci(s, "onSessionSettleRequest()");
			if (o$2) throw new Error(o$2.message);
			const a$1 = Or(i$2, "onSessionSettleRequest()");
			if (a$1) throw new Error(a$1.message);
			if (go(r$1)) {
				const { message: l$2 } = te$1("EXPIRED", "onSessionSettleRequest()");
				throw new Error(l$2);
			}
		}), c(this, "isValidUpdate", async (e) => {
			if (!Vi(e)) {
				const { message: a$1 } = te$1("MISSING_OR_INVALID", `update() params: ${e}`);
				throw new Error(a$1);
			}
			const { topic: t, namespaces: s } = e;
			this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
			const i$2 = this.client.session.get(t), r$1 = Or(s, "update()");
			if (r$1) throw new Error(r$1.message);
			const o$2 = Nr(i$2.requiredNamespaces, s, "update()");
			if (o$2) throw new Error(o$2.message);
		}), c(this, "isValidExtend", async (e) => {
			if (!Vi(e)) {
				const { message: s } = te$1("MISSING_OR_INVALID", `extend() params: ${e}`);
				throw new Error(s);
			}
			const { topic: t } = e;
			this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
		}), c(this, "isValidRequest", async (e) => {
			if (!Vi(e)) {
				const { message: a$1 } = te$1("MISSING_OR_INVALID", `request() params: ${e}`);
				throw new Error(a$1);
			}
			const { topic: t, request: s, chainId: i$2, expiry: r$1 } = e;
			this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
			const { namespaces: o$2 } = this.client.session.get(t);
			if (!Gi(o$2, i$2)) {
				const { message: a$1 } = te$1("MISSING_OR_INVALID", `request() chainId: ${i$2}`);
				throw new Error(a$1);
			}
			if (!Ki(s)) {
				const { message: a$1 } = te$1("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
				throw new Error(a$1);
			}
			if (!Wi(o$2, i$2, s.method)) {
				const { message: a$1 } = te$1("MISSING_OR_INVALID", `request() method: ${s.method}`);
				throw new Error(a$1);
			}
			if (r$1 && !Xi(r$1, _e$2)) {
				const { message: a$1 } = te$1("MISSING_OR_INVALID", `request() expiry: ${r$1}. Expiry must be a number (in seconds) between ${_e$2.min} and ${_e$2.max}`);
				throw new Error(a$1);
			}
		}), c(this, "isValidRespond", async (e) => {
			var t;
			if (!Vi(e)) {
				const { message: r$1 } = te$1("MISSING_OR_INVALID", `respond() params: ${e}`);
				throw new Error(r$1);
			}
			const { topic: s, response: i$2 } = e;
			try {
				await this.isValidSessionTopic(s);
			} catch (r$1) {
				throw (t = e?.response) != null && t.id && this.cleanupAfterResponse(e), r$1;
			}
			if (!Fi(i$2)) {
				const { message: r$1 } = te$1("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i$2)}`);
				throw new Error(r$1);
			}
		}), c(this, "isValidPing", async (e) => {
			if (!Vi(e)) {
				const { message: s } = te$1("MISSING_OR_INVALID", `ping() params: ${e}`);
				throw new Error(s);
			}
			const { topic: t } = e;
			await this.isValidSessionOrPairingTopic(t);
		}), c(this, "isValidEmit", async (e) => {
			if (!Vi(e)) {
				const { message: o$2 } = te$1("MISSING_OR_INVALID", `emit() params: ${e}`);
				throw new Error(o$2);
			}
			const { topic: t, event: s, chainId: i$2 } = e;
			await this.isValidSessionTopic(t);
			const { namespaces: r$1 } = this.client.session.get(t);
			if (!Gi(r$1, i$2)) {
				const { message: o$2 } = te$1("MISSING_OR_INVALID", `emit() chainId: ${i$2}`);
				throw new Error(o$2);
			}
			if (!qi(s)) {
				const { message: o$2 } = te$1("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
				throw new Error(o$2);
			}
			if (!zi$1(r$1, i$2, s.name)) {
				const { message: o$2 } = te$1("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
				throw new Error(o$2);
			}
		}), c(this, "isValidDisconnect", async (e) => {
			if (!Vi(e)) {
				const { message: s } = te$1("MISSING_OR_INVALID", `disconnect() params: ${e}`);
				throw new Error(s);
			}
			const { topic: t } = e;
			await this.isValidSessionOrPairingTopic(t);
		}), c(this, "isValidAuthenticate", (e) => {
			const { chains: t, uri: s, domain: i$2, nonce: r$1 } = e;
			if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
			if (!q(s, !1)) throw new Error("uri is required parameter");
			if (!q(i$2, !1)) throw new Error("domain is required parameter");
			if (!q(r$1, !1)) throw new Error("nonce is required parameter");
			if ([...new Set(t.map((a$1) => Ye(a$1).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
			const { namespace: o$2 } = Ye(t[0]);
			if (o$2 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
		}), c(this, "getVerifyContext", async (e) => {
			const { attestationId: t, hash: s, encryptedId: i$2, metadata: r$1, transportType: o$2 } = e, a$1 = { verified: {
				verifyUrl: r$1.verifyUrl || ue$1,
				validation: "UNKNOWN",
				origin: r$1.url || ""
			} };
			try {
				if (o$2 === Q$1.link_mode) {
					const p$5 = this.getAppLinkIfEnabled(r$1, o$2);
					return a$1.verified.validation = p$5 && new URL(p$5).origin === new URL(r$1.url).origin ? "VALID" : "INVALID", a$1;
				}
				const l$2 = await this.client.core.verify.resolve({
					attestationId: t,
					hash: s,
					encryptedId: i$2,
					verifyUrl: r$1.verifyUrl
				});
				l$2 && (a$1.verified.origin = l$2.origin, a$1.verified.isScam = l$2.isScam, a$1.verified.validation = l$2.origin === new URL(r$1.url).origin ? "VALID" : "INVALID");
			} catch (l$2) {
				this.client.logger.warn(l$2);
			}
			return this.client.logger.debug(`Verify context: ${JSON.stringify(a$1)}`), a$1;
		}), c(this, "validateSessionProps", (e, t) => {
			Object.values(e).forEach((s, i$2) => {
				if (s == null) {
					const { message: r$1 } = te$1("MISSING_OR_INVALID", `${t} must contain an existing value for each key. Received: ${s} for key ${Object.keys(e)[i$2]}`);
					throw new Error(r$1);
				}
			});
		}), c(this, "getPendingAuthRequest", (e) => {
			const t = this.client.auth.requests.get(e);
			return typeof t == "object" ? t : void 0;
		}), c(this, "addToRecentlyDeleted", (e, t) => {
			if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
				let s = 0;
				const i$2 = this.recentlyDeletedLimit / 2;
				for (const r$1 of this.recentlyDeletedMap.keys()) {
					if (s++ >= i$2) break;
					this.recentlyDeletedMap.delete(r$1);
				}
			}
		}), c(this, "checkRecentlyDeleted", (e) => {
			const t = this.recentlyDeletedMap.get(e);
			if (t) {
				const { message: s } = te$1("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
				throw new Error(s);
			}
		}), c(this, "isLinkModeEnabled", (e, t) => {
			var s, i$2, r$1, o$2, a$1, l$2, p$5, h$4, u$2;
			return !e || t !== Q$1.link_mode ? !1 : ((i$2 = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i$2.linkMode) === !0 && ((o$2 = (r$1 = this.client.metadata) == null ? void 0 : r$1.redirect) == null ? void 0 : o$2.universal) !== void 0 && ((l$2 = (a$1 = this.client.metadata) == null ? void 0 : a$1.redirect) == null ? void 0 : l$2.universal) !== "" && ((p$5 = e?.redirect) == null ? void 0 : p$5.universal) !== void 0 && ((h$4 = e?.redirect) == null ? void 0 : h$4.universal) !== "" && ((u$2 = e?.redirect) == null ? void 0 : u$2.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
		}), c(this, "getAppLinkIfEnabled", (e, t) => {
			var s;
			return this.isLinkModeEnabled(e, t) ? (s = e?.redirect) == null ? void 0 : s.universal : void 0;
		}), c(this, "handleLinkModeMessage", ({ url: e }) => {
			if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
			const t = wo(e, "topic") || "", s = decodeURIComponent(wo(e, "wc_ev") || ""), i$2 = this.client.session.keys.includes(t);
			i$2 && this.client.session.update(t, { transportType: Q$1.link_mode }), this.client.core.dispatchEnvelope({
				topic: t,
				message: s,
				sessionExists: i$2
			});
		}), c(this, "registerLinkModeListeners", async () => {
			var e;
			if (vo() || ne$1() && (e = this.client.metadata.redirect) != null && e.linkMode) {
				const t = global == null ? void 0 : global.Linking;
				if (typeof t < "u") {
					t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
					const s = await t.getInitialURL();
					s && setTimeout(() => {
						this.handleLinkModeMessage({ url: s });
					}, 50);
				}
			}
		}), c(this, "shouldSetTVF", (e, t) => {
			if (!t || e !== "wc_sessionRequest") return !1;
			const { request: s } = t;
			return Object.keys(Ue$1).includes(s.method);
		}), c(this, "getTVFParams", (e, t, s) => {
			var i$2, r$1;
			try {
				const o$2 = t.request.method, a$1 = this.extractTxHashesFromResult(o$2, s);
				return b$1(v({
					correlationId: e,
					rpcMethods: [o$2],
					chainId: t.chainId
				}, this.isValidContractData(t.request.params) && { contractAddresses: [(r$1 = (i$2 = t.request.params) == null ? void 0 : i$2[0]) == null ? void 0 : r$1.to] }), { txHashes: a$1 });
			} catch (o$2) {
				this.client.logger.warn("Error getting TVF params", o$2);
			}
			return {};
		}), c(this, "isValidContractData", (e) => {
			var t;
			if (!e) return !1;
			try {
				const s = e?.data || ((t = e?.[0]) == null ? void 0 : t.data);
				if (!s.startsWith("0x")) return !1;
				const i$2 = s.slice(2);
				return /^[0-9a-fA-F]*$/.test(i$2) ? i$2.length % 2 === 0 : !1;
			} catch {}
			return !1;
		}), c(this, "extractTxHashesFromResult", (e, t) => {
			try {
				const s = Ue$1[e];
				if (typeof t == "string") return [t];
				const i$2 = t[s.key];
				if ($e(i$2)) return e === "solana_signAllTransactions" ? i$2.map((r$1) => qo(r$1)) : i$2;
				if (typeof i$2 == "string") return [i$2];
			} catch (s) {
				this.client.logger.warn("Error extracting tx hashes from result", s);
			}
			return [];
		});
	}
	async processPendingMessageEvents() {
		try {
			const n$2 = this.client.session.keys, e = this.client.core.relayer.messages.getWithoutAck(n$2);
			for (const [t, s] of Object.entries(e)) for (const i$2 of s) try {
				await this.onProviderMessageEvent({
					topic: t,
					message: i$2,
					publishedAt: Date.now()
				});
			} catch {
				this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${i$2}`);
			}
		} catch (n$2) {
			this.client.logger.warn("processPendingMessageEvents failed", n$2);
		}
	}
	isInitialized() {
		if (!this.initialized) {
			const { message: n$2 } = te$1("NOT_INITIALIZED", this.name);
			throw new Error(n$2);
		}
	}
	async confirmOnlineStateOrThrow() {
		await this.client.core.relayer.confirmOnlineStateOrThrow();
	}
	registerRelayerEvents() {
		this.client.core.relayer.on(C$1.message, (n$2) => {
			this.onProviderMessageEvent(n$2);
		});
	}
	async onRelayMessage(n$2) {
		const { topic: e, message: t, attestation: s, transportType: i$2 } = n$2, { publicKey: r$1 } = this.client.auth.authKeys.keys.includes(ce$1) ? this.client.auth.authKeys.get(ce$1) : {
			responseTopic: void 0,
			publicKey: void 0
		};
		try {
			const o$2 = await this.client.core.crypto.decode(e, t, {
				receiverPublicKey: r$1,
				encoding: i$2 === Q$1.link_mode ? ti : At$1
			});
			isJsonRpcRequest(o$2) ? (this.client.core.history.set(e, o$2), await this.onRelayEventRequest({
				topic: e,
				payload: o$2,
				attestation: s,
				transportType: i$2,
				encryptedId: ci(t)
			})) : isJsonRpcResponse(o$2) ? (await this.client.core.history.resolve(o$2), await this.onRelayEventResponse({
				topic: e,
				payload: o$2,
				transportType: i$2
			}), this.client.core.history.delete(e, o$2.id)) : await this.onRelayEventUnknownPayload({
				topic: e,
				payload: o$2,
				transportType: i$2
			}), await this.client.core.relayer.messages.ack(e, t);
		} catch (o$2) {
			this.client.logger.error(o$2);
		}
	}
	registerExpirerEvents() {
		this.client.core.expirer.on(F$1.expired, async (n$2) => {
			const { topic: e, id: t } = ho(n$2.target);
			if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, te$1("EXPIRED"), !0);
			if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, te$1("EXPIRED"), !0);
			e ? this.client.session.keys.includes(e) && (await this.deleteSession({
				topic: e,
				expirerHasDeleted: !0
			}), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, !0), this.client.events.emit("proposal_expire", { id: t }));
		});
	}
	registerPairingEvents() {
		this.client.core.pairing.events.on(se$1.create, (n$2) => this.onPairingCreated(n$2)), this.client.core.pairing.events.on(se$1.delete, (n$2) => {
			this.addToRecentlyDeleted(n$2.topic, "pairing");
		});
	}
	isValidPairingTopic(n$2) {
		if (!q(n$2, !1)) {
			const { message: e } = te$1("MISSING_OR_INVALID", `pairing topic should be a string: ${n$2}`);
			throw new Error(e);
		}
		if (!this.client.core.pairing.pairings.keys.includes(n$2)) {
			const { message: e } = te$1("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n$2}`);
			throw new Error(e);
		}
		if (go(this.client.core.pairing.pairings.get(n$2).expiry)) {
			const { message: e } = te$1("EXPIRED", `pairing topic: ${n$2}`);
			throw new Error(e);
		}
	}
	async isValidSessionTopic(n$2) {
		if (!q(n$2, !1)) {
			const { message: e } = te$1("MISSING_OR_INVALID", `session topic should be a string: ${n$2}`);
			throw new Error(e);
		}
		if (this.checkRecentlyDeleted(n$2), !this.client.session.keys.includes(n$2)) {
			const { message: e } = te$1("NO_MATCHING_KEY", `session topic doesn't exist: ${n$2}`);
			throw new Error(e);
		}
		if (go(this.client.session.get(n$2).expiry)) {
			await this.deleteSession({ topic: n$2 });
			const { message: e } = te$1("EXPIRED", `session topic: ${n$2}`);
			throw new Error(e);
		}
		if (!this.client.core.crypto.keychain.has(n$2)) {
			const { message: e } = te$1("MISSING_OR_INVALID", `session topic does not exist in keychain: ${n$2}`);
			throw await this.deleteSession({ topic: n$2 }), new Error(e);
		}
	}
	async isValidSessionOrPairingTopic(n$2) {
		if (this.checkRecentlyDeleted(n$2), this.client.session.keys.includes(n$2)) await this.isValidSessionTopic(n$2);
		else if (this.client.core.pairing.pairings.keys.includes(n$2)) this.isValidPairingTopic(n$2);
		else if (q(n$2, !1)) {
			const { message: e } = te$1("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n$2}`);
			throw new Error(e);
		} else {
			const { message: e } = te$1("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n$2}`);
			throw new Error(e);
		}
	}
	async isValidProposalId(n$2) {
		if (!Mi(n$2)) {
			const { message: e } = te$1("MISSING_OR_INVALID", `proposal id should be a number: ${n$2}`);
			throw new Error(e);
		}
		if (!this.client.proposal.keys.includes(n$2)) {
			const { message: e } = te$1("NO_MATCHING_KEY", `proposal id doesn't exist: ${n$2}`);
			throw new Error(e);
		}
		if (go(this.client.proposal.get(n$2).expiryTimestamp)) {
			await this.deleteProposal(n$2);
			const { message: e } = te$1("EXPIRED", `proposal id: ${n$2}`);
			throw new Error(e);
		}
	}
};
var Ns = class extends zi {
	constructor(n$2, e) {
		super(n$2, e, pt$1, we$1), this.core = n$2, this.logger = e;
	}
};
var St = class extends zi {
	constructor(n$2, e) {
		super(n$2, e, ht$1, we$1), this.core = n$2, this.logger = e;
	}
};
var Os = class extends zi {
	constructor(n$2, e) {
		super(n$2, e, ut$2, we$1, (t) => t.id), this.core = n$2, this.logger = e;
	}
};
var bs = class extends zi {
	constructor(n$2, e) {
		super(n$2, e, mt$1, ae$2, () => ce$1), this.core = n$2, this.logger = e;
	}
};
var As = class extends zi {
	constructor(n$2, e) {
		super(n$2, e, _t$1, ae$2), this.core = n$2, this.logger = e;
	}
};
var xs = class extends zi {
	constructor(n$2, e) {
		super(n$2, e, Et, ae$2, (t) => t.id), this.core = n$2, this.logger = e;
	}
};
var Cs = Object.defineProperty, Vs = (S$6, n$2, e) => n$2 in S$6 ? Cs(S$6, n$2, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : S$6[n$2] = e, Ge$1 = (S$6, n$2, e) => Vs(S$6, typeof n$2 != "symbol" ? n$2 + "" : n$2, e);
var Ds = class {
	constructor(n$2, e) {
		this.core = n$2, this.logger = e, Ge$1(this, "authKeys"), Ge$1(this, "pairingTopics"), Ge$1(this, "requests"), this.authKeys = new bs(this.core, this.logger), this.pairingTopics = new As(this.core, this.logger), this.requests = new xs(this.core, this.logger);
	}
	async init() {
		await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
	}
};
var Ls = Object.defineProperty, ks = (S$6, n$2, e) => n$2 in S$6 ? Ls(S$6, n$2, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : S$6[n$2] = e, E$2 = (S$6, n$2, e) => ks(S$6, typeof n$2 != "symbol" ? n$2 + "" : n$2, e);
var Ee = class Ee extends J$1 {
	constructor(n$2) {
		super(n$2), E$2(this, "protocol", De$1), E$2(this, "version", Le$1), E$2(this, "name", me$1.name), E$2(this, "metadata"), E$2(this, "core"), E$2(this, "logger"), E$2(this, "events", new import_events$1.EventEmitter()), E$2(this, "engine"), E$2(this, "session"), E$2(this, "proposal"), E$2(this, "pendingRequest"), E$2(this, "auth"), E$2(this, "signConfig"), E$2(this, "on", (t, s) => this.events.on(t, s)), E$2(this, "once", (t, s) => this.events.once(t, s)), E$2(this, "off", (t, s) => this.events.off(t, s)), E$2(this, "removeListener", (t, s) => this.events.removeListener(t, s)), E$2(this, "removeAllListeners", (t) => this.events.removeAllListeners(t)), E$2(this, "connect", async (t) => {
			try {
				return await this.engine.connect(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "pair", async (t) => {
			try {
				return await this.engine.pair(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "approve", async (t) => {
			try {
				return await this.engine.approve(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "reject", async (t) => {
			try {
				return await this.engine.reject(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "update", async (t) => {
			try {
				return await this.engine.update(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "extend", async (t) => {
			try {
				return await this.engine.extend(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "request", async (t) => {
			try {
				return await this.engine.request(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "respond", async (t) => {
			try {
				return await this.engine.respond(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "ping", async (t) => {
			try {
				return await this.engine.ping(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "emit", async (t) => {
			try {
				return await this.engine.emit(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "disconnect", async (t) => {
			try {
				return await this.engine.disconnect(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "find", (t) => {
			try {
				return this.engine.find(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "getPendingSessionRequests", () => {
			try {
				return this.engine.getPendingSessionRequests();
			} catch (t) {
				throw this.logger.error(t.message), t;
			}
		}), E$2(this, "authenticate", async (t, s) => {
			try {
				return await this.engine.authenticate(t, s);
			} catch (i$2) {
				throw this.logger.error(i$2.message), i$2;
			}
		}), E$2(this, "formatAuthMessage", (t) => {
			try {
				return this.engine.formatAuthMessage(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "approveSessionAuthenticate", async (t) => {
			try {
				return await this.engine.approveSessionAuthenticate(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), E$2(this, "rejectSessionAuthenticate", async (t) => {
			try {
				return await this.engine.rejectSessionAuthenticate(t);
			} catch (s) {
				throw this.logger.error(s.message), s;
			}
		}), this.name = n$2?.name || me$1.name, this.metadata = n$2?.metadata || Xr(), this.signConfig = n$2?.signConfig;
		const e = typeof n$2?.logger < "u" && typeof n$2?.logger != "string" ? n$2.logger : (0, import_browser.default)(k({ level: n$2?.logger || me$1.logger }));
		this.core = n$2?.core || new Jo(n$2), this.logger = E$1(e, this.name), this.session = new St(this.core, this.logger), this.proposal = new Ns(this.core, this.logger), this.pendingRequest = new Os(this.core, this.logger), this.engine = new Ps(this), this.auth = new Ds(this.core, this.logger);
	}
	static async init(n$2) {
		const e = new Ee(n$2);
		return await e.initialize(), e;
	}
	get context() {
		return y$1(this.logger);
	}
	get pairing() {
		return this.core.pairing.pairings;
	}
	async initialize() {
		this.logger.trace("Initialized");
		try {
			await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
				this.engine.processRelayMessageCache();
			}, (0, import_cjs.toMiliseconds)(import_cjs.ONE_SECOND));
		} catch (n$2) {
			throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n$2.message), n$2;
		}
	}
};

//#endregion
//#region node_modules/@reown/appkit/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events = /* @__PURE__ */ __toESM(require_events());
var tt = "error", Nt = "wss://relay.walletconnect.org", _ = `wc@2:universal_provider:`, et = "https://rpc.walletconnect.org/v1/", w = "generic", qt = `${et}bundler`, d = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function jt() {}
function B(s) {
	return s == null || typeof s != "object" && typeof s != "function";
}
function G(s) {
	return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function Rt(s) {
	if (B(s)) return s;
	if (Array.isArray(s) || G(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
	const t = Object.getPrototypeOf(s), e = t.constructor;
	if (s instanceof Date || s instanceof Map || s instanceof Set) return new e(s);
	if (s instanceof RegExp) {
		const i$2 = new e(s);
		return i$2.lastIndex = s.lastIndex, i$2;
	}
	if (s instanceof DataView) return new e(s.buffer.slice(0));
	if (s instanceof Error) {
		const i$2 = new e(s.message);
		return i$2.stack = s.stack, i$2.name = s.name, i$2.cause = s.cause, i$2;
	}
	if (typeof File < "u" && s instanceof File) return new e([s], s.name, {
		type: s.type,
		lastModified: s.lastModified
	});
	if (typeof s == "object") {
		const i$2 = Object.create(t);
		return Object.assign(i$2, s);
	}
	return s;
}
function st(s) {
	return typeof s == "object" && s !== null;
}
function it(s) {
	return Object.getOwnPropertySymbols(s).filter((t) => Object.prototype.propertyIsEnumerable.call(s, t));
}
function rt(s) {
	return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s);
}
var _t = "[object RegExp]", nt = "[object String]", at = "[object Number]", ct = "[object Boolean]", ot = "[object Arguments]", Ut = "[object Symbol]", Ft = "[object Date]", Lt = "[object Map]", xt = "[object Set]", Mt = "[object Array]", Bt = "[object ArrayBuffer]", Gt = "[object Object]", Jt = "[object DataView]", zt = "[object Uint8Array]", kt = "[object Uint8ClampedArray]", Wt = "[object Uint16Array]", Kt = "[object Uint32Array]", Vt = "[object Int8Array]", Xt = "[object Int16Array]", Yt = "[object Int32Array]", Qt = "[object Float32Array]", Zt = "[object Float64Array]";
function Tt$1(s, t) {
	return y(s, void 0, s, /* @__PURE__ */ new Map(), t);
}
function y(s, t, e, i$2 = /* @__PURE__ */ new Map(), r$1 = void 0) {
	const a$1 = r$1?.(s, t, e, i$2);
	if (a$1 != null) return a$1;
	if (B(s)) return s;
	if (i$2.has(s)) return i$2.get(s);
	if (Array.isArray(s)) {
		const n$2 = new Array(s.length);
		i$2.set(s, n$2);
		for (let c$3 = 0; c$3 < s.length; c$3++) n$2[c$3] = y(s[c$3], c$3, e, i$2, r$1);
		return Object.hasOwn(s, "index") && (n$2.index = s.index), Object.hasOwn(s, "input") && (n$2.input = s.input), n$2;
	}
	if (s instanceof Date) return new Date(s.getTime());
	if (s instanceof RegExp) {
		const n$2 = new RegExp(s.source, s.flags);
		return n$2.lastIndex = s.lastIndex, n$2;
	}
	if (s instanceof Map) {
		const n$2 = /* @__PURE__ */ new Map();
		i$2.set(s, n$2);
		for (const [c$3, h$4] of s) n$2.set(c$3, y(h$4, c$3, e, i$2, r$1));
		return n$2;
	}
	if (s instanceof Set) {
		const n$2 = /* @__PURE__ */ new Set();
		i$2.set(s, n$2);
		for (const c$3 of s) n$2.add(y(c$3, void 0, e, i$2, r$1));
		return n$2;
	}
	if (typeof Buffer < "u" && Buffer.isBuffer(s)) return s.subarray();
	if (G(s)) {
		const n$2 = new (Object.getPrototypeOf(s)).constructor(s.length);
		i$2.set(s, n$2);
		for (let c$3 = 0; c$3 < s.length; c$3++) n$2[c$3] = y(s[c$3], c$3, e, i$2, r$1);
		return n$2;
	}
	if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
	if (s instanceof DataView) {
		const n$2 = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);
		return i$2.set(s, n$2), g(n$2, s, e, i$2, r$1), n$2;
	}
	if (typeof File < "u" && s instanceof File) {
		const n$2 = new File([s], s.name, { type: s.type });
		return i$2.set(s, n$2), g(n$2, s, e, i$2, r$1), n$2;
	}
	if (s instanceof Blob) {
		const n$2 = new Blob([s], { type: s.type });
		return i$2.set(s, n$2), g(n$2, s, e, i$2, r$1), n$2;
	}
	if (s instanceof Error) {
		const n$2 = new s.constructor();
		return i$2.set(s, n$2), n$2.message = s.message, n$2.name = s.name, n$2.stack = s.stack, n$2.cause = s.cause, g(n$2, s, e, i$2, r$1), n$2;
	}
	if (typeof s == "object" && te(s)) {
		const n$2 = Object.create(Object.getPrototypeOf(s));
		return i$2.set(s, n$2), g(n$2, s, e, i$2, r$1), n$2;
	}
	return s;
}
function g(s, t, e = s, i$2, r$1) {
	const a$1 = [...Object.keys(t), ...it(t)];
	for (let n$2 = 0; n$2 < a$1.length; n$2++) {
		const c$3 = a$1[n$2], h$4 = Object.getOwnPropertyDescriptor(s, c$3);
		(h$4 == null || h$4.writable) && (s[c$3] = y(t[c$3], c$3, e, i$2, r$1));
	}
}
function te(s) {
	switch (rt(s)) {
		case ot:
		case Mt:
		case Bt:
		case Jt:
		case ct:
		case Ft:
		case Qt:
		case Zt:
		case Vt:
		case Xt:
		case Yt:
		case Lt:
		case at:
		case Gt:
		case _t:
		case xt:
		case nt:
		case Ut:
		case zt:
		case kt:
		case Wt:
		case Kt: return !0;
		default: return !1;
	}
}
function ee(s, t) {
	return Tt$1(s, (e, i$2, r$1, a$1) => {
		const n$2 = t?.(e, i$2, r$1, a$1);
		if (n$2 != null) return n$2;
		if (typeof s == "object") switch (Object.prototype.toString.call(s)) {
			case at:
			case nt:
			case ct: {
				const c$3 = new s.constructor(s?.valueOf());
				return g(c$3, s), c$3;
			}
			case ot: {
				const c$3 = {};
				return g(c$3, s), c$3.length = s.length, c$3[Symbol.iterator] = s[Symbol.iterator], c$3;
			}
			default: return;
		}
	});
}
function ht(s) {
	return ee(s);
}
function pt(s) {
	return s !== null && typeof s == "object" && rt(s) === "[object Arguments]";
}
function se(s) {
	return G(s);
}
function ie(s) {
	if (typeof s != "object" || s == null) return !1;
	if (Object.getPrototypeOf(s) === null) return !0;
	if (Object.prototype.toString.call(s) !== "[object Object]") {
		const e = s[Symbol.toStringTag];
		return e == null || !Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)?.writable ? !1 : s.toString() === `[object ${e}]`;
	}
	let t = s;
	for (; Object.getPrototypeOf(t) !== null;) t = Object.getPrototypeOf(t);
	return Object.getPrototypeOf(s) === t;
}
function re(s, ...t) {
	const e = t.slice(0, -1), i$2 = t[t.length - 1];
	let r$1 = s;
	for (let a$1 = 0; a$1 < e.length; a$1++) {
		const n$2 = e[a$1];
		r$1 = U(r$1, n$2, i$2, /* @__PURE__ */ new Map());
	}
	return r$1;
}
function U(s, t, e, i$2) {
	if (B(s) && (s = Object(s)), t == null || typeof t != "object") return s;
	if (i$2.has(t)) return Rt(i$2.get(t));
	if (i$2.set(t, s), Array.isArray(t)) {
		t = t.slice();
		for (let a$1 = 0; a$1 < t.length; a$1++) t[a$1] = t[a$1] ?? void 0;
	}
	const r$1 = [...Object.keys(t), ...it(t)];
	for (let a$1 = 0; a$1 < r$1.length; a$1++) {
		const n$2 = r$1[a$1];
		let c$3 = t[n$2], h$4 = s[n$2];
		if (pt(c$3) && (c$3 = { ...c$3 }), pt(h$4) && (h$4 = { ...h$4 }), typeof Buffer < "u" && Buffer.isBuffer(c$3) && (c$3 = ht(c$3)), Array.isArray(c$3)) if (typeof h$4 == "object" && h$4 != null) {
			const j$2 = [], R$5 = Reflect.ownKeys(h$4);
			for (let f$7 = 0; f$7 < R$5.length; f$7++) {
				const X$1 = R$5[f$7];
				j$2[X$1] = h$4[X$1];
			}
			h$4 = j$2;
		} else h$4 = [];
		const v$5 = e(h$4, c$3, n$2, s, t, i$2);
		v$5 != null ? s[n$2] = v$5 : Array.isArray(c$3) || st(h$4) && st(c$3) ? s[n$2] = U(h$4, c$3, e, i$2) : h$4 == null && ie(c$3) ? s[n$2] = U({}, c$3, e, i$2) : h$4 == null && se(c$3) ? s[n$2] = ht(c$3) : (h$4 === void 0 || c$3 !== void 0) && (s[n$2] = c$3);
	}
	return s;
}
function ne(s, ...t) {
	return re(s, ...t, jt);
}
var ae = Object.defineProperty, ce = Object.defineProperties, oe = Object.getOwnPropertyDescriptors, dt = Object.getOwnPropertySymbols, he = Object.prototype.hasOwnProperty, pe = Object.prototype.propertyIsEnumerable, ut = (s, t, e) => t in s ? ae(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, F = (s, t) => {
	for (var e in t || (t = {})) he.call(t, e) && ut(s, e, t[e]);
	if (dt) for (var e of dt(t)) pe.call(t, e) && ut(s, e, t[e]);
	return s;
}, de$1 = (s, t) => ce(s, oe(t));
function p(s, t, e) {
	var i$2;
	const r$1 = Ye(s);
	return ((i$2 = t.rpcMap) == null ? void 0 : i$2[r$1.reference]) || `${et}?chainId=${r$1.namespace}:${r$1.reference}&projectId=${e}`;
}
function P(s) {
	return s.includes(":") ? s.split(":")[1] : s;
}
function lt(s) {
	return s.map((t) => `${t.split(":")[0]}:${t.split(":")[1]}`);
}
function ue(s, t) {
	const e = Object.keys(t.namespaces).filter((r$1) => r$1.includes(s));
	if (!e.length) return [];
	const i$2 = [];
	return e.forEach((r$1) => {
		const a$1 = t.namespaces[r$1].accounts;
		i$2.push(...a$1);
	}), i$2;
}
function J(s = {}, t = {}) {
	return ne(ft(s), ft(t));
}
function ft(s) {
	var t, e, i$2, r$1;
	const a$1 = {};
	if (!qe(s)) return a$1;
	for (const [n$2, c$3] of Object.entries(s)) {
		const h$4 = Tt(n$2) ? [n$2] : c$3.chains, v$5 = c$3.methods || [], j$2 = c$3.events || [], R$5 = c$3.rpcMap || {}, f$7 = pr(n$2);
		a$1[f$7] = de$1(F(F({}, a$1[f$7]), c$3), {
			chains: Q(h$4, (t = a$1[f$7]) == null ? void 0 : t.chains),
			methods: Q(v$5, (e = a$1[f$7]) == null ? void 0 : e.methods),
			events: Q(j$2, (i$2 = a$1[f$7]) == null ? void 0 : i$2.events),
			rpcMap: F(F({}, R$5), (r$1 = a$1[f$7]) == null ? void 0 : r$1.rpcMap)
		});
	}
	return a$1;
}
function le(s) {
	return s.includes(":") ? s.split(":")[2] : s;
}
function mt(s) {
	const t = {};
	for (const [e, i$2] of Object.entries(s)) {
		const r$1 = i$2.methods || [], a$1 = i$2.events || [], n$2 = i$2.accounts || [];
		t[e] = {
			chains: Tt(e) ? [e] : i$2.chains ? i$2.chains : lt(i$2.accounts),
			methods: r$1,
			events: a$1,
			accounts: n$2
		};
	}
	return t;
}
function z(s) {
	return typeof s == "number" ? s : s.includes("0x") ? parseInt(s, 16) : (s = s.includes(":") ? s.split(":")[1] : s, isNaN(Number(s)) ? s : Number(s));
}
var vt = {}, o$1 = (s) => vt[s], k$1 = (s, t) => {
	vt[s] = t;
};
var fe = Object.defineProperty, me = (s, t, e) => t in s ? fe(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, b = (s, t, e) => me(s, typeof t != "symbol" ? t + "" : t, e);
var ve = class {
	constructor(t) {
		b(this, "name", "polkadot"), b(this, "client"), b(this, "httpProviders"), b(this, "events"), b(this, "namespace"), b(this, "chainId"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(t) {
		this.namespace = Object.assign(this.namespace, t);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	request(t) {
		return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
	}
	setDefaultChain(t, e) {
		this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
	}
	createHttpProviders() {
		const t = {};
		return this.namespace.chains.forEach((e) => {
			var i$2;
			const r$1 = P(e);
			t[r$1] = this.createHttpProvider(r$1, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[e]);
		}), t;
	}
	getHttpProvider() {
		const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProvider(t, e) {
		const i$2 = e || p(t, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
		return new o(new f(i$2, o$1("disableProviderPing")));
	}
};
var ge = Object.defineProperty, Pe = Object.defineProperties, we = Object.getOwnPropertyDescriptors, gt = Object.getOwnPropertySymbols, ye = Object.prototype.hasOwnProperty, be = Object.prototype.propertyIsEnumerable, W = (s, t, e) => t in s ? ge(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, Pt = (s, t) => {
	for (var e in t || (t = {})) ye.call(t, e) && W(s, e, t[e]);
	if (gt) for (var e of gt(t)) be.call(t, e) && W(s, e, t[e]);
	return s;
}, wt = (s, t) => Pe(s, we(t)), I = (s, t, e) => W(s, typeof t != "symbol" ? t + "" : t, e);
var Ie = class {
	constructor(t) {
		I(this, "name", "eip155"), I(this, "client"), I(this, "chainId"), I(this, "namespace"), I(this, "httpProviders"), I(this, "events"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
	}
	async request(t) {
		switch (t.request.method) {
			case "eth_requestAccounts": return this.getAccounts();
			case "eth_accounts": return this.getAccounts();
			case "wallet_switchEthereumChain": return await this.handleSwitchChain(t);
			case "eth_chainId": return parseInt(this.getDefaultChain());
			case "wallet_getCapabilities": return await this.getCapabilities(t);
			case "wallet_getCallsStatus": return await this.getCallStatus(t);
		}
		return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);
	}
	updateNamespace(t) {
		this.namespace = Object.assign(this.namespace, t);
	}
	setDefaultChain(t, e) {
		this.httpProviders[t] || this.setHttpProvider(parseInt(t), e), this.chainId = parseInt(t), this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId.toString();
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	createHttpProvider(t, e) {
		const i$2 = e || p(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
		return new o(new f(i$2, o$1("disableProviderPing")));
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProviders() {
		const t = {};
		return this.namespace.chains.forEach((e) => {
			var i$2;
			const r$1 = parseInt(P(e));
			t[r$1] = this.createHttpProvider(r$1, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[e]);
		}), t;
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
	}
	getHttpProvider() {
		const t = this.chainId, e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	async handleSwitchChain(t) {
		var e, i$2;
		let r$1 = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : "0x0";
		r$1 = r$1.startsWith("0x") ? r$1 : `0x${r$1}`;
		const a$1 = parseInt(r$1, 16);
		if (this.isChainApproved(a$1)) this.setDefaultChain(`${a$1}`);
		else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({
			topic: t.topic,
			request: {
				method: t.request.method,
				params: [{ chainId: r$1 }]
			},
			chainId: (i$2 = this.namespace.chains) == null ? void 0 : i$2[0]
		}), this.setDefaultChain(`${a$1}`);
		else throw new Error(`Failed to switch to chain 'eip155:${a$1}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
		return null;
	}
	isChainApproved(t) {
		return this.namespace.chains.includes(`${this.name}:${t}`);
	}
	async getCapabilities(t) {
		var e, i$2, r$1;
		const a$1 = (i$2 = (e = t.request) == null ? void 0 : e.params) == null ? void 0 : i$2[0];
		if (!a$1) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
		const n$2 = this.client.session.get(t.topic), c$3 = ((r$1 = n$2?.sessionProperties) == null ? void 0 : r$1.capabilities) || {};
		if (c$3 != null && c$3[a$1]) return c$3?.[a$1];
		const h$4 = await this.client.request(t);
		try {
			await this.client.session.update(t.topic, { sessionProperties: wt(Pt({}, n$2.sessionProperties || {}), { capabilities: wt(Pt({}, c$3 || {}), { [a$1]: h$4 }) }) });
		} catch (v$5) {
			console.warn("Failed to update session with capabilities", v$5);
		}
		return h$4;
	}
	async getCallStatus(t) {
		var e, i$2;
		const r$1 = this.client.session.get(t.topic), a$1 = (e = r$1.sessionProperties) == null ? void 0 : e.bundler_name;
		if (a$1) {
			const c$3 = this.getBundlerUrl(t.chainId, a$1);
			try {
				return await this.getUserOperationReceipt(c$3, t);
			} catch (h$4) {
				console.warn("Failed to fetch call status from bundler", h$4, c$3);
			}
		}
		const n$2 = (i$2 = r$1.sessionProperties) == null ? void 0 : i$2.bundler_url;
		if (n$2) try {
			return await this.getUserOperationReceipt(n$2, t);
		} catch (c$3) {
			console.warn("Failed to fetch call status from custom bundler", c$3, n$2);
		}
		if (this.namespace.methods.includes(t.request.method)) return await this.client.request(t);
		throw new Error("Fetching call status not approved by the wallet.");
	}
	async getUserOperationReceipt(t, e) {
		var i$2;
		const r$1 = new URL(t), a$1 = await fetch(r$1, {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i$2 = e.request.params) == null ? void 0 : i$2[0]]))
		});
		if (!a$1.ok) throw new Error(`Failed to fetch user operation receipt - ${a$1.status}`);
		return await a$1.json();
	}
	getBundlerUrl(t, e) {
		return `${qt}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`;
	}
};
var $e$1 = Object.defineProperty, Oe = (s, t, e) => t in s ? $e$1(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, $ = (s, t, e) => Oe(s, typeof t != "symbol" ? t + "" : t, e);
var Ae = class {
	constructor(t) {
		$(this, "name", "solana"), $(this, "client"), $(this, "httpProviders"), $(this, "events"), $(this, "namespace"), $(this, "chainId"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(t) {
		this.namespace = Object.assign(this.namespace, t);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	request(t) {
		return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
	}
	setDefaultChain(t, e) {
		this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const t = {};
		return this.namespace.chains.forEach((e) => {
			var i$2;
			const r$1 = P(e);
			t[r$1] = this.createHttpProvider(r$1, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[e]);
		}), t;
	}
	getHttpProvider() {
		const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProvider(t, e) {
		const i$2 = e || p(t, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
		return new o(new f(i$2, o$1("disableProviderPing")));
	}
};
var He = Object.defineProperty, Ee$1 = (s, t, e) => t in s ? He(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, O = (s, t, e) => Ee$1(s, typeof t != "symbol" ? t + "" : t, e);
var Ce = class {
	constructor(t) {
		O(this, "name", "cosmos"), O(this, "client"), O(this, "httpProviders"), O(this, "events"), O(this, "namespace"), O(this, "chainId"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(t) {
		this.namespace = Object.assign(this.namespace, t);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	request(t) {
		return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
	}
	setDefaultChain(t, e) {
		this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const t = {};
		return this.namespace.chains.forEach((e) => {
			var i$2;
			const r$1 = P(e);
			t[r$1] = this.createHttpProvider(r$1, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[e]);
		}), t;
	}
	getHttpProvider() {
		const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProvider(t, e) {
		const i$2 = e || p(t, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
		return new o(new f(i$2, o$1("disableProviderPing")));
	}
};
var Ne = Object.defineProperty, Se = (s, t, e) => t in s ? Ne(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, A$1 = (s, t, e) => Se(s, typeof t != "symbol" ? t + "" : t, e);
var De = class {
	constructor(t) {
		A$1(this, "name", "algorand"), A$1(this, "client"), A$1(this, "httpProviders"), A$1(this, "events"), A$1(this, "namespace"), A$1(this, "chainId"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(t) {
		this.namespace = Object.assign(this.namespace, t);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	request(t) {
		return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
	}
	setDefaultChain(t, e) {
		if (!this.httpProviders[t]) {
			const i$2 = e || p(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
			if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
			this.setHttpProvider(t, i$2);
		}
		this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const t = {};
		return this.namespace.chains.forEach((e) => {
			var i$2;
			t[e] = this.createHttpProvider(e, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[e]);
		}), t;
	}
	getHttpProvider() {
		const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProvider(t, e) {
		const i$2 = e || p(t, this.namespace, this.client.core.projectId);
		return typeof i$2 > "u" ? void 0 : new o(new f(i$2, o$1("disableProviderPing")));
	}
};
var qe$1 = Object.defineProperty, je = (s, t, e) => t in s ? qe$1(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, H = (s, t, e) => je(s, typeof t != "symbol" ? t + "" : t, e);
var Re = class {
	constructor(t) {
		H(this, "name", "cip34"), H(this, "client"), H(this, "httpProviders"), H(this, "events"), H(this, "namespace"), H(this, "chainId"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(t) {
		this.namespace = Object.assign(this.namespace, t);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	request(t) {
		return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
	}
	setDefaultChain(t, e) {
		this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const t = {};
		return this.namespace.chains.forEach((e) => {
			const i$2 = this.getCardanoRPCUrl(e), r$1 = P(e);
			t[r$1] = this.createHttpProvider(r$1, i$2);
		}), t;
	}
	getHttpProvider() {
		const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	getCardanoRPCUrl(t) {
		const e = this.namespace.rpcMap;
		if (e) return e[t];
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProvider(t, e) {
		const i$2 = e || this.getCardanoRPCUrl(t);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
		return new o(new f(i$2, o$1("disableProviderPing")));
	}
};
var _e = Object.defineProperty, Ue = (s, t, e) => t in s ? _e(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, E = (s, t, e) => Ue(s, typeof t != "symbol" ? t + "" : t, e);
var Fe = class {
	constructor(t) {
		E(this, "name", "elrond"), E(this, "client"), E(this, "httpProviders"), E(this, "events"), E(this, "namespace"), E(this, "chainId"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(t) {
		this.namespace = Object.assign(this.namespace, t);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	request(t) {
		return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
	}
	setDefaultChain(t, e) {
		this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const t = {};
		return this.namespace.chains.forEach((e) => {
			var i$2;
			const r$1 = P(e);
			t[r$1] = this.createHttpProvider(r$1, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[e]);
		}), t;
	}
	getHttpProvider() {
		const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProvider(t, e) {
		const i$2 = e || p(t, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
		return new o(new f(i$2, o$1("disableProviderPing")));
	}
};
var Le = Object.defineProperty, xe = (s, t, e) => t in s ? Le(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, C = (s, t, e) => xe(s, typeof t != "symbol" ? t + "" : t, e);
var Me = class {
	constructor(t) {
		C(this, "name", "multiversx"), C(this, "client"), C(this, "httpProviders"), C(this, "events"), C(this, "namespace"), C(this, "chainId"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(t) {
		this.namespace = Object.assign(this.namespace, t);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	request(t) {
		return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
	}
	setDefaultChain(t, e) {
		this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
	}
	createHttpProviders() {
		const t = {};
		return this.namespace.chains.forEach((e) => {
			var i$2;
			const r$1 = P(e);
			t[r$1] = this.createHttpProvider(r$1, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[e]);
		}), t;
	}
	getHttpProvider() {
		const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProvider(t, e) {
		const i$2 = e || p(t, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
		return new o(new f(i$2, o$1("disableProviderPing")));
	}
};
var Be = Object.defineProperty, Ge = (s, t, e) => t in s ? Be(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, N = (s, t, e) => Ge(s, typeof t != "symbol" ? t + "" : t, e);
var Je = class {
	constructor(t) {
		N(this, "name", "near"), N(this, "client"), N(this, "httpProviders"), N(this, "events"), N(this, "namespace"), N(this, "chainId"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(t) {
		this.namespace = Object.assign(this.namespace, t);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	request(t) {
		return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
	}
	setDefaultChain(t, e) {
		if (this.chainId = t, !this.httpProviders[t]) {
			const i$2 = e || p(`${this.name}:${t}`, this.namespace);
			if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
			this.setHttpProvider(t, i$2);
		}
		this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
	}
	createHttpProviders() {
		const t = {};
		return this.namespace.chains.forEach((e) => {
			var i$2;
			t[e] = this.createHttpProvider(e, (i$2 = this.namespace.rpcMap) == null ? void 0 : i$2[e]);
		}), t;
	}
	getHttpProvider() {
		const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProvider(t, e) {
		const i$2 = e || p(t, this.namespace);
		return typeof i$2 > "u" ? void 0 : new o(new f(i$2, o$1("disableProviderPing")));
	}
};
var ze = Object.defineProperty, ke = (s, t, e) => t in s ? ze(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, S = (s, t, e) => ke(s, typeof t != "symbol" ? t + "" : t, e);
var We = class {
	constructor(t) {
		S(this, "name", "tezos"), S(this, "client"), S(this, "httpProviders"), S(this, "events"), S(this, "namespace"), S(this, "chainId"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(t) {
		this.namespace = Object.assign(this.namespace, t);
	}
	requestAccounts() {
		return this.getAccounts();
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	request(t) {
		return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
	}
	setDefaultChain(t, e) {
		if (this.chainId = t, !this.httpProviders[t]) {
			const i$2 = e || p(`${this.name}:${t}`, this.namespace);
			if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
			this.setHttpProvider(t, i$2);
		}
		this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
	}
	createHttpProviders() {
		const t = {};
		return this.namespace.chains.forEach((e) => {
			t[e] = this.createHttpProvider(e);
		}), t;
	}
	getHttpProvider() {
		const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProvider(t, e) {
		const i$2 = e || p(t, this.namespace);
		return typeof i$2 > "u" ? void 0 : new o(new f(i$2));
	}
};
var Ke = Object.defineProperty, Ve = (s, t, e) => t in s ? Ke(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, D = (s, t, e) => Ve(s, typeof t != "symbol" ? t + "" : t, e);
var Xe$1 = class {
	constructor(t) {
		D(this, "name", w), D(this, "client"), D(this, "httpProviders"), D(this, "events"), D(this, "namespace"), D(this, "chainId"), this.namespace = t.namespace, this.events = o$1("events"), this.client = o$1("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
	}
	updateNamespace(t) {
		this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t.events || []))], this.httpProviders = this.createHttpProviders();
	}
	requestAccounts() {
		return this.getAccounts();
	}
	request(t) {
		return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider(t.chainId).request(t.request);
	}
	setDefaultChain(t, e) {
		this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
	}
	getDefaultChain() {
		if (this.chainId) return this.chainId;
		if (this.namespace.defaultChain) return this.namespace.defaultChain;
		const t = this.namespace.chains[0];
		if (!t) throw new Error("ChainId not found");
		return t.split(":")[1];
	}
	getAccounts() {
		const t = this.namespace.accounts;
		return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
	}
	createHttpProviders() {
		var t, e;
		const i$2 = {};
		return (e = (t = this.namespace) == null ? void 0 : t.accounts) == null || e.forEach((r$1) => {
			const a$1 = Ye(r$1);
			i$2[`${a$1.namespace}:${a$1.reference}`] = this.createHttpProvider(r$1);
		}), i$2;
	}
	getHttpProvider(t) {
		const e = this.httpProviders[t];
		if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
		return e;
	}
	setHttpProvider(t, e) {
		const i$2 = this.createHttpProvider(t, e);
		i$2 && (this.httpProviders[t] = i$2);
	}
	createHttpProvider(t, e) {
		const i$2 = e || p(t, this.namespace, this.client.core.projectId);
		if (!i$2) throw new Error(`No RPC url provided for chainId: ${t}`);
		return new o(new f(i$2, o$1("disableProviderPing")));
	}
};
var Ye$1 = Object.defineProperty, Qe = Object.defineProperties, Ze = Object.getOwnPropertyDescriptors, yt = Object.getOwnPropertySymbols, Te = Object.prototype.hasOwnProperty, ts = Object.prototype.propertyIsEnumerable, K = (s, t, e) => t in s ? Ye$1(s, t, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : s[t] = e, L = (s, t) => {
	for (var e in t || (t = {})) Te.call(t, e) && K(s, e, t[e]);
	if (yt) for (var e of yt(t)) ts.call(t, e) && K(s, e, t[e]);
	return s;
}, V = (s, t) => Qe(s, Ze(t)), u = (s, t, e) => K(s, typeof t != "symbol" ? t + "" : t, e);
var x = class x {
	constructor(t) {
		u(this, "client"), u(this, "namespaces"), u(this, "optionalNamespaces"), u(this, "sessionProperties"), u(this, "scopedProperties"), u(this, "events", new import_events.default()), u(this, "rpcProviders", {}), u(this, "session"), u(this, "providerOpts"), u(this, "logger"), u(this, "uri"), u(this, "disableProviderPing", !1), this.providerOpts = t, this.logger = typeof t?.logger < "u" && typeof t?.logger != "string" ? t.logger : (0, import_browser.default)(k({ level: t?.logger || tt })), this.disableProviderPing = t?.disableProviderPing || !1;
	}
	static async init(t) {
		const e = new x(t);
		return await e.initialize(), e;
	}
	async request(t, e, i$2) {
		const [r$1, a$1] = this.validateChain(e);
		if (!this.session) throw new Error("Please call connect() before request()");
		return await this.getProvider(r$1).request({
			request: L({}, t),
			chainId: `${r$1}:${a$1}`,
			topic: this.session.topic,
			expiry: i$2
		});
	}
	sendAsync(t, e, i$2, r$1) {
		const a$1 = (/* @__PURE__ */ new Date()).getTime();
		this.request(t, i$2, r$1).then((n$2) => e(null, formatJsonRpcResult(a$1, n$2))).catch((n$2) => e(n$2, void 0));
	}
	async enable() {
		if (!this.client) throw new Error("Sign Client not initialized");
		return this.session || await this.connect({
			namespaces: this.namespaces,
			optionalNamespaces: this.optionalNamespaces,
			sessionProperties: this.sessionProperties,
			scopedProperties: this.scopedProperties
		}), await this.requestAccounts();
	}
	async disconnect() {
		var t;
		if (!this.session) throw new Error("Please call connect() before enable()");
		await this.client.disconnect({
			topic: (t = this.session) == null ? void 0 : t.topic,
			reason: de("USER_DISCONNECTED")
		}), await this.cleanup();
	}
	async connect(t) {
		if (!this.client) throw new Error("Sign Client not initialized");
		if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);
	}
	async authenticate(t, e) {
		if (!this.client) throw new Error("Sign Client not initialized");
		this.setNamespaces(t), await this.cleanupPendingPairings();
		const { uri: i$2, response: r$1 } = await this.client.authenticate(t, e);
		i$2 && (this.uri = i$2, this.events.emit("display_uri", i$2));
		const a$1 = await r$1();
		if (this.session = a$1.session, this.session) {
			const n$2 = mt(this.session.namespaces);
			this.namespaces = J(this.namespaces, n$2), await this.persist("namespaces", this.namespaces), this.onConnect();
		}
		return a$1;
	}
	on(t, e) {
		this.events.on(t, e);
	}
	once(t, e) {
		this.events.once(t, e);
	}
	removeListener(t, e) {
		this.events.removeListener(t, e);
	}
	off(t, e) {
		this.events.off(t, e);
	}
	get isWalletConnect() {
		return !0;
	}
	async pair(t) {
		const { uri: e, approval: i$2 } = await this.client.connect({
			pairingTopic: t,
			requiredNamespaces: this.namespaces,
			optionalNamespaces: this.optionalNamespaces,
			sessionProperties: this.sessionProperties,
			scopedProperties: this.scopedProperties
		});
		e && (this.uri = e, this.events.emit("display_uri", e));
		const r$1 = await i$2();
		this.session = r$1;
		const a$1 = mt(r$1.namespaces);
		return this.namespaces = J(this.namespaces, a$1), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
	}
	setDefaultChain(t, e) {
		try {
			if (!this.session) return;
			const [i$2, r$1] = this.validateChain(t), a$1 = this.getProvider(i$2);
			a$1.name === w ? a$1.setDefaultChain(`${i$2}:${r$1}`, e) : a$1.setDefaultChain(r$1, e);
		} catch (i$2) {
			if (!/Please call connect/.test(i$2.message)) throw i$2;
		}
	}
	async cleanupPendingPairings(t = {}) {
		this.logger.info("Cleaning up inactive pairings...");
		const e = this.client.pairing.getAll();
		if ($e(e)) {
			for (const i$2 of e) t.deletePairings ? this.client.core.expirer.set(i$2.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i$2.topic);
			this.logger.info(`Inactive pairings cleared: ${e.length}`);
		}
	}
	abortPairingAttempt() {
		this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
	}
	async checkStorage() {
		this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
	}
	async initialize() {
		this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
	}
	async createClient() {
		var t, e;
		if (this.client = this.providerOpts.client || await Ee.init({
			core: this.providerOpts.core,
			logger: this.providerOpts.logger || tt,
			relayUrl: this.providerOpts.relayUrl || Nt,
			projectId: this.providerOpts.projectId,
			metadata: this.providerOpts.metadata,
			storageOptions: this.providerOpts.storageOptions,
			storage: this.providerOpts.storage,
			name: this.providerOpts.name,
			customStoragePrefix: this.providerOpts.customStoragePrefix,
			telemetryEnabled: this.providerOpts.telemetryEnabled
		}), this.providerOpts.session) try {
			this.session = this.client.session.get(this.providerOpts.session.topic);
		} catch (i$2) {
			throw this.logger.error("Failed to get session", i$2), /* @__PURE__ */ new Error(`The provided session: ${(e = (t = this.providerOpts) == null ? void 0 : t.session) == null ? void 0 : e.topic} doesn't exist in the Sign client`);
		}
		else this.session = this.client.session.getAll()[0];
		this.logger.trace("SignClient Initialized");
	}
	createProviders() {
		if (!this.client) throw new Error("Sign Client not initialized");
		if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
		const t = [...new Set(Object.keys(this.session.namespaces).map((e) => pr(e)))];
		k$1("client", this.client), k$1("events", this.events), k$1("disableProviderPing", this.disableProviderPing), t.forEach((e) => {
			if (!this.session) return;
			const i$2 = ue(e, this.session), r$1 = lt(i$2), n$2 = V(L({}, J(this.namespaces, this.optionalNamespaces)[e]), {
				accounts: i$2,
				chains: r$1
			});
			switch (e) {
				case "eip155":
					this.rpcProviders[e] = new Ie({ namespace: n$2 });
					break;
				case "algorand":
					this.rpcProviders[e] = new De({ namespace: n$2 });
					break;
				case "solana":
					this.rpcProviders[e] = new Ae({ namespace: n$2 });
					break;
				case "cosmos":
					this.rpcProviders[e] = new Ce({ namespace: n$2 });
					break;
				case "polkadot":
					this.rpcProviders[e] = new ve({ namespace: n$2 });
					break;
				case "cip34":
					this.rpcProviders[e] = new Re({ namespace: n$2 });
					break;
				case "elrond":
					this.rpcProviders[e] = new Fe({ namespace: n$2 });
					break;
				case "multiversx":
					this.rpcProviders[e] = new Me({ namespace: n$2 });
					break;
				case "near":
					this.rpcProviders[e] = new Je({ namespace: n$2 });
					break;
				case "tezos":
					this.rpcProviders[e] = new We({ namespace: n$2 });
					break;
				default: this.rpcProviders[w] ? this.rpcProviders[w].updateNamespace(n$2) : this.rpcProviders[w] = new Xe$1({ namespace: n$2 });
			}
		});
	}
	registerEventListeners() {
		if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
		this.client.on("session_ping", (t) => {
			var e;
			const { topic: i$2 } = t;
			i$2 === ((e = this.session) == null ? void 0 : e.topic) && this.events.emit("session_ping", t);
		}), this.client.on("session_event", (t) => {
			var e;
			const { params: i$2, topic: r$1 } = t;
			if (r$1 !== ((e = this.session) == null ? void 0 : e.topic)) return;
			const { event: a$1 } = i$2;
			if (a$1.name === "accountsChanged") {
				const n$2 = a$1.data;
				n$2 && $e(n$2) && this.events.emit("accountsChanged", n$2.map(le));
			} else if (a$1.name === "chainChanged") {
				const n$2 = i$2.chainId, c$3 = i$2.event.data, h$4 = pr(n$2), v$5 = z(n$2) !== z(c$3) ? `${h$4}:${z(c$3)}` : n$2;
				this.onChainChanged(v$5);
			} else this.events.emit(a$1.name, a$1.data);
			this.events.emit("session_event", t);
		}), this.client.on("session_update", ({ topic: t, params: e }) => {
			var i$2, r$1;
			if (t !== ((i$2 = this.session) == null ? void 0 : i$2.topic)) return;
			const { namespaces: a$1 } = e;
			this.session = V(L({}, (r$1 = this.client) == null ? void 0 : r$1.session.get(t)), { namespaces: a$1 }), this.onSessionUpdate(), this.events.emit("session_update", {
				topic: t,
				params: e
			});
		}), this.client.on("session_delete", async (t) => {
			var e;
			t.topic === ((e = this.session) == null ? void 0 : e.topic) && (await this.cleanup(), this.events.emit("session_delete", t), this.events.emit("disconnect", V(L({}, de("USER_DISCONNECTED")), { data: t.topic })));
		}), this.on(d.DEFAULT_CHAIN_CHANGED, (t) => {
			this.onChainChanged(t, !0);
		});
	}
	getProvider(t) {
		return this.rpcProviders[t] || this.rpcProviders[w];
	}
	onSessionUpdate() {
		Object.keys(this.rpcProviders).forEach((t) => {
			var e;
			this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);
		});
	}
	setNamespaces(t) {
		const { namespaces: e, optionalNamespaces: i$2, sessionProperties: r$1, scopedProperties: a$1 } = t;
		e && Object.keys(e).length && (this.namespaces = e), i$2 && Object.keys(i$2).length && (this.optionalNamespaces = i$2), this.sessionProperties = r$1, this.scopedProperties = a$1;
	}
	validateChain(t) {
		const [e, i$2] = t?.split(":") || ["", ""];
		if (!this.namespaces || !Object.keys(this.namespaces).length) return [e, i$2];
		if (e && !Object.keys(this.namespaces || {}).map((n$2) => pr(n$2)).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);
		if (e && i$2) return [e, i$2];
		const r$1 = pr(Object.keys(this.namespaces)[0]);
		return [r$1, this.rpcProviders[r$1].getDefaultChain()];
	}
	async requestAccounts() {
		const [t] = this.validateChain();
		return await this.getProvider(t).requestAccounts();
	}
	async onChainChanged(t, e = !1) {
		if (!this.namespaces) return;
		const [i$2, r$1] = this.validateChain(t);
		r$1 && (e || this.getProvider(i$2).setDefaultChain(r$1), this.namespaces[i$2] ? this.namespaces[i$2].defaultChain = r$1 : this.namespaces[`${i$2}:${r$1}`] ? this.namespaces[`${i$2}:${r$1}`].defaultChain = r$1 : this.namespaces[`${i$2}:${r$1}`] = { defaultChain: r$1 }, this.events.emit("chainChanged", r$1), await this.persist("namespaces", this.namespaces));
	}
	onConnect() {
		this.createProviders(), this.events.emit("connect", { session: this.session });
	}
	async cleanup() {
		this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({ deletePairings: !0 }), await this.cleanupStorage();
	}
	async persist(t, e) {
		var i$2;
		const r$1 = ((i$2 = this.session) == null ? void 0 : i$2.topic) || "";
		await this.client.core.storage.setItem(`${_}/${t}${r$1}`, e);
	}
	async getFromStore(t) {
		var e;
		const i$2 = ((e = this.session) == null ? void 0 : e.topic) || "";
		return await this.client.core.storage.getItem(`${_}/${t}${i$2}`);
	}
	async deleteFromStore(t) {
		var e;
		const i$2 = ((e = this.session) == null ? void 0 : e.topic) || "";
		await this.client.core.storage.removeItem(`${_}/${t}${i$2}`);
	}
	async cleanupStorage() {
		var t;
		try {
			if (((t = this.client) == null ? void 0 : t.session.length) > 0) return;
			const e = await this.client.core.storage.getKeys();
			for (const i$2 of e) i$2.startsWith(_) && await this.client.core.storage.removeItem(i$2);
		} catch (e) {
			this.logger.warn("Failed to cleanup storage", e);
		}
	}
};

//#endregion
//#region node_modules/@reown/appkit-utils/dist/esm/src/PresetsUtil.js
const PresetsUtil = {
	ConnectorExplorerIds: {
		[ConstantsUtil.CONNECTOR_ID.COINBASE]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
		[ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
		[ConstantsUtil.CONNECTOR_ID.SAFE]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
		[ConstantsUtil.CONNECTOR_ID.LEDGER]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
		[ConstantsUtil.CONNECTOR_ID.OKX]: "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
		[ConstantsUtil$1.METMASK_CONNECTOR_NAME]: "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
		[ConstantsUtil$1.TRUST_CONNECTOR_NAME]: "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
		[ConstantsUtil$1.SOLFLARE_CONNECTOR_NAME]: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
		[ConstantsUtil$1.PHANTOM_CONNECTOR_NAME]: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
		[ConstantsUtil$1.COIN98_CONNECTOR_NAME]: "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
		[ConstantsUtil$1.MAGIC_EDEN_CONNECTOR_NAME]: "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
		[ConstantsUtil$1.BACKPACK_CONNECTOR_NAME]: "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
		[ConstantsUtil$1.BITGET_CONNECTOR_NAME]: "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
		[ConstantsUtil$1.FRONTIER_CONNECTOR_NAME]: "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
		[ConstantsUtil$1.XVERSE_CONNECTOR_NAME]: "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
		[ConstantsUtil$1.LEATHER_CONNECTOR_NAME]: "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13"
	},
	NetworkImageIds: {
		1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
		42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
		43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
		56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
		250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
		10: "ab9c186a-c52f-464b-2906-ca59d760a400",
		137: "41d04d42-da3b-4453-8506-668cc0727900",
		5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
		295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
		11155111: "e909ea0a-f92a-4512-c8fc-748044ea6800",
		84532: "a18a7ecd-e307-4360-4746-283182228e00",
		1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
		130: "2257980a-3463-48c6-cbac-a42d2a956e00",
		10143: "0a728e83-bacb-46db-7844-948f05434900",
		100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
		9001: "f926ff41-260d-4028-635e-91913fc28e00",
		324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
		314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
		4689: "34e68754-e536-40da-c153-6ef2e7188a00",
		1088: "3897a66d-40b9-4833-162f-a2c90531c900",
		1284: "161038da-44ae-4ec7-1208-0ea569454b00",
		1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
		7777777: "845c60df-d429-4991-e687-91ae45791600",
		42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
		8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
		1313161554: "3ff73439-a619-4894-9262-4470c773a100",
		2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
		2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
		80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
		"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": "a1b58899-f671-4276-6a5e-56ca5bd59700",
		"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": "a1b58899-f671-4276-6a5e-56ca5bd59700",
		EtWTRABZaYq6iMfeYKouRu166VU2xqa1: "a1b58899-f671-4276-6a5e-56ca5bd59700",
		"000000000019d6689c085ae165831e93": "0b4838db-0161-4ffe-022d-532bf03dba00",
		"000000000933ea01ad0ee984209779ba": "39354064-d79b-420b-065d-f980c4b78200"
	},
	ConnectorImageIds: {
		[ConstantsUtil.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
		[ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
		[ConstantsUtil.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
		[ConstantsUtil.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
		[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
		[ConstantsUtil.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
	},
	ConnectorNamesMap: {
		[ConstantsUtil.CONNECTOR_ID.INJECTED]: "Browser Wallet",
		[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
		[ConstantsUtil.CONNECTOR_ID.COINBASE]: "Coinbase",
		[ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
		[ConstantsUtil.CONNECTOR_ID.LEDGER]: "Ledger",
		[ConstantsUtil.CONNECTOR_ID.SAFE]: "Safe"
	},
	ConnectorTypesMap: {
		[ConstantsUtil.CONNECTOR_ID.INJECTED]: "INJECTED",
		[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
		[ConstantsUtil.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
		[ConstantsUtil.CONNECTOR_ID.AUTH]: "AUTH"
	},
	WalletConnectRpcChainIds: [
		1,
		5,
		11155111,
		10,
		420,
		42161,
		421613,
		137,
		80001,
		42220,
		1313161554,
		1313161555,
		56,
		97,
		43114,
		43113,
		100,
		8453,
		84531,
		7777777,
		999,
		324,
		280
	]
};

//#endregion
//#region node_modules/@reown/appkit-utils/dist/esm/src/ErrorUtil.js
const ErrorUtil = {
	UniversalProviderErrors: {
		UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
			message: "Unauthorized: origin not allowed",
			alertErrorKey: "INVALID_APP_CONFIGURATION"
		},
		JWT_VALIDATION_ERROR: {
			message: "JWT validation error: JWT Token is not yet valid",
			alertErrorKey: "JWT_TOKEN_NOT_VALID"
		},
		INVALID_KEY: {
			message: "Unauthorized: invalid key",
			alertErrorKey: "INVALID_PROJECT_ID"
		}
	},
	ALERT_ERRORS: {
		SWITCH_NETWORK_NOT_FOUND: {
			shortMessage: "Network Not Found",
			longMessage: "Network not found - please make sure it is included in 'networks' array in createAppKit function"
		},
		INVALID_APP_CONFIGURATION: {
			shortMessage: "Invalid App Configuration",
			longMessage: () => `Origin ${isSafe() ? window.origin : "unknown"} not found on Allowlist - update configuration on cloud.reown.com`
		},
		SOCIALS_TIMEOUT: {
			shortMessage: "Invalid App Configuration",
			longMessage: () => "There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com"
		},
		JWT_TOKEN_NOT_VALID: {
			shortMessage: "Session Expired",
			longMessage: "Invalid session found on UniversalProvider - please check your time settings and connect again"
		},
		INVALID_PROJECT_ID: {
			shortMessage: "Invalid App Configuration",
			longMessage: "Invalid Project ID - update configuration"
		},
		PROJECT_ID_NOT_CONFIGURED: {
			shortMessage: "Project ID Not Configured",
			longMessage: "Project ID Not Configured - update configuration on cloud.reown.com"
		}
	}
};
function isSafe() {
	return typeof window !== "undefined";
}

//#endregion
//#region node_modules/@reown/appkit-utils/dist/esm/src/LoggerUtil.js
const LoggerUtil = { createLogger(onError, level = "error") {
	const { logger } = A({ opts: k({ level }) });
	logger.error = (...args) => {
		for (const arg of args) if (arg instanceof Error) {
			onError(arg, ...args);
			return;
		}
		onError(void 0, ...args);
	};
	return logger;
} };

//#endregion
//#region node_modules/@reown/appkit-utils/dist/esm/src/CaipNetworkUtil.js
var RPC_URL_HOST = "rpc.walletconnect.org";
function getBlockchainApiRpcUrl(caipNetworkId, projectId) {
	const url = new URL("https://rpc.walletconnect.org/v1/");
	url.searchParams.set("chainId", caipNetworkId);
	url.searchParams.set("projectId", projectId);
	return url.toString();
}
var WC_HTTP_RPC_SUPPORTED_CHAINS = [
	"near:mainnet",
	"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
	"eip155:1101",
	"eip155:56",
	"eip155:42161",
	"eip155:7777777",
	"eip155:59144",
	"eip155:324",
	"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
	"eip155:5000",
	"solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
	"eip155:80084",
	"eip155:5003",
	"eip155:100",
	"eip155:8453",
	"eip155:42220",
	"eip155:1313161555",
	"eip155:17000",
	"eip155:1",
	"eip155:300",
	"eip155:1313161554",
	"eip155:1329",
	"eip155:84532",
	"eip155:421614",
	"eip155:11155111",
	"eip155:8217",
	"eip155:43114",
	"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
	"eip155:999999999",
	"eip155:11155420",
	"eip155:80002",
	"eip155:97",
	"eip155:43113",
	"eip155:137",
	"eip155:10",
	"eip155:1301",
	"bip122:000000000019d6689c085ae165831e93",
	"bip122:000000000933ea01ad0ee984209779ba"
];
const CaipNetworksUtil = {
	extendRpcUrlWithProjectId(rpcUrl, projectId) {
		let isReownUrl = false;
		try {
			isReownUrl = new URL(rpcUrl).host === RPC_URL_HOST;
		} catch (e) {
			isReownUrl = false;
		}
		if (isReownUrl) {
			const url = new URL(rpcUrl);
			if (!url.searchParams.has("projectId")) url.searchParams.set("projectId", projectId);
			return url.toString();
		}
		return rpcUrl;
	},
	isCaipNetwork(network) {
		return "chainNamespace" in network && "caipNetworkId" in network;
	},
	getChainNamespace(network) {
		if (this.isCaipNetwork(network)) return network.chainNamespace;
		return ConstantsUtil.CHAIN.EVM;
	},
	getCaipNetworkId(network) {
		if (this.isCaipNetwork(network)) return network.caipNetworkId;
		return `${ConstantsUtil.CHAIN.EVM}:${network.id}`;
	},
	getDefaultRpcUrl(caipNetwork, caipNetworkId, projectId) {
		const defaultRpcUrl = caipNetwork.rpcUrls?.default?.http?.[0];
		if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetworkId)) return getBlockchainApiRpcUrl(caipNetworkId, projectId);
		return defaultRpcUrl || "";
	},
	extendCaipNetwork(caipNetwork, { customNetworkImageUrls, projectId, customRpcUrls }) {
		const chainNamespace = this.getChainNamespace(caipNetwork);
		const caipNetworkId = this.getCaipNetworkId(caipNetwork);
		const networkDefaultRpcUrl = caipNetwork.rpcUrls.default.http?.[0];
		const reownRpcUrl = this.getDefaultRpcUrl(caipNetwork, caipNetworkId, projectId);
		const chainDefaultRpcUrl = caipNetwork?.rpcUrls?.["chainDefault"]?.http?.[0] || networkDefaultRpcUrl;
		const customRpcUrlsOfNetwork = customRpcUrls?.[caipNetworkId]?.map((i$2) => i$2.url) || [];
		const rpcUrls = [...customRpcUrlsOfNetwork, reownRpcUrl];
		const rpcUrlsWithoutReown = [...customRpcUrlsOfNetwork];
		if (chainDefaultRpcUrl && !rpcUrlsWithoutReown.includes(chainDefaultRpcUrl)) rpcUrlsWithoutReown.push(chainDefaultRpcUrl);
		return {
			...caipNetwork,
			chainNamespace,
			caipNetworkId,
			assets: {
				imageId: PresetsUtil.NetworkImageIds[caipNetwork.id],
				imageUrl: customNetworkImageUrls?.[caipNetwork.id]
			},
			rpcUrls: {
				...caipNetwork.rpcUrls,
				default: { http: rpcUrls },
				chainDefault: { http: rpcUrlsWithoutReown }
			}
		};
	},
	extendCaipNetworks(caipNetworks, { customNetworkImageUrls, projectId, customRpcUrls }) {
		return caipNetworks.map((caipNetwork) => CaipNetworksUtil.extendCaipNetwork(caipNetwork, {
			customNetworkImageUrls,
			customRpcUrls,
			projectId
		}));
	},
	getViemTransport(caipNetwork, projectId, customRpcUrls) {
		const transports = [];
		customRpcUrls?.forEach((rpcUrl) => {
			transports.push(http(rpcUrl.url, rpcUrl.config));
		});
		if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetwork.caipNetworkId)) {
			const reownRpcUrl = this.getDefaultRpcUrl(caipNetwork, caipNetwork.caipNetworkId, projectId);
			transports.push(http(reownRpcUrl, { fetchOptions: { headers: { "Content-Type": "text/plain" } } }));
		}
		return fallback(transports);
	},
	extendWagmiTransports(caipNetwork, projectId, transport) {
		if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetwork.caipNetworkId)) return fallback([transport, http(this.getDefaultRpcUrl(caipNetwork, caipNetwork.caipNetworkId, projectId))]);
		return transport;
	},
	getUnsupportedNetwork(caipNetworkId) {
		return {
			id: caipNetworkId.split(":")[1],
			caipNetworkId,
			name: ConstantsUtil.UNSUPPORTED_NETWORK_NAME,
			chainNamespace: caipNetworkId.split(":")[0],
			nativeCurrency: {
				name: "",
				decimals: 0,
				symbol: ""
			},
			rpcUrls: { default: { http: [] } }
		};
	},
	getCaipNetworkFromStorage(defaultCaipNetwork) {
		const caipNetworkIdFromStorage = StorageUtil.getActiveCaipNetworkId();
		const caipNetworks = ChainController.getAllRequestedCaipNetworks();
		const availableNamespaces = Array.from(ChainController.state.chains?.keys() || []);
		const namespace = caipNetworkIdFromStorage?.split(":")[0];
		const isNamespaceAvailable = namespace ? availableNamespaces.includes(namespace) : false;
		const caipNetwork = caipNetworks?.find((cn$4) => cn$4.caipNetworkId === caipNetworkIdFromStorage);
		if (isNamespaceAvailable && !caipNetwork && caipNetworkIdFromStorage) return this.getUnsupportedNetwork(caipNetworkIdFromStorage);
		if (caipNetwork) return caipNetwork;
		if (defaultCaipNetwork) return defaultCaipNetwork;
		return caipNetworks?.[0];
	}
};

//#endregion
//#region node_modules/@reown/appkit-utils/dist/esm/src/ProviderUtil.js
var CLEAN_PROVIDERS_STATE = {
	eip155: void 0,
	solana: void 0,
	polkadot: void 0,
	bip122: void 0
};
var state = proxy({
	providers: { ...CLEAN_PROVIDERS_STATE },
	providerIds: { ...CLEAN_PROVIDERS_STATE }
});
const ProviderUtil = {
	state,
	subscribeKey(key, callback) {
		return subscribeKey(state, key, callback);
	},
	subscribe(callback) {
		return subscribe(state, () => {
			callback(state);
		});
	},
	subscribeProviders(callback) {
		return subscribe(state.providers, () => callback(state.providers));
	},
	setProvider(chainNamespace, provider) {
		if (provider) state.providers[chainNamespace] = ref(provider);
	},
	getProvider(chainNamespace) {
		return state.providers[chainNamespace];
	},
	setProviderId(chainNamespace, providerId) {
		if (providerId) state.providerIds[chainNamespace] = providerId;
	},
	getProviderId(chainNamespace) {
		if (!chainNamespace) return;
		return state.providerIds[chainNamespace];
	},
	reset() {
		state.providers = { ...CLEAN_PROVIDERS_STATE };
		state.providerIds = { ...CLEAN_PROVIDERS_STATE };
	},
	resetChain(chainNamespace) {
		state.providers[chainNamespace] = void 0;
		state.providerIds[chainNamespace] = void 0;
	}
};

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
const WcConstantsUtil = {
	ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
	ERROR_CODE_DEFAULT: 5e3,
	ERROR_INVALID_CHAIN_ID: 32603
};

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/networks/utils.js
function defineChain(chain) {
	return {
		formatters: void 0,
		fees: void 0,
		serializers: void 0,
		...chain
	};
}

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/networks/solana/solana.js
const solana = defineChain({
	id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
	name: "Solana",
	network: "solana-mainnet",
	nativeCurrency: {
		name: "Solana",
		symbol: "SOL",
		decimals: 9
	},
	rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
	blockExplorers: { default: {
		name: "Solscan",
		url: "https://solscan.io"
	} },
	testnet: false,
	chainNamespace: "solana",
	caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
	deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"
});

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaDevnet.js
const solanaDevnet = defineChain({
	id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
	name: "Solana Devnet",
	network: "solana-devnet",
	nativeCurrency: {
		name: "Solana",
		symbol: "SOL",
		decimals: 9
	},
	rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
	blockExplorers: { default: {
		name: "Solscan",
		url: "https://solscan.io"
	} },
	testnet: true,
	chainNamespace: "solana",
	caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
	deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
});

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaTestnet.js
const solanaTestnet = defineChain({
	id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
	name: "Solana Testnet",
	network: "solana-testnet",
	nativeCurrency: {
		name: "Solana",
		symbol: "SOL",
		decimals: 9
	},
	rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
	blockExplorers: { default: {
		name: "Solscan",
		url: "https://solscan.io"
	} },
	testnet: true,
	chainNamespace: "solana",
	caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
});

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/networks/bitcoin.js
const bitcoin = defineChain({
	id: "000000000019d6689c085ae165831e93",
	caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
	chainNamespace: "bip122",
	name: "Bitcoin",
	nativeCurrency: {
		name: "Bitcoin",
		symbol: "BTC",
		decimals: 8
	},
	rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } }
});
const bitcoinTestnet = defineChain({
	id: "000000000933ea01ad0ee984209779ba",
	caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
	chainNamespace: "bip122",
	name: "Bitcoin Testnet",
	nativeCurrency: {
		name: "Bitcoin",
		symbol: "BTC",
		decimals: 8
	},
	rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
	testnet: true
});

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
const DEFAULT_METHODS = {
	solana: [
		"solana_signMessage",
		"solana_signTransaction",
		"solana_requestAccounts",
		"solana_getAccounts",
		"solana_signAllTransactions",
		"solana_signAndSendTransaction"
	],
	eip155: [
		"eth_accounts",
		"eth_requestAccounts",
		"eth_sendRawTransaction",
		"eth_sign",
		"eth_signTransaction",
		"eth_signTypedData",
		"eth_signTypedData_v3",
		"eth_signTypedData_v4",
		"eth_sendTransaction",
		"personal_sign",
		"wallet_switchEthereumChain",
		"wallet_addEthereumChain",
		"wallet_getPermissions",
		"wallet_requestPermissions",
		"wallet_registerOnboarding",
		"wallet_watchAsset",
		"wallet_scanQRCode",
		"wallet_getCallsStatus",
		"wallet_showCallsStatus",
		"wallet_sendCalls",
		"wallet_getCapabilities",
		"wallet_grantPermissions",
		"wallet_revokePermissions",
		"wallet_getAssets"
	],
	bip122: [
		"sendTransfer",
		"signMessage",
		"signPsbt",
		"getAccountAddresses"
	]
};
const WcHelpersUtil = {
	getMethodsByChainNamespace(chainNamespace) {
		return DEFAULT_METHODS[chainNamespace] || [];
	},
	createDefaultNamespace(chainNamespace) {
		return {
			methods: this.getMethodsByChainNamespace(chainNamespace),
			events: ["accountsChanged", "chainChanged"],
			chains: [],
			rpcMap: {}
		};
	},
	applyNamespaceOverrides(baseNamespaces, overrides) {
		if (!overrides) return { ...baseNamespaces };
		const result = { ...baseNamespaces };
		const namespacesToOverride = /* @__PURE__ */ new Set();
		if (overrides.methods) Object.keys(overrides.methods).forEach((ns$2) => namespacesToOverride.add(ns$2));
		if (overrides.chains) Object.keys(overrides.chains).forEach((ns$2) => namespacesToOverride.add(ns$2));
		if (overrides.events) Object.keys(overrides.events).forEach((ns$2) => namespacesToOverride.add(ns$2));
		if (overrides.rpcMap) Object.keys(overrides.rpcMap).forEach((chainId) => {
			const [ns$2] = chainId.split(":");
			if (ns$2) namespacesToOverride.add(ns$2);
		});
		namespacesToOverride.forEach((ns$2) => {
			if (!result[ns$2]) result[ns$2] = this.createDefaultNamespace(ns$2);
		});
		if (overrides.methods) Object.entries(overrides.methods).forEach(([ns$2, methods]) => {
			if (result[ns$2]) result[ns$2].methods = methods;
		});
		if (overrides.chains) Object.entries(overrides.chains).forEach(([ns$2, chains]) => {
			if (result[ns$2]) result[ns$2].chains = chains;
		});
		if (overrides.events) Object.entries(overrides.events).forEach(([ns$2, events]) => {
			if (result[ns$2]) result[ns$2].events = events;
		});
		if (overrides.rpcMap) {
			const processedNamespaces = /* @__PURE__ */ new Set();
			Object.entries(overrides.rpcMap).forEach(([chainId, rpcUrl]) => {
				const [ns$2, id] = chainId.split(":");
				if (!ns$2 || !id || !result[ns$2]) return;
				if (!result[ns$2].rpcMap) result[ns$2].rpcMap = {};
				if (!processedNamespaces.has(ns$2)) {
					result[ns$2].rpcMap = {};
					processedNamespaces.add(ns$2);
				}
				result[ns$2].rpcMap[id] = rpcUrl;
			});
		}
		return result;
	},
	createNamespaces(caipNetworks, configOverride) {
		const defaultNamespaces = caipNetworks.reduce((acc, chain) => {
			const { id, chainNamespace, rpcUrls } = chain;
			const rpcUrl = rpcUrls.default.http[0];
			if (!acc[chainNamespace]) acc[chainNamespace] = this.createDefaultNamespace(chainNamespace);
			const caipNetworkId = `${chainNamespace}:${id}`;
			const namespace = acc[chainNamespace];
			namespace.chains.push(caipNetworkId);
			switch (caipNetworkId) {
				case solana.caipNetworkId:
					namespace.chains.push(solana.deprecatedCaipNetworkId);
					break;
				case solanaDevnet.caipNetworkId:
					namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
					break;
				default:
			}
			if (namespace?.rpcMap && rpcUrl) namespace.rpcMap[id] = rpcUrl;
			return acc;
		}, {});
		return this.applyNamespaceOverrides(defaultNamespaces, configOverride);
	},
	resolveReownName: async (name) => {
		const wcNameAddress = await EnsController.resolveName(name);
		return (Object.values(wcNameAddress?.addresses) || [])[0]?.address || false;
	},
	getChainsFromNamespaces(namespaces = {}) {
		return Object.values(namespaces).flatMap((namespace) => {
			const chains = namespace.chains || [];
			const accountsChains = namespace.accounts.map((account) => {
				const [chainNamespace, chainId] = account.split(":");
				return `${chainNamespace}:${chainId}`;
			});
			return Array.from(new Set([...chains, ...accountsChains]));
		});
	},
	isSessionEventData(data) {
		return typeof data === "object" && data !== null && "id" in data && "topic" in data && "params" in data && typeof data.params === "object" && data.params !== null && "chainId" in data.params && "event" in data.params && typeof data.params.event === "object" && data.params.event !== null;
	}
};

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/connectors/WalletConnectConnector.js
var WalletConnectConnector = class {
	constructor({ provider, caipNetworks, namespace }) {
		this.id = ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
		this.name = PresetsUtil.ConnectorNamesMap[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
		this.type = "WALLET_CONNECT";
		this.imageId = PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
		this.caipNetworks = caipNetworks;
		this.provider = provider;
		this.chain = namespace;
	}
	get chains() {
		return this.caipNetworks;
	}
	async connectWalletConnect() {
		if (!await this.authenticate()) {
			const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
			const namespaces = WcHelpersUtil.createNamespaces(this.caipNetworks, universalProviderConfigOverride);
			await this.provider.connect({ optionalNamespaces: namespaces });
		}
		return {
			clientId: await this.provider.client.core.crypto.getClientId(),
			session: this.provider.session
		};
	}
	async disconnect() {
		await this.provider.disconnect();
	}
	async authenticate() {
		const chains = this.chains.map((network) => network.caipNetworkId);
		return SIWXUtil.universalProviderAuthenticate({
			universalProvider: this.provider,
			chains,
			methods: OPTIONAL_METHODS
		});
	}
};
var OPTIONAL_METHODS = [
	"eth_accounts",
	"eth_requestAccounts",
	"eth_sendRawTransaction",
	"eth_sign",
	"eth_signTransaction",
	"eth_signTypedData",
	"eth_signTypedData_v3",
	"eth_signTypedData_v4",
	"eth_sendTransaction",
	"personal_sign",
	"wallet_switchEthereumChain",
	"wallet_addEthereumChain",
	"wallet_getPermissions",
	"wallet_requestPermissions",
	"wallet_registerOnboarding",
	"wallet_watchAsset",
	"wallet_scanQRCode",
	"wallet_getCallsStatus",
	"wallet_sendCalls",
	"wallet_getCapabilities",
	"wallet_grantPermissions",
	"wallet_revokePermissions",
	"wallet_getAssets"
];

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js
/**
* Abstract class representing a chain adapter blueprint.
* @template Connector - The type of connector extending ChainAdapterConnector
*/
var AdapterBlueprint = class {
	/**
	* Creates an instance of AdapterBlueprint.
	* @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
	*/
	constructor(params) {
		this.availableConnectors = [];
		this.eventListeners = /* @__PURE__ */ new Map();
		if (params) this.construct(params);
	}
	/**
	* Initializes the adapter with the given parameters.
	* @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
	*/
	construct(params) {
		this.caipNetworks = params.networks;
		this.projectId = params.projectId;
		this.namespace = params.namespace;
		this.adapterType = params.adapterType;
	}
	/**
	* Gets the available connectors.
	* @returns {Connector[]} An array of available connectors
	*/
	get connectors() {
		return this.availableConnectors;
	}
	/**
	* Gets the supported networks.
	* @returns {CaipNetwork[]} An array of supported networks
	*/
	get networks() {
		return this.caipNetworks || [];
	}
	/**
	* Sets the auth provider.
	* @param {W3mFrameProvider} authProvider - The auth provider instance
	*/
	setAuthProvider(authProvider) {
		this.addConnector({
			id: ConstantsUtil.CONNECTOR_ID.AUTH,
			type: "AUTH",
			name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
			provider: authProvider,
			imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.AUTH],
			chain: this.namespace,
			chains: []
		});
	}
	/**
	* Adds one or more connectors to the available connectors list.
	* @param {...Connector} connectors - The connectors to add
	*/
	addConnector(...connectors) {
		const connectorsAdded = /* @__PURE__ */ new Set();
		this.availableConnectors = [...connectors, ...this.availableConnectors].filter((connector) => {
			if (connectorsAdded.has(connector.id)) return false;
			connectorsAdded.add(connector.id);
			return true;
		});
		this.emit("connectors", this.availableConnectors);
	}
	setStatus(status, chainNamespace) {
		AccountController.setStatus(status, chainNamespace);
	}
	/**
	* Adds an event listener for a specific event.
	* @template T
	* @param {T} eventName - The name of the event
	* @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
	*/
	on(eventName, callback) {
		if (!this.eventListeners.has(eventName)) this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
		this.eventListeners.get(eventName)?.add(callback);
	}
	/**
	* Removes an event listener for a specific event.
	* @template T
	* @param {T} eventName - The name of the event
	* @param {EventCallback<T>} callback - The callback function to be removed
	*/
	off(eventName, callback) {
		const listeners = this.eventListeners.get(eventName);
		if (listeners) listeners.delete(callback);
	}
	/**
	* Removes all event listeners.
	*/
	removeAllEventListeners() {
		this.eventListeners.forEach((listeners) => {
			listeners.clear();
		});
	}
	/**
	* Emits an event with the given name and optional data.
	* @template T
	* @param {T} eventName - The name of the event to emit
	* @param {EventData[T]} [data] - The optional data to be passed to the event listeners
	*/
	emit(eventName, data) {
		const listeners = this.eventListeners.get(eventName);
		if (listeners) listeners.forEach((callback) => callback(data));
	}
	/**
	* Connects to WalletConnect.
	* @param {number | string} [_chainId] - Optional chain ID to connect to
	*/
	async connectWalletConnect(_chainId) {
		return { clientId: (await this.getWalletConnectConnector().connectWalletConnect()).clientId };
	}
	/**
	* Switches the network.
	* @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
	*/
	async switchNetwork(params) {
		const { caipNetwork, providerType } = params;
		if (!params.provider) return;
		const provider = "provider" in params.provider ? params.provider.provider : params.provider;
		if (providerType === "WALLET_CONNECT") {
			provider.setDefaultChain(caipNetwork.caipNetworkId);
			return;
		}
		if (provider && providerType === "AUTH") {
			const authProvider = provider;
			await authProvider.switchNetwork(caipNetwork.caipNetworkId);
			const user = await authProvider.getUser({
				chainId: caipNetwork.caipNetworkId,
				preferredAccountType: OptionsController.state.defaultAccountTypes[caipNetwork.chainNamespace]
			});
			this.emit("switchNetwork", user);
		}
	}
	getWalletConnectConnector() {
		const connector = this.connectors.find((c$3) => c$3 instanceof WalletConnectConnector);
		if (!connector) throw new Error("WalletConnectConnector not found");
		return connector;
	}
};

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
var UniversalAdapter = class extends AdapterBlueprint {
	setUniversalProvider(universalProvider) {
		this.addConnector(new WalletConnectConnector({
			provider: universalProvider,
			caipNetworks: this.caipNetworks || [],
			namespace: this.namespace
		}));
	}
	async connect(params) {
		return Promise.resolve({
			id: "WALLET_CONNECT",
			type: "WALLET_CONNECT",
			chainId: Number(params.chainId),
			provider: this.provider,
			address: ""
		});
	}
	async disconnect() {
		try {
			await this.getWalletConnectConnector().disconnect();
		} catch (error) {
			console.warn("UniversalAdapter:disconnect - error", error);
		}
	}
	async getAccounts({ namespace }) {
		const addresses = this.provider?.session?.namespaces?.[namespace]?.accounts?.map((account) => {
			const [, , address] = account.split(":");
			return address;
		}).filter((address, index$1, self$1) => self$1.indexOf(address) === index$1) || [];
		return Promise.resolve({ accounts: addresses.map((address) => CoreHelperUtil.createAccount(namespace, address, namespace === "bip122" ? "payment" : "eoa")) });
	}
	async syncConnectors() {
		return Promise.resolve();
	}
	async getBalance(params) {
		if (!(params.caipNetwork && ConstantsUtil$2.BALANCE_SUPPORTED_CHAINS.includes(params.caipNetwork?.chainNamespace)) || params.caipNetwork?.testnet) return {
			balance: "0.00",
			symbol: params.caipNetwork?.nativeCurrency.symbol || ""
		};
		if (AccountController.state.balanceLoading && params.chainId === ChainController.state.activeCaipNetwork?.id) return {
			balance: AccountController.state.balance || "0.00",
			symbol: AccountController.state.balanceSymbol || ""
		};
		const balance = (await AccountController.fetchTokenBalance()).find((b$3) => b$3.chainId === `${params.caipNetwork?.chainNamespace}:${params.chainId}` && b$3.symbol === params.caipNetwork?.nativeCurrency.symbol);
		return {
			balance: balance?.quantity.numeric || "0.00",
			symbol: balance?.symbol || params.caipNetwork?.nativeCurrency.symbol || ""
		};
	}
	async signMessage(params) {
		const { provider, message, address } = params;
		if (!provider) throw new Error("UniversalAdapter:signMessage - provider is undefined");
		let signature = "";
		if (ChainController.state.activeCaipNetwork?.chainNamespace === ConstantsUtil.CHAIN.SOLANA) signature = (await provider.request({
			method: "solana_signMessage",
			params: {
				message: esm_default$2.encode(new TextEncoder().encode(message)),
				pubkey: address
			}
		}, ChainController.state.activeCaipNetwork?.caipNetworkId)).signature;
		else signature = await provider.request({
			method: "personal_sign",
			params: [message, address]
		}, ChainController.state.activeCaipNetwork?.caipNetworkId);
		return { signature };
	}
	/**
	*
	* These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
	* These function definition is to have a type parity between the clients. Currently not in use.
	*/
	async estimateGas() {
		return Promise.resolve({ gas: BigInt(0) });
	}
	async getProfile() {
		return Promise.resolve({
			profileImage: "",
			profileName: ""
		});
	}
	async sendTransaction() {
		return Promise.resolve({ hash: "" });
	}
	walletGetAssets(_params) {
		return Promise.resolve({});
	}
	async writeContract() {
		return Promise.resolve({ hash: "" });
	}
	async getEnsAddress() {
		return Promise.resolve({ address: false });
	}
	parseUnits() {
		return 0n;
	}
	formatUnits() {
		return "0";
	}
	async getCapabilities() {
		return Promise.resolve({});
	}
	async grantPermissions() {
		return Promise.resolve({});
	}
	async revokePermissions() {
		return Promise.resolve("0x");
	}
	async syncConnection() {
		return Promise.resolve({
			id: "WALLET_CONNECT",
			type: "WALLET_CONNECT",
			chainId: 1,
			provider: this.provider,
			address: ""
		});
	}
	async switchNetwork(params) {
		const { caipNetwork } = params;
		const connector = this.getWalletConnectConnector();
		if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) try {
			await connector.provider?.request({
				method: "wallet_switchEthereumChain",
				params: [{ chainId: toHex(caipNetwork.id) }]
			});
		} catch (switchError) {
			if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || switchError?.data?.originalError?.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) try {
				await connector.provider?.request({
					method: "wallet_addEthereumChain",
					params: [{
						chainId: toHex(caipNetwork.id),
						rpcUrls: [caipNetwork?.rpcUrls["chainDefault"]?.http],
						chainName: caipNetwork.name,
						nativeCurrency: caipNetwork.nativeCurrency,
						blockExplorerUrls: [caipNetwork.blockExplorers?.default.url]
					}]
				});
			} catch (error) {
				throw new Error("Chain is not supported");
			}
		}
		connector.provider.setDefaultChain(caipNetwork.caipNetworkId);
	}
	getWalletConnectProvider() {
		return this.connectors.find((c$3) => c$3.type === "WALLET_CONNECT")?.provider;
	}
};

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js
var AppKitBaseClient = class {
	constructor(options) {
		this.hasSwitchedToPreferredAccountTypeOnConnect = false;
		this.chainNamespaces = [];
		this.reportedAlertErrors = {};
		this.getCaipNetwork = (chainNamespace) => {
			if (chainNamespace) {
				const namespaceCaipNetwork = ChainController.getNetworkData(chainNamespace)?.caipNetwork;
				if (namespaceCaipNetwork) return namespaceCaipNetwork;
				return ChainController.getRequestedCaipNetworks(chainNamespace).filter((c$3) => c$3.chainNamespace === chainNamespace)?.[0];
			}
			return ChainController.state.activeCaipNetwork || this.defaultCaipNetwork;
		};
		this.getCaipNetworkId = () => {
			const network = this.getCaipNetwork();
			if (network) return network.id;
		};
		this.getCaipNetworks = (namespace) => ChainController.getRequestedCaipNetworks(namespace);
		this.getActiveChainNamespace = () => ChainController.state.activeChain;
		this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
			ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
		};
		this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();
		this.getCaipAddress = (chainNamespace) => {
			if (ChainController.state.activeChain === chainNamespace || !chainNamespace) return ChainController.state.activeCaipAddress;
			return ChainController.getAccountProp("caipAddress", chainNamespace);
		};
		this.setClientId = (clientId) => {
			BlockchainApiController.setClientId(clientId);
		};
		this.getProvider = (namespace) => ProviderUtil.getProvider(namespace);
		this.getProviderType = (namespace) => ProviderUtil.getProviderId(namespace);
		this.getPreferredAccountType = () => AccountController.state.preferredAccountType;
		this.setCaipAddress = (caipAddress, chain) => {
			AccountController.setCaipAddress(caipAddress, chain);
		};
		this.setBalance = (balance, balanceSymbol, chain) => {
			AccountController.setBalance(balance, balanceSymbol, chain);
		};
		this.setProfileName = (profileName, chain) => {
			AccountController.setProfileName(profileName, chain);
		};
		this.setProfileImage = (profileImage, chain) => {
			AccountController.setProfileImage(profileImage, chain);
		};
		this.setUser = (user, chain) => {
			AccountController.setUser(user, chain);
			if (OptionsController.state.enableEmbedded) ModalController.close();
		};
		this.resetAccount = (chain) => {
			AccountController.resetAccount(chain);
		};
		this.setCaipNetwork = (caipNetwork) => {
			ChainController.setActiveCaipNetwork(caipNetwork);
		};
		this.setCaipNetworkOfNamespace = (caipNetwork, chainNamespace) => {
			ChainController.setChainNetworkData(chainNamespace, { caipNetwork });
		};
		this.setAllAccounts = (addresses, chain) => {
			AccountController.setAllAccounts(addresses, chain);
			OptionsController.setHasMultipleAddresses(addresses?.length > 1);
		};
		this.setStatus = (status, chain) => {
			AccountController.setStatus(status, chain);
			if (ConnectorController.isConnected()) StorageUtil.setConnectionStatus("connected");
			else StorageUtil.setConnectionStatus("disconnected");
		};
		this.getAddressByChainNamespace = (chainNamespace) => ChainController.getAccountProp("address", chainNamespace);
		this.setConnectors = (connectors) => {
			const allConnectors = [...ConnectorController.getConnectors(), ...connectors];
			ConnectorController.setConnectors(allConnectors);
		};
		this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
		this.getReownName = (address) => EnsController.getNamesForAddress(address);
		this.getConnectors = () => ConnectorController.getConnectors();
		this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
		this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
			const type = ProviderUtil.getProviderId(chain);
			const walletInfo = connectedWalletInfo ? {
				...connectedWalletInfo,
				type
			} : void 0;
			AccountController.setConnectedWalletInfo(walletInfo, chain);
		};
		this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
		this.addAddressLabel = (address, label, chain) => {
			AccountController.addAddressLabel(address, label, chain);
		};
		this.removeAddressLabel = (address, chain) => {
			AccountController.removeAddressLabel(address, chain);
		};
		this.getAddress = (chainNamespace) => {
			if (ChainController.state.activeChain === chainNamespace || !chainNamespace) return AccountController.state.address;
			return ChainController.getAccountProp("address", chainNamespace);
		};
		this.setApprovedCaipNetworksData = (namespace) => ChainController.setApprovedCaipNetworksData(namespace);
		this.resetNetwork = (namespace) => {
			ChainController.resetNetwork(namespace);
		};
		this.addConnector = (connector) => {
			ConnectorController.addConnector(connector);
		};
		this.resetWcConnection = () => {
			ConnectionController.resetWcConnection();
		};
		this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
			AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);
		};
		this.setSmartAccountDeployed = (isDeployed, chain) => {
			AccountController.setSmartAccountDeployed(isDeployed, chain);
		};
		this.setSmartAccountEnabledNetworks = (smartAccountEnabledNetworks, chain) => {
			ChainController.setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain);
		};
		this.setPreferredAccountType = (preferredAccountType, chain) => {
			AccountController.setPreferredAccountType(preferredAccountType, chain);
		};
		this.setEIP6963Enabled = (enabled) => {
			OptionsController.setEIP6963Enabled(enabled);
		};
		this.handleUnsafeRPCRequest = () => {
			if (this.isOpen()) {
				if (this.isTransactionStackEmpty()) return;
				this.redirect("ApproveTransaction");
			} else this.open({ view: "ApproveTransaction" });
		};
		this.options = options;
		this.version = options.sdkVersion;
		this.caipNetworks = this.extendCaipNetworks(options);
		this.chainNamespaces = [...new Set(this.caipNetworks?.map((caipNetwork) => caipNetwork.chainNamespace))];
		this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
		this.chainAdapters = this.createAdapters(options.adapters);
		this.initialize(options);
		this.sendInitializeEvent(options);
	}
	async initialize(options) {
		this.initControllers(options);
		await this.initChainAdapters();
		await this.injectModalUi();
		await this.syncExistingConnection();
		PublicStateController.set({ initialized: true });
	}
	sendInitializeEvent(options) {
		const { ...optionsCopy } = options;
		delete optionsCopy.adapters;
		EventsController.sendEvent({
			type: "track",
			event: "INITIALIZE",
			properties: {
				...optionsCopy,
				networks: options.networks.map((n$2) => n$2.id),
				siweConfig: { options: options.siweConfig?.options || {} }
			}
		});
	}
	initControllers(options) {
		this.initializeOptionsController(options);
		this.initializeChainController(options);
		this.initializeThemeController(options);
		this.initializeConnectionController(options);
		this.initializeConnectorController();
	}
	initializeThemeController(options) {
		if (options.themeMode) ThemeController.setThemeMode(options.themeMode);
		if (options.themeVariables) ThemeController.setThemeVariables(options.themeVariables);
	}
	initializeChainController(options) {
		if (!this.connectionControllerClient || !this.networkControllerClient) throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");
		ChainController.initialize(options.adapters ?? [], this.caipNetworks, {
			connectionControllerClient: this.connectionControllerClient,
			networkControllerClient: this.networkControllerClient
		});
		const network = this.getDefaultNetwork();
		if (network) ChainController.setActiveCaipNetwork(network);
	}
	initializeConnectionController(options) {
		ConnectionController.setWcBasic(options.basic ?? false);
	}
	initializeConnectorController() {
		ConnectorController.initialize(this.chainNamespaces);
	}
	initializeOptionsController(options) {
		OptionsController.setDebug(options.debug !== false);
		OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);
		OptionsController.setEnableWalletGuide(options.enableWalletGuide !== false);
		OptionsController.setEnableWallets(options.enableWallets !== false);
		OptionsController.setEIP6963Enabled(options.enableEIP6963 !== false);
		OptionsController.setEnableNetworkSwitch(options.enableNetworkSwitch !== false);
		OptionsController.setEnableAuthLogger(options.enableAuthLogger !== false);
		OptionsController.setCustomRpcUrls(options.customRpcUrls);
		OptionsController.setSdkVersion(options.sdkVersion);
		OptionsController.setProjectId(options.projectId);
		OptionsController.setEnableEmbedded(options.enableEmbedded);
		OptionsController.setAllWallets(options.allWallets);
		OptionsController.setIncludeWalletIds(options.includeWalletIds);
		OptionsController.setExcludeWalletIds(options.excludeWalletIds);
		OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
		OptionsController.setTokens(options.tokens);
		OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
		OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
		OptionsController.setCustomWallets(options.customWallets);
		OptionsController.setFeatures(options.features);
		OptionsController.setAllowUnsupportedChain(options.allowUnsupportedChain);
		OptionsController.setDefaultAccountTypes(options.defaultAccountTypes);
		OptionsController.setUniversalProviderConfigOverride(options.universalProviderConfigOverride);
		const defaultMetaData = this.getDefaultMetaData();
		if (!options.metadata && defaultMetaData) options.metadata = defaultMetaData;
		OptionsController.setMetadata(options.metadata);
		OptionsController.setDisableAppend(options.disableAppend);
		OptionsController.setEnableEmbedded(options.enableEmbedded);
		OptionsController.setSIWX(options.siwx);
		if (!options.projectId) {
			AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
			return;
		}
		if (options.adapters?.find((adapter) => adapter.namespace === ConstantsUtil.CHAIN.EVM)) {
			if (options.siweConfig) {
				if (options.siwx) throw new Error("Cannot set both `siweConfig` and `siwx` options");
				OptionsController.setSIWX(options.siweConfig.mapToSIWX());
			}
		}
	}
	getDefaultMetaData() {
		if (typeof window !== "undefined" && typeof document !== "undefined") return {
			name: document.getElementsByTagName("title")?.[0]?.textContent || "",
			description: document.querySelector("meta[property=\"og:description\"]")?.content || "",
			url: window.location.origin,
			icons: [document.querySelector("link[rel~=\"icon\"]")?.href || ""]
		};
		return null;
	}
	setUnsupportedNetwork(chainId) {
		const namespace = this.getActiveChainNamespace();
		if (namespace) {
			const unsupportedNetwork = CaipNetworksUtil.getUnsupportedNetwork(`${namespace}:${chainId}`);
			ChainController.setActiveCaipNetwork(unsupportedNetwork);
		}
	}
	getDefaultNetwork() {
		return CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork);
	}
	extendCaipNetwork(network, options) {
		return CaipNetworksUtil.extendCaipNetwork(network, {
			customNetworkImageUrls: options.chainImages,
			projectId: options.projectId
		});
	}
	extendCaipNetworks(options) {
		return CaipNetworksUtil.extendCaipNetworks(options.networks, {
			customNetworkImageUrls: options.chainImages,
			customRpcUrls: options.customRpcUrls,
			projectId: options.projectId
		});
	}
	extendDefaultCaipNetwork(options) {
		const defaultNetwork = options.networks.find((n$2) => n$2.id === options.defaultNetwork?.id);
		return defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
			customNetworkImageUrls: options.chainImages,
			customRpcUrls: options.customRpcUrls,
			projectId: options.projectId
		}) : void 0;
	}
	createClients() {
		this.connectionControllerClient = {
			connectWalletConnect: async () => {
				const activeChain = ChainController.state.activeChain;
				const adapter = this.getAdapter(activeChain);
				const chainId = this.getCaipNetwork(activeChain)?.id;
				if (!adapter) throw new Error("Adapter not found");
				const result = await adapter.connectWalletConnect(chainId);
				this.close();
				this.setClientId(result?.clientId || null);
				StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
				this.chainNamespaces.forEach((namespace) => {
					ConnectorController.setConnectorId(ConstantsUtil$1.CONNECTOR_TYPE_WALLET_CONNECT, namespace);
				});
				await this.syncWalletConnectAccount();
			},
			connectExternal: async ({ id, info, type, provider, chain, caipNetwork }) => {
				const activeChain = ChainController.state.activeChain;
				const chainToUse = chain || activeChain;
				const adapter = this.getAdapter(chainToUse);
				if (chain && chain !== activeChain && !caipNetwork) {
					const toConnectNetwork = this.caipNetworks?.find((network) => network.chainNamespace === chain);
					if (toConnectNetwork) this.setCaipNetwork(toConnectNetwork);
				}
				if (!adapter) throw new Error("Adapter not found");
				const fallbackCaipNetwork = this.getCaipNetwork(chainToUse);
				const res = await adapter.connect({
					id,
					info,
					type,
					provider,
					chainId: caipNetwork?.id || fallbackCaipNetwork?.id,
					rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0] || fallbackCaipNetwork?.rpcUrls?.default?.http?.[0]
				});
				if (!res) return;
				StorageUtil.addConnectedNamespace(chainToUse);
				this.syncProvider({
					...res,
					chainNamespace: chainToUse
				});
				await this.syncAccount({
					...res,
					chainNamespace: chainToUse
				});
				const { accounts } = await adapter.getAccounts({
					namespace: chainToUse,
					id
				});
				this.setAllAccounts(accounts, chainToUse);
			},
			reconnectExternal: async ({ id, info, type, provider }) => {
				const namespace = ChainController.state.activeChain;
				const adapter = this.getAdapter(namespace);
				if (adapter?.reconnect) {
					await adapter?.reconnect({
						id,
						info,
						type,
						provider,
						chainId: this.getCaipNetwork()?.id
					});
					StorageUtil.addConnectedNamespace(namespace);
				}
			},
			disconnect: async (chainNamespace) => {
				const namespace = chainNamespace || ChainController.state.activeChain;
				const adapter = this.getAdapter(namespace);
				const provider = ProviderUtil.getProvider(namespace);
				const providerType = ProviderUtil.getProviderId(namespace);
				await adapter?.disconnect({
					provider,
					providerType
				});
				StorageUtil.removeConnectedNamespace(namespace);
				ProviderUtil.resetChain(namespace);
				this.setUser(void 0, namespace);
				this.setStatus("disconnected", namespace);
				this.hasSwitchedToPreferredAccountTypeOnConnect = false;
			},
			checkInstalled: (ids) => {
				if (!ids) return Boolean(window.ethereum);
				return ids.some((id) => Boolean(window.ethereum?.[String(id)]));
			},
			signMessage: async (message) => {
				return (await this.getAdapter(ChainController.state.activeChain)?.signMessage({
					message,
					address: AccountController.state.address,
					provider: ProviderUtil.getProvider(ChainController.state.activeChain)
				}))?.signature || "";
			},
			sendTransaction: async (args) => {
				if (args.chainNamespace === ConstantsUtil.CHAIN.EVM) {
					const adapter = this.getAdapter(ChainController.state.activeChain);
					const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
					return (await adapter?.sendTransaction({
						...args,
						caipNetwork: this.getCaipNetwork(),
						provider
					}))?.hash || "";
				}
				return "";
			},
			estimateGas: async (args) => {
				if (args.chainNamespace === ConstantsUtil.CHAIN.EVM) {
					const adapter = this.getAdapter(ChainController.state.activeChain);
					const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
					const caipNetwork = this.getCaipNetwork();
					if (!caipNetwork) throw new Error("CaipNetwork is undefined");
					return (await adapter?.estimateGas({
						...args,
						provider,
						caipNetwork
					}))?.gas || 0n;
				}
				return 0n;
			},
			getEnsAvatar: async () => {
				return (await this.getAdapter(ChainController.state.activeChain)?.getProfile({
					address: AccountController.state.address,
					chainId: Number(this.getCaipNetwork()?.id)
				}))?.profileImage || false;
			},
			getEnsAddress: async (name) => {
				const adapter = this.getAdapter(ChainController.state.activeChain);
				const caipNetwork = this.getCaipNetwork();
				if (!caipNetwork) return false;
				return (await adapter?.getEnsAddress({
					name,
					caipNetwork
				}))?.address || false;
			},
			writeContract: async (args) => {
				const adapter = this.getAdapter(ChainController.state.activeChain);
				const caipNetwork = this.getCaipNetwork();
				const caipAddress = this.getCaipAddress();
				const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
				if (!caipNetwork || !caipAddress) throw new Error("CaipNetwork or CaipAddress is undefined");
				return (await adapter?.writeContract({
					...args,
					caipNetwork,
					provider,
					caipAddress
				}))?.hash;
			},
			parseUnits: (value, decimals) => {
				return this.getAdapter(ChainController.state.activeChain)?.parseUnits({
					value,
					decimals
				}) ?? 0n;
			},
			formatUnits: (value, decimals) => {
				return this.getAdapter(ChainController.state.activeChain)?.formatUnits({
					value,
					decimals
				}) ?? "0";
			},
			getCapabilities: async (params) => {
				return await this.getAdapter(ChainController.state.activeChain)?.getCapabilities(params);
			},
			grantPermissions: async (params) => {
				return await this.getAdapter(ChainController.state.activeChain)?.grantPermissions(params);
			},
			revokePermissions: async (params) => {
				const adapter = this.getAdapter(ChainController.state.activeChain);
				if (adapter?.revokePermissions) return await adapter.revokePermissions(params);
				return "0x";
			},
			walletGetAssets: async (params) => {
				return await this.getAdapter(ChainController.state.activeChain)?.walletGetAssets(params) ?? {};
			}
		};
		this.networkControllerClient = {
			switchCaipNetwork: async (caipNetwork) => await this.switchCaipNetwork(caipNetwork),
			getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
		};
		ConnectionController.setClient(this.connectionControllerClient);
	}
	getApprovedCaipNetworksData() {
		if (ProviderUtil.getProviderId(ChainController.state.activeChain) === ConstantsUtil$1.CONNECTOR_TYPE_WALLET_CONNECT) {
			const namespaces = this.universalProvider?.session?.namespaces;
			return {
				supportsAllNetworks: this.universalProvider?.session?.peer?.metadata.name === "MetaMask Wallet",
				approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
			};
		}
		return {
			supportsAllNetworks: true,
			approvedCaipNetworkIds: []
		};
	}
	async switchCaipNetwork(caipNetwork) {
		if (!caipNetwork) return;
		const networkNamespace = caipNetwork.chainNamespace;
		if (this.getAddressByChainNamespace(caipNetwork.chainNamespace)) {
			const provider = ProviderUtil.getProvider(networkNamespace);
			const providerType = ProviderUtil.getProviderId(networkNamespace);
			if (caipNetwork.chainNamespace === ChainController.state.activeChain) await this.getAdapter(networkNamespace)?.switchNetwork({
				caipNetwork,
				provider,
				providerType
			});
			else {
				this.setCaipNetwork(caipNetwork);
				if (providerType === ConstantsUtil$1.CONNECTOR_TYPE_WALLET_CONNECT) this.syncWalletConnectAccount();
				else {
					const address = this.getAddressByChainNamespace(networkNamespace);
					if (address) this.syncAccount({
						address,
						chainId: caipNetwork.id,
						chainNamespace: networkNamespace
					});
				}
			}
		} else this.setCaipNetwork(caipNetwork);
	}
	getChainsFromNamespaces(namespaces = {}) {
		return Object.values(namespaces).flatMap((namespace) => {
			const chains = namespace.chains || [];
			const accountsChains = namespace.accounts.map((account) => {
				const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(account);
				return `${chainNamespace}:${chainId}`;
			});
			return Array.from(new Set([...chains, ...accountsChains]));
		});
	}
	createAdapters(blueprints) {
		this.createClients();
		return this.chainNamespaces.reduce((adapters, namespace) => {
			const blueprint = blueprints?.find((b$3) => b$3.namespace === namespace);
			if (blueprint) {
				adapters[namespace] = blueprint;
				adapters[namespace].namespace = namespace;
				adapters[namespace].construct({
					namespace,
					projectId: this.options?.projectId,
					networks: this.caipNetworks
				});
			} else adapters[namespace] = new UniversalAdapter({
				namespace,
				networks: this.caipNetworks
			});
			return adapters;
		}, {});
	}
	async initChainAdapter(namespace) {
		this.onConnectors(namespace);
		this.listenAdapter(namespace);
		this.chainAdapters?.[namespace].syncConnectors(this.options, this);
		await this.createUniversalProviderForAdapter(namespace);
	}
	async initChainAdapters() {
		await Promise.all(this.chainNamespaces.map(async (namespace) => {
			await this.initChainAdapter(namespace);
		}));
	}
	onConnectors(chainNamespace) {
		this.getAdapter(chainNamespace)?.on("connectors", this.setConnectors.bind(this));
	}
	listenAdapter(chainNamespace) {
		const adapter = this.getAdapter(chainNamespace);
		if (!adapter) return;
		const connectionStatus = StorageUtil.getConnectionStatus();
		if (connectionStatus === "connected") this.setStatus("connecting", chainNamespace);
		else if (connectionStatus === "disconnected") {
			StorageUtil.clearAddressCache();
			this.setStatus(connectionStatus, chainNamespace);
		} else this.setStatus(connectionStatus, chainNamespace);
		adapter.on("switchNetwork", ({ address, chainId }) => {
			const caipNetwork = this.caipNetworks?.find((n$2) => n$2.id === chainId || n$2.caipNetworkId === chainId);
			const isSameNamespace = ChainController.state.activeChain === chainNamespace;
			const accountAddress = ChainController.getAccountProp("address", chainNamespace);
			if (caipNetwork) {
				const account = isSameNamespace && address ? address : accountAddress;
				if (account) this.syncAccount({
					address: account,
					chainId,
					chainNamespace
				});
			} else this.setUnsupportedNetwork(chainId);
		});
		adapter.on("disconnect", this.disconnect.bind(this, chainNamespace));
		adapter.on("pendingTransactions", () => {
			const address = AccountController.state.address;
			const activeCaipNetwork = ChainController.state.activeCaipNetwork;
			if (!address || !activeCaipNetwork?.id) return;
			this.updateNativeBalance(address, activeCaipNetwork.id, activeCaipNetwork.chainNamespace);
		});
		adapter.on("accountChanged", ({ address, chainId }) => {
			const isActiveChain = ChainController.state.activeChain === chainNamespace;
			if (isActiveChain && chainId) this.syncAccount({
				address,
				chainId,
				chainNamespace
			});
			else if (isActiveChain && ChainController.state.activeCaipNetwork?.id) this.syncAccount({
				address,
				chainId: ChainController.state.activeCaipNetwork?.id,
				chainNamespace
			});
			else this.syncAccountInfo(address, chainId, chainNamespace);
		});
	}
	async createUniversalProviderForAdapter(chainNamespace) {
		await this.getUniversalProvider();
		if (this.universalProvider) this.chainAdapters?.[chainNamespace]?.setUniversalProvider?.(this.universalProvider);
	}
	async syncExistingConnection() {
		await Promise.allSettled(this.chainNamespaces.map((namespace) => this.syncNamespaceConnection(namespace)));
	}
	async syncNamespaceConnection(namespace) {
		try {
			const connectorId = ConnectorController.getConnectorId(namespace);
			this.setStatus("connecting", namespace);
			switch (connectorId) {
				case ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:
					await this.syncWalletConnectAccount();
					break;
				case ConstantsUtil.CONNECTOR_ID.AUTH: break;
				default: await this.syncAdapterConnection(namespace);
			}
		} catch (err) {
			console.warn("AppKit couldn't sync existing connection", err);
			this.setStatus("disconnected", namespace);
		}
	}
	async syncAdapterConnection(namespace) {
		const adapter = this.getAdapter(namespace);
		const connectorId = ConnectorController.getConnectorId(namespace);
		const caipNetwork = this.getCaipNetwork(namespace);
		const connector = ConnectorController.getConnectors(namespace).find((c$3) => c$3.id === connectorId);
		try {
			if (!adapter || !connector) throw new Error(`Adapter or connector not found for namespace ${namespace}`);
			if (!caipNetwork?.id) throw new Error("CaipNetwork not found");
			const connection = await adapter?.syncConnection({
				namespace,
				id: connector.id,
				chainId: caipNetwork.id,
				rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0]
			});
			if (connection) {
				const accounts = await adapter?.getAccounts({
					namespace,
					id: connector.id
				});
				if (accounts && accounts.accounts.length > 0) this.setAllAccounts(accounts.accounts, namespace);
				else this.setAllAccounts([CoreHelperUtil.createAccount(namespace, connection.address, "eoa")], namespace);
				this.syncProvider({
					...connection,
					chainNamespace: namespace
				});
				await this.syncAccount({
					...connection,
					chainNamespace: namespace
				});
				this.setStatus("connected", namespace);
			} else this.setStatus("disconnected", namespace);
		} catch (e) {
			this.setStatus("disconnected", namespace);
		}
	}
	async syncWalletConnectAccount() {
		const syncTasks = this.chainNamespaces.map(async (chainNamespace) => {
			const adapter = this.getAdapter(chainNamespace);
			const namespaceAccounts = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts || [];
			const activeChainId = ChainController.state.activeCaipNetwork?.id;
			const sessionAddress = namespaceAccounts.find((account) => {
				const { chainId } = ParseUtil.parseCaipAddress(account);
				return chainId === activeChainId?.toString();
			}) || namespaceAccounts[0];
			if (sessionAddress) {
				const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);
				const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
				ProviderUtil.setProviderId(chainNamespace, ConstantsUtil$1.CONNECTOR_TYPE_WALLET_CONNECT);
				if (this.caipNetworks && ChainController.state.activeCaipNetwork && adapter?.namespace !== ConstantsUtil.CHAIN.EVM) {
					const provider = adapter?.getWalletConnectProvider({
						caipNetworks: this.caipNetworks,
						provider: this.universalProvider,
						activeCaipNetwork: ChainController.state.activeCaipNetwork
					});
					ProviderUtil.setProvider(chainNamespace, provider);
				} else ProviderUtil.setProvider(chainNamespace, this.universalProvider);
				ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT, chainNamespace);
				StorageUtil.addConnectedNamespace(chainNamespace);
				this.syncWalletConnectAccounts(chainNamespace);
				await this.syncAccount({
					address,
					chainId,
					chainNamespace
				});
			} else this.setStatus("disconnected", chainNamespace);
			await ChainController.setApprovedCaipNetworksData(chainNamespace);
		});
		await Promise.all(syncTasks);
	}
	syncWalletConnectAccounts(chainNamespace) {
		const addresses = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts?.map((account) => {
			const { address } = ParseUtil.parseCaipAddress(account);
			return address;
		}).filter((address, index$1, self$1) => self$1.indexOf(address) === index$1);
		if (addresses) this.setAllAccounts(addresses.map((address) => CoreHelperUtil.createAccount(chainNamespace, address, chainNamespace === "bip122" ? "payment" : "eoa")), chainNamespace);
	}
	syncProvider({ type, provider, id, chainNamespace }) {
		ProviderUtil.setProviderId(chainNamespace, type);
		ProviderUtil.setProvider(chainNamespace, provider);
		ConnectorController.setConnectorId(id, chainNamespace);
	}
	async syncAccount(params) {
		const isActiveNamespace = params.chainNamespace === ChainController.state.activeChain;
		const networkOfChain = ChainController.getCaipNetworkByNamespace(params.chainNamespace, params.chainId);
		const { address, chainId, chainNamespace } = params;
		const { chainId: activeChainId } = StorageUtil.getActiveNetworkProps();
		const chainIdToUse = chainId || activeChainId;
		const isUnsupportedNetwork = ChainController.state.activeCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME;
		const shouldSupportAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", chainNamespace);
		this.setStatus("connected", chainNamespace);
		if (isUnsupportedNetwork && !shouldSupportAllNetworks) return;
		if (chainIdToUse) {
			let caipNetwork = this.caipNetworks?.find((n$2) => n$2.id.toString() === chainIdToUse.toString());
			let fallbackCaipNetwork = this.caipNetworks?.find((n$2) => n$2.chainNamespace === chainNamespace);
			if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {
				const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];
				const caipNetworkId = caipNetworkIds.find((id) => ParseUtil.parseCaipNetworkId(id)?.chainId === chainIdToUse.toString());
				const fallBackCaipNetworkId = caipNetworkIds.find((id) => ParseUtil.parseCaipNetworkId(id)?.chainNamespace === chainNamespace);
				caipNetwork = this.caipNetworks?.find((n$2) => n$2.caipNetworkId === caipNetworkId);
				fallbackCaipNetwork = this.caipNetworks?.find((n$2) => n$2.caipNetworkId === fallBackCaipNetworkId || "deprecatedCaipNetworkId" in n$2 && n$2.deprecatedCaipNetworkId === fallBackCaipNetworkId);
			}
			const network = caipNetwork || fallbackCaipNetwork;
			if (network?.chainNamespace === ChainController.state.activeChain) if (OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && ChainController.state.activeCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME) ChainController.showUnsupportedChainUI();
			else this.setCaipNetwork(network);
			else if (!isActiveNamespace) {
				if (networkOfChain) this.setCaipNetworkOfNamespace(networkOfChain, chainNamespace);
			}
			this.syncConnectedWalletInfo(chainNamespace);
			if (!HelpersUtil.isLowerCaseMatch(address, AccountController.state.address)) this.syncAccountInfo(address, network?.id, chainNamespace);
			if (isActiveNamespace) await this.syncBalance({
				address,
				chainId: network?.id,
				chainNamespace
			});
			else await this.syncBalance({
				address,
				chainId: networkOfChain?.id,
				chainNamespace
			});
		}
	}
	async syncAccountInfo(address, chainId, chainNamespace) {
		const caipAddress = this.getCaipAddress(chainNamespace);
		const newChainId = chainId || caipAddress?.split(":")[1];
		if (!newChainId) return;
		const newCaipAddress = `${chainNamespace}:${newChainId}:${address}`;
		this.setCaipAddress(newCaipAddress, chainNamespace);
		await this.syncIdentity({
			address,
			chainId: newChainId,
			chainNamespace
		});
	}
	async syncReownName(address, chainNamespace) {
		try {
			const registeredWcNames = await this.getReownName(address);
			if (registeredWcNames[0]) {
				const wcName = registeredWcNames[0];
				this.setProfileName(wcName.name, chainNamespace);
			} else this.setProfileName(null, chainNamespace);
		} catch {
			this.setProfileName(null, chainNamespace);
		}
	}
	syncConnectedWalletInfo(chainNamespace) {
		const connectorId = ConnectorController.getConnectorId(chainNamespace);
		const providerType = ProviderUtil.getProviderId(chainNamespace);
		if (providerType === ConstantsUtil$1.CONNECTOR_TYPE_ANNOUNCED || providerType === ConstantsUtil$1.CONNECTOR_TYPE_INJECTED) {
			if (connectorId) {
				const connector = this.getConnectors().find((c$3) => c$3.id === connectorId);
				if (connector) {
					const { info, name, imageUrl } = connector;
					const icon$1 = imageUrl || this.getConnectorImage(connector);
					this.setConnectedWalletInfo({
						name,
						icon: icon$1,
						...info
					}, chainNamespace);
				}
			}
		} else if (providerType === ConstantsUtil$1.CONNECTOR_TYPE_WALLET_CONNECT) {
			const provider = ProviderUtil.getProvider(chainNamespace);
			if (provider?.session) this.setConnectedWalletInfo({
				...provider.session.peer.metadata,
				name: provider.session.peer.metadata.name,
				icon: provider.session.peer.metadata.icons?.[0]
			}, chainNamespace);
		} else if (connectorId) if (connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE) {
			const connector = this.getConnectors().find((c$3) => c$3.id === ConstantsUtil.CONNECTOR_ID.COINBASE);
			this.setConnectedWalletInfo({
				name: "Coinbase Wallet",
				icon: this.getConnectorImage(connector)
			}, chainNamespace);
		} else this.setConnectedWalletInfo({ name: connectorId }, chainNamespace);
	}
	async syncBalance(params) {
		if (!NetworkUtil.getNetworksByNamespace(this.caipNetworks, params.chainNamespace).find((n$2) => n$2.id.toString() === params.chainId?.toString()) || !params.chainId) return;
		await this.updateNativeBalance(params.address, params.chainId, params.chainNamespace);
	}
	async updateNativeBalance(address, chainId, namespace) {
		const adapter = this.getAdapter(namespace);
		if (adapter) {
			const balance = await adapter.getBalance({
				address,
				chainId,
				caipNetwork: this.getCaipNetwork(namespace),
				tokens: this.options.tokens
			});
			this.setBalance(balance.balance, balance.symbol, namespace);
		}
	}
	async initializeUniversalAdapter() {
		const logger = LoggerUtil.createLogger((error, ...args) => {
			if (error) this.handleAlertError(error);
			console.error(...args);
		});
		const universalProviderOptions = {
			projectId: this.options?.projectId,
			metadata: {
				name: this.options?.metadata ? this.options?.metadata.name : "",
				description: this.options?.metadata ? this.options?.metadata.description : "",
				url: this.options?.metadata ? this.options?.metadata.url : "",
				icons: this.options?.metadata ? this.options?.metadata.icons : [""]
			},
			logger
		};
		OptionsController.setManualWCControl(Boolean(this.options?.manualWCControl));
		this.universalProvider = this.options.universalProvider ?? await x.init(universalProviderOptions);
		this.listenWalletConnect();
	}
	listenWalletConnect() {
		if (this.universalProvider) {
			this.universalProvider.on("display_uri", (uri) => {
				ConnectionController.setUri(uri);
			});
			this.universalProvider.on("connect", ConnectionController.finalizeWcConnection);
			this.universalProvider.on("disconnect", () => {
				this.chainNamespaces.forEach((namespace) => {
					this.resetAccount(namespace);
				});
				ConnectionController.resetWcConnection();
			});
			this.universalProvider.on("chainChanged", (chainId) => {
				const caipNetwork = this.caipNetworks?.find((c$3) => c$3.id == chainId);
				const currentCaipNetwork = this.getCaipNetwork();
				if (!caipNetwork) {
					this.setUnsupportedNetwork(chainId);
					return;
				}
				if (currentCaipNetwork?.id !== caipNetwork?.id) this.setCaipNetwork(caipNetwork);
			});
			this.universalProvider.on("session_event", (callbackData) => {
				if (WcHelpersUtil.isSessionEventData(callbackData)) {
					const { name, data } = callbackData.params.event;
					if (name === "accountsChanged" && Array.isArray(data) && CoreHelperUtil.isCaipAddress(data[0])) this.syncAccount(ParseUtil.parseCaipAddress(data[0]));
				}
			});
		}
	}
	createUniversalProvider() {
		if (!this.universalProviderInitPromise && CoreHelperUtil.isClient() && this.options?.projectId) this.universalProviderInitPromise = this.initializeUniversalAdapter();
		return this.universalProviderInitPromise;
	}
	async getUniversalProvider() {
		if (!this.universalProvider) try {
			await this.createUniversalProvider();
		} catch (err) {
			EventsController.sendEvent({
				type: "error",
				event: "INTERNAL_SDK_ERROR",
				properties: {
					errorType: "UniversalProviderInitError",
					errorMessage: err instanceof Error ? err.message : "Unknown",
					uncaught: false
				}
			});
			console.error("AppKit:getUniversalProvider - Cannot create provider", err);
		}
		return this.universalProvider;
	}
	handleAlertError(error) {
		const [errorKey, errorValue] = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, { message: message$1 }]) => error.message.includes(message$1)) ?? [];
		const { message, alertErrorKey } = errorValue ?? {};
		if (errorKey && message && !this.reportedAlertErrors[errorKey]) {
			const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];
			if (alertError) {
				AlertController.open(alertError, "error");
				this.reportedAlertErrors[errorKey] = true;
			}
		}
	}
	getAdapter(namespace) {
		if (!namespace) return;
		return this.chainAdapters?.[namespace];
	}
	createAdapter(blueprint) {
		if (!blueprint) return;
		const namespace = blueprint.namespace;
		if (!namespace) return;
		this.createClients();
		const adapterBlueprint = blueprint;
		adapterBlueprint.namespace = namespace;
		adapterBlueprint.construct({
			namespace,
			projectId: this.options?.projectId,
			networks: this.caipNetworks
		});
		if (!this.chainNamespaces.includes(namespace)) this.chainNamespaces.push(namespace);
		if (this.chainAdapters) this.chainAdapters[namespace] = adapterBlueprint;
	}
	async open(options) {
		await this.injectModalUi();
		if (options?.uri) ConnectionController.setUri(options.uri);
		await ModalController.open(options);
	}
	async close() {
		await this.injectModalUi();
		ModalController.close();
	}
	setLoading(loading, namespace) {
		ModalController.setLoading(loading, namespace);
	}
	async disconnect(chainNamespace) {
		await ConnectionController.disconnect(chainNamespace);
	}
	getError() {
		return "";
	}
	getChainId() {
		return ChainController.state.activeCaipNetwork?.id;
	}
	async switchNetwork(appKitNetwork) {
		const network = this.caipNetworks?.find((n$2) => n$2.id === appKitNetwork.id);
		if (!network) {
			AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
			return;
		}
		await ChainController.switchActiveNetwork(network);
	}
	getWalletProvider() {
		return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;
	}
	getWalletProviderType() {
		return ProviderUtil.getProviderId(ChainController.state.activeChain);
	}
	subscribeProviders(callback) {
		return ProviderUtil.subscribeProviders(callback);
	}
	getThemeMode() {
		return ThemeController.state.themeMode;
	}
	getThemeVariables() {
		return ThemeController.state.themeVariables;
	}
	setThemeMode(themeMode) {
		ThemeController.setThemeMode(themeMode);
		setColorTheme(ThemeController.state.themeMode);
	}
	setTermsConditionsUrl(termsConditionsUrl) {
		OptionsController.setTermsConditionsUrl(termsConditionsUrl);
	}
	setPrivacyPolicyUrl(privacyPolicyUrl) {
		OptionsController.setPrivacyPolicyUrl(privacyPolicyUrl);
	}
	setThemeVariables(themeVariables) {
		ThemeController.setThemeVariables(themeVariables);
		setThemeVariables(ThemeController.state.themeVariables);
	}
	subscribeTheme(callback) {
		return ThemeController.subscribe(callback);
	}
	getWalletInfo() {
		return AccountController.state.connectedWalletInfo;
	}
	getAccount(namespace) {
		const authConnector = ConnectorController.getAuthConnector(namespace);
		const accountState = ChainController.getAccountData(namespace);
		if (!accountState) return;
		return {
			allAccounts: accountState.allAccounts,
			caipAddress: accountState.caipAddress,
			address: CoreHelperUtil.getPlainAddress(accountState.caipAddress),
			isConnected: Boolean(accountState.caipAddress),
			status: accountState.status,
			embeddedWalletInfo: authConnector ? {
				user: accountState.user,
				authProvider: accountState.socialProvider || "email",
				accountType: accountState.preferredAccountType,
				isSmartAccountDeployed: Boolean(accountState.smartAccountDeployed)
			} : void 0
		};
	}
	subscribeAccount(callback, namespace) {
		const updateVal = () => {
			const account = this.getAccount(namespace);
			if (!account) return;
			callback(account);
		};
		if (namespace) ChainController.subscribeChainProp("accountState", updateVal, namespace);
		else ChainController.subscribe(updateVal);
		ConnectorController.subscribe(updateVal);
	}
	subscribeNetwork(callback) {
		return ChainController.subscribe(({ activeCaipNetwork }) => {
			callback({
				caipNetwork: activeCaipNetwork,
				chainId: activeCaipNetwork?.id,
				caipNetworkId: activeCaipNetwork?.caipNetworkId
			});
		});
	}
	subscribeWalletInfo(callback) {
		return AccountController.subscribeKey("connectedWalletInfo", callback);
	}
	subscribeShouldUpdateToAddress(callback) {
		AccountController.subscribeKey("shouldUpdateToAddress", callback);
	}
	subscribeCaipNetworkChange(callback) {
		ChainController.subscribeKey("activeCaipNetwork", callback);
	}
	getState() {
		return PublicStateController.state;
	}
	subscribeState(callback) {
		return PublicStateController.subscribe(callback);
	}
	showErrorMessage(message) {
		SnackController.showError(message);
	}
	showSuccessMessage(message) {
		SnackController.showSuccess(message);
	}
	getEvent() {
		return { ...EventsController.state };
	}
	subscribeEvents(callback) {
		return EventsController.subscribe(callback);
	}
	replace(route) {
		RouterController.replace(route);
	}
	redirect(route) {
		RouterController.push(route);
	}
	popTransactionStack(cancel) {
		RouterController.popTransactionStack(cancel);
	}
	isOpen() {
		return ModalController.state.open;
	}
	isTransactionStackEmpty() {
		return RouterController.state.transactionStack.length === 0;
	}
	isTransactionShouldReplaceView() {
		return RouterController.state.transactionStack[RouterController.state.transactionStack.length - 1]?.replace;
	}
	static getInstance() {
		return this.instance;
	}
	updateFeatures(newFeatures) {
		OptionsController.setFeatures(newFeatures);
	}
	updateOptions(newOptions) {
		const updatedOptions = {
			...OptionsController.state || {},
			...newOptions
		};
		OptionsController.setOptions(updatedOptions);
	}
	setConnectMethodsOrder(connectMethodsOrder) {
		OptionsController.setConnectMethodsOrder(connectMethodsOrder);
	}
	setWalletFeaturesOrder(walletFeaturesOrder) {
		OptionsController.setWalletFeaturesOrder(walletFeaturesOrder);
	}
	setCollapseWallets(collapseWallets) {
		OptionsController.setCollapseWallets(collapseWallets);
	}
	setSocialsOrder(socialsOrder) {
		OptionsController.setSocialsOrder(socialsOrder);
	}
	getConnectMethodsOrder() {
		return WalletUtil.getConnectOrderMethod(OptionsController.state.features, ConnectorController.getConnectors());
	}
	/**
	* Removes an adapter from the AppKit.
	* @param namespace - The namespace of the adapter to remove.
	*/
	removeAdapter(namespace) {
		const isConnected = this.getIsConnectedState();
		const adapter = this.getAdapter(namespace);
		if (!adapter || !this.chainAdapters || isConnected) return;
		const newCaipNetworks = this.caipNetworks?.filter((network) => network.chainNamespace !== namespace);
		ChainController.removeAdapter(namespace);
		ConnectorController.removeAdapter(namespace);
		this.chainNamespaces = this.chainNamespaces.filter((n$2) => n$2 !== namespace);
		this.caipNetworks = newCaipNetworks;
		adapter.removeAllEventListeners();
		Reflect.deleteProperty(this.chainAdapters, namespace);
	}
	/**
	* Adds an adapter to the AppKit.
	* @param adapter - The adapter instance.
	* @param networks - The list of networks that this adapter supports / uses.
	*/
	addAdapter(adapter, networks) {
		const namespace = adapter.namespace;
		if (!this.connectionControllerClient || !this.networkControllerClient) return;
		if (!this.chainAdapters || !namespace) return;
		const extendedAdapterNetworks = this.extendCaipNetworks({
			...this.options,
			networks
		});
		this.caipNetworks = [...this.caipNetworks || [], ...extendedAdapterNetworks];
		this.createAdapter(adapter);
		this.initChainAdapter(namespace);
		ChainController.addAdapter(adapter, {
			connectionControllerClient: this.connectionControllerClient,
			networkControllerClient: this.networkControllerClient
		}, extendedAdapterNetworks);
	}
	/**
	* Adds a network to an existing adapter in AppKit.
	* @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
	* @param network - The network configuration to add
	* @throws Error if adapter for namespace doesn't exist
	*/
	addNetwork(namespace, network) {
		if (this.chainAdapters && !this.chainAdapters[namespace]) throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
		const extendedNetwork = this.extendCaipNetwork(network, this.options);
		ChainController.addNetwork(extendedNetwork);
		if (this.caipNetworks && !this.caipNetworks?.find((n$2) => n$2.id === extendedNetwork.id)) this.caipNetworks.push(extendedNetwork);
	}
	/**
	* Removes a network from an existing adapter in AppKit.
	* @param namespace - The chain namespace the network belongs to
	* @param networkId - The network ID to remove
	* @throws Error if adapter for namespace doesn't exist or if removing last network
	*/
	removeNetwork(namespace, networkId) {
		if (this.chainAdapters && !this.chainAdapters[namespace]) throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
		if (!this.caipNetworks?.find((n$2) => n$2.id === networkId)) throw new Error(`Network with ID ${networkId} not found`);
		if (!this.caipNetworks) return;
		const remainingNetworks = this.caipNetworks.filter((n$2) => n$2.chainNamespace === namespace && n$2.id !== networkId);
		if (!remainingNetworks?.length) throw new Error("Cannot remove last network for a namespace");
		ChainController.removeNetwork(namespace, networkId);
		this.caipNetworks = [...remainingNetworks];
	}
};

//#endregion
//#region node_modules/@reown/appkit/dist/esm/src/client/appkit-core.js
var isInitialized = false;
var AppKit = class extends AppKitBaseClient {
	async open(options) {
		if (!ConnectorController.isConnected()) await super.open(options);
	}
	async close() {
		await super.close();
		if (this.options.manualWCControl) ConnectionController.finalizeWcConnection();
	}
	async syncIdentity(_request) {
		return Promise.resolve();
	}
	async syncBalance(_params) {
		return Promise.resolve();
	}
	async injectModalUi() {
		if (!isInitialized && CoreHelperUtil.isClient()) {
			await import("./basic-hsmRZgsx.js");
			await import("./w3m-modal-Ci6c8oT-.js");
			if (!document.querySelector("w3m-modal")) {
				const modal = document.createElement("w3m-modal");
				if (!OptionsController.state.disableAppend && !OptionsController.state.enableEmbedded) document.body.insertAdjacentElement("beforeend", modal);
			}
			isInitialized = true;
		}
	}
};

//#endregion
//#region node_modules/@reown/appkit/dist/esm/exports/constants.js
const PACKAGE_VERSION = "1.7.2";

//#endregion
//#region node_modules/@reown/appkit/dist/esm/exports/core.js
function createAppKit(options) {
	return new AppKit({
		...options,
		basic: true,
		sdkVersion: `html-core-${PACKAGE_VERSION}`
	});
}

//#endregion
//#region node_modules/@walletconnect/solana-adapter/node_modules/base-x/src/esm/index.js
function base(ALPHABET$3) {
	if (ALPHABET$3.length >= 255) throw new TypeError("Alphabet too long");
	const BASE_MAP = new Uint8Array(256);
	for (let j$2 = 0; j$2 < BASE_MAP.length; j$2++) BASE_MAP[j$2] = 255;
	for (let i$2 = 0; i$2 < ALPHABET$3.length; i$2++) {
		const x$6 = ALPHABET$3.charAt(i$2);
		const xc$1 = x$6.charCodeAt(0);
		if (BASE_MAP[xc$1] !== 255) throw new TypeError(x$6 + " is ambiguous");
		BASE_MAP[xc$1] = i$2;
	}
	const BASE = ALPHABET$3.length;
	const LEADER = ALPHABET$3.charAt(0);
	const FACTOR = Math.log(BASE) / Math.log(256);
	const iFACTOR = Math.log(256) / Math.log(BASE);
	function encode(source) {
		if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
		else if (Array.isArray(source)) source = Uint8Array.from(source);
		if (!(source instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
		if (source.length === 0) return "";
		let zeroes = 0;
		let length = 0;
		let pbegin = 0;
		const pend = source.length;
		while (pbegin !== pend && source[pbegin] === 0) {
			pbegin++;
			zeroes++;
		}
		const size$4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
		const b58 = new Uint8Array(size$4);
		while (pbegin !== pend) {
			let carry = source[pbegin];
			let i$2 = 0;
			for (let it1 = size$4 - 1; (carry !== 0 || i$2 < length) && it1 !== -1; it1--, i$2++) {
				carry += 256 * b58[it1] >>> 0;
				b58[it1] = carry % BASE >>> 0;
				carry = carry / BASE >>> 0;
			}
			if (carry !== 0) throw new Error("Non-zero carry");
			length = i$2;
			pbegin++;
		}
		let it2 = size$4 - length;
		while (it2 !== size$4 && b58[it2] === 0) it2++;
		let str = LEADER.repeat(zeroes);
		for (; it2 < size$4; ++it2) str += ALPHABET$3.charAt(b58[it2]);
		return str;
	}
	function decodeUnsafe(source) {
		if (typeof source !== "string") throw new TypeError("Expected String");
		if (source.length === 0) return new Uint8Array();
		let psz = 0;
		let zeroes = 0;
		let length = 0;
		while (source[psz] === LEADER) {
			zeroes++;
			psz++;
		}
		const size$4 = (source.length - psz) * FACTOR + 1 >>> 0;
		const b256 = new Uint8Array(size$4);
		while (psz < source.length) {
			const charCode = source.charCodeAt(psz);
			if (charCode > 255) return;
			let carry = BASE_MAP[charCode];
			if (carry === 255) return;
			let i$2 = 0;
			for (let it3 = size$4 - 1; (carry !== 0 || i$2 < length) && it3 !== -1; it3--, i$2++) {
				carry += BASE * b256[it3] >>> 0;
				b256[it3] = carry % 256 >>> 0;
				carry = carry / 256 >>> 0;
			}
			if (carry !== 0) throw new Error("Non-zero carry");
			length = i$2;
			psz++;
		}
		let it4 = size$4 - length;
		while (it4 !== size$4 && b256[it4] === 0) it4++;
		const vch = new Uint8Array(zeroes + (size$4 - it4));
		let j$2 = zeroes;
		while (it4 !== size$4) vch[j$2++] = b256[it4++];
		return vch;
	}
	function decode(string) {
		const buffer$1 = decodeUnsafe(string);
		if (buffer$1) return buffer$1;
		throw new Error("Non-base" + BASE + " character");
	}
	return {
		encode,
		decodeUnsafe,
		decode
	};
}
var esm_default$1 = base;

//#endregion
//#region node_modules/@walletconnect/solana-adapter/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default = esm_default$1(ALPHABET);

//#endregion
//#region node_modules/@walletconnect/solana-adapter/dist/errors/ClientNotInitializedError.js
var ClientNotInitializedError = class ClientNotInitializedError extends Error {
	constructor() {
		super();
		Object.setPrototypeOf(this, ClientNotInitializedError.prototype);
	}
};

//#endregion
//#region node_modules/@walletconnect/solana-adapter/dist/errors/WalletConnectNotSupportedError.js
var WalletConnectFeatureNotSupportedError = class extends Error {
	constructor(method) {
		super(`WalletConnect Adapter - Method ${method} is not supported by the wallet`);
		this.name = "WalletConnectFeatureNotSupportedError";
	}
};

//#endregion
//#region node_modules/@walletconnect/solana-adapter/dist/utils.js
function getChainsFromChainId(chainId) {
	let chains = [chainId];
	if (chainId === SolanaChainIDs.Mainnet || chainId === SolanaChainIDs.Deprecated_Mainnet) {
		chains = [SolanaChainIDs.Mainnet, SolanaChainIDs.Deprecated_Mainnet];
		if (chainId === SolanaChainIDs.Deprecated_Mainnet) console.warn(chainWarns.mainnet);
	} else if (chainId === SolanaChainIDs.Deprecated_Devnet || chainId === SolanaChainIDs.Devnet) {
		chains = [SolanaChainIDs.Devnet, SolanaChainIDs.Deprecated_Devnet];
		if (SolanaChainIDs.Deprecated_Devnet) console.warn(chainWarns.devnet);
	}
	return chains;
}
var chainWarns = {
	mainnet: `You are using a deprecated chain ID for Solana Mainnet, please use ${SolanaChainIDs.Mainnet} instead.`,
	devnet: `You are using a deprecated chain ID for Solana Devnet, please use ${SolanaChainIDs.Devnet} instead.`,
	wallet: "The connected wallet is using a deprecated chain ID for Solana. Please, contact them to upgrade. You can learn more at https://github.com/ChainAgnostic/namespaces/blob/main/solana/caip10.md#chain-ids"
};
function getDefaultChainFromSession(session, selectedChain) {
	const chains = session.namespaces["solana"]?.accounts.map((account) => `solana:${account.split(":")[1]}`);
	if (selectedChain === SolanaChainIDs.Mainnet) {
		if (chains?.find((chain) => chain === SolanaChainIDs.Mainnet)) return SolanaChainIDs.Mainnet;
		console.warn(chainWarns.wallet);
		return SolanaChainIDs.Deprecated_Mainnet;
	} else if (selectedChain === SolanaChainIDs.Devnet) {
		if (chains?.find((chain) => chain === SolanaChainIDs.Devnet)) return SolanaChainIDs.Devnet;
		console.warn(chainWarns.wallet);
		return SolanaChainIDs.Deprecated_Devnet;
	}
	throw Error("WalletConnect Solana Adapter: Unable to get a default chain from the session.");
}
function getConnectParams(chainId) {
	return { optionalNamespaces: { solana: {
		chains: getChainsFromChainId(chainId),
		methods: [WalletConnectRPCMethods.signTransaction, WalletConnectRPCMethods.signMessage],
		events: []
	} } };
}

//#endregion
//#region node_modules/@walletconnect/solana-adapter/dist/errors/QRCodeModalError.js
var QRCodeModalError = class QRCodeModalError extends Error {
	constructor() {
		super("QR Code Modal was closed by user");
		Object.setPrototypeOf(this, QRCodeModalError.prototype);
		this.name = "QRCodeModalError";
	}
};

//#endregion
//#region node_modules/@walletconnect/solana-adapter/dist/core.js
init_index_browser_esm();
var WalletConnectWallet = class {
	_UniversalProvider;
	_session;
	_modal;
	_projectId;
	_network;
	_ConnectQueueResolver;
	constructor(config) {
		this.initClient(config.options);
		this._network = config.network;
		if (!config.options.projectId) throw Error("WalletConnect Adapter: Project ID is undefined");
		this._projectId = config.options.projectId;
	}
	async connect() {
		if (!this._UniversalProvider) await new Promise((res) => {
			this._ConnectQueueResolver = res;
		});
		if (!this._UniversalProvider) throw new Error("WalletConnect Adapter - Universal Provider was undefined while calling 'connect()'");
		if (this._UniversalProvider.session) {
			this._session = this._UniversalProvider.session;
			const defaultNetwork = getDefaultChainFromSession(this._session, this._network);
			this._network = defaultNetwork;
			this._UniversalProvider.setDefaultChain(defaultNetwork);
			return { publicKey: this.publicKey };
		}
		await this.initModal();
		const params = getConnectParams(this._network);
		this._modal?.open();
		const controller = new AbortController();
		const signal = controller.signal;
		this._modal?.subscribeState((state$2) => {
			if (!state$2.open) controller.abort(new QRCodeModalError());
		});
		try {
			const session = await Promise.race([this._UniversalProvider?.connect(params), new Promise((_$4, reject) => {
				signal.addEventListener("abort", () => {
					reject(signal.reason);
				});
			})]);
			this._modal?.close();
			this._session = session;
			if (!session) throw new WalletConnectionError();
			const defaultNetwork = getDefaultChainFromSession(session, this._network);
			this._network = defaultNetwork;
			this._UniversalProvider?.setDefaultChain(defaultNetwork);
			return { publicKey: this.publicKey };
		} catch (error) {
			this._modal?.close();
			throw error;
		}
	}
	async disconnect() {
		if (this._UniversalProvider?.session) {
			await this.initModal();
			if (!this._modal) throw Error("WalletConnect Adapter -Modal is undefined: unable to disconnect");
			await this.client.disconnect();
			this._session = void 0;
		} else throw new ClientNotInitializedError();
	}
	get client() {
		if (this._UniversalProvider) return this._UniversalProvider;
		throw new ClientNotInitializedError();
	}
	get session() {
		if (!this._session) throw new ClientNotInitializedError();
		return this._session;
	}
	get publicKey() {
		if (this._UniversalProvider?.session && this._session) {
			const { address } = Xe(this._session?.namespaces["solana"]?.accounts[0] ?? "");
			return new PublicKey(address);
		}
		throw new ClientNotInitializedError();
	}
	async signTransaction(transaction) {
		this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signTransaction);
		const isVersioned = isVersionedTransaction(transaction);
		const legacyTransaction = isVersioned ? {} : transaction;
		const { signature, transaction: signedSerializedTransaction } = await this.client.client.request({
			chainId: this._network,
			topic: this.session.topic,
			request: {
				method: WalletConnectRPCMethods.signTransaction,
				params: {
					...legacyTransaction,
					transaction: this.serialize(transaction)
				}
			}
		});
		if (signedSerializedTransaction) return this.deserialize(signedSerializedTransaction, isVersioned);
		transaction.addSignature(this.publicKey, Buffer.from(esm_default.decode(signature)));
		return transaction;
	}
	async signMessage(message) {
		this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signMessage);
		const { signature } = await this.client.client.request({
			chainId: this._network,
			topic: this.session.topic,
			request: {
				method: WalletConnectRPCMethods.signMessage,
				params: {
					pubkey: this.publicKey.toString(),
					message: esm_default.encode(message)
				}
			}
		});
		return esm_default.decode(signature);
	}
	async signAndSendTransaction(transaction) {
		this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAndSendTransaction);
		const { signature } = await this.client.client.request({
			chainId: this._network,
			topic: this.session.topic,
			request: {
				method: WalletConnectRPCMethods.signAndSendTransaction,
				params: { transaction: this.serialize(transaction) }
			}
		});
		return signature;
	}
	async signAllTransactions(transactions) {
		try {
			this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAllTransactions);
			const serializedTransactions = transactions.map((transaction) => this.serialize(transaction));
			const { transactions: serializedSignedTransactions } = await this.client.client.request({
				chainId: this._network,
				topic: this.session.topic,
				request: {
					method: WalletConnectRPCMethods.signAllTransactions,
					params: { transactions: serializedTransactions }
				}
			});
			return transactions.map((transaction, index$1) => {
				if (isVersionedTransaction(transaction)) return this.deserialize(serializedSignedTransactions[index$1] ?? "", true);
				return this.deserialize(serializedSignedTransactions[index$1] ?? "");
			});
		} catch (error) {
			if (error instanceof WalletConnectFeatureNotSupportedError) {
				const promises = transactions.map((transaction) => this.signTransaction(transaction));
				return await Promise.all(promises);
			}
			throw error;
		}
	}
	async initClient(options) {
		this._UniversalProvider = await oh.init(options);
		if (this._ConnectQueueResolver) this._ConnectQueueResolver(true);
	}
	async initModal() {
		if (this._modal) return;
		if (!this._UniversalProvider) throw new Error("WalletConnect Adapter - cannot init modal when Universal Provider is undefined");
		this._modal = createAppKit({
			projectId: this._projectId,
			universalProvider: this._UniversalProvider,
			networks: [
				solana,
				solanaDevnet,
				solanaTestnet
			],
			manualWCControl: true
		});
	}
	serialize(transaction) {
		return Buffer.from(transaction.serialize({ verifySignatures: false })).toString("base64");
	}
	deserialize(serializedTransaction, versioned = false) {
		if (versioned) return VersionedTransaction.deserialize(Buffer.from(serializedTransaction, "base64"));
		return Transaction.from(Buffer.from(serializedTransaction, "base64"));
	}
	checkIfWalletSupportsMethod(method) {
		if (!this.session.namespaces["solana"]?.methods.includes(method)) throw new WalletConnectFeatureNotSupportedError(method);
	}
};

//#endregion
//#region node_modules/@walletconnect/solana-adapter/dist/adapter.js
const WalletConnectWalletName = "WalletConnect";
var WalletConnectWalletAdapter = class extends BaseSignerWalletAdapter {
	name = WalletConnectWalletName;
	url = "https://walletconnect.org";
	icon = "data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE4NSIgdmlld0JveD0iMCAwIDMwMCAxODUiIHdpZHRoPSIzMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTYxLjQzODU0MjkgMzYuMjU2MjYxMmM0OC45MTEyMjQxLTQ3Ljg4ODE2NjMgMTI4LjIxMTk4NzEtNDcuODg4MTY2MyAxNzcuMTIzMjA5MSAwbDUuODg2NTQ1IDUuNzYzNDE3NGMyLjQ0NTU2MSAyLjM5NDQwODEgMi40NDU1NjEgNi4yNzY1MTEyIDAgOC42NzA5MjA0bC0yMC4xMzY2OTUgMTkuNzE1NTAzYy0xLjIyMjc4MSAxLjE5NzIwNTEtMy4yMDUzIDEuMTk3MjA1MS00LjQyODA4MSAwbC04LjEwMDU4NC03LjkzMTE0NzljLTM0LjEyMTY5Mi0zMy40MDc5ODE3LTg5LjQ0Mzg4Ni0zMy40MDc5ODE3LTEyMy41NjU1Nzg4IDBsLTguNjc1MDU2MiA4LjQ5MzYwNTFjLTEuMjIyNzgxNiAxLjE5NzIwNDEtMy4yMDUzMDEgMS4xOTcyMDQxLTQuNDI4MDgwNiAwbC0yMC4xMzY2OTQ5LTE5LjcxNTUwMzFjLTIuNDQ1NTYxMi0yLjM5NDQwOTItMi40NDU1NjEyLTYuMjc2NTEyMiAwLTguNjcwOTIwNHptMjE4Ljc2Nzc5NjEgNDAuNzczNzQ0OSAxNy45MjE2OTcgMTcuNTQ2ODk3YzIuNDQ1NTQ5IDIuMzk0Mzk2OSAyLjQ0NTU2MyA2LjI3NjQ3NjkuMDAwMDMxIDguNjcwODg5OWwtODAuODEwMTcxIDc5LjEyMTEzNGMtMi40NDU1NDQgMi4zOTQ0MjYtNi40MTA1ODIgMi4zOTQ0NTMtOC44NTYxNi4wMDAwNjItLjAwMDAxLS4wMDAwMS0uMDAwMDIyLS4wMDAwMjItLjAwMDAzMi0uMDAwMDMybC01Ny4zNTQxNDMtNTYuMTU0NTcyYy0uNjExMzktLjU5ODYwMi0xLjYwMjY1LS41OTg2MDItMi4yMTQwNCAwLS4wMDAwMDQuMDAwMDA0LS4wMDAwMDcuMDAwMDA4LS4wMDAwMTEuMDAwMDExbC01Ny4zNTI5MjEyIDU2LjE1NDUzMWMtMi40NDU1MzY4IDIuMzk0NDMyLTYuNDEwNTc1NSAyLjM5NDQ3Mi04Ljg1NjE2MTIuMDAwMDg3LS4wMDAwMTQzLS4wMDAwMTQtLjAwMDAyOTYtLjAwMDAyOC0uMDAwMDQ0OS0uMDAwMDQ0bC04MC44MTI0MTk0My03OS4xMjIxODVjLTIuNDQ1NTYwMjEtMi4zOTQ0MDgtMi40NDU1NjAyMS02LjI3NjUxMTUgMC04LjY3MDkxOTdsMTcuOTIxNzI5NjMtMTcuNTQ2ODY3M2MyLjQ0NTU2MDItMi4zOTQ0MDgyIDYuNDEwNTk4OS0yLjM5NDQwODIgOC44NTYxNjAyIDBsNTcuMzU0OTc3NSA1Ni4xNTUzNTdjLjYxMTM5MDguNTk4NjAyIDEuNjAyNjQ5LjU5ODYwMiAyLjIxNDAzOTggMCAuMDAwMDA5Mi0uMDAwMDA5LjAwMDAxNzQtLjAwMDAxNy4wMDAwMjY1LS4wMDAwMjRsNTcuMzUyMTAzMS01Ni4xNTUzMzNjMi40NDU1MDUtMi4zOTQ0NjMzIDYuNDEwNTQ0LTIuMzk0NTUzMSA4Ljg1NjE2MS0uMDAwMi4wMDAwMzQuMDAwMDMzNi4wMDAwNjguMDAwMDY3My4wMDAxMDEuMDAwMTAxbDU3LjM1NDkwMiA1Ni4xNTU0MzJjLjYxMTM5LjU5ODYwMSAxLjYwMjY1LjU5ODYwMSAyLjIxNDA0IDBsNTcuMzUzOTc1LTU2LjE1NDMyNDljMi40NDU1NjEtMi4zOTQ0MDkyIDYuNDEwNTk5LTIuMzk0NDA5MiA4Ljg1NjE2IDB6IiBmaWxsPSIjM2I5OWZjIi8+PC9zdmc+";
	supportedTransactionVersions = new Set(["legacy", 0]);
	_publicKey;
	_connecting;
	_wallet;
	_config;
	_readyState;
	_onDisconnect;
	constructor(config) {
		super();
		this._publicKey = null;
		this._connecting = false;
		this._config = config;
		this._wallet = null;
		this._readyState = typeof window === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
		this._onDisconnect = this.disconnect.bind(this);
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Loadable) throw new WalletNotReadyError();
			this._connecting = true;
			this._wallet = new WalletConnectWallet({
				network: this._config.network === WalletAdapterNetwork.Mainnet ? WalletConnectChainID.Mainnet : WalletConnectChainID.Devnet,
				options: this._config.options
			});
			const { publicKey } = await this._wallet.connect();
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
			this._wallet.client.on("session_delete", this._onDisconnect);
		} catch (error) {
			if (error.constructor.name === "QRCodeModalError" || error instanceof Error && error.name === "QRCodeModalError") throw new WalletWindowClosedError();
			this._connecting = false;
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.client.off("session_delete", this._onDisconnect);
			this._publicKey = null;
			try {
				if (wallet.client.session) await wallet.disconnect();
			} catch (error) {
				console.error("WalletConnectWalletAdapter: disconnect error", error);
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signMessage(message);
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAndSendTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAndSendTransaction(transaction);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions);
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@solana/wallet-adapter-xdefi/lib/esm/adapter.js
init_index_browser_esm();
const XDEFIWalletName = "XDEFI";
var XDEFIWalletAdapter = class extends BaseMessageSignerWalletAdapter {
	constructor(config = {}) {
		super();
		this.name = XDEFIWalletName;
		this.url = "https://xdefi.io";
		this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE0LjI2MjggMTMuNDAxM0MxMi40MjI4IDE0LjUzMDcgOS45NTk5NyAxNS4xMTI0IDcuNDY1NjkgMTQuOTg4MUM1LjM2ODU1IDE0Ljg4NjUgMy42NDg1NSAxNC4xNDExIDIuNjA4NTUgMTIuOTE1N0MxLjY5NDI2IDExLjgyMDEgMS4zMzk5OCAxMC4zNzQ1IDEuNTc5OTggOC43MTE0M0MxLjY2MTMyIDguMTU4NzQgMS44MjgwMiA3LjYyMTY2IDIuMDc0MjYgNy4xMTg5NkwyLjEwODU1IDcuMDQ4MzdDMi45NzE4IDUuNDA1OTUgNC4yNTI5MyA0LjAxMzk3IDUuODI1ODQgMy4wMDk0MkM3LjM5ODc1IDIuMDA0ODYgOS4yMDkyNCAxLjQyMjM2IDExLjA3OTEgMS4zMTkyNEMxMi45NDkgMS4yMTYxMSAxNC44MTM4IDEuNTk1OTIgMTYuNDkwMSAyLjQyMTI4QzE4LjE2NjMgMy4yNDY2NSAxOS41OTYyIDQuNDg5MTIgMjAuNjM5IDYuMDI2NDFDMjEuNjgxOSA3LjU2MzcxIDIyLjMwMTcgOS4zNDI4NSAyMi40Mzc0IDExLjE4ODdDMjIuNTczMiAxMy4wMzQ2IDIyLjIyMDMgMTQuODgzNiAyMS40MTM0IDE2LjU1MzhDMjAuNjA2NSAxOC4yMjQgMTkuMzczNSAxOS42NTc3IDE3LjgzNTYgMjAuNzE0QzE2LjI5NzggMjEuNzcwMiAxNC41MDgxIDIyLjQxMjYgMTIuNjQyOCAyMi41Nzc4TDEyLjc1NzEgMjMuODczOEMxNC44NTE0IDIzLjY4OTQgMTYuODYxIDIyLjk2OTEgMTguNTg3OCAyMS43ODM3QzIwLjMxNDcgMjAuNTk4NCAyMS42OTkzIDE4Ljk4ODkgMjIuNjA1MiAxNy4xMTM4QzIzLjUxMTEgMTUuMjM4NyAyMy45MDcxIDEzLjE2MjcgMjMuNzU0MiAxMS4wOTA0QzIzLjYwMTIgOS4wMTgwOCAyMi45MDQ2IDcuMDIwODggMjEuNzMyOSA1LjI5NTU1QzIwLjU2MTMgMy41NzAyMiAxOC45NTUgMi4xNzYzIDE3LjA3MjQgMS4yNTExMUMxNS4xODk4IDAuMzI1OTA5IDEzLjA5NTcgLTAuMDk4NjQxMSAxMC45OTY1IDAuMDE5Mjc4N0M4Ljg5NzMzIDAuMTM3MTk4IDYuODY1NDQgMC43OTM1MiA1LjEwMTAyIDEuOTIzNTlDMy4zMzY2IDMuMDUzNjUgMS45MDA1MyA0LjYxODQ4IDAuOTM0MjY0IDYuNDYzOUwwLjg4ODU0OCA2LjU1NzA3QzAuNTgzMDgzIDcuMTgwOSAwLjM3Njg0NyA3Ljg0NzU2IDAuMjc3MTIgOC41MzM1NEMtMC4wMDg1OTQ1IDEwLjU2MDggMC40MzQyNiAxMi4zNjUxIDEuNTkxNCAxMy43NTQyQzIuODU3MTIgMTUuMjczMyA0LjkxNzEyIDE2LjE3NjggNy4zODg1NSAxNi4yOTU0QzEwLjM5NzEgMTYuNDQ1MSAxMy4zODg1IDE1LjYzNDcgMTUuNTExNCAxNC4xNDM5TDE0LjI2MjggMTMuNDAxM1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0xNi43OCAxNC44NzUxQzE1LjU4MjkgMTUuOTAyOSAxMi44IDE3Ljc2NjQgOC4xODI4NiAxOC4wMjA1QzMuMDE0MjkgMTguMzAyOSAwLjg2MDAwMSAxNi42NDI3IDAuODQwMDAxIDE2LjYyNTdMMC40MjI4NTYgMTcuMTMzOUwwLjg0Mjg1NiAxNi42MzQyTDAgMTcuNjMzN0MwLjA5MTQyODYgMTcuNzA5OSAyLjE1NzE0IDE5LjM1ODkgNy4wMDg1NyAxOS4zNTg5QzcuNDA1NzEgMTkuMzU4OSA3LjgyMjg2IDE5LjM1ODkgOC4yNTcxNCAxOS4zMjVDMTMuODM3MSAxOS4wMTcyIDE2LjkwMjkgMTYuNjExNiAxNy45NzE0IDE1LjU4MzhMMTYuNzggMTQuODc1MVoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0xOS4wMiAxNi4yMTkyQzE4LjMxMjEgMTcuMTM4NyAxNy40NDA4IDE3LjkyMzMgMTYuNDQ4NiAxOC41MzQ1QzEyLjk1MTUgMjAuNzY1IDguNTAyODkgMjEuMDUzIDUuMzg4NiAyMC44OTc4TDUuMzIyODkgMjIuMTk5NEM1Ljg0NTc1IDIyLjIyNDggNi4zNDg2MSAyMi4yMzYxIDYuODM3MTggMjIuMjM2MUMxNS42MiAyMi4yMzYxIDE5LjE2ODYgMTguMjgzMiAyMC4xNiAxNi44NzE0TDE5LjAxNzIgMTYuMjA3OSIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTE4LjY4NTcgMTEuMjkyMkMxOS4yNjggMTEuMjkyMiAxOS43NCAxMC44MjU3IDE5Ljc0IDEwLjI1MDNDMTkuNzQgOS42NzQ4OSAxOS4yNjggOS4yMDg0MiAxOC42ODU3IDkuMjA4NDJDMTguMTAzNCA5LjIwODQyIDE3LjYzMTQgOS42NzQ4OSAxNy42MzE0IDEwLjI1MDNDMTcuNjMxNCAxMC44MjU3IDE4LjEwMzQgMTEuMjkyMiAxOC42ODU3IDExLjI5MjJaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K";
		this.supportedTransactionVersions = null;
		this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
		this._disconnected = () => {
			const wallet = this._wallet;
			if (wallet) {
				wallet.off("disconnect", this._disconnected);
				this._wallet = null;
				this._publicKey = null;
				this.emit("error", new WalletDisconnectedError());
				this.emit("disconnect");
			}
		};
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		if (this._readyState !== WalletReadyState.Unsupported) scopePollingDetectionStrategy(() => {
			if (window.xfi?.solana?.isXDEFI) {
				this._readyState = WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get connecting() {
		return this._connecting;
	}
	get connected() {
		return !!this._wallet?.isConnected;
	}
	get readyState() {
		return this._readyState;
	}
	async connect() {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();
			this._connecting = true;
			const wallet = window.xfi.solana;
			if (!wallet.isConnected) try {
				await wallet.connect();
			} catch (error) {
				throw new WalletConnectionError(error?.message, error);
			}
			if (!wallet.publicKey) throw new WalletAccountError();
			let publicKey;
			try {
				publicKey = new PublicKey(wallet.publicKey.toBytes());
			} catch (error) {
				throw new WalletPublicKeyError(error?.message, error);
			}
			wallet.on("disconnect", this._disconnected);
			this._wallet = wallet;
			this._publicKey = publicKey;
			this.emit("connect", publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			wallet.off("disconnect", this._disconnected);
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signTransaction(transaction) || transaction;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				return await wallet.signAllTransactions(transactions) || transactions;
			} catch (error) {
				throw new WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet) throw new WalletNotConnectedError();
			try {
				const { signature } = await wallet.signMessage(message);
				return signature;
			} catch (error) {
				throw new WalletSignMessageError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
export { AlphaWalletAdapter, AlphaWalletName, AvanaWalletAdapter, AvanaWalletName, BitKeepWalletAdapter, BitKeepWalletName, BitgetWalletAdapter, BitgetWalletName, BitpieWalletAdapter, BitpieWalletName, CloverWalletAdapter, CloverWalletName, Coin98WalletAdapter, Coin98WalletName, CoinbaseWalletAdapter, CoinbaseWalletName, CoinhubWalletAdapter, CoinhubWalletName, FractalWalletAdapter, FractalWalletName, HuobiWalletAdapter, HuobiWalletName, HyperPayWalletAdapter, HyperPayWalletName, KeystoneWalletAdapter, KeystoneWalletName, KrystalWalletAdapter, KrystalWalletName, LedgerWalletAdapter, LedgerWalletName, MathWalletAdapter, MathWalletName, NekoWalletAdapter, NekoWalletName, NightlyWalletAdapter, NightlyWalletName, NufiWalletAdapter, NufiWalletName, OntoWalletAdapter, OntoWalletName, ParticleAdapter, ParticleName, PhantomWalletAdapter, PhantomWalletName, SafePalWalletAdapter, SafePalWalletName, SaifuWalletAdapter, SaifuWalletName, SalmonWalletAdapter, SalmonWalletName, SkyWalletAdapter, SkyWalletName, SolflareWalletAdapter, SolflareWalletName, SolongWalletAdapter, SolongWalletName, SpotWalletAdapter, SpotWalletName, TokenPocketWalletAdapter, TokenPocketWalletName, TokenaryWalletAdapter, TokenaryWalletName, TorusWalletAdapter, TorusWalletName, TrezorWalletAdapter, TrezorWalletName, TrustWalletAdapter, TrustWalletName, UnsafeBurnerWalletAdapter, UnsafeBurnerWalletName, WalletConnectWalletAdapter, WalletConnectWalletName, XDEFIWalletAdapter, XDEFIWalletName, getDerivationPath };
//# sourceMappingURL=@solana_wallet-adapter-wallets.js.map