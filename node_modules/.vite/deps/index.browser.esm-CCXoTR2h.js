import { c as __toESM, n as __esm, o as __toCommonJS, r as __export, t as __commonJS } from "./chunk-CBgdiQcn.js";
import { t as require_buffer } from "./buffer-B-cPJC5o.js";
import { t as require_browser_external_buffer } from "./browser-external_buffer-X3Ug0HYL.js";

//#region node_modules/@noble/hashes/esm/crypto.js
var crypto$1;
var init_crypto = __esm({ "node_modules/@noble/hashes/esm/crypto.js": (() => {
	crypto$1 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
}) });

//#endregion
//#region node_modules/@noble/hashes/esm/utils.js
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
	return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
/** Asserts something is positive integer. */
function anumber(n) {
	if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, got " + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
	if (!isBytes(b)) throw new Error("Uint8Array expected");
	if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
/** Asserts something is hash */
function ahash(h) {
	if (typeof h !== "function" || typeof h.create !== "function") throw new Error("Hash should be wrapped by utils.createHasher");
	anumber(h.outputLen);
	anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance$1, checkFinished = true) {
	if (instance$1.destroyed) throw new Error("Hash instance has been destroyed");
	if (checkFinished && instance$1.finished) throw new Error("Hash#digest() has already been called");
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance$1) {
	abytes(out);
	const min = instance$1.outputLen;
	if (out.length < min) throw new Error("digestInto() expects output buffer of length at least " + min);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
	return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
	for (let i$1 = 0; i$1 < arrays.length; i$1++) arrays[i$1].fill(0);
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
	return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
	return word << 32 - shift | word >>> shift;
}
/** The byte swap operation for uint32 */
function byteSwap(word) {
	return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
	for (let i$1 = 0; i$1 < arr.length; i$1++) arr[i$1] = byteSwap(arr[i$1]);
	return arr;
}
/**
* Convert byte array to hex string. Uses built-in function, when available.
* @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
*/
function bytesToHex(bytes) {
	abytes(bytes);
	if (hasHexBuiltin) return bytes.toHex();
	let hex = "";
	for (let i$1 = 0; i$1 < bytes.length; i$1++) hex += hexes[bytes[i$1]];
	return hex;
}
function asciiToBase16(ch) {
	if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0;
	if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10);
	if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10);
}
/**
* Convert hex string to byte array. Uses built-in function, when available.
* @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
*/
function hexToBytes(hex) {
	if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
	if (hasHexBuiltin) return Uint8Array.fromHex(hex);
	const hl = hex.length;
	const al = hl / 2;
	if (hl % 2) throw new Error("hex string expected, got unpadded hex of length " + hl);
	const array$1 = new Uint8Array(al);
	for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
		const n1 = asciiToBase16(hex.charCodeAt(hi));
		const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
		if (n1 === void 0 || n2 === void 0) {
			const char = hex[hi] + hex[hi + 1];
			throw new Error("hex string expected, got non-hex character \"" + char + "\" at index " + hi);
		}
		array$1[ai] = n1 * 16 + n2;
	}
	return array$1;
}
/**
* Converts string to bytes using UTF8 encoding.
* @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
*/
function utf8ToBytes(str) {
	if (typeof str !== "string") throw new Error("string expected");
	return new Uint8Array(new TextEncoder().encode(str));
}
/**
* Normalizes (non-hex) string or Uint8Array to Uint8Array.
* Warning: when Uint8Array is passed, it would NOT get copied.
* Keep in mind for future mutable operations.
*/
function toBytes(data) {
	if (typeof data === "string") data = utf8ToBytes(data);
	abytes(data);
	return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
	let sum = 0;
	for (let i$1 = 0; i$1 < arrays.length; i$1++) {
		const a = arrays[i$1];
		abytes(a);
		sum += a.length;
	}
	const res = new Uint8Array(sum);
	for (let i$1 = 0, pad = 0; i$1 < arrays.length; i$1++) {
		const a = arrays[i$1];
		res.set(a, pad);
		pad += a.length;
	}
	return res;
}
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
	const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
	const tmp = hashCons();
	hashC.outputLen = tmp.outputLen;
	hashC.blockLen = tmp.blockLen;
	hashC.create = () => hashCons();
	return hashC;
}
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
	if (crypto$1 && typeof crypto$1.getRandomValues === "function") return crypto$1.getRandomValues(new Uint8Array(bytesLength));
	if (crypto$1 && typeof crypto$1.randomBytes === "function") return Uint8Array.from(crypto$1.randomBytes(bytesLength));
	throw new Error("crypto.getRandomValues must be defined");
}
var isLE, swap32IfBE, hasHexBuiltin, hexes, asciis, Hash;
var init_utils$1 = __esm({ "node_modules/@noble/hashes/esm/utils.js": (() => {
	init_crypto();
	isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
	swap32IfBE = isLE ? (u) => u : byteSwap32;
	hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
	hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i$1) => i$1.toString(16).padStart(2, "0"));
	asciis = {
		_0: 48,
		_9: 57,
		A: 65,
		F: 70,
		a: 97,
		f: 102
	};
	Hash = class {};
}) });

//#endregion
//#region node_modules/@noble/hashes/esm/_md.js
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
function setBigUint64(view, byteOffset, value, isLE$1) {
	if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE$1);
	const _32n$1 = BigInt(32);
	const _u32_max = BigInt(4294967295);
	const wh = Number(value >> _32n$1 & _u32_max);
	const wl = Number(value & _u32_max);
	const h = isLE$1 ? 4 : 0;
	const l = isLE$1 ? 0 : 4;
	view.setUint32(byteOffset + h, wh, isLE$1);
	view.setUint32(byteOffset + l, wl, isLE$1);
}
/** Choice: a ? b : c */
function Chi(a, b, c) {
	return a & b ^ ~a & c;
}
/** Majority function, true if any two inputs is true. */
function Maj(a, b, c) {
	return a & b ^ a & c ^ b & c;
}
var HashMD, SHA256_IV, SHA512_IV;
var init__md = __esm({ "node_modules/@noble/hashes/esm/_md.js": (() => {
	init_utils$1();
	HashMD = class extends Hash {
		constructor(blockLen, outputLen, padOffset, isLE$1) {
			super();
			this.finished = false;
			this.length = 0;
			this.pos = 0;
			this.destroyed = false;
			this.blockLen = blockLen;
			this.outputLen = outputLen;
			this.padOffset = padOffset;
			this.isLE = isLE$1;
			this.buffer = new Uint8Array(blockLen);
			this.view = createView(this.buffer);
		}
		update(data) {
			aexists(this);
			data = toBytes(data);
			abytes(data);
			const { view, buffer: buffer$1, blockLen } = this;
			const len = data.length;
			for (let pos = 0; pos < len;) {
				const take = Math.min(blockLen - this.pos, len - pos);
				if (take === blockLen) {
					const dataView = createView(data);
					for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
					continue;
				}
				buffer$1.set(data.subarray(pos, pos + take), this.pos);
				this.pos += take;
				pos += take;
				if (this.pos === blockLen) {
					this.process(view, 0);
					this.pos = 0;
				}
			}
			this.length += data.length;
			this.roundClean();
			return this;
		}
		digestInto(out) {
			aexists(this);
			aoutput(out, this);
			this.finished = true;
			const { buffer: buffer$1, view, blockLen, isLE: isLE$1 } = this;
			let { pos } = this;
			buffer$1[pos++] = 128;
			clean(this.buffer.subarray(pos));
			if (this.padOffset > blockLen - pos) {
				this.process(view, 0);
				pos = 0;
			}
			for (let i$1 = pos; i$1 < blockLen; i$1++) buffer$1[i$1] = 0;
			setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE$1);
			this.process(view, 0);
			const oview = createView(out);
			const len = this.outputLen;
			if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
			const outLen = len / 4;
			const state = this.get();
			if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
			for (let i$1 = 0; i$1 < outLen; i$1++) oview.setUint32(4 * i$1, state[i$1], isLE$1);
		}
		digest() {
			const { buffer: buffer$1, outputLen } = this;
			this.digestInto(buffer$1);
			const res = buffer$1.slice(0, outputLen);
			this.destroy();
			return res;
		}
		_cloneInto(to) {
			to || (to = new this.constructor());
			to.set(...this.get());
			const { blockLen, buffer: buffer$1, length, finished: finished$1, destroyed, pos } = this;
			to.destroyed = destroyed;
			to.finished = finished$1;
			to.length = length;
			to.pos = pos;
			if (length % blockLen) to.buffer.set(buffer$1);
			return to;
		}
		clone() {
			return this._cloneInto();
		}
	};
	SHA256_IV = /* @__PURE__ */ Uint32Array.from([
		1779033703,
		3144134277,
		1013904242,
		2773480762,
		1359893119,
		2600822924,
		528734635,
		1541459225
	]);
	SHA512_IV = /* @__PURE__ */ Uint32Array.from([
		1779033703,
		4089235720,
		3144134277,
		2227873595,
		1013904242,
		4271175723,
		2773480762,
		1595750129,
		1359893119,
		2917565137,
		2600822924,
		725511199,
		528734635,
		4215389547,
		1541459225,
		327033209
	]);
}) });

//#endregion
//#region node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
	if (le) return {
		h: Number(n & U32_MASK64),
		l: Number(n >> _32n & U32_MASK64)
	};
	return {
		h: Number(n >> _32n & U32_MASK64) | 0,
		l: Number(n & U32_MASK64) | 0
	};
}
function split(lst, le = false) {
	const len = lst.length;
	let Ah = new Uint32Array(len);
	let Al = new Uint32Array(len);
	for (let i$1 = 0; i$1 < len; i$1++) {
		const { h, l } = fromBig(lst[i$1], le);
		[Ah[i$1], Al[i$1]] = [h, l];
	}
	return [Ah, Al];
}
function add(Ah, Al, Bh, Bl) {
	const l = (Al >>> 0) + (Bl >>> 0);
	return {
		h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
		l: l | 0
	};
}
var U32_MASK64, _32n, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotlSH, rotlSL, rotlBH, rotlBL, add3L, add3H, add4L, add4H, add5L, add5H;
var init__u64 = __esm({ "node_modules/@noble/hashes/esm/_u64.js": (() => {
	U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
	_32n = /* @__PURE__ */ BigInt(32);
	shrSH = (h, _l, s) => h >>> s;
	shrSL = (h, l, s) => h << 32 - s | l >>> s;
	rotrSH = (h, l, s) => h >>> s | l << 32 - s;
	rotrSL = (h, l, s) => h << 32 - s | l >>> s;
	rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
	rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
	rotlSH = (h, l, s) => h << s | l >>> 32 - s;
	rotlSL = (h, l, s) => l << s | h >>> 32 - s;
	rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
	rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
	add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
	add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
	add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
	add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
	add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
	add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
}) });

//#endregion
//#region node_modules/@noble/hashes/esm/sha2.js
var SHA256_K, SHA256_W, SHA256, K512, SHA512_Kh, SHA512_Kl, SHA512_W_H, SHA512_W_L, SHA512, sha256$1, sha512;
var init_sha2 = __esm({ "node_modules/@noble/hashes/esm/sha2.js": (() => {
	init__md();
	init__u64();
	init_utils$1();
	SHA256_K = /* @__PURE__ */ Uint32Array.from([
		1116352408,
		1899447441,
		3049323471,
		3921009573,
		961987163,
		1508970993,
		2453635748,
		2870763221,
		3624381080,
		310598401,
		607225278,
		1426881987,
		1925078388,
		2162078206,
		2614888103,
		3248222580,
		3835390401,
		4022224774,
		264347078,
		604807628,
		770255983,
		1249150122,
		1555081692,
		1996064986,
		2554220882,
		2821834349,
		2952996808,
		3210313671,
		3336571891,
		3584528711,
		113926993,
		338241895,
		666307205,
		773529912,
		1294757372,
		1396182291,
		1695183700,
		1986661051,
		2177026350,
		2456956037,
		2730485921,
		2820302411,
		3259730800,
		3345764771,
		3516065817,
		3600352804,
		4094571909,
		275423344,
		430227734,
		506948616,
		659060556,
		883997877,
		958139571,
		1322822218,
		1537002063,
		1747873779,
		1955562222,
		2024104815,
		2227730452,
		2361852424,
		2428436474,
		2756734187,
		3204031479,
		3329325298
	]);
	SHA256_W = /* @__PURE__ */ new Uint32Array(64);
	SHA256 = class extends HashMD {
		constructor(outputLen = 32) {
			super(64, outputLen, 8, false);
			this.A = SHA256_IV[0] | 0;
			this.B = SHA256_IV[1] | 0;
			this.C = SHA256_IV[2] | 0;
			this.D = SHA256_IV[3] | 0;
			this.E = SHA256_IV[4] | 0;
			this.F = SHA256_IV[5] | 0;
			this.G = SHA256_IV[6] | 0;
			this.H = SHA256_IV[7] | 0;
		}
		get() {
			const { A, B, C, D, E, F, G, H } = this;
			return [
				A,
				B,
				C,
				D,
				E,
				F,
				G,
				H
			];
		}
		set(A, B, C, D, E, F, G, H) {
			this.A = A | 0;
			this.B = B | 0;
			this.C = C | 0;
			this.D = D | 0;
			this.E = E | 0;
			this.F = F | 0;
			this.G = G | 0;
			this.H = H | 0;
		}
		process(view, offset) {
			for (let i$1 = 0; i$1 < 16; i$1++, offset += 4) SHA256_W[i$1] = view.getUint32(offset, false);
			for (let i$1 = 16; i$1 < 64; i$1++) {
				const W15 = SHA256_W[i$1 - 15];
				const W2 = SHA256_W[i$1 - 2];
				const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
				SHA256_W[i$1] = (rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10) + SHA256_W[i$1 - 7] + s0 + SHA256_W[i$1 - 16] | 0;
			}
			let { A, B, C, D, E, F, G, H } = this;
			for (let i$1 = 0; i$1 < 64; i$1++) {
				const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
				const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i$1] + SHA256_W[i$1] | 0;
				const T2 = (rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22)) + Maj(A, B, C) | 0;
				H = G;
				G = F;
				F = E;
				E = D + T1 | 0;
				D = C;
				C = B;
				B = A;
				A = T1 + T2 | 0;
			}
			A = A + this.A | 0;
			B = B + this.B | 0;
			C = C + this.C | 0;
			D = D + this.D | 0;
			E = E + this.E | 0;
			F = F + this.F | 0;
			G = G + this.G | 0;
			H = H + this.H | 0;
			this.set(A, B, C, D, E, F, G, H);
		}
		roundClean() {
			clean(SHA256_W);
		}
		destroy() {
			this.set(0, 0, 0, 0, 0, 0, 0, 0);
			clean(this.buffer);
		}
	};
	K512 = /* @__PURE__ */ (() => split([
		"0x428a2f98d728ae22",
		"0x7137449123ef65cd",
		"0xb5c0fbcfec4d3b2f",
		"0xe9b5dba58189dbbc",
		"0x3956c25bf348b538",
		"0x59f111f1b605d019",
		"0x923f82a4af194f9b",
		"0xab1c5ed5da6d8118",
		"0xd807aa98a3030242",
		"0x12835b0145706fbe",
		"0x243185be4ee4b28c",
		"0x550c7dc3d5ffb4e2",
		"0x72be5d74f27b896f",
		"0x80deb1fe3b1696b1",
		"0x9bdc06a725c71235",
		"0xc19bf174cf692694",
		"0xe49b69c19ef14ad2",
		"0xefbe4786384f25e3",
		"0x0fc19dc68b8cd5b5",
		"0x240ca1cc77ac9c65",
		"0x2de92c6f592b0275",
		"0x4a7484aa6ea6e483",
		"0x5cb0a9dcbd41fbd4",
		"0x76f988da831153b5",
		"0x983e5152ee66dfab",
		"0xa831c66d2db43210",
		"0xb00327c898fb213f",
		"0xbf597fc7beef0ee4",
		"0xc6e00bf33da88fc2",
		"0xd5a79147930aa725",
		"0x06ca6351e003826f",
		"0x142929670a0e6e70",
		"0x27b70a8546d22ffc",
		"0x2e1b21385c26c926",
		"0x4d2c6dfc5ac42aed",
		"0x53380d139d95b3df",
		"0x650a73548baf63de",
		"0x766a0abb3c77b2a8",
		"0x81c2c92e47edaee6",
		"0x92722c851482353b",
		"0xa2bfe8a14cf10364",
		"0xa81a664bbc423001",
		"0xc24b8b70d0f89791",
		"0xc76c51a30654be30",
		"0xd192e819d6ef5218",
		"0xd69906245565a910",
		"0xf40e35855771202a",
		"0x106aa07032bbd1b8",
		"0x19a4c116b8d2d0c8",
		"0x1e376c085141ab53",
		"0x2748774cdf8eeb99",
		"0x34b0bcb5e19b48a8",
		"0x391c0cb3c5c95a63",
		"0x4ed8aa4ae3418acb",
		"0x5b9cca4f7763e373",
		"0x682e6ff3d6b2b8a3",
		"0x748f82ee5defb2fc",
		"0x78a5636f43172f60",
		"0x84c87814a1f0ab72",
		"0x8cc702081a6439ec",
		"0x90befffa23631e28",
		"0xa4506cebde82bde9",
		"0xbef9a3f7b2c67915",
		"0xc67178f2e372532b",
		"0xca273eceea26619c",
		"0xd186b8c721c0c207",
		"0xeada7dd6cde0eb1e",
		"0xf57d4f7fee6ed178",
		"0x06f067aa72176fba",
		"0x0a637dc5a2c898a6",
		"0x113f9804bef90dae",
		"0x1b710b35131c471b",
		"0x28db77f523047d84",
		"0x32caab7b40c72493",
		"0x3c9ebe0a15c9bebc",
		"0x431d67c49c100d4c",
		"0x4cc5d4becb3e42b6",
		"0x597f299cfc657e2a",
		"0x5fcb6fab3ad6faec",
		"0x6c44198c4a475817"
	].map((n) => BigInt(n))))();
	SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
	SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
	SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
	SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
	SHA512 = class extends HashMD {
		constructor(outputLen = 64) {
			super(128, outputLen, 16, false);
			this.Ah = SHA512_IV[0] | 0;
			this.Al = SHA512_IV[1] | 0;
			this.Bh = SHA512_IV[2] | 0;
			this.Bl = SHA512_IV[3] | 0;
			this.Ch = SHA512_IV[4] | 0;
			this.Cl = SHA512_IV[5] | 0;
			this.Dh = SHA512_IV[6] | 0;
			this.Dl = SHA512_IV[7] | 0;
			this.Eh = SHA512_IV[8] | 0;
			this.El = SHA512_IV[9] | 0;
			this.Fh = SHA512_IV[10] | 0;
			this.Fl = SHA512_IV[11] | 0;
			this.Gh = SHA512_IV[12] | 0;
			this.Gl = SHA512_IV[13] | 0;
			this.Hh = SHA512_IV[14] | 0;
			this.Hl = SHA512_IV[15] | 0;
		}
		get() {
			const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
			return [
				Ah,
				Al,
				Bh,
				Bl,
				Ch,
				Cl,
				Dh,
				Dl,
				Eh,
				El,
				Fh,
				Fl,
				Gh,
				Gl,
				Hh,
				Hl
			];
		}
		set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
			this.Ah = Ah | 0;
			this.Al = Al | 0;
			this.Bh = Bh | 0;
			this.Bl = Bl | 0;
			this.Ch = Ch | 0;
			this.Cl = Cl | 0;
			this.Dh = Dh | 0;
			this.Dl = Dl | 0;
			this.Eh = Eh | 0;
			this.El = El | 0;
			this.Fh = Fh | 0;
			this.Fl = Fl | 0;
			this.Gh = Gh | 0;
			this.Gl = Gl | 0;
			this.Hh = Hh | 0;
			this.Hl = Hl | 0;
		}
		process(view, offset) {
			for (let i$1 = 0; i$1 < 16; i$1++, offset += 4) {
				SHA512_W_H[i$1] = view.getUint32(offset);
				SHA512_W_L[i$1] = view.getUint32(offset += 4);
			}
			for (let i$1 = 16; i$1 < 80; i$1++) {
				const W15h = SHA512_W_H[i$1 - 15] | 0;
				const W15l = SHA512_W_L[i$1 - 15] | 0;
				const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
				const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
				const W2h = SHA512_W_H[i$1 - 2] | 0;
				const W2l = SHA512_W_L[i$1 - 2] | 0;
				const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
				const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
				const SUMl = add4L(s0l, s1l, SHA512_W_L[i$1 - 7], SHA512_W_L[i$1 - 16]);
				SHA512_W_H[i$1] = add4H(SUMl, s0h, s1h, SHA512_W_H[i$1 - 7], SHA512_W_H[i$1 - 16]) | 0;
				SHA512_W_L[i$1] = SUMl | 0;
			}
			let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
			for (let i$1 = 0; i$1 < 80; i$1++) {
				const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
				const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
				const CHIh = Eh & Fh ^ ~Eh & Gh;
				const CHIl = El & Fl ^ ~El & Gl;
				const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i$1], SHA512_W_L[i$1]);
				const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i$1], SHA512_W_H[i$1]);
				const T1l = T1ll | 0;
				const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
				const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
				const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
				const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
				Hh = Gh | 0;
				Hl = Gl | 0;
				Gh = Fh | 0;
				Gl = Fl | 0;
				Fh = Eh | 0;
				Fl = El | 0;
				({h: Eh, l: El} = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
				Dh = Ch | 0;
				Dl = Cl | 0;
				Ch = Bh | 0;
				Cl = Bl | 0;
				Bh = Ah | 0;
				Bl = Al | 0;
				const All = add3L(T1l, sigma0l, MAJl);
				Ah = add3H(All, T1h, sigma0h, MAJh);
				Al = All | 0;
			}
			({h: Ah, l: Al} = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
			({h: Bh, l: Bl} = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
			({h: Ch, l: Cl} = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
			({h: Dh, l: Dl} = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
			({h: Eh, l: El} = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
			({h: Fh, l: Fl} = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
			({h: Gh, l: Gl} = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
			({h: Hh, l: Hl} = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
			this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
		}
		roundClean() {
			clean(SHA512_W_H, SHA512_W_L);
		}
		destroy() {
			clean(this.buffer);
			this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		}
	};
	sha256$1 = /* @__PURE__ */ createHasher(() => new SHA256());
	sha512 = /* @__PURE__ */ createHasher(() => new SHA512());
}) });

//#endregion
//#region node_modules/@noble/curves/esm/utils.js
function _abool2(value, title = "") {
	if (typeof value !== "boolean") {
		const prefix$1 = title && `"${title}"`;
		throw new Error(prefix$1 + "expected boolean, got type=" + typeof value);
	}
	return value;
}
/** Asserts something is Uint8Array. */
function _abytes2(value, length, title = "") {
	const bytes = isBytes(value);
	const len = value?.length;
	const needsLen = length !== void 0;
	if (!bytes || needsLen && len !== length) {
		const prefix$1 = title && `"${title}" `;
		const ofLen = needsLen ? ` of length ${length}` : "";
		const got = bytes ? `length=${len}` : `type=${typeof value}`;
		throw new Error(prefix$1 + "expected Uint8Array" + ofLen + ", got " + got);
	}
	return value;
}
function numberToHexUnpadded(num) {
	const hex = num.toString(16);
	return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
	if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
	return hex === "" ? _0n$6 : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes) {
	return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
	abytes(bytes);
	return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
	return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
	return numberToBytesBE(n, len).reverse();
}
/**
* Takes hex string or Uint8Array, converts to Uint8Array.
* Validates output length.
* Will throw error for other types.
* @param title descriptive title for an error e.g. 'secret key'
* @param hex hex string or Uint8Array
* @param expectedLength optional, will compare to result array's length
* @returns
*/
function ensureBytes(title, hex, expectedLength) {
	let res;
	if (typeof hex === "string") try {
		res = hexToBytes(hex);
	} catch (e) {
		throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
	}
	else if (isBytes(hex)) res = Uint8Array.from(hex);
	else throw new Error(title + " must be hex string or Uint8Array");
	const len = res.length;
	if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(title + " of length " + expectedLength + " expected, got " + len);
	return res;
}
function equalBytes(a, b) {
	if (a.length !== b.length) return false;
	let diff = 0;
	for (let i$1 = 0; i$1 < a.length; i$1++) diff |= a[i$1] ^ b[i$1];
	return diff === 0;
}
/**
* Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,
* and Buffer#slice creates mutable copy. Never use Buffers!
*/
function copyBytes(bytes) {
	return Uint8Array.from(bytes);
}
function inRange(n, min, max) {
	return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
* Asserts min <= n < max. NOTE: It's < max and not <= max.
* @example
* aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
*/
function aInRange(title, n, min, max) {
	if (!inRange(n, min, max)) throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
/**
* Calculates amount of bits in a bigint.
* Same as `n.toString(2).length`
* TODO: merge with nLength in modular
*/
function bitLen(n) {
	let len;
	for (len = 0; n > _0n$6; n >>= _1n$6, len += 1);
	return len;
}
/**
* Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
* @returns function that will call DRBG until 2nd arg returns something meaningful
* @example
*   const drbg = createHmacDRBG<Key>(32, 32, hmac);
*   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
*/
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
	if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
	if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
	if (typeof hmacFn !== "function") throw new Error("hmacFn must be a function");
	const u8n = (len) => new Uint8Array(len);
	const u8of = (byte) => Uint8Array.of(byte);
	let v = u8n(hashLen);
	let k = u8n(hashLen);
	let i$1 = 0;
	const reset = () => {
		v.fill(1);
		k.fill(0);
		i$1 = 0;
	};
	const h = (...b) => hmacFn(k, v, ...b);
	const reseed = (seed = u8n(0)) => {
		k = h(u8of(0), seed);
		v = h();
		if (seed.length === 0) return;
		k = h(u8of(1), seed);
		v = h();
	};
	const gen$1 = () => {
		if (i$1++ >= 1e3) throw new Error("drbg: tried 1000 values");
		let len = 0;
		const out = [];
		while (len < qByteLen) {
			v = h();
			const sl = v.slice();
			out.push(sl);
			len += v.length;
		}
		return concatBytes(...out);
	};
	const genUntil = (seed, pred) => {
		reset();
		reseed(seed);
		let res = void 0;
		while (!(res = pred(gen$1()))) reseed();
		reset();
		return res;
	};
	return genUntil;
}
function _validateObject(object, fields, optFields = {}) {
	if (!object || typeof object !== "object") throw new Error("expected valid options object");
	function checkField(fieldName, expectedType, isOpt) {
		const val = object[fieldName];
		if (isOpt && val === void 0) return;
		const current = typeof val;
		if (current !== expectedType || val === null) throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
	}
	Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
	Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
/**
* Memoizes (caches) computation result.
* Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
*/
function memoized(fn) {
	const map = /* @__PURE__ */ new WeakMap();
	return (arg, ...args) => {
		const val = map.get(arg);
		if (val !== void 0) return val;
		const computed = fn(arg, ...args);
		map.set(arg, computed);
		return computed;
	};
}
var _0n$6, _1n$6, isPosBig, bitMask, notImplemented;
var init_utils = __esm({ "node_modules/@noble/curves/esm/utils.js": (() => {
	init_utils$1();
	_0n$6 = /* @__PURE__ */ BigInt(0);
	_1n$6 = /* @__PURE__ */ BigInt(1);
	isPosBig = (n) => typeof n === "bigint" && _0n$6 <= n;
	bitMask = (n) => (_1n$6 << BigInt(n)) - _1n$6;
	notImplemented = () => {
		throw new Error("not implemented");
	};
}) });

//#endregion
//#region node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b) {
	const result = a % b;
	return result >= _0n$5 ? result : b + result;
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */
function pow2(x, power, modulo) {
	let res = x;
	while (power-- > _0n$5) {
		res *= res;
		res %= modulo;
	}
	return res;
}
/**
* Inverses number over modulo.
* Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
*/
function invert(number$1, modulo) {
	if (number$1 === _0n$5) throw new Error("invert: expected non-zero number");
	if (modulo <= _0n$5) throw new Error("invert: expected positive modulus, got " + modulo);
	let a = mod(number$1, modulo);
	let b = modulo;
	let x = _0n$5, y = _1n$5, u = _1n$5, v = _0n$5;
	while (a !== _0n$5) {
		const q = b / a;
		const r = b % a;
		const m = x - u * q;
		const n = y - v * q;
		b = a, a = r, x = u, y = v, u = m, v = n;
	}
	if (b !== _1n$5) throw new Error("invert: does not exist");
	return mod(x, modulo);
}
function assertIsSquare(Fp$1, root, n) {
	if (!Fp$1.eql(Fp$1.sqr(root), n)) throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp$1, n) {
	const p1div4 = (Fp$1.ORDER + _1n$5) / _4n$1;
	const root = Fp$1.pow(n, p1div4);
	assertIsSquare(Fp$1, root, n);
	return root;
}
function sqrt5mod8(Fp$1, n) {
	const p5div8 = (Fp$1.ORDER - _5n$1) / _8n$2;
	const n2 = Fp$1.mul(n, _2n$5);
	const v = Fp$1.pow(n2, p5div8);
	const nv = Fp$1.mul(n, v);
	const i$1 = Fp$1.mul(Fp$1.mul(nv, _2n$5), v);
	const root = Fp$1.mul(nv, Fp$1.sub(i$1, Fp$1.ONE));
	assertIsSquare(Fp$1, root, n);
	return root;
}
function sqrt9mod16(P) {
	const Fp_ = Field(P);
	const tn = tonelliShanks(P);
	const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
	const c2 = tn(Fp_, c1);
	const c3 = tn(Fp_, Fp_.neg(c1));
	const c4 = (P + _7n$1) / _16n;
	return (Fp$1, n) => {
		let tv1 = Fp$1.pow(n, c4);
		let tv2 = Fp$1.mul(tv1, c1);
		const tv3 = Fp$1.mul(tv1, c2);
		const tv4 = Fp$1.mul(tv1, c3);
		const e1 = Fp$1.eql(Fp$1.sqr(tv2), n);
		const e2 = Fp$1.eql(Fp$1.sqr(tv3), n);
		tv1 = Fp$1.cmov(tv1, tv2, e1);
		tv2 = Fp$1.cmov(tv4, tv3, e2);
		const e3 = Fp$1.eql(Fp$1.sqr(tv2), n);
		const root = Fp$1.cmov(tv1, tv2, e3);
		assertIsSquare(Fp$1, root, n);
		return root;
	};
}
/**
* Tonelli-Shanks square root search algorithm.
* 1. https://eprint.iacr.org/2012/685.pdf (page 12)
* 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
* @param P field order
* @returns function that takes field Fp (created from P) and number n
*/
function tonelliShanks(P) {
	if (P < _3n$2) throw new Error("sqrt is not defined for small field");
	let Q = P - _1n$5;
	let S = 0;
	while (Q % _2n$5 === _0n$5) {
		Q /= _2n$5;
		S++;
	}
	let Z = _2n$5;
	const _Fp = Field(P);
	while (FpLegendre(_Fp, Z) === 1) if (Z++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
	if (S === 1) return sqrt3mod4;
	let cc = _Fp.pow(Z, Q);
	const Q1div2 = (Q + _1n$5) / _2n$5;
	return function tonelliSlow(Fp$1, n) {
		if (Fp$1.is0(n)) return n;
		if (FpLegendre(Fp$1, n) !== 1) throw new Error("Cannot find square root");
		let M = S;
		let c = Fp$1.mul(Fp$1.ONE, cc);
		let t = Fp$1.pow(n, Q);
		let R = Fp$1.pow(n, Q1div2);
		while (!Fp$1.eql(t, Fp$1.ONE)) {
			if (Fp$1.is0(t)) return Fp$1.ZERO;
			let i$1 = 1;
			let t_tmp = Fp$1.sqr(t);
			while (!Fp$1.eql(t_tmp, Fp$1.ONE)) {
				i$1++;
				t_tmp = Fp$1.sqr(t_tmp);
				if (i$1 === M) throw new Error("Cannot find square root");
			}
			const exponent = _1n$5 << BigInt(M - i$1 - 1);
			const b = Fp$1.pow(c, exponent);
			M = i$1;
			c = Fp$1.sqr(b);
			t = Fp$1.mul(t, c);
			R = Fp$1.mul(R, b);
		}
		return R;
	};
}
/**
* Square root for a finite field. Will try optimized versions first:
*
* 1. P ‚â° 3 (mod 4)
* 2. P ‚â° 5 (mod 8)
* 3. P ‚â° 9 (mod 16)
* 4. Tonelli-Shanks algorithm
*
* Different algorithms can give different roots, it is up to user to decide which one they want.
* For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
*/
function FpSqrt(P) {
	if (P % _4n$1 === _3n$2) return sqrt3mod4;
	if (P % _8n$2 === _5n$1) return sqrt5mod8;
	if (P % _16n === _9n) return sqrt9mod16(P);
	return tonelliShanks(P);
}
function validateField(field) {
	_validateObject(field, FIELD_FIELDS.reduce((map, val) => {
		map[val] = "function";
		return map;
	}, {
		ORDER: "bigint",
		MASK: "bigint",
		BYTES: "number",
		BITS: "number"
	}));
	return field;
}
/**
* Same as `pow` but for Fp: non-constant-time.
* Unsafe in some contexts: uses ladder, so can expose bigint bits.
*/
function FpPow(Fp$1, num, power) {
	if (power < _0n$5) throw new Error("invalid exponent, negatives unsupported");
	if (power === _0n$5) return Fp$1.ONE;
	if (power === _1n$5) return num;
	let p = Fp$1.ONE;
	let d = num;
	while (power > _0n$5) {
		if (power & _1n$5) p = Fp$1.mul(p, d);
		d = Fp$1.sqr(d);
		power >>= _1n$5;
	}
	return p;
}
/**
* Efficiently invert an array of Field elements.
* Exception-free. Will return `undefined` for 0 elements.
* @param passZero map 0 to 0 (instead of undefined)
*/
function FpInvertBatch(Fp$1, nums, passZero = false) {
	const inverted = new Array(nums.length).fill(passZero ? Fp$1.ZERO : void 0);
	const multipliedAcc = nums.reduce((acc, num, i$1) => {
		if (Fp$1.is0(num)) return acc;
		inverted[i$1] = acc;
		return Fp$1.mul(acc, num);
	}, Fp$1.ONE);
	const invertedAcc = Fp$1.inv(multipliedAcc);
	nums.reduceRight((acc, num, i$1) => {
		if (Fp$1.is0(num)) return acc;
		inverted[i$1] = Fp$1.mul(acc, inverted[i$1]);
		return Fp$1.mul(acc, num);
	}, invertedAcc);
	return inverted;
}
/**
* Legendre symbol.
* Legendre constant is used to calculate Legendre symbol (a | p)
* which denotes the value of a^((p-1)/2) (mod p).
*
* * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue
* * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue
* * (a | p) ‚â° 0    if a ‚â° 0 (mod p)
*/
function FpLegendre(Fp$1, n) {
	const p1mod2 = (Fp$1.ORDER - _1n$5) / _2n$5;
	const powered = Fp$1.pow(n, p1mod2);
	const yes = Fp$1.eql(powered, Fp$1.ONE);
	const zero = Fp$1.eql(powered, Fp$1.ZERO);
	const no = Fp$1.eql(powered, Fp$1.neg(Fp$1.ONE));
	if (!yes && !zero && !no) throw new Error("invalid Legendre symbol result");
	return yes ? 1 : zero ? 0 : -1;
}
function nLength(n, nBitLength) {
	if (nBitLength !== void 0) anumber(nBitLength);
	const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
	return {
		nBitLength: _nBitLength,
		nByteLength: Math.ceil(_nBitLength / 8)
	};
}
/**
* Creates a finite field. Major performance optimizations:
* * 1. Denormalized operations like mulN instead of mul.
* * 2. Identical object shape: never add or remove keys.
* * 3. `Object.freeze`.
* Fragile: always run a benchmark on a change.
* Security note: operations don't check 'isValid' for all elements for performance reasons,
* it is caller responsibility to check this.
* This is low-level code, please make sure you know what you're doing.
*
* Note about field properties:
* * CHARACTERISTIC p = prime number, number of elements in main subgroup.
* * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.
*
* @param ORDER field order, probably prime, or could be composite
* @param bitLen how many bits the field consumes
* @param isLE (default: false) if encoding / decoding should be in little-endian
* @param redef optional faster redefinitions of sqrt and other methods
*/
function Field(ORDER, bitLenOrOpts, isLE$1 = false, opts = {}) {
	if (ORDER <= _0n$5) throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
	let _nbitLength = void 0;
	let _sqrt = void 0;
	let modFromBytes = false;
	let allowedLengths = void 0;
	if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
		if (opts.sqrt || isLE$1) throw new Error("cannot specify opts in two arguments");
		const _opts = bitLenOrOpts;
		if (_opts.BITS) _nbitLength = _opts.BITS;
		if (_opts.sqrt) _sqrt = _opts.sqrt;
		if (typeof _opts.isLE === "boolean") isLE$1 = _opts.isLE;
		if (typeof _opts.modFromBytes === "boolean") modFromBytes = _opts.modFromBytes;
		allowedLengths = _opts.allowedLengths;
	} else {
		if (typeof bitLenOrOpts === "number") _nbitLength = bitLenOrOpts;
		if (opts.sqrt) _sqrt = opts.sqrt;
	}
	const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
	if (BYTES > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
	let sqrtP;
	const f$1 = Object.freeze({
		ORDER,
		isLE: isLE$1,
		BITS,
		BYTES,
		MASK: bitMask(BITS),
		ZERO: _0n$5,
		ONE: _1n$5,
		allowedLengths,
		create: (num) => mod(num, ORDER),
		isValid: (num) => {
			if (typeof num !== "bigint") throw new Error("invalid field element: expected bigint, got " + typeof num);
			return _0n$5 <= num && num < ORDER;
		},
		is0: (num) => num === _0n$5,
		isValidNot0: (num) => !f$1.is0(num) && f$1.isValid(num),
		isOdd: (num) => (num & _1n$5) === _1n$5,
		neg: (num) => mod(-num, ORDER),
		eql: (lhs, rhs) => lhs === rhs,
		sqr: (num) => mod(num * num, ORDER),
		add: (lhs, rhs) => mod(lhs + rhs, ORDER),
		sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
		mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
		pow: (num, power) => FpPow(f$1, num, power),
		div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
		sqrN: (num) => num * num,
		addN: (lhs, rhs) => lhs + rhs,
		subN: (lhs, rhs) => lhs - rhs,
		mulN: (lhs, rhs) => lhs * rhs,
		inv: (num) => invert(num, ORDER),
		sqrt: _sqrt || ((n) => {
			if (!sqrtP) sqrtP = FpSqrt(ORDER);
			return sqrtP(f$1, n);
		}),
		toBytes: (num) => isLE$1 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
		fromBytes: (bytes, skipValidation = true) => {
			if (allowedLengths) {
				if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
				const padded = new Uint8Array(BYTES);
				padded.set(bytes, isLE$1 ? 0 : padded.length - bytes.length);
				bytes = padded;
			}
			if (bytes.length !== BYTES) throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
			let scalar = isLE$1 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
			if (modFromBytes) scalar = mod(scalar, ORDER);
			if (!skipValidation) {
				if (!f$1.isValid(scalar)) throw new Error("invalid field element: outside of range 0..ORDER");
			}
			return scalar;
		},
		invertBatch: (lst) => FpInvertBatch(f$1, lst),
		cmov: (a, b, c) => c ? b : a
	});
	return Object.freeze(f$1);
}
/**
* Returns total number of bytes consumed by the field element.
* For example, 32 bytes for usual 256-bit weierstrass curve.
* @param fieldOrder number of field elements, usually CURVE.n
* @returns byte length of field
*/
function getFieldBytesLength(fieldOrder) {
	if (typeof fieldOrder !== "bigint") throw new Error("field order must be bigint");
	const bitLength = fieldOrder.toString(2).length;
	return Math.ceil(bitLength / 8);
}
/**
* Returns minimal amount of bytes that can be safely reduced
* by field order.
* Should be 2^-128 for 128-bit curve such as P256.
* @param fieldOrder number of field elements, usually CURVE.n
* @returns byte length of target hash
*/
function getMinHashLength(fieldOrder) {
	const length = getFieldBytesLength(fieldOrder);
	return length + Math.ceil(length / 2);
}
/**
* "Constant-time" private key generation utility.
* Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
* and convert them into private scalar, with the modulo bias being negligible.
* Needs at least 48 bytes of input for 32-byte private key.
* https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
* FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
* RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
* @param hash hash output from SHA3 or a similar function
* @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
* @param isLE interpret hash bytes as LE num
* @returns valid private scalar
*/
function mapHashToField(key, fieldOrder, isLE$1 = false) {
	const len = key.length;
	const fieldLen = getFieldBytesLength(fieldOrder);
	const minLen = getMinHashLength(fieldOrder);
	if (len < 16 || len < minLen || len > 1024) throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
	const reduced = mod(isLE$1 ? bytesToNumberLE(key) : bytesToNumberBE(key), fieldOrder - _1n$5) + _1n$5;
	return isLE$1 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
var _0n$5, _1n$5, _2n$5, _3n$2, _4n$1, _5n$1, _7n$1, _8n$2, _9n, _16n, isNegativeLE, FIELD_FIELDS;
var init_modular = __esm({ "node_modules/@noble/curves/esm/abstract/modular.js": (() => {
	init_utils();
	_0n$5 = BigInt(0), _1n$5 = BigInt(1), _2n$5 = /* @__PURE__ */ BigInt(2), _3n$2 = /* @__PURE__ */ BigInt(3);
	_4n$1 = /* @__PURE__ */ BigInt(4), _5n$1 = /* @__PURE__ */ BigInt(5), _7n$1 = /* @__PURE__ */ BigInt(7);
	_8n$2 = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);
	isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$5) === _1n$5;
	FIELD_FIELDS = [
		"create",
		"isValid",
		"is0",
		"neg",
		"inv",
		"sqrt",
		"sqr",
		"eql",
		"add",
		"sub",
		"mul",
		"pow",
		"div",
		"addN",
		"subN",
		"mulN",
		"sqrN"
	];
}) });

//#endregion
//#region node_modules/@noble/curves/esm/abstract/curve.js
function negateCt(condition, item) {
	const neg = item.negate();
	return condition ? neg : item;
}
/**
* Takes a bunch of Projective Points but executes only one
* inversion on all of them. Inversion is very slow operation,
* so this improves performance massively.
* Optimization: converts a list of projective points to a list of identical points with Z=1.
*/
function normalizeZ(c, points) {
	const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
	return points.map((p, i$1) => c.fromAffine(p.toAffine(invertedZs[i$1])));
}
function validateW(W, bits) {
	if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
	validateW(W, scalarBits);
	const windows = Math.ceil(scalarBits / W) + 1;
	const windowSize = 2 ** (W - 1);
	const maxNumber = 2 ** W;
	return {
		windows,
		windowSize,
		mask: bitMask(W),
		maxNumber,
		shiftBy: BigInt(W)
	};
}
function calcOffsets(n, window$1, wOpts) {
	const { windowSize, mask: mask$1, maxNumber, shiftBy } = wOpts;
	let wbits = Number(n & mask$1);
	let nextN = n >> shiftBy;
	if (wbits > windowSize) {
		wbits -= maxNumber;
		nextN += _1n$4;
	}
	const offsetStart = window$1 * windowSize;
	const offset = offsetStart + Math.abs(wbits) - 1;
	const isZero = wbits === 0;
	const isNeg = wbits < 0;
	const isNegF = window$1 % 2 !== 0;
	return {
		nextN,
		offset,
		isZero,
		isNeg,
		isNegF,
		offsetF: offsetStart
	};
}
function validateMSMPoints(points, c) {
	if (!Array.isArray(points)) throw new Error("array expected");
	points.forEach((p, i$1) => {
		if (!(p instanceof c)) throw new Error("invalid point at index " + i$1);
	});
}
function validateMSMScalars(scalars, field) {
	if (!Array.isArray(scalars)) throw new Error("array of scalars expected");
	scalars.forEach((s, i$1) => {
		if (!field.isValid(s)) throw new Error("invalid scalar at index " + i$1);
	});
}
function getW(P) {
	return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
	if (n !== _0n$4) throw new Error("invalid wNAF");
}
/**
* Endomorphism-specific multiplication for Koblitz curves.
* Cost: 128 dbl, 0-256 adds.
*/
function mulEndoUnsafe(Point, point, k1, k2) {
	let acc = point;
	let p1 = Point.ZERO;
	let p2 = Point.ZERO;
	while (k1 > _0n$4 || k2 > _0n$4) {
		if (k1 & _1n$4) p1 = p1.add(acc);
		if (k2 & _1n$4) p2 = p2.add(acc);
		acc = acc.double();
		k1 >>= _1n$4;
		k2 >>= _1n$4;
	}
	return {
		p1,
		p2
	};
}
/**
* Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
* 30x faster vs naive addition on L=4096, 10x faster than precomputes.
* For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
* Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
* @param c Curve Point constructor
* @param fieldN field over CURVE.N - important that it's not over CURVE.P
* @param points array of L curve points
* @param scalars array of L scalars (aka secret keys / bigints)
*/
function pippenger(c, fieldN, points, scalars) {
	validateMSMPoints(points, c);
	validateMSMScalars(scalars, fieldN);
	const plength = points.length;
	const slength = scalars.length;
	if (plength !== slength) throw new Error("arrays of points and scalars must have equal length");
	const zero = c.ZERO;
	const wbits = bitLen(BigInt(plength));
	let windowSize = 1;
	if (wbits > 12) windowSize = wbits - 3;
	else if (wbits > 4) windowSize = wbits - 2;
	else if (wbits > 0) windowSize = 2;
	const MASK = bitMask(windowSize);
	const buckets = new Array(Number(MASK) + 1).fill(zero);
	const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
	let sum = zero;
	for (let i$1 = lastBits; i$1 >= 0; i$1 -= windowSize) {
		buckets.fill(zero);
		for (let j = 0; j < slength; j++) {
			const scalar = scalars[j];
			const wbits$1 = Number(scalar >> BigInt(i$1) & MASK);
			buckets[wbits$1] = buckets[wbits$1].add(points[j]);
		}
		let resI = zero;
		for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
			sumI = sumI.add(buckets[j]);
			resI = resI.add(sumI);
		}
		sum = sum.add(resI);
		if (i$1 !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();
	}
	return sum;
}
function createField(order, field, isLE$1) {
	if (field) {
		if (field.ORDER !== order) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
		validateField(field);
		return field;
	} else return Field(order, { isLE: isLE$1 });
}
/** Validates CURVE opts and creates fields */
function _createCurveFields(type$1, CURVE, curveOpts = {}, FpFnLE) {
	if (FpFnLE === void 0) FpFnLE = type$1 === "edwards";
	if (!CURVE || typeof CURVE !== "object") throw new Error(`expected valid ${type$1} CURVE object`);
	for (const p of [
		"p",
		"n",
		"h"
	]) {
		const val = CURVE[p];
		if (!(typeof val === "bigint" && val > _0n$4)) throw new Error(`CURVE.${p} must be positive bigint`);
	}
	const Fp$1 = createField(CURVE.p, curveOpts.Fp, FpFnLE);
	const Fn$1 = createField(CURVE.n, curveOpts.Fn, FpFnLE);
	const params = [
		"Gx",
		"Gy",
		"a",
		type$1 === "weierstrass" ? "b" : "d"
	];
	for (const p of params) if (!Fp$1.isValid(CURVE[p])) throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
	CURVE = Object.freeze(Object.assign({}, CURVE));
	return {
		CURVE,
		Fp: Fp$1,
		Fn: Fn$1
	};
}
var _0n$4, _1n$4, pointPrecomputes, pointWindowSizes, wNAF;
var init_curve = __esm({ "node_modules/@noble/curves/esm/abstract/curve.js": (() => {
	init_utils();
	init_modular();
	_0n$4 = BigInt(0);
	_1n$4 = BigInt(1);
	pointPrecomputes = /* @__PURE__ */ new WeakMap();
	pointWindowSizes = /* @__PURE__ */ new WeakMap();
	wNAF = class {
		constructor(Point, bits) {
			this.BASE = Point.BASE;
			this.ZERO = Point.ZERO;
			this.Fn = Point.Fn;
			this.bits = bits;
		}
		_unsafeLadder(elm, n, p = this.ZERO) {
			let d = elm;
			while (n > _0n$4) {
				if (n & _1n$4) p = p.add(d);
				d = d.double();
				n >>= _1n$4;
			}
			return p;
		}
		/**
		* Creates a wNAF precomputation window. Used for caching.
		* Default window size is set by `utils.precompute()` and is equal to 8.
		* Number of precomputed points depends on the curve size:
		* 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
		* - ùëä is the window size
		* - ùëõ is the bitlength of the curve order.
		* For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
		* @param point Point instance
		* @param W window size
		* @returns precomputed point tables flattened to a single array
		*/
		precomputeWindow(point, W) {
			const { windows, windowSize } = calcWOpts(W, this.bits);
			const points = [];
			let p = point;
			let base$2 = p;
			for (let window$1 = 0; window$1 < windows; window$1++) {
				base$2 = p;
				points.push(base$2);
				for (let i$1 = 1; i$1 < windowSize; i$1++) {
					base$2 = base$2.add(p);
					points.push(base$2);
				}
				p = base$2.double();
			}
			return points;
		}
		/**
		* Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
		* More compact implementation:
		* https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
		* @returns real and fake (for const-time) points
		*/
		wNAF(W, precomputes, n) {
			if (!this.Fn.isValid(n)) throw new Error("invalid scalar");
			let p = this.ZERO;
			let f$1 = this.BASE;
			const wo = calcWOpts(W, this.bits);
			for (let window$1 = 0; window$1 < wo.windows; window$1++) {
				const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window$1, wo);
				n = nextN;
				if (isZero) f$1 = f$1.add(negateCt(isNegF, precomputes[offsetF]));
				else p = p.add(negateCt(isNeg, precomputes[offset]));
			}
			assert0(n);
			return {
				p,
				f: f$1
			};
		}
		/**
		* Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
		* @param acc accumulator point to add result of multiplication
		* @returns point
		*/
		wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
			const wo = calcWOpts(W, this.bits);
			for (let window$1 = 0; window$1 < wo.windows; window$1++) {
				if (n === _0n$4) break;
				const { nextN, offset, isZero, isNeg } = calcOffsets(n, window$1, wo);
				n = nextN;
				if (isZero) continue;
				else {
					const item = precomputes[offset];
					acc = acc.add(isNeg ? item.negate() : item);
				}
			}
			assert0(n);
			return acc;
		}
		getPrecomputes(W, point, transform) {
			let comp = pointPrecomputes.get(point);
			if (!comp) {
				comp = this.precomputeWindow(point, W);
				if (W !== 1) {
					if (typeof transform === "function") comp = transform(comp);
					pointPrecomputes.set(point, comp);
				}
			}
			return comp;
		}
		cached(point, scalar, transform) {
			const W = getW(point);
			return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
		}
		unsafe(point, scalar, transform, prev) {
			const W = getW(point);
			if (W === 1) return this._unsafeLadder(point, scalar, prev);
			return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
		}
		createCache(P, W) {
			validateW(W, this.bits);
			pointWindowSizes.set(P, W);
			pointPrecomputes.delete(P);
		}
		hasCache(elm) {
			return getW(elm) !== 1;
		}
	};
}) });

//#endregion
//#region node_modules/@noble/curves/esm/abstract/edwards.js
function isEdValidXY(Fp$1, CURVE, x, y) {
	const x2 = Fp$1.sqr(x);
	const y2 = Fp$1.sqr(y);
	const left = Fp$1.add(Fp$1.mul(CURVE.a, x2), y2);
	const right = Fp$1.add(Fp$1.ONE, Fp$1.mul(CURVE.d, Fp$1.mul(x2, y2)));
	return Fp$1.eql(left, right);
}
function edwards(params, extraOpts = {}) {
	const validated = _createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
	const { Fp: Fp$1, Fn: Fn$1 } = validated;
	let CURVE = validated.CURVE;
	const { h: cofactor } = CURVE;
	_validateObject(extraOpts, {}, { uvRatio: "function" });
	const MASK = _2n$4 << BigInt(Fn$1.BYTES * 8) - _1n$3;
	const modP = (n) => Fp$1.create(n);
	const uvRatio$1 = extraOpts.uvRatio || ((u, v) => {
		try {
			return {
				isValid: true,
				value: Fp$1.sqrt(Fp$1.div(u, v))
			};
		} catch (e) {
			return {
				isValid: false,
				value: _0n$3
			};
		}
	});
	if (!isEdValidXY(Fp$1, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error("bad curve params: generator point");
	/**
	* Asserts coordinate is valid: 0 <= n < MASK.
	* Coordinates >= Fp.ORDER are allowed for zip215.
	*/
	function acoord(title, n, banZero = false) {
		const min = banZero ? _1n$3 : _0n$3;
		aInRange("coordinate " + title, n, min, MASK);
		return n;
	}
	function aextpoint(other) {
		if (!(other instanceof Point)) throw new Error("ExtendedPoint expected");
	}
	const toAffineMemo = memoized((p, iz) => {
		const { X, Y, Z } = p;
		const is0 = p.is0();
		if (iz == null) iz = is0 ? _8n$1 : Fp$1.inv(Z);
		const x = modP(X * iz);
		const y = modP(Y * iz);
		const zz = Fp$1.mul(Z, iz);
		if (is0) return {
			x: _0n$3,
			y: _1n$3
		};
		if (zz !== _1n$3) throw new Error("invZ was invalid");
		return {
			x,
			y
		};
	});
	const assertValidMemo = memoized((p) => {
		const { a, d } = CURVE;
		if (p.is0()) throw new Error("bad point: ZERO");
		const { X, Y, Z, T } = p;
		const X2 = modP(X * X);
		const Y2 = modP(Y * Y);
		const Z2 = modP(Z * Z);
		const Z4 = modP(Z2 * Z2);
		if (modP(Z2 * modP(modP(X2 * a) + Y2)) !== modP(Z4 + modP(d * modP(X2 * Y2)))) throw new Error("bad point: equation left != right (1)");
		if (modP(X * Y) !== modP(Z * T)) throw new Error("bad point: equation left != right (2)");
		return true;
	});
	class Point {
		constructor(X, Y, Z, T) {
			this.X = acoord("x", X);
			this.Y = acoord("y", Y);
			this.Z = acoord("z", Z, true);
			this.T = acoord("t", T);
			Object.freeze(this);
		}
		static CURVE() {
			return CURVE;
		}
		static fromAffine(p) {
			if (p instanceof Point) throw new Error("extended point not allowed");
			const { x, y } = p || {};
			acoord("x", x);
			acoord("y", y);
			return new Point(x, y, _1n$3, modP(x * y));
		}
		static fromBytes(bytes, zip215 = false) {
			const len = Fp$1.BYTES;
			const { a, d } = CURVE;
			bytes = copyBytes(_abytes2(bytes, len, "point"));
			_abool2(zip215, "zip215");
			const normed = copyBytes(bytes);
			const lastByte = bytes[len - 1];
			normed[len - 1] = lastByte & -129;
			const y = bytesToNumberLE(normed);
			aInRange("point.y", y, _0n$3, zip215 ? MASK : Fp$1.ORDER);
			const y2 = modP(y * y);
			let { isValid, value: x } = uvRatio$1(modP(y2 - _1n$3), modP(d * y2 - a));
			if (!isValid) throw new Error("bad point: invalid y coordinate");
			const isXOdd = (x & _1n$3) === _1n$3;
			const isLastByteOdd = (lastByte & 128) !== 0;
			if (!zip215 && x === _0n$3 && isLastByteOdd) throw new Error("bad point: x=0 and x_0=1");
			if (isLastByteOdd !== isXOdd) x = modP(-x);
			return Point.fromAffine({
				x,
				y
			});
		}
		static fromHex(bytes, zip215 = false) {
			return Point.fromBytes(ensureBytes("point", bytes), zip215);
		}
		get x() {
			return this.toAffine().x;
		}
		get y() {
			return this.toAffine().y;
		}
		precompute(windowSize = 8, isLazy = true) {
			wnaf.createCache(this, windowSize);
			if (!isLazy) this.multiply(_2n$4);
			return this;
		}
		assertValidity() {
			assertValidMemo(this);
		}
		equals(other) {
			aextpoint(other);
			const { X: X1, Y: Y1, Z: Z1 } = this;
			const { X: X2, Y: Y2, Z: Z2 } = other;
			const X1Z2 = modP(X1 * Z2);
			const X2Z1 = modP(X2 * Z1);
			const Y1Z2 = modP(Y1 * Z2);
			const Y2Z1 = modP(Y2 * Z1);
			return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
		}
		is0() {
			return this.equals(Point.ZERO);
		}
		negate() {
			return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
		}
		double() {
			const { a } = CURVE;
			const { X: X1, Y: Y1, Z: Z1 } = this;
			const A = modP(X1 * X1);
			const B = modP(Y1 * Y1);
			const C = modP(_2n$4 * modP(Z1 * Z1));
			const D = modP(a * A);
			const x1y1 = X1 + Y1;
			const E = modP(modP(x1y1 * x1y1) - A - B);
			const G = D + B;
			const F = G - C;
			const H = D - B;
			const X3 = modP(E * F);
			const Y3 = modP(G * H);
			const T3 = modP(E * H);
			return new Point(X3, Y3, modP(F * G), T3);
		}
		add(other) {
			aextpoint(other);
			const { a, d } = CURVE;
			const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
			const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
			const A = modP(X1 * X2);
			const B = modP(Y1 * Y2);
			const C = modP(T1 * d * T2);
			const D = modP(Z1 * Z2);
			const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
			const F = D - C;
			const G = D + C;
			const H = modP(B - a * A);
			const X3 = modP(E * F);
			const Y3 = modP(G * H);
			const T3 = modP(E * H);
			return new Point(X3, Y3, modP(F * G), T3);
		}
		subtract(other) {
			return this.add(other.negate());
		}
		multiply(scalar) {
			if (!Fn$1.isValidNot0(scalar)) throw new Error("invalid scalar: expected 1 <= sc < curve.n");
			const { p, f: f$1 } = wnaf.cached(this, scalar, (p$1) => normalizeZ(Point, p$1));
			return normalizeZ(Point, [p, f$1])[0];
		}
		multiplyUnsafe(scalar, acc = Point.ZERO) {
			if (!Fn$1.isValid(scalar)) throw new Error("invalid scalar: expected 0 <= sc < curve.n");
			if (scalar === _0n$3) return Point.ZERO;
			if (this.is0() || scalar === _1n$3) return this;
			return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);
		}
		isSmallOrder() {
			return this.multiplyUnsafe(cofactor).is0();
		}
		isTorsionFree() {
			return wnaf.unsafe(this, CURVE.n).is0();
		}
		toAffine(invertedZ) {
			return toAffineMemo(this, invertedZ);
		}
		clearCofactor() {
			if (cofactor === _1n$3) return this;
			return this.multiplyUnsafe(cofactor);
		}
		toBytes() {
			const { x, y } = this.toAffine();
			const bytes = Fp$1.toBytes(y);
			bytes[bytes.length - 1] |= x & _1n$3 ? 128 : 0;
			return bytes;
		}
		toHex() {
			return bytesToHex(this.toBytes());
		}
		toString() {
			return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
		}
		get ex() {
			return this.X;
		}
		get ey() {
			return this.Y;
		}
		get ez() {
			return this.Z;
		}
		get et() {
			return this.T;
		}
		static normalizeZ(points) {
			return normalizeZ(Point, points);
		}
		static msm(points, scalars) {
			return pippenger(Point, Fn$1, points, scalars);
		}
		_setWindowSize(windowSize) {
			this.precompute(windowSize);
		}
		toRawBytes() {
			return this.toBytes();
		}
	}
	Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n$3, modP(CURVE.Gx * CURVE.Gy));
	Point.ZERO = new Point(_0n$3, _1n$3, _1n$3, _0n$3);
	Point.Fp = Fp$1;
	Point.Fn = Fn$1;
	const wnaf = new wNAF(Point, Fn$1.BITS);
	Point.BASE.precompute(8);
	return Point;
}
/**
* Initializes EdDSA signatures over given Edwards curve.
*/
function eddsa(Point, cHash, eddsaOpts = {}) {
	if (typeof cHash !== "function") throw new Error("\"hash\" function param is required");
	_validateObject(eddsaOpts, {}, {
		adjustScalarBytes: "function",
		randomBytes: "function",
		domain: "function",
		prehash: "function",
		mapToCurve: "function"
	});
	const { prehash } = eddsaOpts;
	const { BASE, Fp: Fp$1, Fn: Fn$1 } = Point;
	const randomBytes$1 = eddsaOpts.randomBytes || randomBytes;
	const adjustScalarBytes$1 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
	const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
		_abool2(phflag, "phflag");
		if (ctx.length || phflag) throw new Error("Contexts/pre-hash are not supported");
		return data;
	});
	function modN_LE(hash) {
		return Fn$1.create(bytesToNumberLE(hash));
	}
	function getPrivateScalar(key) {
		const len = lengths.secretKey;
		key = ensureBytes("private key", key, len);
		const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
		const head = adjustScalarBytes$1(hashed.slice(0, len));
		return {
			head,
			prefix: hashed.slice(len, 2 * len),
			scalar: modN_LE(head)
		};
	}
	/** Convenience method that creates public key from scalar. RFC8032 5.1.5 */
	function getExtendedPublicKey(secretKey) {
		const { head, prefix: prefix$1, scalar } = getPrivateScalar(secretKey);
		const point = BASE.multiply(scalar);
		return {
			head,
			prefix: prefix$1,
			scalar,
			point,
			pointBytes: point.toBytes()
		};
	}
	/** Calculates EdDSA pub key. RFC8032 5.1.5. */
	function getPublicKey$1(secretKey) {
		return getExtendedPublicKey(secretKey).pointBytes;
	}
	function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
		return modN_LE(cHash(domain(concatBytes(...msgs), ensureBytes("context", context), !!prehash)));
	}
	/** Signs message with privateKey. RFC8032 5.1.6 */
	function sign$1(msg, secretKey, options = {}) {
		msg = ensureBytes("message", msg);
		if (prehash) msg = prehash(msg);
		const { prefix: prefix$1, scalar, pointBytes } = getExtendedPublicKey(secretKey);
		const r = hashDomainToScalar(options.context, prefix$1, msg);
		const R = BASE.multiply(r).toBytes();
		const k = hashDomainToScalar(options.context, R, pointBytes, msg);
		const s = Fn$1.create(r + k * scalar);
		if (!Fn$1.isValid(s)) throw new Error("sign failed: invalid s");
		return _abytes2(concatBytes(R, Fn$1.toBytes(s)), lengths.signature, "result");
	}
	const verifyOpts = { zip215: true };
	/**
	* Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
	* An extended group equation is checked.
	*/
	function verify$1(sig, msg, publicKey$1, options = verifyOpts) {
		const { context, zip215 } = options;
		const len = lengths.signature;
		sig = ensureBytes("signature", sig, len);
		msg = ensureBytes("message", msg);
		publicKey$1 = ensureBytes("publicKey", publicKey$1, lengths.publicKey);
		if (zip215 !== void 0) _abool2(zip215, "zip215");
		if (prehash) msg = prehash(msg);
		const mid = len / 2;
		const r = sig.subarray(0, mid);
		const s = bytesToNumberLE(sig.subarray(mid, len));
		let A, R, SB;
		try {
			A = Point.fromBytes(publicKey$1, zip215);
			R = Point.fromBytes(r, zip215);
			SB = BASE.multiplyUnsafe(s);
		} catch (error) {
			return false;
		}
		if (!zip215 && A.isSmallOrder()) return false;
		const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
		return R.add(A.multiplyUnsafe(k)).subtract(SB).clearCofactor().is0();
	}
	const _size = Fp$1.BYTES;
	const lengths = {
		secretKey: _size,
		publicKey: _size,
		signature: 2 * _size,
		seed: _size
	};
	function randomSecretKey(seed = randomBytes$1(lengths.seed)) {
		return _abytes2(seed, lengths.seed, "seed");
	}
	function keygen(seed) {
		const secretKey = utils.randomSecretKey(seed);
		return {
			secretKey,
			publicKey: getPublicKey$1(secretKey)
		};
	}
	function isValidSecretKey(key) {
		return isBytes(key) && key.length === Fn$1.BYTES;
	}
	function isValidPublicKey(key, zip215) {
		try {
			return !!Point.fromBytes(key, zip215);
		} catch (error) {
			return false;
		}
	}
	const utils = {
		getExtendedPublicKey,
		randomSecretKey,
		isValidSecretKey,
		isValidPublicKey,
		toMontgomery(publicKey$1) {
			const { y } = Point.fromBytes(publicKey$1);
			const size = lengths.publicKey;
			const is25519 = size === 32;
			if (!is25519 && size !== 57) throw new Error("only defined for 25519 and 448");
			const u = is25519 ? Fp$1.div(_1n$3 + y, _1n$3 - y) : Fp$1.div(y - _1n$3, y + _1n$3);
			return Fp$1.toBytes(u);
		},
		toMontgomerySecret(secretKey) {
			const size = lengths.secretKey;
			_abytes2(secretKey, size);
			return adjustScalarBytes$1(cHash(secretKey.subarray(0, size))).subarray(0, size);
		},
		randomPrivateKey: randomSecretKey,
		precompute(windowSize = 8, point = Point.BASE) {
			return point.precompute(windowSize, false);
		}
	};
	return Object.freeze({
		keygen,
		getPublicKey: getPublicKey$1,
		sign: sign$1,
		verify: verify$1,
		utils,
		Point,
		lengths
	});
}
function _eddsa_legacy_opts_to_new(c) {
	const CURVE = {
		a: c.a,
		d: c.d,
		p: c.Fp.ORDER,
		n: c.n,
		h: c.h,
		Gx: c.Gx,
		Gy: c.Gy
	};
	const curveOpts = {
		Fp: c.Fp,
		Fn: Field(CURVE.n, c.nBitLength, true),
		uvRatio: c.uvRatio
	};
	const eddsaOpts = {
		randomBytes: c.randomBytes,
		adjustScalarBytes: c.adjustScalarBytes,
		domain: c.domain,
		prehash: c.prehash,
		mapToCurve: c.mapToCurve
	};
	return {
		CURVE,
		curveOpts,
		hash: c.hash,
		eddsaOpts
	};
}
function _eddsa_new_output_to_legacy(c, eddsa$1) {
	const Point = eddsa$1.Point;
	return Object.assign({}, eddsa$1, {
		ExtendedPoint: Point,
		CURVE: c,
		nBitLength: Point.Fn.BITS,
		nByteLength: Point.Fn.BYTES
	});
}
function twistedEdwards(c) {
	const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
	return _eddsa_new_output_to_legacy(c, eddsa(edwards(CURVE, curveOpts), hash, eddsaOpts));
}
var _0n$3, _1n$3, _2n$4, _8n$1, PrimeEdwardsPoint;
var init_edwards = __esm({ "node_modules/@noble/curves/esm/abstract/edwards.js": (() => {
	init_utils();
	init_curve();
	init_modular();
	_0n$3 = BigInt(0), _1n$3 = BigInt(1), _2n$4 = BigInt(2), _8n$1 = BigInt(8);
	PrimeEdwardsPoint = class {
		constructor(ep) {
			this.ep = ep;
		}
		static fromBytes(_bytes) {
			notImplemented();
		}
		static fromHex(_hex) {
			notImplemented();
		}
		get x() {
			return this.toAffine().x;
		}
		get y() {
			return this.toAffine().y;
		}
		clearCofactor() {
			return this;
		}
		assertValidity() {
			this.ep.assertValidity();
		}
		toAffine(invertedZ) {
			return this.ep.toAffine(invertedZ);
		}
		toHex() {
			return bytesToHex(this.toBytes());
		}
		toString() {
			return this.toHex();
		}
		isTorsionFree() {
			return true;
		}
		isSmallOrder() {
			return false;
		}
		add(other) {
			this.assertSame(other);
			return this.init(this.ep.add(other.ep));
		}
		subtract(other) {
			this.assertSame(other);
			return this.init(this.ep.subtract(other.ep));
		}
		multiply(scalar) {
			return this.init(this.ep.multiply(scalar));
		}
		multiplyUnsafe(scalar) {
			return this.init(this.ep.multiplyUnsafe(scalar));
		}
		double() {
			return this.init(this.ep.double());
		}
		negate() {
			return this.init(this.ep.negate());
		}
		precompute(windowSize, isLazy) {
			return this.init(this.ep.precompute(windowSize, isLazy));
		}
		/** @deprecated use `toBytes` */
		toRawBytes() {
			return this.toBytes();
		}
	};
}) });

//#endregion
//#region node_modules/@noble/curves/esm/ed25519.js
function ed25519_pow_2_252_3(x) {
	const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
	const P = ed25519_CURVE_p;
	const b2 = x * x % P * x % P;
	const b5 = pow2(pow2(b2, _2n$3, P) * b2 % P, _1n$2, P) * x % P;
	const b10 = pow2(b5, _5n, P) * b5 % P;
	const b20 = pow2(b10, _10n, P) * b10 % P;
	const b40 = pow2(b20, _20n, P) * b20 % P;
	const b80 = pow2(b40, _40n, P) * b40 % P;
	return {
		pow_p_5_8: pow2(pow2(pow2(pow2(b80, _80n, P) * b80 % P, _80n, P) * b80 % P, _10n, P) * b10 % P, _2n$3, P) * x % P,
		b2
	};
}
function adjustScalarBytes(bytes) {
	bytes[0] &= 248;
	bytes[31] &= 127;
	bytes[31] |= 64;
	return bytes;
}
function uvRatio(u, v) {
	const P = ed25519_CURVE_p;
	const v3$1 = mod(v * v * v, P);
	const pow = ed25519_pow_2_252_3(u * mod(v3$1 * v3$1 * v, P)).pow_p_5_8;
	let x = mod(u * v3$1 * pow, P);
	const vx2 = mod(v * x * x, P);
	const root1 = x;
	const root2 = mod(x * ED25519_SQRT_M1, P);
	const useRoot1 = vx2 === u;
	const useRoot2 = vx2 === mod(-u, P);
	const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
	if (useRoot1) x = root1;
	if (useRoot2 || noRoot) x = root2;
	if (isNegativeLE(x, P)) x = mod(-x, P);
	return {
		isValid: useRoot1 || useRoot2,
		value: x
	};
}
/**
* Computes Elligator map for Ristretto255.
* Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
* the [website](https://ristretto.group/formulas/elligator.html).
*/
function calcElligatorRistrettoMap(r0) {
	const { d } = ed25519_CURVE;
	const P = ed25519_CURVE_p;
	const mod$1 = (n) => Fp.create(n);
	const r = mod$1(SQRT_M1 * r0 * r0);
	const Ns = mod$1((r + _1n$2) * ONE_MINUS_D_SQ);
	let c = BigInt(-1);
	const D = mod$1((c - d * r) * mod$1(r + d));
	let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
	let s_ = mod$1(s * r0);
	if (!isNegativeLE(s_, P)) s_ = mod$1(-s_);
	if (!Ns_D_is_sq) s = s_;
	if (!Ns_D_is_sq) c = r;
	const Nt = mod$1(c * (r - _1n$2) * D_MINUS_ONE_SQ - D);
	const s2 = s * s;
	const W0 = mod$1((s + s) * D);
	const W1 = mod$1(Nt * SQRT_AD_MINUS_ONE);
	const W2 = mod$1(_1n$2 - s2);
	const W3 = mod$1(_1n$2 + s2);
	return new ed25519.Point(mod$1(W0 * W3), mod$1(W2 * W1), mod$1(W1 * W3), mod$1(W0 * W2));
}
function ristretto255_map(bytes) {
	abytes(bytes, 64);
	const R1 = calcElligatorRistrettoMap(bytes255ToNumberLE(bytes.subarray(0, 32)));
	const R2 = calcElligatorRistrettoMap(bytes255ToNumberLE(bytes.subarray(32, 64)));
	return new _RistrettoPoint(R1.add(R2));
}
var _0n$2, _1n$2, _2n$3, _3n$1, _5n, _8n, ed25519_CURVE_p, ed25519_CURVE, ED25519_SQRT_M1, Fp, Fn, ed25519Defaults, ed25519, SQRT_M1, SQRT_AD_MINUS_ONE, INVSQRT_A_MINUS_D, ONE_MINUS_D_SQ, D_MINUS_ONE_SQ, invertSqrt, MAX_255B, bytes255ToNumberLE, _RistrettoPoint;
var init_ed25519 = __esm({ "node_modules/@noble/curves/esm/ed25519.js": (() => {
	init_sha2();
	init_utils$1();
	init_curve();
	init_edwards();
	init_modular();
	init_utils();
	_0n$2 = /* @__PURE__ */ BigInt(0), _1n$2 = BigInt(1), _2n$3 = BigInt(2), _3n$1 = BigInt(3);
	_5n = BigInt(5), _8n = BigInt(8);
	ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
	ed25519_CURVE = /* @__PURE__ */ (() => ({
		p: ed25519_CURVE_p,
		n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
		h: _8n,
		a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
		d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
		Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
		Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
	}))();
	ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
	Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();
	Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();
	ed25519Defaults = /* @__PURE__ */ (() => ({
		...ed25519_CURVE,
		Fp,
		hash: sha512,
		adjustScalarBytes,
		uvRatio
	}))();
	ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
	SQRT_M1 = ED25519_SQRT_M1;
	SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
	INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
	ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
	D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
	invertSqrt = (number$1) => uvRatio(_1n$2, number$1);
	MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
	bytes255ToNumberLE = (bytes) => ed25519.Point.Fp.create(bytesToNumberLE(bytes) & MAX_255B);
	_RistrettoPoint = class _RistrettoPoint extends PrimeEdwardsPoint {
		constructor(ep) {
			super(ep);
		}
		static fromAffine(ap) {
			return new _RistrettoPoint(ed25519.Point.fromAffine(ap));
		}
		assertSame(other) {
			if (!(other instanceof _RistrettoPoint)) throw new Error("RistrettoPoint expected");
		}
		init(ep) {
			return new _RistrettoPoint(ep);
		}
		/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
		static hashToCurve(hex) {
			return ristretto255_map(ensureBytes("ristrettoHash", hex, 64));
		}
		static fromBytes(bytes) {
			abytes(bytes, 32);
			const { a, d } = ed25519_CURVE;
			const P = ed25519_CURVE_p;
			const mod$1 = (n) => Fp.create(n);
			const s = bytes255ToNumberLE(bytes);
			if (!equalBytes(Fp.toBytes(s), bytes) || isNegativeLE(s, P)) throw new Error("invalid ristretto255 encoding 1");
			const s2 = mod$1(s * s);
			const u1 = mod$1(_1n$2 + a * s2);
			const u2 = mod$1(_1n$2 - a * s2);
			const u1_2 = mod$1(u1 * u1);
			const u2_2 = mod$1(u2 * u2);
			const v = mod$1(a * d * u1_2 - u2_2);
			const { isValid, value: I } = invertSqrt(mod$1(v * u2_2));
			const Dx = mod$1(I * u2);
			const Dy = mod$1(I * Dx * v);
			let x = mod$1((s + s) * Dx);
			if (isNegativeLE(x, P)) x = mod$1(-x);
			const y = mod$1(u1 * Dy);
			const t = mod$1(x * y);
			if (!isValid || isNegativeLE(t, P) || y === _0n$2) throw new Error("invalid ristretto255 encoding 2");
			return new _RistrettoPoint(new ed25519.Point(x, y, _1n$2, t));
		}
		/**
		* Converts ristretto-encoded string to ristretto point.
		* Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
		* @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
		*/
		static fromHex(hex) {
			return _RistrettoPoint.fromBytes(ensureBytes("ristrettoHex", hex, 32));
		}
		static msm(points, scalars) {
			return pippenger(_RistrettoPoint, ed25519.Point.Fn, points, scalars);
		}
		/**
		* Encodes ristretto point to Uint8Array.
		* Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
		*/
		toBytes() {
			let { X, Y, Z, T } = this.ep;
			const P = ed25519_CURVE_p;
			const mod$1 = (n) => Fp.create(n);
			const u1 = mod$1(mod$1(Z + Y) * mod$1(Z - Y));
			const u2 = mod$1(X * Y);
			const { value: invsqrt } = invertSqrt(mod$1(u1 * mod$1(u2 * u2)));
			const D1 = mod$1(invsqrt * u1);
			const D2 = mod$1(invsqrt * u2);
			const zInv = mod$1(D1 * D2 * T);
			let D;
			if (isNegativeLE(T * zInv, P)) {
				let _x = mod$1(Y * SQRT_M1);
				let _y = mod$1(X * SQRT_M1);
				X = _x;
				Y = _y;
				D = mod$1(D1 * INVSQRT_A_MINUS_D);
			} else D = D2;
			if (isNegativeLE(X * zInv, P)) Y = mod$1(-Y);
			let s = mod$1((Z - Y) * D);
			if (isNegativeLE(s, P)) s = mod$1(-s);
			return Fp.toBytes(s);
		}
		/**
		* Compares two Ristretto points.
		* Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
		*/
		equals(other) {
			this.assertSame(other);
			const { X: X1, Y: Y1 } = this.ep;
			const { X: X2, Y: Y2 } = other.ep;
			const mod$1 = (n) => Fp.create(n);
			const one = mod$1(X1 * Y2) === mod$1(Y1 * X2);
			const two = mod$1(Y1 * Y2) === mod$1(X1 * X2);
			return one || two;
		}
		is0() {
			return this.equals(_RistrettoPoint.ZERO);
		}
	};
	_RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();
	_RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();
	_RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
	_RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();
}) });

//#endregion
//#region node_modules/bn.js/lib/bn.js
var require_bn = /* @__PURE__ */ __commonJS({ "node_modules/bn.js/lib/bn.js": ((exports, module) => {
	(function(module$1, exports$1) {
		function assert$2(val, msg) {
			if (!val) throw new Error(msg || "Assertion failed");
		}
		function inherits(ctor, superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
		function BN$1(number$1, base$2, endian) {
			if (BN$1.isBN(number$1)) return number$1;
			this.negative = 0;
			this.words = null;
			this.length = 0;
			this.red = null;
			if (number$1 !== null) {
				if (base$2 === "le" || base$2 === "be") {
					endian = base$2;
					base$2 = 10;
				}
				this._init(number$1 || 0, base$2 || 10, endian || "be");
			}
		}
		if (typeof module$1 === "object") module$1.exports = BN$1;
		else exports$1.BN = BN$1;
		BN$1.BN = BN$1;
		BN$1.wordSize = 26;
		var Buffer$4;
		try {
			if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") Buffer$4 = window.Buffer;
			else Buffer$4 = require_browser_external_buffer().Buffer;
		} catch (e) {}
		BN$1.isBN = function isBN(num) {
			if (num instanceof BN$1) return true;
			return num !== null && typeof num === "object" && num.constructor.wordSize === BN$1.wordSize && Array.isArray(num.words);
		};
		BN$1.max = function max(left, right) {
			if (left.cmp(right) > 0) return left;
			return right;
		};
		BN$1.min = function min(left, right) {
			if (left.cmp(right) < 0) return left;
			return right;
		};
		BN$1.prototype._init = function init(number$1, base$2, endian) {
			if (typeof number$1 === "number") return this._initNumber(number$1, base$2, endian);
			if (typeof number$1 === "object") return this._initArray(number$1, base$2, endian);
			if (base$2 === "hex") base$2 = 16;
			assert$2(base$2 === (base$2 | 0) && base$2 >= 2 && base$2 <= 36);
			number$1 = number$1.toString().replace(/\s+/g, "");
			var start = 0;
			if (number$1[0] === "-") {
				start++;
				this.negative = 1;
			}
			if (start < number$1.length) if (base$2 === 16) this._parseHex(number$1, start, endian);
			else {
				this._parseBase(number$1, base$2, start);
				if (endian === "le") this._initArray(this.toArray(), base$2, endian);
			}
		};
		BN$1.prototype._initNumber = function _initNumber(number$1, base$2, endian) {
			if (number$1 < 0) {
				this.negative = 1;
				number$1 = -number$1;
			}
			if (number$1 < 67108864) {
				this.words = [number$1 & 67108863];
				this.length = 1;
			} else if (number$1 < 4503599627370496) {
				this.words = [number$1 & 67108863, number$1 / 67108864 & 67108863];
				this.length = 2;
			} else {
				assert$2(number$1 < 9007199254740992);
				this.words = [
					number$1 & 67108863,
					number$1 / 67108864 & 67108863,
					1
				];
				this.length = 3;
			}
			if (endian !== "le") return;
			this._initArray(this.toArray(), base$2, endian);
		};
		BN$1.prototype._initArray = function _initArray(number$1, base$2, endian) {
			assert$2(typeof number$1.length === "number");
			if (number$1.length <= 0) {
				this.words = [0];
				this.length = 1;
				return this;
			}
			this.length = Math.ceil(number$1.length / 3);
			this.words = new Array(this.length);
			for (var i$1 = 0; i$1 < this.length; i$1++) this.words[i$1] = 0;
			var j, w;
			var off = 0;
			if (endian === "be") for (i$1 = number$1.length - 1, j = 0; i$1 >= 0; i$1 -= 3) {
				w = number$1[i$1] | number$1[i$1 - 1] << 8 | number$1[i$1 - 2] << 16;
				this.words[j] |= w << off & 67108863;
				this.words[j + 1] = w >>> 26 - off & 67108863;
				off += 24;
				if (off >= 26) {
					off -= 26;
					j++;
				}
			}
			else if (endian === "le") for (i$1 = 0, j = 0; i$1 < number$1.length; i$1 += 3) {
				w = number$1[i$1] | number$1[i$1 + 1] << 8 | number$1[i$1 + 2] << 16;
				this.words[j] |= w << off & 67108863;
				this.words[j + 1] = w >>> 26 - off & 67108863;
				off += 24;
				if (off >= 26) {
					off -= 26;
					j++;
				}
			}
			return this._strip();
		};
		function parseHex4Bits(string$1, index) {
			var c = string$1.charCodeAt(index);
			if (c >= 48 && c <= 57) return c - 48;
			else if (c >= 65 && c <= 70) return c - 55;
			else if (c >= 97 && c <= 102) return c - 87;
			else assert$2(false, "Invalid character in " + string$1);
		}
		function parseHexByte(string$1, lowerBound, index) {
			var r = parseHex4Bits(string$1, index);
			if (index - 1 >= lowerBound) r |= parseHex4Bits(string$1, index - 1) << 4;
			return r;
		}
		BN$1.prototype._parseHex = function _parseHex(number$1, start, endian) {
			this.length = Math.ceil((number$1.length - start) / 6);
			this.words = new Array(this.length);
			for (var i$1 = 0; i$1 < this.length; i$1++) this.words[i$1] = 0;
			var off = 0;
			var j = 0;
			var w;
			if (endian === "be") for (i$1 = number$1.length - 1; i$1 >= start; i$1 -= 2) {
				w = parseHexByte(number$1, start, i$1) << off;
				this.words[j] |= w & 67108863;
				if (off >= 18) {
					off -= 18;
					j += 1;
					this.words[j] |= w >>> 26;
				} else off += 8;
			}
			else for (i$1 = (number$1.length - start) % 2 === 0 ? start + 1 : start; i$1 < number$1.length; i$1 += 2) {
				w = parseHexByte(number$1, start, i$1) << off;
				this.words[j] |= w & 67108863;
				if (off >= 18) {
					off -= 18;
					j += 1;
					this.words[j] |= w >>> 26;
				} else off += 8;
			}
			this._strip();
		};
		function parseBase(str, start, end, mul) {
			var r = 0;
			var b = 0;
			var len = Math.min(str.length, end);
			for (var i$1 = start; i$1 < len; i$1++) {
				var c = str.charCodeAt(i$1) - 48;
				r *= mul;
				if (c >= 49) b = c - 49 + 10;
				else if (c >= 17) b = c - 17 + 10;
				else b = c;
				assert$2(c >= 0 && b < mul, "Invalid character");
				r += b;
			}
			return r;
		}
		BN$1.prototype._parseBase = function _parseBase(number$1, base$2, start) {
			this.words = [0];
			this.length = 1;
			for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base$2) limbLen++;
			limbLen--;
			limbPow = limbPow / base$2 | 0;
			var total = number$1.length - start;
			var mod$1 = total % limbLen;
			var end = Math.min(total, total - mod$1) + start;
			var word = 0;
			for (var i$1 = start; i$1 < end; i$1 += limbLen) {
				word = parseBase(number$1, i$1, i$1 + limbLen, base$2);
				this.imuln(limbPow);
				if (this.words[0] + word < 67108864) this.words[0] += word;
				else this._iaddn(word);
			}
			if (mod$1 !== 0) {
				var pow = 1;
				word = parseBase(number$1, i$1, number$1.length, base$2);
				for (i$1 = 0; i$1 < mod$1; i$1++) pow *= base$2;
				this.imuln(pow);
				if (this.words[0] + word < 67108864) this.words[0] += word;
				else this._iaddn(word);
			}
			this._strip();
		};
		BN$1.prototype.copy = function copy(dest) {
			dest.words = new Array(this.length);
			for (var i$1 = 0; i$1 < this.length; i$1++) dest.words[i$1] = this.words[i$1];
			dest.length = this.length;
			dest.negative = this.negative;
			dest.red = this.red;
		};
		function move(dest, src) {
			dest.words = src.words;
			dest.length = src.length;
			dest.negative = src.negative;
			dest.red = src.red;
		}
		BN$1.prototype._move = function _move(dest) {
			move(dest, this);
		};
		BN$1.prototype.clone = function clone() {
			var r = new BN$1(null);
			this.copy(r);
			return r;
		};
		BN$1.prototype._expand = function _expand(size) {
			while (this.length < size) this.words[this.length++] = 0;
			return this;
		};
		BN$1.prototype._strip = function strip() {
			while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
			return this._normSign();
		};
		BN$1.prototype._normSign = function _normSign() {
			if (this.length === 1 && this.words[0] === 0) this.negative = 0;
			return this;
		};
		if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") try {
			BN$1.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
		} catch (e) {
			BN$1.prototype.inspect = inspect;
		}
		else BN$1.prototype.inspect = inspect;
		function inspect() {
			return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
		}
		var zeros = [
			"",
			"0",
			"00",
			"000",
			"0000",
			"00000",
			"000000",
			"0000000",
			"00000000",
			"000000000",
			"0000000000",
			"00000000000",
			"000000000000",
			"0000000000000",
			"00000000000000",
			"000000000000000",
			"0000000000000000",
			"00000000000000000",
			"000000000000000000",
			"0000000000000000000",
			"00000000000000000000",
			"000000000000000000000",
			"0000000000000000000000",
			"00000000000000000000000",
			"000000000000000000000000",
			"0000000000000000000000000"
		];
		var groupSizes = [
			0,
			0,
			25,
			16,
			12,
			11,
			10,
			9,
			8,
			8,
			7,
			7,
			7,
			7,
			6,
			6,
			6,
			6,
			6,
			6,
			6,
			5,
			5,
			5,
			5,
			5,
			5,
			5,
			5,
			5,
			5,
			5,
			5,
			5,
			5,
			5,
			5
		];
		var groupBases = [
			0,
			0,
			33554432,
			43046721,
			16777216,
			48828125,
			60466176,
			40353607,
			16777216,
			43046721,
			1e7,
			19487171,
			35831808,
			62748517,
			7529536,
			11390625,
			16777216,
			24137569,
			34012224,
			47045881,
			64e6,
			4084101,
			5153632,
			6436343,
			7962624,
			9765625,
			11881376,
			14348907,
			17210368,
			20511149,
			243e5,
			28629151,
			33554432,
			39135393,
			45435424,
			52521875,
			60466176
		];
		BN$1.prototype.toString = function toString(base$2, padding) {
			base$2 = base$2 || 10;
			padding = padding | 0 || 1;
			var out;
			if (base$2 === 16 || base$2 === "hex") {
				out = "";
				var off = 0;
				var carry = 0;
				for (var i$1 = 0; i$1 < this.length; i$1++) {
					var w = this.words[i$1];
					var word = ((w << off | carry) & 16777215).toString(16);
					carry = w >>> 24 - off & 16777215;
					off += 2;
					if (off >= 26) {
						off -= 26;
						i$1--;
					}
					if (carry !== 0 || i$1 !== this.length - 1) out = zeros[6 - word.length] + word + out;
					else out = word + out;
				}
				if (carry !== 0) out = carry.toString(16) + out;
				while (out.length % padding !== 0) out = "0" + out;
				if (this.negative !== 0) out = "-" + out;
				return out;
			}
			if (base$2 === (base$2 | 0) && base$2 >= 2 && base$2 <= 36) {
				var groupSize = groupSizes[base$2];
				var groupBase = groupBases[base$2];
				out = "";
				var c = this.clone();
				c.negative = 0;
				while (!c.isZero()) {
					var r = c.modrn(groupBase).toString(base$2);
					c = c.idivn(groupBase);
					if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
					else out = r + out;
				}
				if (this.isZero()) out = "0" + out;
				while (out.length % padding !== 0) out = "0" + out;
				if (this.negative !== 0) out = "-" + out;
				return out;
			}
			assert$2(false, "Base should be between 2 and 36");
		};
		BN$1.prototype.toNumber = function toNumber() {
			var ret = this.words[0];
			if (this.length === 2) ret += this.words[1] * 67108864;
			else if (this.length === 3 && this.words[2] === 1) ret += 4503599627370496 + this.words[1] * 67108864;
			else if (this.length > 2) assert$2(false, "Number can only safely store up to 53 bits");
			return this.negative !== 0 ? -ret : ret;
		};
		BN$1.prototype.toJSON = function toJSON() {
			return this.toString(16, 2);
		};
		if (Buffer$4) BN$1.prototype.toBuffer = function toBuffer$1(endian, length) {
			return this.toArrayLike(Buffer$4, endian, length);
		};
		BN$1.prototype.toArray = function toArray(endian, length) {
			return this.toArrayLike(Array, endian, length);
		};
		var allocate = function allocate$1(ArrayType, size) {
			if (ArrayType.allocUnsafe) return ArrayType.allocUnsafe(size);
			return new ArrayType(size);
		};
		BN$1.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
			this._strip();
			var byteLength = this.byteLength();
			var reqLength = length || Math.max(1, byteLength);
			assert$2(byteLength <= reqLength, "byte array longer than desired length");
			assert$2(reqLength > 0, "Requested array length <= 0");
			var res = allocate(ArrayType, reqLength);
			this["_toArrayLike" + (endian === "le" ? "LE" : "BE")](res, byteLength);
			return res;
		};
		BN$1.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
			var position = 0;
			var carry = 0;
			for (var i$1 = 0, shift = 0; i$1 < this.length; i$1++) {
				var word = this.words[i$1] << shift | carry;
				res[position++] = word & 255;
				if (position < res.length) res[position++] = word >> 8 & 255;
				if (position < res.length) res[position++] = word >> 16 & 255;
				if (shift === 6) {
					if (position < res.length) res[position++] = word >> 24 & 255;
					carry = 0;
					shift = 0;
				} else {
					carry = word >>> 24;
					shift += 2;
				}
			}
			if (position < res.length) {
				res[position++] = carry;
				while (position < res.length) res[position++] = 0;
			}
		};
		BN$1.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
			var position = res.length - 1;
			var carry = 0;
			for (var i$1 = 0, shift = 0; i$1 < this.length; i$1++) {
				var word = this.words[i$1] << shift | carry;
				res[position--] = word & 255;
				if (position >= 0) res[position--] = word >> 8 & 255;
				if (position >= 0) res[position--] = word >> 16 & 255;
				if (shift === 6) {
					if (position >= 0) res[position--] = word >> 24 & 255;
					carry = 0;
					shift = 0;
				} else {
					carry = word >>> 24;
					shift += 2;
				}
			}
			if (position >= 0) {
				res[position--] = carry;
				while (position >= 0) res[position--] = 0;
			}
		};
		if (Math.clz32) BN$1.prototype._countBits = function _countBits(w) {
			return 32 - Math.clz32(w);
		};
		else BN$1.prototype._countBits = function _countBits(w) {
			var t = w;
			var r = 0;
			if (t >= 4096) {
				r += 13;
				t >>>= 13;
			}
			if (t >= 64) {
				r += 7;
				t >>>= 7;
			}
			if (t >= 8) {
				r += 4;
				t >>>= 4;
			}
			if (t >= 2) {
				r += 2;
				t >>>= 2;
			}
			return r + t;
		};
		BN$1.prototype._zeroBits = function _zeroBits(w) {
			if (w === 0) return 26;
			var t = w;
			var r = 0;
			if ((t & 8191) === 0) {
				r += 13;
				t >>>= 13;
			}
			if ((t & 127) === 0) {
				r += 7;
				t >>>= 7;
			}
			if ((t & 15) === 0) {
				r += 4;
				t >>>= 4;
			}
			if ((t & 3) === 0) {
				r += 2;
				t >>>= 2;
			}
			if ((t & 1) === 0) r++;
			return r;
		};
		BN$1.prototype.bitLength = function bitLength() {
			var w = this.words[this.length - 1];
			var hi = this._countBits(w);
			return (this.length - 1) * 26 + hi;
		};
		function toBitArray(num) {
			var w = new Array(num.bitLength());
			for (var bit = 0; bit < w.length; bit++) {
				var off = bit / 26 | 0;
				var wbit = bit % 26;
				w[bit] = num.words[off] >>> wbit & 1;
			}
			return w;
		}
		BN$1.prototype.zeroBits = function zeroBits() {
			if (this.isZero()) return 0;
			var r = 0;
			for (var i$1 = 0; i$1 < this.length; i$1++) {
				var b = this._zeroBits(this.words[i$1]);
				r += b;
				if (b !== 26) break;
			}
			return r;
		};
		BN$1.prototype.byteLength = function byteLength() {
			return Math.ceil(this.bitLength() / 8);
		};
		BN$1.prototype.toTwos = function toTwos(width) {
			if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
			return this.clone();
		};
		BN$1.prototype.fromTwos = function fromTwos(width) {
			if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
			return this.clone();
		};
		BN$1.prototype.isNeg = function isNeg() {
			return this.negative !== 0;
		};
		BN$1.prototype.neg = function neg() {
			return this.clone().ineg();
		};
		BN$1.prototype.ineg = function ineg() {
			if (!this.isZero()) this.negative ^= 1;
			return this;
		};
		BN$1.prototype.iuor = function iuor(num) {
			while (this.length < num.length) this.words[this.length++] = 0;
			for (var i$1 = 0; i$1 < num.length; i$1++) this.words[i$1] = this.words[i$1] | num.words[i$1];
			return this._strip();
		};
		BN$1.prototype.ior = function ior(num) {
			assert$2((this.negative | num.negative) === 0);
			return this.iuor(num);
		};
		BN$1.prototype.or = function or(num) {
			if (this.length > num.length) return this.clone().ior(num);
			return num.clone().ior(this);
		};
		BN$1.prototype.uor = function uor(num) {
			if (this.length > num.length) return this.clone().iuor(num);
			return num.clone().iuor(this);
		};
		BN$1.prototype.iuand = function iuand(num) {
			var b;
			if (this.length > num.length) b = num;
			else b = this;
			for (var i$1 = 0; i$1 < b.length; i$1++) this.words[i$1] = this.words[i$1] & num.words[i$1];
			this.length = b.length;
			return this._strip();
		};
		BN$1.prototype.iand = function iand(num) {
			assert$2((this.negative | num.negative) === 0);
			return this.iuand(num);
		};
		BN$1.prototype.and = function and(num) {
			if (this.length > num.length) return this.clone().iand(num);
			return num.clone().iand(this);
		};
		BN$1.prototype.uand = function uand(num) {
			if (this.length > num.length) return this.clone().iuand(num);
			return num.clone().iuand(this);
		};
		BN$1.prototype.iuxor = function iuxor(num) {
			var a;
			var b;
			if (this.length > num.length) {
				a = this;
				b = num;
			} else {
				a = num;
				b = this;
			}
			for (var i$1 = 0; i$1 < b.length; i$1++) this.words[i$1] = a.words[i$1] ^ b.words[i$1];
			if (this !== a) for (; i$1 < a.length; i$1++) this.words[i$1] = a.words[i$1];
			this.length = a.length;
			return this._strip();
		};
		BN$1.prototype.ixor = function ixor(num) {
			assert$2((this.negative | num.negative) === 0);
			return this.iuxor(num);
		};
		BN$1.prototype.xor = function xor(num) {
			if (this.length > num.length) return this.clone().ixor(num);
			return num.clone().ixor(this);
		};
		BN$1.prototype.uxor = function uxor(num) {
			if (this.length > num.length) return this.clone().iuxor(num);
			return num.clone().iuxor(this);
		};
		BN$1.prototype.inotn = function inotn(width) {
			assert$2(typeof width === "number" && width >= 0);
			var bytesNeeded = Math.ceil(width / 26) | 0;
			var bitsLeft = width % 26;
			this._expand(bytesNeeded);
			if (bitsLeft > 0) bytesNeeded--;
			for (var i$1 = 0; i$1 < bytesNeeded; i$1++) this.words[i$1] = ~this.words[i$1] & 67108863;
			if (bitsLeft > 0) this.words[i$1] = ~this.words[i$1] & 67108863 >> 26 - bitsLeft;
			return this._strip();
		};
		BN$1.prototype.notn = function notn(width) {
			return this.clone().inotn(width);
		};
		BN$1.prototype.setn = function setn(bit, val) {
			assert$2(typeof bit === "number" && bit >= 0);
			var off = bit / 26 | 0;
			var wbit = bit % 26;
			this._expand(off + 1);
			if (val) this.words[off] = this.words[off] | 1 << wbit;
			else this.words[off] = this.words[off] & ~(1 << wbit);
			return this._strip();
		};
		BN$1.prototype.iadd = function iadd(num) {
			var r;
			if (this.negative !== 0 && num.negative === 0) {
				this.negative = 0;
				r = this.isub(num);
				this.negative ^= 1;
				return this._normSign();
			} else if (this.negative === 0 && num.negative !== 0) {
				num.negative = 0;
				r = this.isub(num);
				num.negative = 1;
				return r._normSign();
			}
			var a, b;
			if (this.length > num.length) {
				a = this;
				b = num;
			} else {
				a = num;
				b = this;
			}
			var carry = 0;
			for (var i$1 = 0; i$1 < b.length; i$1++) {
				r = (a.words[i$1] | 0) + (b.words[i$1] | 0) + carry;
				this.words[i$1] = r & 67108863;
				carry = r >>> 26;
			}
			for (; carry !== 0 && i$1 < a.length; i$1++) {
				r = (a.words[i$1] | 0) + carry;
				this.words[i$1] = r & 67108863;
				carry = r >>> 26;
			}
			this.length = a.length;
			if (carry !== 0) {
				this.words[this.length] = carry;
				this.length++;
			} else if (a !== this) for (; i$1 < a.length; i$1++) this.words[i$1] = a.words[i$1];
			return this;
		};
		BN$1.prototype.add = function add$1(num) {
			var res;
			if (num.negative !== 0 && this.negative === 0) {
				num.negative = 0;
				res = this.sub(num);
				num.negative ^= 1;
				return res;
			} else if (num.negative === 0 && this.negative !== 0) {
				this.negative = 0;
				res = num.sub(this);
				this.negative = 1;
				return res;
			}
			if (this.length > num.length) return this.clone().iadd(num);
			return num.clone().iadd(this);
		};
		BN$1.prototype.isub = function isub(num) {
			if (num.negative !== 0) {
				num.negative = 0;
				var r = this.iadd(num);
				num.negative = 1;
				return r._normSign();
			} else if (this.negative !== 0) {
				this.negative = 0;
				this.iadd(num);
				this.negative = 1;
				return this._normSign();
			}
			var cmp = this.cmp(num);
			if (cmp === 0) {
				this.negative = 0;
				this.length = 1;
				this.words[0] = 0;
				return this;
			}
			var a, b;
			if (cmp > 0) {
				a = this;
				b = num;
			} else {
				a = num;
				b = this;
			}
			var carry = 0;
			for (var i$1 = 0; i$1 < b.length; i$1++) {
				r = (a.words[i$1] | 0) - (b.words[i$1] | 0) + carry;
				carry = r >> 26;
				this.words[i$1] = r & 67108863;
			}
			for (; carry !== 0 && i$1 < a.length; i$1++) {
				r = (a.words[i$1] | 0) + carry;
				carry = r >> 26;
				this.words[i$1] = r & 67108863;
			}
			if (carry === 0 && i$1 < a.length && a !== this) for (; i$1 < a.length; i$1++) this.words[i$1] = a.words[i$1];
			this.length = Math.max(this.length, i$1);
			if (a !== this) this.negative = 1;
			return this._strip();
		};
		BN$1.prototype.sub = function sub(num) {
			return this.clone().isub(num);
		};
		function smallMulTo(self, num, out) {
			out.negative = num.negative ^ self.negative;
			var len = self.length + num.length | 0;
			out.length = len;
			len = len - 1 | 0;
			var a = self.words[0] | 0;
			var b = num.words[0] | 0;
			var r = a * b;
			var lo = r & 67108863;
			var carry = r / 67108864 | 0;
			out.words[0] = lo;
			for (var k = 1; k < len; k++) {
				var ncarry = carry >>> 26;
				var rword = carry & 67108863;
				var maxJ = Math.min(k, num.length - 1);
				for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
					var i$1 = k - j | 0;
					a = self.words[i$1] | 0;
					b = num.words[j] | 0;
					r = a * b + rword;
					ncarry += r / 67108864 | 0;
					rword = r & 67108863;
				}
				out.words[k] = rword | 0;
				carry = ncarry | 0;
			}
			if (carry !== 0) out.words[k] = carry | 0;
			else out.length--;
			return out._strip();
		}
		var comb10MulTo = function comb10MulTo$1(self, num, out) {
			var a = self.words;
			var b = num.words;
			var o = out.words;
			var c = 0;
			var lo;
			var mid;
			var hi;
			var a0 = a[0] | 0;
			var al0 = a0 & 8191;
			var ah0 = a0 >>> 13;
			var a1 = a[1] | 0;
			var al1 = a1 & 8191;
			var ah1 = a1 >>> 13;
			var a2 = a[2] | 0;
			var al2 = a2 & 8191;
			var ah2 = a2 >>> 13;
			var a3 = a[3] | 0;
			var al3 = a3 & 8191;
			var ah3 = a3 >>> 13;
			var a4 = a[4] | 0;
			var al4 = a4 & 8191;
			var ah4 = a4 >>> 13;
			var a5 = a[5] | 0;
			var al5 = a5 & 8191;
			var ah5 = a5 >>> 13;
			var a6 = a[6] | 0;
			var al6 = a6 & 8191;
			var ah6 = a6 >>> 13;
			var a7 = a[7] | 0;
			var al7 = a7 & 8191;
			var ah7 = a7 >>> 13;
			var a8 = a[8] | 0;
			var al8 = a8 & 8191;
			var ah8 = a8 >>> 13;
			var a9 = a[9] | 0;
			var al9 = a9 & 8191;
			var ah9 = a9 >>> 13;
			var b0 = b[0] | 0;
			var bl0 = b0 & 8191;
			var bh0 = b0 >>> 13;
			var b1 = b[1] | 0;
			var bl1 = b1 & 8191;
			var bh1 = b1 >>> 13;
			var b2 = b[2] | 0;
			var bl2 = b2 & 8191;
			var bh2 = b2 >>> 13;
			var b3 = b[3] | 0;
			var bl3 = b3 & 8191;
			var bh3 = b3 >>> 13;
			var b4 = b[4] | 0;
			var bl4 = b4 & 8191;
			var bh4 = b4 >>> 13;
			var b5 = b[5] | 0;
			var bl5 = b5 & 8191;
			var bh5 = b5 >>> 13;
			var b6 = b[6] | 0;
			var bl6 = b6 & 8191;
			var bh6 = b6 >>> 13;
			var b7 = b[7] | 0;
			var bl7 = b7 & 8191;
			var bh7 = b7 >>> 13;
			var b8 = b[8] | 0;
			var bl8 = b8 & 8191;
			var bh8 = b8 >>> 13;
			var b9 = b[9] | 0;
			var bl9 = b9 & 8191;
			var bh9 = b9 >>> 13;
			out.negative = self.negative ^ num.negative;
			out.length = 19;
			lo = Math.imul(al0, bl0);
			mid = Math.imul(al0, bh0);
			mid = mid + Math.imul(ah0, bl0) | 0;
			hi = Math.imul(ah0, bh0);
			var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
			w0 &= 67108863;
			lo = Math.imul(al1, bl0);
			mid = Math.imul(al1, bh0);
			mid = mid + Math.imul(ah1, bl0) | 0;
			hi = Math.imul(ah1, bh0);
			lo = lo + Math.imul(al0, bl1) | 0;
			mid = mid + Math.imul(al0, bh1) | 0;
			mid = mid + Math.imul(ah0, bl1) | 0;
			hi = hi + Math.imul(ah0, bh1) | 0;
			var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
			w1 &= 67108863;
			lo = Math.imul(al2, bl0);
			mid = Math.imul(al2, bh0);
			mid = mid + Math.imul(ah2, bl0) | 0;
			hi = Math.imul(ah2, bh0);
			lo = lo + Math.imul(al1, bl1) | 0;
			mid = mid + Math.imul(al1, bh1) | 0;
			mid = mid + Math.imul(ah1, bl1) | 0;
			hi = hi + Math.imul(ah1, bh1) | 0;
			lo = lo + Math.imul(al0, bl2) | 0;
			mid = mid + Math.imul(al0, bh2) | 0;
			mid = mid + Math.imul(ah0, bl2) | 0;
			hi = hi + Math.imul(ah0, bh2) | 0;
			var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
			w2 &= 67108863;
			lo = Math.imul(al3, bl0);
			mid = Math.imul(al3, bh0);
			mid = mid + Math.imul(ah3, bl0) | 0;
			hi = Math.imul(ah3, bh0);
			lo = lo + Math.imul(al2, bl1) | 0;
			mid = mid + Math.imul(al2, bh1) | 0;
			mid = mid + Math.imul(ah2, bl1) | 0;
			hi = hi + Math.imul(ah2, bh1) | 0;
			lo = lo + Math.imul(al1, bl2) | 0;
			mid = mid + Math.imul(al1, bh2) | 0;
			mid = mid + Math.imul(ah1, bl2) | 0;
			hi = hi + Math.imul(ah1, bh2) | 0;
			lo = lo + Math.imul(al0, bl3) | 0;
			mid = mid + Math.imul(al0, bh3) | 0;
			mid = mid + Math.imul(ah0, bl3) | 0;
			hi = hi + Math.imul(ah0, bh3) | 0;
			var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
			w3 &= 67108863;
			lo = Math.imul(al4, bl0);
			mid = Math.imul(al4, bh0);
			mid = mid + Math.imul(ah4, bl0) | 0;
			hi = Math.imul(ah4, bh0);
			lo = lo + Math.imul(al3, bl1) | 0;
			mid = mid + Math.imul(al3, bh1) | 0;
			mid = mid + Math.imul(ah3, bl1) | 0;
			hi = hi + Math.imul(ah3, bh1) | 0;
			lo = lo + Math.imul(al2, bl2) | 0;
			mid = mid + Math.imul(al2, bh2) | 0;
			mid = mid + Math.imul(ah2, bl2) | 0;
			hi = hi + Math.imul(ah2, bh2) | 0;
			lo = lo + Math.imul(al1, bl3) | 0;
			mid = mid + Math.imul(al1, bh3) | 0;
			mid = mid + Math.imul(ah1, bl3) | 0;
			hi = hi + Math.imul(ah1, bh3) | 0;
			lo = lo + Math.imul(al0, bl4) | 0;
			mid = mid + Math.imul(al0, bh4) | 0;
			mid = mid + Math.imul(ah0, bl4) | 0;
			hi = hi + Math.imul(ah0, bh4) | 0;
			var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
			w4 &= 67108863;
			lo = Math.imul(al5, bl0);
			mid = Math.imul(al5, bh0);
			mid = mid + Math.imul(ah5, bl0) | 0;
			hi = Math.imul(ah5, bh0);
			lo = lo + Math.imul(al4, bl1) | 0;
			mid = mid + Math.imul(al4, bh1) | 0;
			mid = mid + Math.imul(ah4, bl1) | 0;
			hi = hi + Math.imul(ah4, bh1) | 0;
			lo = lo + Math.imul(al3, bl2) | 0;
			mid = mid + Math.imul(al3, bh2) | 0;
			mid = mid + Math.imul(ah3, bl2) | 0;
			hi = hi + Math.imul(ah3, bh2) | 0;
			lo = lo + Math.imul(al2, bl3) | 0;
			mid = mid + Math.imul(al2, bh3) | 0;
			mid = mid + Math.imul(ah2, bl3) | 0;
			hi = hi + Math.imul(ah2, bh3) | 0;
			lo = lo + Math.imul(al1, bl4) | 0;
			mid = mid + Math.imul(al1, bh4) | 0;
			mid = mid + Math.imul(ah1, bl4) | 0;
			hi = hi + Math.imul(ah1, bh4) | 0;
			lo = lo + Math.imul(al0, bl5) | 0;
			mid = mid + Math.imul(al0, bh5) | 0;
			mid = mid + Math.imul(ah0, bl5) | 0;
			hi = hi + Math.imul(ah0, bh5) | 0;
			var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
			w5 &= 67108863;
			lo = Math.imul(al6, bl0);
			mid = Math.imul(al6, bh0);
			mid = mid + Math.imul(ah6, bl0) | 0;
			hi = Math.imul(ah6, bh0);
			lo = lo + Math.imul(al5, bl1) | 0;
			mid = mid + Math.imul(al5, bh1) | 0;
			mid = mid + Math.imul(ah5, bl1) | 0;
			hi = hi + Math.imul(ah5, bh1) | 0;
			lo = lo + Math.imul(al4, bl2) | 0;
			mid = mid + Math.imul(al4, bh2) | 0;
			mid = mid + Math.imul(ah4, bl2) | 0;
			hi = hi + Math.imul(ah4, bh2) | 0;
			lo = lo + Math.imul(al3, bl3) | 0;
			mid = mid + Math.imul(al3, bh3) | 0;
			mid = mid + Math.imul(ah3, bl3) | 0;
			hi = hi + Math.imul(ah3, bh3) | 0;
			lo = lo + Math.imul(al2, bl4) | 0;
			mid = mid + Math.imul(al2, bh4) | 0;
			mid = mid + Math.imul(ah2, bl4) | 0;
			hi = hi + Math.imul(ah2, bh4) | 0;
			lo = lo + Math.imul(al1, bl5) | 0;
			mid = mid + Math.imul(al1, bh5) | 0;
			mid = mid + Math.imul(ah1, bl5) | 0;
			hi = hi + Math.imul(ah1, bh5) | 0;
			lo = lo + Math.imul(al0, bl6) | 0;
			mid = mid + Math.imul(al0, bh6) | 0;
			mid = mid + Math.imul(ah0, bl6) | 0;
			hi = hi + Math.imul(ah0, bh6) | 0;
			var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
			w6 &= 67108863;
			lo = Math.imul(al7, bl0);
			mid = Math.imul(al7, bh0);
			mid = mid + Math.imul(ah7, bl0) | 0;
			hi = Math.imul(ah7, bh0);
			lo = lo + Math.imul(al6, bl1) | 0;
			mid = mid + Math.imul(al6, bh1) | 0;
			mid = mid + Math.imul(ah6, bl1) | 0;
			hi = hi + Math.imul(ah6, bh1) | 0;
			lo = lo + Math.imul(al5, bl2) | 0;
			mid = mid + Math.imul(al5, bh2) | 0;
			mid = mid + Math.imul(ah5, bl2) | 0;
			hi = hi + Math.imul(ah5, bh2) | 0;
			lo = lo + Math.imul(al4, bl3) | 0;
			mid = mid + Math.imul(al4, bh3) | 0;
			mid = mid + Math.imul(ah4, bl3) | 0;
			hi = hi + Math.imul(ah4, bh3) | 0;
			lo = lo + Math.imul(al3, bl4) | 0;
			mid = mid + Math.imul(al3, bh4) | 0;
			mid = mid + Math.imul(ah3, bl4) | 0;
			hi = hi + Math.imul(ah3, bh4) | 0;
			lo = lo + Math.imul(al2, bl5) | 0;
			mid = mid + Math.imul(al2, bh5) | 0;
			mid = mid + Math.imul(ah2, bl5) | 0;
			hi = hi + Math.imul(ah2, bh5) | 0;
			lo = lo + Math.imul(al1, bl6) | 0;
			mid = mid + Math.imul(al1, bh6) | 0;
			mid = mid + Math.imul(ah1, bl6) | 0;
			hi = hi + Math.imul(ah1, bh6) | 0;
			lo = lo + Math.imul(al0, bl7) | 0;
			mid = mid + Math.imul(al0, bh7) | 0;
			mid = mid + Math.imul(ah0, bl7) | 0;
			hi = hi + Math.imul(ah0, bh7) | 0;
			var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
			w7 &= 67108863;
			lo = Math.imul(al8, bl0);
			mid = Math.imul(al8, bh0);
			mid = mid + Math.imul(ah8, bl0) | 0;
			hi = Math.imul(ah8, bh0);
			lo = lo + Math.imul(al7, bl1) | 0;
			mid = mid + Math.imul(al7, bh1) | 0;
			mid = mid + Math.imul(ah7, bl1) | 0;
			hi = hi + Math.imul(ah7, bh1) | 0;
			lo = lo + Math.imul(al6, bl2) | 0;
			mid = mid + Math.imul(al6, bh2) | 0;
			mid = mid + Math.imul(ah6, bl2) | 0;
			hi = hi + Math.imul(ah6, bh2) | 0;
			lo = lo + Math.imul(al5, bl3) | 0;
			mid = mid + Math.imul(al5, bh3) | 0;
			mid = mid + Math.imul(ah5, bl3) | 0;
			hi = hi + Math.imul(ah5, bh3) | 0;
			lo = lo + Math.imul(al4, bl4) | 0;
			mid = mid + Math.imul(al4, bh4) | 0;
			mid = mid + Math.imul(ah4, bl4) | 0;
			hi = hi + Math.imul(ah4, bh4) | 0;
			lo = lo + Math.imul(al3, bl5) | 0;
			mid = mid + Math.imul(al3, bh5) | 0;
			mid = mid + Math.imul(ah3, bl5) | 0;
			hi = hi + Math.imul(ah3, bh5) | 0;
			lo = lo + Math.imul(al2, bl6) | 0;
			mid = mid + Math.imul(al2, bh6) | 0;
			mid = mid + Math.imul(ah2, bl6) | 0;
			hi = hi + Math.imul(ah2, bh6) | 0;
			lo = lo + Math.imul(al1, bl7) | 0;
			mid = mid + Math.imul(al1, bh7) | 0;
			mid = mid + Math.imul(ah1, bl7) | 0;
			hi = hi + Math.imul(ah1, bh7) | 0;
			lo = lo + Math.imul(al0, bl8) | 0;
			mid = mid + Math.imul(al0, bh8) | 0;
			mid = mid + Math.imul(ah0, bl8) | 0;
			hi = hi + Math.imul(ah0, bh8) | 0;
			var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
			w8 &= 67108863;
			lo = Math.imul(al9, bl0);
			mid = Math.imul(al9, bh0);
			mid = mid + Math.imul(ah9, bl0) | 0;
			hi = Math.imul(ah9, bh0);
			lo = lo + Math.imul(al8, bl1) | 0;
			mid = mid + Math.imul(al8, bh1) | 0;
			mid = mid + Math.imul(ah8, bl1) | 0;
			hi = hi + Math.imul(ah8, bh1) | 0;
			lo = lo + Math.imul(al7, bl2) | 0;
			mid = mid + Math.imul(al7, bh2) | 0;
			mid = mid + Math.imul(ah7, bl2) | 0;
			hi = hi + Math.imul(ah7, bh2) | 0;
			lo = lo + Math.imul(al6, bl3) | 0;
			mid = mid + Math.imul(al6, bh3) | 0;
			mid = mid + Math.imul(ah6, bl3) | 0;
			hi = hi + Math.imul(ah6, bh3) | 0;
			lo = lo + Math.imul(al5, bl4) | 0;
			mid = mid + Math.imul(al5, bh4) | 0;
			mid = mid + Math.imul(ah5, bl4) | 0;
			hi = hi + Math.imul(ah5, bh4) | 0;
			lo = lo + Math.imul(al4, bl5) | 0;
			mid = mid + Math.imul(al4, bh5) | 0;
			mid = mid + Math.imul(ah4, bl5) | 0;
			hi = hi + Math.imul(ah4, bh5) | 0;
			lo = lo + Math.imul(al3, bl6) | 0;
			mid = mid + Math.imul(al3, bh6) | 0;
			mid = mid + Math.imul(ah3, bl6) | 0;
			hi = hi + Math.imul(ah3, bh6) | 0;
			lo = lo + Math.imul(al2, bl7) | 0;
			mid = mid + Math.imul(al2, bh7) | 0;
			mid = mid + Math.imul(ah2, bl7) | 0;
			hi = hi + Math.imul(ah2, bh7) | 0;
			lo = lo + Math.imul(al1, bl8) | 0;
			mid = mid + Math.imul(al1, bh8) | 0;
			mid = mid + Math.imul(ah1, bl8) | 0;
			hi = hi + Math.imul(ah1, bh8) | 0;
			lo = lo + Math.imul(al0, bl9) | 0;
			mid = mid + Math.imul(al0, bh9) | 0;
			mid = mid + Math.imul(ah0, bl9) | 0;
			hi = hi + Math.imul(ah0, bh9) | 0;
			var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
			w9 &= 67108863;
			lo = Math.imul(al9, bl1);
			mid = Math.imul(al9, bh1);
			mid = mid + Math.imul(ah9, bl1) | 0;
			hi = Math.imul(ah9, bh1);
			lo = lo + Math.imul(al8, bl2) | 0;
			mid = mid + Math.imul(al8, bh2) | 0;
			mid = mid + Math.imul(ah8, bl2) | 0;
			hi = hi + Math.imul(ah8, bh2) | 0;
			lo = lo + Math.imul(al7, bl3) | 0;
			mid = mid + Math.imul(al7, bh3) | 0;
			mid = mid + Math.imul(ah7, bl3) | 0;
			hi = hi + Math.imul(ah7, bh3) | 0;
			lo = lo + Math.imul(al6, bl4) | 0;
			mid = mid + Math.imul(al6, bh4) | 0;
			mid = mid + Math.imul(ah6, bl4) | 0;
			hi = hi + Math.imul(ah6, bh4) | 0;
			lo = lo + Math.imul(al5, bl5) | 0;
			mid = mid + Math.imul(al5, bh5) | 0;
			mid = mid + Math.imul(ah5, bl5) | 0;
			hi = hi + Math.imul(ah5, bh5) | 0;
			lo = lo + Math.imul(al4, bl6) | 0;
			mid = mid + Math.imul(al4, bh6) | 0;
			mid = mid + Math.imul(ah4, bl6) | 0;
			hi = hi + Math.imul(ah4, bh6) | 0;
			lo = lo + Math.imul(al3, bl7) | 0;
			mid = mid + Math.imul(al3, bh7) | 0;
			mid = mid + Math.imul(ah3, bl7) | 0;
			hi = hi + Math.imul(ah3, bh7) | 0;
			lo = lo + Math.imul(al2, bl8) | 0;
			mid = mid + Math.imul(al2, bh8) | 0;
			mid = mid + Math.imul(ah2, bl8) | 0;
			hi = hi + Math.imul(ah2, bh8) | 0;
			lo = lo + Math.imul(al1, bl9) | 0;
			mid = mid + Math.imul(al1, bh9) | 0;
			mid = mid + Math.imul(ah1, bl9) | 0;
			hi = hi + Math.imul(ah1, bh9) | 0;
			var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
			w10 &= 67108863;
			lo = Math.imul(al9, bl2);
			mid = Math.imul(al9, bh2);
			mid = mid + Math.imul(ah9, bl2) | 0;
			hi = Math.imul(ah9, bh2);
			lo = lo + Math.imul(al8, bl3) | 0;
			mid = mid + Math.imul(al8, bh3) | 0;
			mid = mid + Math.imul(ah8, bl3) | 0;
			hi = hi + Math.imul(ah8, bh3) | 0;
			lo = lo + Math.imul(al7, bl4) | 0;
			mid = mid + Math.imul(al7, bh4) | 0;
			mid = mid + Math.imul(ah7, bl4) | 0;
			hi = hi + Math.imul(ah7, bh4) | 0;
			lo = lo + Math.imul(al6, bl5) | 0;
			mid = mid + Math.imul(al6, bh5) | 0;
			mid = mid + Math.imul(ah6, bl5) | 0;
			hi = hi + Math.imul(ah6, bh5) | 0;
			lo = lo + Math.imul(al5, bl6) | 0;
			mid = mid + Math.imul(al5, bh6) | 0;
			mid = mid + Math.imul(ah5, bl6) | 0;
			hi = hi + Math.imul(ah5, bh6) | 0;
			lo = lo + Math.imul(al4, bl7) | 0;
			mid = mid + Math.imul(al4, bh7) | 0;
			mid = mid + Math.imul(ah4, bl7) | 0;
			hi = hi + Math.imul(ah4, bh7) | 0;
			lo = lo + Math.imul(al3, bl8) | 0;
			mid = mid + Math.imul(al3, bh8) | 0;
			mid = mid + Math.imul(ah3, bl8) | 0;
			hi = hi + Math.imul(ah3, bh8) | 0;
			lo = lo + Math.imul(al2, bl9) | 0;
			mid = mid + Math.imul(al2, bh9) | 0;
			mid = mid + Math.imul(ah2, bl9) | 0;
			hi = hi + Math.imul(ah2, bh9) | 0;
			var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
			w11 &= 67108863;
			lo = Math.imul(al9, bl3);
			mid = Math.imul(al9, bh3);
			mid = mid + Math.imul(ah9, bl3) | 0;
			hi = Math.imul(ah9, bh3);
			lo = lo + Math.imul(al8, bl4) | 0;
			mid = mid + Math.imul(al8, bh4) | 0;
			mid = mid + Math.imul(ah8, bl4) | 0;
			hi = hi + Math.imul(ah8, bh4) | 0;
			lo = lo + Math.imul(al7, bl5) | 0;
			mid = mid + Math.imul(al7, bh5) | 0;
			mid = mid + Math.imul(ah7, bl5) | 0;
			hi = hi + Math.imul(ah7, bh5) | 0;
			lo = lo + Math.imul(al6, bl6) | 0;
			mid = mid + Math.imul(al6, bh6) | 0;
			mid = mid + Math.imul(ah6, bl6) | 0;
			hi = hi + Math.imul(ah6, bh6) | 0;
			lo = lo + Math.imul(al5, bl7) | 0;
			mid = mid + Math.imul(al5, bh7) | 0;
			mid = mid + Math.imul(ah5, bl7) | 0;
			hi = hi + Math.imul(ah5, bh7) | 0;
			lo = lo + Math.imul(al4, bl8) | 0;
			mid = mid + Math.imul(al4, bh8) | 0;
			mid = mid + Math.imul(ah4, bl8) | 0;
			hi = hi + Math.imul(ah4, bh8) | 0;
			lo = lo + Math.imul(al3, bl9) | 0;
			mid = mid + Math.imul(al3, bh9) | 0;
			mid = mid + Math.imul(ah3, bl9) | 0;
			hi = hi + Math.imul(ah3, bh9) | 0;
			var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
			w12 &= 67108863;
			lo = Math.imul(al9, bl4);
			mid = Math.imul(al9, bh4);
			mid = mid + Math.imul(ah9, bl4) | 0;
			hi = Math.imul(ah9, bh4);
			lo = lo + Math.imul(al8, bl5) | 0;
			mid = mid + Math.imul(al8, bh5) | 0;
			mid = mid + Math.imul(ah8, bl5) | 0;
			hi = hi + Math.imul(ah8, bh5) | 0;
			lo = lo + Math.imul(al7, bl6) | 0;
			mid = mid + Math.imul(al7, bh6) | 0;
			mid = mid + Math.imul(ah7, bl6) | 0;
			hi = hi + Math.imul(ah7, bh6) | 0;
			lo = lo + Math.imul(al6, bl7) | 0;
			mid = mid + Math.imul(al6, bh7) | 0;
			mid = mid + Math.imul(ah6, bl7) | 0;
			hi = hi + Math.imul(ah6, bh7) | 0;
			lo = lo + Math.imul(al5, bl8) | 0;
			mid = mid + Math.imul(al5, bh8) | 0;
			mid = mid + Math.imul(ah5, bl8) | 0;
			hi = hi + Math.imul(ah5, bh8) | 0;
			lo = lo + Math.imul(al4, bl9) | 0;
			mid = mid + Math.imul(al4, bh9) | 0;
			mid = mid + Math.imul(ah4, bl9) | 0;
			hi = hi + Math.imul(ah4, bh9) | 0;
			var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
			w13 &= 67108863;
			lo = Math.imul(al9, bl5);
			mid = Math.imul(al9, bh5);
			mid = mid + Math.imul(ah9, bl5) | 0;
			hi = Math.imul(ah9, bh5);
			lo = lo + Math.imul(al8, bl6) | 0;
			mid = mid + Math.imul(al8, bh6) | 0;
			mid = mid + Math.imul(ah8, bl6) | 0;
			hi = hi + Math.imul(ah8, bh6) | 0;
			lo = lo + Math.imul(al7, bl7) | 0;
			mid = mid + Math.imul(al7, bh7) | 0;
			mid = mid + Math.imul(ah7, bl7) | 0;
			hi = hi + Math.imul(ah7, bh7) | 0;
			lo = lo + Math.imul(al6, bl8) | 0;
			mid = mid + Math.imul(al6, bh8) | 0;
			mid = mid + Math.imul(ah6, bl8) | 0;
			hi = hi + Math.imul(ah6, bh8) | 0;
			lo = lo + Math.imul(al5, bl9) | 0;
			mid = mid + Math.imul(al5, bh9) | 0;
			mid = mid + Math.imul(ah5, bl9) | 0;
			hi = hi + Math.imul(ah5, bh9) | 0;
			var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
			w14 &= 67108863;
			lo = Math.imul(al9, bl6);
			mid = Math.imul(al9, bh6);
			mid = mid + Math.imul(ah9, bl6) | 0;
			hi = Math.imul(ah9, bh6);
			lo = lo + Math.imul(al8, bl7) | 0;
			mid = mid + Math.imul(al8, bh7) | 0;
			mid = mid + Math.imul(ah8, bl7) | 0;
			hi = hi + Math.imul(ah8, bh7) | 0;
			lo = lo + Math.imul(al7, bl8) | 0;
			mid = mid + Math.imul(al7, bh8) | 0;
			mid = mid + Math.imul(ah7, bl8) | 0;
			hi = hi + Math.imul(ah7, bh8) | 0;
			lo = lo + Math.imul(al6, bl9) | 0;
			mid = mid + Math.imul(al6, bh9) | 0;
			mid = mid + Math.imul(ah6, bl9) | 0;
			hi = hi + Math.imul(ah6, bh9) | 0;
			var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
			w15 &= 67108863;
			lo = Math.imul(al9, bl7);
			mid = Math.imul(al9, bh7);
			mid = mid + Math.imul(ah9, bl7) | 0;
			hi = Math.imul(ah9, bh7);
			lo = lo + Math.imul(al8, bl8) | 0;
			mid = mid + Math.imul(al8, bh8) | 0;
			mid = mid + Math.imul(ah8, bl8) | 0;
			hi = hi + Math.imul(ah8, bh8) | 0;
			lo = lo + Math.imul(al7, bl9) | 0;
			mid = mid + Math.imul(al7, bh9) | 0;
			mid = mid + Math.imul(ah7, bl9) | 0;
			hi = hi + Math.imul(ah7, bh9) | 0;
			var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
			w16 &= 67108863;
			lo = Math.imul(al9, bl8);
			mid = Math.imul(al9, bh8);
			mid = mid + Math.imul(ah9, bl8) | 0;
			hi = Math.imul(ah9, bh8);
			lo = lo + Math.imul(al8, bl9) | 0;
			mid = mid + Math.imul(al8, bh9) | 0;
			mid = mid + Math.imul(ah8, bl9) | 0;
			hi = hi + Math.imul(ah8, bh9) | 0;
			var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
			w17 &= 67108863;
			lo = Math.imul(al9, bl9);
			mid = Math.imul(al9, bh9);
			mid = mid + Math.imul(ah9, bl9) | 0;
			hi = Math.imul(ah9, bh9);
			var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
			c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
			w18 &= 67108863;
			o[0] = w0;
			o[1] = w1;
			o[2] = w2;
			o[3] = w3;
			o[4] = w4;
			o[5] = w5;
			o[6] = w6;
			o[7] = w7;
			o[8] = w8;
			o[9] = w9;
			o[10] = w10;
			o[11] = w11;
			o[12] = w12;
			o[13] = w13;
			o[14] = w14;
			o[15] = w15;
			o[16] = w16;
			o[17] = w17;
			o[18] = w18;
			if (c !== 0) {
				o[19] = c;
				out.length++;
			}
			return out;
		};
		if (!Math.imul) comb10MulTo = smallMulTo;
		function bigMulTo(self, num, out) {
			out.negative = num.negative ^ self.negative;
			out.length = self.length + num.length;
			var carry = 0;
			var hncarry = 0;
			for (var k = 0; k < out.length - 1; k++) {
				var ncarry = hncarry;
				hncarry = 0;
				var rword = carry & 67108863;
				var maxJ = Math.min(k, num.length - 1);
				for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
					var i$1 = k - j;
					var r = (self.words[i$1] | 0) * (num.words[j] | 0);
					var lo = r & 67108863;
					ncarry = ncarry + (r / 67108864 | 0) | 0;
					lo = lo + rword | 0;
					rword = lo & 67108863;
					ncarry = ncarry + (lo >>> 26) | 0;
					hncarry += ncarry >>> 26;
					ncarry &= 67108863;
				}
				out.words[k] = rword;
				carry = ncarry;
				ncarry = hncarry;
			}
			if (carry !== 0) out.words[k] = carry;
			else out.length--;
			return out._strip();
		}
		function jumboMulTo(self, num, out) {
			return bigMulTo(self, num, out);
		}
		BN$1.prototype.mulTo = function mulTo(num, out) {
			var res;
			var len = this.length + num.length;
			if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
			else if (len < 63) res = smallMulTo(this, num, out);
			else if (len < 1024) res = bigMulTo(this, num, out);
			else res = jumboMulTo(this, num, out);
			return res;
		};
		function FFTM(x, y) {
			this.x = x;
			this.y = y;
		}
		FFTM.prototype.makeRBT = function makeRBT(N) {
			var t = new Array(N);
			var l = BN$1.prototype._countBits(N) - 1;
			for (var i$1 = 0; i$1 < N; i$1++) t[i$1] = this.revBin(i$1, l, N);
			return t;
		};
		FFTM.prototype.revBin = function revBin(x, l, N) {
			if (x === 0 || x === N - 1) return x;
			var rb = 0;
			for (var i$1 = 0; i$1 < l; i$1++) {
				rb |= (x & 1) << l - i$1 - 1;
				x >>= 1;
			}
			return rb;
		};
		FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
			for (var i$1 = 0; i$1 < N; i$1++) {
				rtws[i$1] = rws[rbt[i$1]];
				itws[i$1] = iws[rbt[i$1]];
			}
		};
		FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
			this.permute(rbt, rws, iws, rtws, itws, N);
			for (var s = 1; s < N; s <<= 1) {
				var l = s << 1;
				var rtwdf = Math.cos(2 * Math.PI / l);
				var itwdf = Math.sin(2 * Math.PI / l);
				for (var p = 0; p < N; p += l) {
					var rtwdf_ = rtwdf;
					var itwdf_ = itwdf;
					for (var j = 0; j < s; j++) {
						var re = rtws[p + j];
						var ie = itws[p + j];
						var ro = rtws[p + j + s];
						var io = itws[p + j + s];
						var rx = rtwdf_ * ro - itwdf_ * io;
						io = rtwdf_ * io + itwdf_ * ro;
						ro = rx;
						rtws[p + j] = re + ro;
						itws[p + j] = ie + io;
						rtws[p + j + s] = re - ro;
						itws[p + j + s] = ie - io;
						if (j !== l) {
							rx = rtwdf * rtwdf_ - itwdf * itwdf_;
							itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
							rtwdf_ = rx;
						}
					}
				}
			}
		};
		FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
			var N = Math.max(m, n) | 1;
			var odd = N & 1;
			var i$1 = 0;
			for (N = N / 2 | 0; N; N = N >>> 1) i$1++;
			return 1 << i$1 + 1 + odd;
		};
		FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
			if (N <= 1) return;
			for (var i$1 = 0; i$1 < N / 2; i$1++) {
				var t = rws[i$1];
				rws[i$1] = rws[N - i$1 - 1];
				rws[N - i$1 - 1] = t;
				t = iws[i$1];
				iws[i$1] = -iws[N - i$1 - 1];
				iws[N - i$1 - 1] = -t;
			}
		};
		FFTM.prototype.normalize13b = function normalize13b(ws, N) {
			var carry = 0;
			for (var i$1 = 0; i$1 < N / 2; i$1++) {
				var w = Math.round(ws[2 * i$1 + 1] / N) * 8192 + Math.round(ws[2 * i$1] / N) + carry;
				ws[i$1] = w & 67108863;
				if (w < 67108864) carry = 0;
				else carry = w / 67108864 | 0;
			}
			return ws;
		};
		FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
			var carry = 0;
			for (var i$1 = 0; i$1 < len; i$1++) {
				carry = carry + (ws[i$1] | 0);
				rws[2 * i$1] = carry & 8191;
				carry = carry >>> 13;
				rws[2 * i$1 + 1] = carry & 8191;
				carry = carry >>> 13;
			}
			for (i$1 = 2 * len; i$1 < N; ++i$1) rws[i$1] = 0;
			assert$2(carry === 0);
			assert$2((carry & -8192) === 0);
		};
		FFTM.prototype.stub = function stub(N) {
			var ph = new Array(N);
			for (var i$1 = 0; i$1 < N; i$1++) ph[i$1] = 0;
			return ph;
		};
		FFTM.prototype.mulp = function mulp(x, y, out) {
			var N = 2 * this.guessLen13b(x.length, y.length);
			var rbt = this.makeRBT(N);
			var _ = this.stub(N);
			var rws = new Array(N);
			var rwst = new Array(N);
			var iwst = new Array(N);
			var nrws = new Array(N);
			var nrwst = new Array(N);
			var niwst = new Array(N);
			var rmws = out.words;
			rmws.length = N;
			this.convert13b(x.words, x.length, rws, N);
			this.convert13b(y.words, y.length, nrws, N);
			this.transform(rws, _, rwst, iwst, N, rbt);
			this.transform(nrws, _, nrwst, niwst, N, rbt);
			for (var i$1 = 0; i$1 < N; i$1++) {
				var rx = rwst[i$1] * nrwst[i$1] - iwst[i$1] * niwst[i$1];
				iwst[i$1] = rwst[i$1] * niwst[i$1] + iwst[i$1] * nrwst[i$1];
				rwst[i$1] = rx;
			}
			this.conjugate(rwst, iwst, N);
			this.transform(rwst, iwst, rmws, _, N, rbt);
			this.conjugate(rmws, _, N);
			this.normalize13b(rmws, N);
			out.negative = x.negative ^ y.negative;
			out.length = x.length + y.length;
			return out._strip();
		};
		BN$1.prototype.mul = function mul(num) {
			var out = new BN$1(null);
			out.words = new Array(this.length + num.length);
			return this.mulTo(num, out);
		};
		BN$1.prototype.mulf = function mulf(num) {
			var out = new BN$1(null);
			out.words = new Array(this.length + num.length);
			return jumboMulTo(this, num, out);
		};
		BN$1.prototype.imul = function imul(num) {
			return this.clone().mulTo(num, this);
		};
		BN$1.prototype.imuln = function imuln(num) {
			var isNegNum = num < 0;
			if (isNegNum) num = -num;
			assert$2(typeof num === "number");
			assert$2(num < 67108864);
			var carry = 0;
			for (var i$1 = 0; i$1 < this.length; i$1++) {
				var w = (this.words[i$1] | 0) * num;
				var lo = (w & 67108863) + (carry & 67108863);
				carry >>= 26;
				carry += w / 67108864 | 0;
				carry += lo >>> 26;
				this.words[i$1] = lo & 67108863;
			}
			if (carry !== 0) {
				this.words[i$1] = carry;
				this.length++;
			}
			this.length = num === 0 ? 1 : this.length;
			return isNegNum ? this.ineg() : this;
		};
		BN$1.prototype.muln = function muln(num) {
			return this.clone().imuln(num);
		};
		BN$1.prototype.sqr = function sqr() {
			return this.mul(this);
		};
		BN$1.prototype.isqr = function isqr() {
			return this.imul(this.clone());
		};
		BN$1.prototype.pow = function pow(num) {
			var w = toBitArray(num);
			if (w.length === 0) return new BN$1(1);
			var res = this;
			for (var i$1 = 0; i$1 < w.length; i$1++, res = res.sqr()) if (w[i$1] !== 0) break;
			if (++i$1 < w.length) for (var q = res.sqr(); i$1 < w.length; i$1++, q = q.sqr()) {
				if (w[i$1] === 0) continue;
				res = res.mul(q);
			}
			return res;
		};
		BN$1.prototype.iushln = function iushln(bits) {
			assert$2(typeof bits === "number" && bits >= 0);
			var r = bits % 26;
			var s = (bits - r) / 26;
			var carryMask = 67108863 >>> 26 - r << 26 - r;
			var i$1;
			if (r !== 0) {
				var carry = 0;
				for (i$1 = 0; i$1 < this.length; i$1++) {
					var newCarry = this.words[i$1] & carryMask;
					var c = (this.words[i$1] | 0) - newCarry << r;
					this.words[i$1] = c | carry;
					carry = newCarry >>> 26 - r;
				}
				if (carry) {
					this.words[i$1] = carry;
					this.length++;
				}
			}
			if (s !== 0) {
				for (i$1 = this.length - 1; i$1 >= 0; i$1--) this.words[i$1 + s] = this.words[i$1];
				for (i$1 = 0; i$1 < s; i$1++) this.words[i$1] = 0;
				this.length += s;
			}
			return this._strip();
		};
		BN$1.prototype.ishln = function ishln(bits) {
			assert$2(this.negative === 0);
			return this.iushln(bits);
		};
		BN$1.prototype.iushrn = function iushrn(bits, hint, extended) {
			assert$2(typeof bits === "number" && bits >= 0);
			var h;
			if (hint) h = (hint - hint % 26) / 26;
			else h = 0;
			var r = bits % 26;
			var s = Math.min((bits - r) / 26, this.length);
			var mask$1 = 67108863 ^ 67108863 >>> r << r;
			var maskedWords = extended;
			h -= s;
			h = Math.max(0, h);
			if (maskedWords) {
				for (var i$1 = 0; i$1 < s; i$1++) maskedWords.words[i$1] = this.words[i$1];
				maskedWords.length = s;
			}
			if (s === 0) {} else if (this.length > s) {
				this.length -= s;
				for (i$1 = 0; i$1 < this.length; i$1++) this.words[i$1] = this.words[i$1 + s];
			} else {
				this.words[0] = 0;
				this.length = 1;
			}
			var carry = 0;
			for (i$1 = this.length - 1; i$1 >= 0 && (carry !== 0 || i$1 >= h); i$1--) {
				var word = this.words[i$1] | 0;
				this.words[i$1] = carry << 26 - r | word >>> r;
				carry = word & mask$1;
			}
			if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
			if (this.length === 0) {
				this.words[0] = 0;
				this.length = 1;
			}
			return this._strip();
		};
		BN$1.prototype.ishrn = function ishrn(bits, hint, extended) {
			assert$2(this.negative === 0);
			return this.iushrn(bits, hint, extended);
		};
		BN$1.prototype.shln = function shln(bits) {
			return this.clone().ishln(bits);
		};
		BN$1.prototype.ushln = function ushln(bits) {
			return this.clone().iushln(bits);
		};
		BN$1.prototype.shrn = function shrn(bits) {
			return this.clone().ishrn(bits);
		};
		BN$1.prototype.ushrn = function ushrn(bits) {
			return this.clone().iushrn(bits);
		};
		BN$1.prototype.testn = function testn(bit) {
			assert$2(typeof bit === "number" && bit >= 0);
			var r = bit % 26;
			var s = (bit - r) / 26;
			var q = 1 << r;
			if (this.length <= s) return false;
			return !!(this.words[s] & q);
		};
		BN$1.prototype.imaskn = function imaskn(bits) {
			assert$2(typeof bits === "number" && bits >= 0);
			var r = bits % 26;
			var s = (bits - r) / 26;
			assert$2(this.negative === 0, "imaskn works only with positive numbers");
			if (this.length <= s) return this;
			if (r !== 0) s++;
			this.length = Math.min(s, this.length);
			if (r !== 0) {
				var mask$1 = 67108863 ^ 67108863 >>> r << r;
				this.words[this.length - 1] &= mask$1;
			}
			return this._strip();
		};
		BN$1.prototype.maskn = function maskn(bits) {
			return this.clone().imaskn(bits);
		};
		BN$1.prototype.iaddn = function iaddn(num) {
			assert$2(typeof num === "number");
			assert$2(num < 67108864);
			if (num < 0) return this.isubn(-num);
			if (this.negative !== 0) {
				if (this.length === 1 && (this.words[0] | 0) <= num) {
					this.words[0] = num - (this.words[0] | 0);
					this.negative = 0;
					return this;
				}
				this.negative = 0;
				this.isubn(num);
				this.negative = 1;
				return this;
			}
			return this._iaddn(num);
		};
		BN$1.prototype._iaddn = function _iaddn(num) {
			this.words[0] += num;
			for (var i$1 = 0; i$1 < this.length && this.words[i$1] >= 67108864; i$1++) {
				this.words[i$1] -= 67108864;
				if (i$1 === this.length - 1) this.words[i$1 + 1] = 1;
				else this.words[i$1 + 1]++;
			}
			this.length = Math.max(this.length, i$1 + 1);
			return this;
		};
		BN$1.prototype.isubn = function isubn(num) {
			assert$2(typeof num === "number");
			assert$2(num < 67108864);
			if (num < 0) return this.iaddn(-num);
			if (this.negative !== 0) {
				this.negative = 0;
				this.iaddn(num);
				this.negative = 1;
				return this;
			}
			this.words[0] -= num;
			if (this.length === 1 && this.words[0] < 0) {
				this.words[0] = -this.words[0];
				this.negative = 1;
			} else for (var i$1 = 0; i$1 < this.length && this.words[i$1] < 0; i$1++) {
				this.words[i$1] += 67108864;
				this.words[i$1 + 1] -= 1;
			}
			return this._strip();
		};
		BN$1.prototype.addn = function addn(num) {
			return this.clone().iaddn(num);
		};
		BN$1.prototype.subn = function subn(num) {
			return this.clone().isubn(num);
		};
		BN$1.prototype.iabs = function iabs() {
			this.negative = 0;
			return this;
		};
		BN$1.prototype.abs = function abs() {
			return this.clone().iabs();
		};
		BN$1.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
			var len = num.length + shift;
			var i$1;
			this._expand(len);
			var w;
			var carry = 0;
			for (i$1 = 0; i$1 < num.length; i$1++) {
				w = (this.words[i$1 + shift] | 0) + carry;
				var right = (num.words[i$1] | 0) * mul;
				w -= right & 67108863;
				carry = (w >> 26) - (right / 67108864 | 0);
				this.words[i$1 + shift] = w & 67108863;
			}
			for (; i$1 < this.length - shift; i$1++) {
				w = (this.words[i$1 + shift] | 0) + carry;
				carry = w >> 26;
				this.words[i$1 + shift] = w & 67108863;
			}
			if (carry === 0) return this._strip();
			assert$2(carry === -1);
			carry = 0;
			for (i$1 = 0; i$1 < this.length; i$1++) {
				w = -(this.words[i$1] | 0) + carry;
				carry = w >> 26;
				this.words[i$1] = w & 67108863;
			}
			this.negative = 1;
			return this._strip();
		};
		BN$1.prototype._wordDiv = function _wordDiv(num, mode) {
			var shift = this.length - num.length;
			var a = this.clone();
			var b = num;
			var bhi = b.words[b.length - 1] | 0;
			shift = 26 - this._countBits(bhi);
			if (shift !== 0) {
				b = b.ushln(shift);
				a.iushln(shift);
				bhi = b.words[b.length - 1] | 0;
			}
			var m = a.length - b.length;
			var q;
			if (mode !== "mod") {
				q = new BN$1(null);
				q.length = m + 1;
				q.words = new Array(q.length);
				for (var i$1 = 0; i$1 < q.length; i$1++) q.words[i$1] = 0;
			}
			var diff = a.clone()._ishlnsubmul(b, 1, m);
			if (diff.negative === 0) {
				a = diff;
				if (q) q.words[m] = 1;
			}
			for (var j = m - 1; j >= 0; j--) {
				var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
				qj = Math.min(qj / bhi | 0, 67108863);
				a._ishlnsubmul(b, qj, j);
				while (a.negative !== 0) {
					qj--;
					a.negative = 0;
					a._ishlnsubmul(b, 1, j);
					if (!a.isZero()) a.negative ^= 1;
				}
				if (q) q.words[j] = qj;
			}
			if (q) q._strip();
			a._strip();
			if (mode !== "div" && shift !== 0) a.iushrn(shift);
			return {
				div: q || null,
				mod: a
			};
		};
		BN$1.prototype.divmod = function divmod(num, mode, positive) {
			assert$2(!num.isZero());
			if (this.isZero()) return {
				div: new BN$1(0),
				mod: new BN$1(0)
			};
			var div, mod$1, res;
			if (this.negative !== 0 && num.negative === 0) {
				res = this.neg().divmod(num, mode);
				if (mode !== "mod") div = res.div.neg();
				if (mode !== "div") {
					mod$1 = res.mod.neg();
					if (positive && mod$1.negative !== 0) mod$1.iadd(num);
				}
				return {
					div,
					mod: mod$1
				};
			}
			if (this.negative === 0 && num.negative !== 0) {
				res = this.divmod(num.neg(), mode);
				if (mode !== "mod") div = res.div.neg();
				return {
					div,
					mod: res.mod
				};
			}
			if ((this.negative & num.negative) !== 0) {
				res = this.neg().divmod(num.neg(), mode);
				if (mode !== "div") {
					mod$1 = res.mod.neg();
					if (positive && mod$1.negative !== 0) mod$1.isub(num);
				}
				return {
					div: res.div,
					mod: mod$1
				};
			}
			if (num.length > this.length || this.cmp(num) < 0) return {
				div: new BN$1(0),
				mod: this
			};
			if (num.length === 1) {
				if (mode === "div") return {
					div: this.divn(num.words[0]),
					mod: null
				};
				if (mode === "mod") return {
					div: null,
					mod: new BN$1(this.modrn(num.words[0]))
				};
				return {
					div: this.divn(num.words[0]),
					mod: new BN$1(this.modrn(num.words[0]))
				};
			}
			return this._wordDiv(num, mode);
		};
		BN$1.prototype.div = function div(num) {
			return this.divmod(num, "div", false).div;
		};
		BN$1.prototype.mod = function mod$1(num) {
			return this.divmod(num, "mod", false).mod;
		};
		BN$1.prototype.umod = function umod(num) {
			return this.divmod(num, "mod", true).mod;
		};
		BN$1.prototype.divRound = function divRound(num) {
			var dm = this.divmod(num);
			if (dm.mod.isZero()) return dm.div;
			var mod$1 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
			var half = num.ushrn(1);
			var r2 = num.andln(1);
			var cmp = mod$1.cmp(half);
			if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
			return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		};
		BN$1.prototype.modrn = function modrn(num) {
			var isNegNum = num < 0;
			if (isNegNum) num = -num;
			assert$2(num <= 67108863);
			var p = (1 << 26) % num;
			var acc = 0;
			for (var i$1 = this.length - 1; i$1 >= 0; i$1--) acc = (p * acc + (this.words[i$1] | 0)) % num;
			return isNegNum ? -acc : acc;
		};
		BN$1.prototype.modn = function modn(num) {
			return this.modrn(num);
		};
		BN$1.prototype.idivn = function idivn(num) {
			var isNegNum = num < 0;
			if (isNegNum) num = -num;
			assert$2(num <= 67108863);
			var carry = 0;
			for (var i$1 = this.length - 1; i$1 >= 0; i$1--) {
				var w = (this.words[i$1] | 0) + carry * 67108864;
				this.words[i$1] = w / num | 0;
				carry = w % num;
			}
			this._strip();
			return isNegNum ? this.ineg() : this;
		};
		BN$1.prototype.divn = function divn(num) {
			return this.clone().idivn(num);
		};
		BN$1.prototype.egcd = function egcd(p) {
			assert$2(p.negative === 0);
			assert$2(!p.isZero());
			var x = this;
			var y = p.clone();
			if (x.negative !== 0) x = x.umod(p);
			else x = x.clone();
			var A = new BN$1(1);
			var B = new BN$1(0);
			var C = new BN$1(0);
			var D = new BN$1(1);
			var g = 0;
			while (x.isEven() && y.isEven()) {
				x.iushrn(1);
				y.iushrn(1);
				++g;
			}
			var yp = y.clone();
			var xp = x.clone();
			while (!x.isZero()) {
				for (var i$1 = 0, im = 1; (x.words[0] & im) === 0 && i$1 < 26; ++i$1, im <<= 1);
				if (i$1 > 0) {
					x.iushrn(i$1);
					while (i$1-- > 0) {
						if (A.isOdd() || B.isOdd()) {
							A.iadd(yp);
							B.isub(xp);
						}
						A.iushrn(1);
						B.iushrn(1);
					}
				}
				for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
				if (j > 0) {
					y.iushrn(j);
					while (j-- > 0) {
						if (C.isOdd() || D.isOdd()) {
							C.iadd(yp);
							D.isub(xp);
						}
						C.iushrn(1);
						D.iushrn(1);
					}
				}
				if (x.cmp(y) >= 0) {
					x.isub(y);
					A.isub(C);
					B.isub(D);
				} else {
					y.isub(x);
					C.isub(A);
					D.isub(B);
				}
			}
			return {
				a: C,
				b: D,
				gcd: y.iushln(g)
			};
		};
		BN$1.prototype._invmp = function _invmp(p) {
			assert$2(p.negative === 0);
			assert$2(!p.isZero());
			var a = this;
			var b = p.clone();
			if (a.negative !== 0) a = a.umod(p);
			else a = a.clone();
			var x1 = new BN$1(1);
			var x2 = new BN$1(0);
			var delta = b.clone();
			while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
				for (var i$1 = 0, im = 1; (a.words[0] & im) === 0 && i$1 < 26; ++i$1, im <<= 1);
				if (i$1 > 0) {
					a.iushrn(i$1);
					while (i$1-- > 0) {
						if (x1.isOdd()) x1.iadd(delta);
						x1.iushrn(1);
					}
				}
				for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
				if (j > 0) {
					b.iushrn(j);
					while (j-- > 0) {
						if (x2.isOdd()) x2.iadd(delta);
						x2.iushrn(1);
					}
				}
				if (a.cmp(b) >= 0) {
					a.isub(b);
					x1.isub(x2);
				} else {
					b.isub(a);
					x2.isub(x1);
				}
			}
			var res;
			if (a.cmpn(1) === 0) res = x1;
			else res = x2;
			if (res.cmpn(0) < 0) res.iadd(p);
			return res;
		};
		BN$1.prototype.gcd = function gcd(num) {
			if (this.isZero()) return num.abs();
			if (num.isZero()) return this.abs();
			var a = this.clone();
			var b = num.clone();
			a.negative = 0;
			b.negative = 0;
			for (var shift = 0; a.isEven() && b.isEven(); shift++) {
				a.iushrn(1);
				b.iushrn(1);
			}
			do {
				while (a.isEven()) a.iushrn(1);
				while (b.isEven()) b.iushrn(1);
				var r = a.cmp(b);
				if (r < 0) {
					var t = a;
					a = b;
					b = t;
				} else if (r === 0 || b.cmpn(1) === 0) break;
				a.isub(b);
			} while (true);
			return b.iushln(shift);
		};
		BN$1.prototype.invm = function invm(num) {
			return this.egcd(num).a.umod(num);
		};
		BN$1.prototype.isEven = function isEven() {
			return (this.words[0] & 1) === 0;
		};
		BN$1.prototype.isOdd = function isOdd() {
			return (this.words[0] & 1) === 1;
		};
		BN$1.prototype.andln = function andln(num) {
			return this.words[0] & num;
		};
		BN$1.prototype.bincn = function bincn(bit) {
			assert$2(typeof bit === "number");
			var r = bit % 26;
			var s = (bit - r) / 26;
			var q = 1 << r;
			if (this.length <= s) {
				this._expand(s + 1);
				this.words[s] |= q;
				return this;
			}
			var carry = q;
			for (var i$1 = s; carry !== 0 && i$1 < this.length; i$1++) {
				var w = this.words[i$1] | 0;
				w += carry;
				carry = w >>> 26;
				w &= 67108863;
				this.words[i$1] = w;
			}
			if (carry !== 0) {
				this.words[i$1] = carry;
				this.length++;
			}
			return this;
		};
		BN$1.prototype.isZero = function isZero() {
			return this.length === 1 && this.words[0] === 0;
		};
		BN$1.prototype.cmpn = function cmpn(num) {
			var negative = num < 0;
			if (this.negative !== 0 && !negative) return -1;
			if (this.negative === 0 && negative) return 1;
			this._strip();
			var res;
			if (this.length > 1) res = 1;
			else {
				if (negative) num = -num;
				assert$2(num <= 67108863, "Number is too big");
				var w = this.words[0] | 0;
				res = w === num ? 0 : w < num ? -1 : 1;
			}
			if (this.negative !== 0) return -res | 0;
			return res;
		};
		BN$1.prototype.cmp = function cmp(num) {
			if (this.negative !== 0 && num.negative === 0) return -1;
			if (this.negative === 0 && num.negative !== 0) return 1;
			var res = this.ucmp(num);
			if (this.negative !== 0) return -res | 0;
			return res;
		};
		BN$1.prototype.ucmp = function ucmp(num) {
			if (this.length > num.length) return 1;
			if (this.length < num.length) return -1;
			var res = 0;
			for (var i$1 = this.length - 1; i$1 >= 0; i$1--) {
				var a = this.words[i$1] | 0;
				var b = num.words[i$1] | 0;
				if (a === b) continue;
				if (a < b) res = -1;
				else if (a > b) res = 1;
				break;
			}
			return res;
		};
		BN$1.prototype.gtn = function gtn(num) {
			return this.cmpn(num) === 1;
		};
		BN$1.prototype.gt = function gt(num) {
			return this.cmp(num) === 1;
		};
		BN$1.prototype.gten = function gten(num) {
			return this.cmpn(num) >= 0;
		};
		BN$1.prototype.gte = function gte(num) {
			return this.cmp(num) >= 0;
		};
		BN$1.prototype.ltn = function ltn(num) {
			return this.cmpn(num) === -1;
		};
		BN$1.prototype.lt = function lt(num) {
			return this.cmp(num) === -1;
		};
		BN$1.prototype.lten = function lten(num) {
			return this.cmpn(num) <= 0;
		};
		BN$1.prototype.lte = function lte(num) {
			return this.cmp(num) <= 0;
		};
		BN$1.prototype.eqn = function eqn(num) {
			return this.cmpn(num) === 0;
		};
		BN$1.prototype.eq = function eq(num) {
			return this.cmp(num) === 0;
		};
		BN$1.red = function red(num) {
			return new Red(num);
		};
		BN$1.prototype.toRed = function toRed(ctx) {
			assert$2(!this.red, "Already a number in reduction context");
			assert$2(this.negative === 0, "red works only with positives");
			return ctx.convertTo(this)._forceRed(ctx);
		};
		BN$1.prototype.fromRed = function fromRed() {
			assert$2(this.red, "fromRed works only with numbers in reduction context");
			return this.red.convertFrom(this);
		};
		BN$1.prototype._forceRed = function _forceRed(ctx) {
			this.red = ctx;
			return this;
		};
		BN$1.prototype.forceRed = function forceRed(ctx) {
			assert$2(!this.red, "Already a number in reduction context");
			return this._forceRed(ctx);
		};
		BN$1.prototype.redAdd = function redAdd(num) {
			assert$2(this.red, "redAdd works only with red numbers");
			return this.red.add(this, num);
		};
		BN$1.prototype.redIAdd = function redIAdd(num) {
			assert$2(this.red, "redIAdd works only with red numbers");
			return this.red.iadd(this, num);
		};
		BN$1.prototype.redSub = function redSub(num) {
			assert$2(this.red, "redSub works only with red numbers");
			return this.red.sub(this, num);
		};
		BN$1.prototype.redISub = function redISub(num) {
			assert$2(this.red, "redISub works only with red numbers");
			return this.red.isub(this, num);
		};
		BN$1.prototype.redShl = function redShl(num) {
			assert$2(this.red, "redShl works only with red numbers");
			return this.red.shl(this, num);
		};
		BN$1.prototype.redMul = function redMul(num) {
			assert$2(this.red, "redMul works only with red numbers");
			this.red._verify2(this, num);
			return this.red.mul(this, num);
		};
		BN$1.prototype.redIMul = function redIMul(num) {
			assert$2(this.red, "redMul works only with red numbers");
			this.red._verify2(this, num);
			return this.red.imul(this, num);
		};
		BN$1.prototype.redSqr = function redSqr() {
			assert$2(this.red, "redSqr works only with red numbers");
			this.red._verify1(this);
			return this.red.sqr(this);
		};
		BN$1.prototype.redISqr = function redISqr() {
			assert$2(this.red, "redISqr works only with red numbers");
			this.red._verify1(this);
			return this.red.isqr(this);
		};
		BN$1.prototype.redSqrt = function redSqrt() {
			assert$2(this.red, "redSqrt works only with red numbers");
			this.red._verify1(this);
			return this.red.sqrt(this);
		};
		BN$1.prototype.redInvm = function redInvm() {
			assert$2(this.red, "redInvm works only with red numbers");
			this.red._verify1(this);
			return this.red.invm(this);
		};
		BN$1.prototype.redNeg = function redNeg() {
			assert$2(this.red, "redNeg works only with red numbers");
			this.red._verify1(this);
			return this.red.neg(this);
		};
		BN$1.prototype.redPow = function redPow(num) {
			assert$2(this.red && !num.red, "redPow(normalNum)");
			this.red._verify1(this);
			return this.red.pow(this, num);
		};
		var primes = {
			k256: null,
			p224: null,
			p192: null,
			p25519: null
		};
		function MPrime(name, p) {
			this.name = name;
			this.p = new BN$1(p, 16);
			this.n = this.p.bitLength();
			this.k = new BN$1(1).iushln(this.n).isub(this.p);
			this.tmp = this._tmp();
		}
		MPrime.prototype._tmp = function _tmp() {
			var tmp = new BN$1(null);
			tmp.words = new Array(Math.ceil(this.n / 13));
			return tmp;
		};
		MPrime.prototype.ireduce = function ireduce(num) {
			var r = num;
			var rlen;
			do {
				this.split(r, this.tmp);
				r = this.imulK(r);
				r = r.iadd(this.tmp);
				rlen = r.bitLength();
			} while (rlen > this.n);
			var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
			if (cmp === 0) {
				r.words[0] = 0;
				r.length = 1;
			} else if (cmp > 0) r.isub(this.p);
			else if (r.strip !== void 0) r.strip();
			else r._strip();
			return r;
		};
		MPrime.prototype.split = function split$1(input, out) {
			input.iushrn(this.n, 0, out);
		};
		MPrime.prototype.imulK = function imulK(num) {
			return num.imul(this.k);
		};
		function K256() {
			MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
		}
		inherits(K256, MPrime);
		K256.prototype.split = function split$1(input, output) {
			var mask$1 = 4194303;
			var outLen = Math.min(input.length, 9);
			for (var i$1 = 0; i$1 < outLen; i$1++) output.words[i$1] = input.words[i$1];
			output.length = outLen;
			if (input.length <= 9) {
				input.words[0] = 0;
				input.length = 1;
				return;
			}
			var prev = input.words[9];
			output.words[output.length++] = prev & mask$1;
			for (i$1 = 10; i$1 < input.length; i$1++) {
				var next = input.words[i$1] | 0;
				input.words[i$1 - 10] = (next & mask$1) << 4 | prev >>> 22;
				prev = next;
			}
			prev >>>= 22;
			input.words[i$1 - 10] = prev;
			if (prev === 0 && input.length > 10) input.length -= 10;
			else input.length -= 9;
		};
		K256.prototype.imulK = function imulK(num) {
			num.words[num.length] = 0;
			num.words[num.length + 1] = 0;
			num.length += 2;
			var lo = 0;
			for (var i$1 = 0; i$1 < num.length; i$1++) {
				var w = num.words[i$1] | 0;
				lo += w * 977;
				num.words[i$1] = lo & 67108863;
				lo = w * 64 + (lo / 67108864 | 0);
			}
			if (num.words[num.length - 1] === 0) {
				num.length--;
				if (num.words[num.length - 1] === 0) num.length--;
			}
			return num;
		};
		function P224() {
			MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
		}
		inherits(P224, MPrime);
		function P192() {
			MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
		}
		inherits(P192, MPrime);
		function P25519() {
			MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
		}
		inherits(P25519, MPrime);
		P25519.prototype.imulK = function imulK(num) {
			var carry = 0;
			for (var i$1 = 0; i$1 < num.length; i$1++) {
				var hi = (num.words[i$1] | 0) * 19 + carry;
				var lo = hi & 67108863;
				hi >>>= 26;
				num.words[i$1] = lo;
				carry = hi;
			}
			if (carry !== 0) num.words[num.length++] = carry;
			return num;
		};
		BN$1._prime = function prime(name) {
			if (primes[name]) return primes[name];
			var prime$1;
			if (name === "k256") prime$1 = new K256();
			else if (name === "p224") prime$1 = new P224();
			else if (name === "p192") prime$1 = new P192();
			else if (name === "p25519") prime$1 = new P25519();
			else throw new Error("Unknown prime " + name);
			primes[name] = prime$1;
			return prime$1;
		};
		function Red(m) {
			if (typeof m === "string") {
				var prime = BN$1._prime(m);
				this.m = prime.p;
				this.prime = prime;
			} else {
				assert$2(m.gtn(1), "modulus must be greater than 1");
				this.m = m;
				this.prime = null;
			}
		}
		Red.prototype._verify1 = function _verify1(a) {
			assert$2(a.negative === 0, "red works only with positives");
			assert$2(a.red, "red works only with red numbers");
		};
		Red.prototype._verify2 = function _verify2(a, b) {
			assert$2((a.negative | b.negative) === 0, "red works only with positives");
			assert$2(a.red && a.red === b.red, "red works only with red numbers");
		};
		Red.prototype.imod = function imod(a) {
			if (this.prime) return this.prime.ireduce(a)._forceRed(this);
			move(a, a.umod(this.m)._forceRed(this));
			return a;
		};
		Red.prototype.neg = function neg(a) {
			if (a.isZero()) return a.clone();
			return this.m.sub(a)._forceRed(this);
		};
		Red.prototype.add = function add$1(a, b) {
			this._verify2(a, b);
			var res = a.add(b);
			if (res.cmp(this.m) >= 0) res.isub(this.m);
			return res._forceRed(this);
		};
		Red.prototype.iadd = function iadd(a, b) {
			this._verify2(a, b);
			var res = a.iadd(b);
			if (res.cmp(this.m) >= 0) res.isub(this.m);
			return res;
		};
		Red.prototype.sub = function sub(a, b) {
			this._verify2(a, b);
			var res = a.sub(b);
			if (res.cmpn(0) < 0) res.iadd(this.m);
			return res._forceRed(this);
		};
		Red.prototype.isub = function isub(a, b) {
			this._verify2(a, b);
			var res = a.isub(b);
			if (res.cmpn(0) < 0) res.iadd(this.m);
			return res;
		};
		Red.prototype.shl = function shl(a, num) {
			this._verify1(a);
			return this.imod(a.ushln(num));
		};
		Red.prototype.imul = function imul(a, b) {
			this._verify2(a, b);
			return this.imod(a.imul(b));
		};
		Red.prototype.mul = function mul(a, b) {
			this._verify2(a, b);
			return this.imod(a.mul(b));
		};
		Red.prototype.isqr = function isqr(a) {
			return this.imul(a, a.clone());
		};
		Red.prototype.sqr = function sqr(a) {
			return this.mul(a, a);
		};
		Red.prototype.sqrt = function sqrt(a) {
			if (a.isZero()) return a.clone();
			var mod3 = this.m.andln(3);
			assert$2(mod3 % 2 === 1);
			if (mod3 === 3) {
				var pow = this.m.add(new BN$1(1)).iushrn(2);
				return this.pow(a, pow);
			}
			var q = this.m.subn(1);
			var s = 0;
			while (!q.isZero() && q.andln(1) === 0) {
				s++;
				q.iushrn(1);
			}
			assert$2(!q.isZero());
			var one = new BN$1(1).toRed(this);
			var nOne = one.redNeg();
			var lpow = this.m.subn(1).iushrn(1);
			var z = this.m.bitLength();
			z = new BN$1(2 * z * z).toRed(this);
			while (this.pow(z, lpow).cmp(nOne) !== 0) z.redIAdd(nOne);
			var c = this.pow(z, q);
			var r = this.pow(a, q.addn(1).iushrn(1));
			var t = this.pow(a, q);
			var m = s;
			while (t.cmp(one) !== 0) {
				var tmp = t;
				for (var i$1 = 0; tmp.cmp(one) !== 0; i$1++) tmp = tmp.redSqr();
				assert$2(i$1 < m);
				var b = this.pow(c, new BN$1(1).iushln(m - i$1 - 1));
				r = r.redMul(b);
				c = b.redSqr();
				t = t.redMul(c);
				m = i$1;
			}
			return r;
		};
		Red.prototype.invm = function invm(a) {
			var inv = a._invmp(this.m);
			if (inv.negative !== 0) {
				inv.negative = 0;
				return this.imod(inv).redNeg();
			} else return this.imod(inv);
		};
		Red.prototype.pow = function pow(a, num) {
			if (num.isZero()) return new BN$1(1).toRed(this);
			if (num.cmpn(1) === 0) return a.clone();
			var windowSize = 4;
			var wnd = new Array(1 << windowSize);
			wnd[0] = new BN$1(1).toRed(this);
			wnd[1] = a;
			for (var i$1 = 2; i$1 < wnd.length; i$1++) wnd[i$1] = this.mul(wnd[i$1 - 1], a);
			var res = wnd[0];
			var current = 0;
			var currentLen = 0;
			var start = num.bitLength() % 26;
			if (start === 0) start = 26;
			for (i$1 = num.length - 1; i$1 >= 0; i$1--) {
				var word = num.words[i$1];
				for (var j = start - 1; j >= 0; j--) {
					var bit = word >> j & 1;
					if (res !== wnd[0]) res = this.sqr(res);
					if (bit === 0 && current === 0) {
						currentLen = 0;
						continue;
					}
					current <<= 1;
					current |= bit;
					currentLen++;
					if (currentLen !== windowSize && (i$1 !== 0 || j !== 0)) continue;
					res = this.mul(res, wnd[current]);
					currentLen = 0;
					current = 0;
				}
				start = 26;
			}
			return res;
		};
		Red.prototype.convertTo = function convertTo(num) {
			var r = num.umod(this.m);
			return r === num ? r.clone() : r;
		};
		Red.prototype.convertFrom = function convertFrom(num) {
			var res = num.clone();
			res.red = null;
			return res;
		};
		BN$1.mont = function mont(num) {
			return new Mont(num);
		};
		function Mont(m) {
			Red.call(this, m);
			this.shift = this.m.bitLength();
			if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
			this.r = new BN$1(1).iushln(this.shift);
			this.r2 = this.imod(this.r.sqr());
			this.rinv = this.r._invmp(this.m);
			this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
			this.minv = this.minv.umod(this.r);
			this.minv = this.r.sub(this.minv);
		}
		inherits(Mont, Red);
		Mont.prototype.convertTo = function convertTo(num) {
			return this.imod(num.ushln(this.shift));
		};
		Mont.prototype.convertFrom = function convertFrom(num) {
			var r = this.imod(num.mul(this.rinv));
			r.red = null;
			return r;
		};
		Mont.prototype.imul = function imul(a, b) {
			if (a.isZero() || b.isZero()) {
				a.words[0] = 0;
				a.length = 1;
				return a;
			}
			var t = a.imul(b);
			var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
			var u = t.isub(c).iushrn(this.shift);
			var res = u;
			if (u.cmp(this.m) >= 0) res = u.isub(this.m);
			else if (u.cmpn(0) < 0) res = u.iadd(this.m);
			return res._forceRed(this);
		};
		Mont.prototype.mul = function mul(a, b) {
			if (a.isZero() || b.isZero()) return new BN$1(0)._forceRed(this);
			var t = a.mul(b);
			var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
			var u = t.isub(c).iushrn(this.shift);
			var res = u;
			if (u.cmp(this.m) >= 0) res = u.isub(this.m);
			else if (u.cmpn(0) < 0) res = u.iadd(this.m);
			return res._forceRed(this);
		};
		Mont.prototype.invm = function invm(a) {
			return this.imod(a._invmp(this.m).mul(this.r2))._forceRed(this);
		};
	})(typeof module === "undefined" || module, exports);
}) });

//#endregion
//#region node_modules/safe-buffer/index.js
var require_safe_buffer = /* @__PURE__ */ __commonJS({ "node_modules/safe-buffer/index.js": ((exports, module) => {
	var buffer = require_buffer();
	var Buffer$3 = buffer.Buffer;
	function copyProps(src, dst) {
		for (var key in src) dst[key] = src[key];
	}
	if (Buffer$3.from && Buffer$3.alloc && Buffer$3.allocUnsafe && Buffer$3.allocUnsafeSlow) module.exports = buffer;
	else {
		copyProps(buffer, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length) {
		return Buffer$3(arg, encodingOrOffset, length);
	}
	SafeBuffer.prototype = Object.create(Buffer$3.prototype);
	copyProps(Buffer$3, SafeBuffer);
	SafeBuffer.from = function(arg, encodingOrOffset, length) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer$3(arg, encodingOrOffset, length);
	};
	SafeBuffer.alloc = function(size, fill, encoding$1) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer$3(size);
		if (fill !== void 0) if (typeof encoding$1 === "string") buf.fill(fill, encoding$1);
		else buf.fill(fill);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer$3(size);
	};
	SafeBuffer.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer.SlowBuffer(size);
	};
}) });

//#endregion
//#region node_modules/@solana/web3.js/node_modules/base-x/src/index.js
var require_src$1 = /* @__PURE__ */ __commonJS({ "node_modules/@solana/web3.js/node_modules/base-x/src/index.js": ((exports, module) => {
	var _Buffer$1 = require_safe_buffer().Buffer;
	function base$1(ALPHABET$2) {
		if (ALPHABET$2.length >= 255) throw new TypeError("Alphabet too long");
		var BASE_MAP = new Uint8Array(256);
		for (var j = 0; j < BASE_MAP.length; j++) BASE_MAP[j] = 255;
		for (var i$1 = 0; i$1 < ALPHABET$2.length; i$1++) {
			var x = ALPHABET$2.charAt(i$1);
			var xc = x.charCodeAt(0);
			if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
			BASE_MAP[xc] = i$1;
		}
		var BASE = ALPHABET$2.length;
		var LEADER = ALPHABET$2.charAt(0);
		var FACTOR = Math.log(BASE) / Math.log(256);
		var iFACTOR = Math.log(256) / Math.log(BASE);
		function encode(source) {
			if (Array.isArray(source) || source instanceof Uint8Array) source = _Buffer$1.from(source);
			if (!_Buffer$1.isBuffer(source)) throw new TypeError("Expected Buffer");
			if (source.length === 0) return "";
			var zeroes = 0;
			var length = 0;
			var pbegin = 0;
			var pend = source.length;
			while (pbegin !== pend && source[pbegin] === 0) {
				pbegin++;
				zeroes++;
			}
			var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
			var b58 = new Uint8Array(size);
			while (pbegin !== pend) {
				var carry = source[pbegin];
				var i$2 = 0;
				for (var it1 = size - 1; (carry !== 0 || i$2 < length) && it1 !== -1; it1--, i$2++) {
					carry += 256 * b58[it1] >>> 0;
					b58[it1] = carry % BASE >>> 0;
					carry = carry / BASE >>> 0;
				}
				if (carry !== 0) throw new Error("Non-zero carry");
				length = i$2;
				pbegin++;
			}
			var it2 = size - length;
			while (it2 !== size && b58[it2] === 0) it2++;
			var str = LEADER.repeat(zeroes);
			for (; it2 < size; ++it2) str += ALPHABET$2.charAt(b58[it2]);
			return str;
		}
		function decodeUnsafe(source) {
			if (typeof source !== "string") throw new TypeError("Expected String");
			if (source.length === 0) return _Buffer$1.alloc(0);
			var psz = 0;
			var zeroes = 0;
			var length = 0;
			while (source[psz] === LEADER) {
				zeroes++;
				psz++;
			}
			var size = (source.length - psz) * FACTOR + 1 >>> 0;
			var b256 = new Uint8Array(size);
			while (psz < source.length) {
				var charCode = source.charCodeAt(psz);
				if (charCode > 255) return;
				var carry = BASE_MAP[charCode];
				if (carry === 255) return;
				var i$2 = 0;
				for (var it3 = size - 1; (carry !== 0 || i$2 < length) && it3 !== -1; it3--, i$2++) {
					carry += BASE * b256[it3] >>> 0;
					b256[it3] = carry % 256 >>> 0;
					carry = carry / 256 >>> 0;
				}
				if (carry !== 0) throw new Error("Non-zero carry");
				length = i$2;
				psz++;
			}
			var it4 = size - length;
			while (it4 !== size && b256[it4] === 0) it4++;
			var vch = _Buffer$1.allocUnsafe(zeroes + (size - it4));
			vch.fill(0, 0, zeroes);
			var j$1 = zeroes;
			while (it4 !== size) vch[j$1++] = b256[it4++];
			return vch;
		}
		function decode(string$1) {
			var buffer$1 = decodeUnsafe(string$1);
			if (buffer$1) return buffer$1;
			throw new Error("Non-base" + BASE + " character");
		}
		return {
			encode,
			decodeUnsafe,
			decode
		};
	}
	module.exports = base$1;
}) });

//#endregion
//#region node_modules/@solana/web3.js/node_modules/bs58/index.js
var require_bs58$1 = /* @__PURE__ */ __commonJS({ "node_modules/@solana/web3.js/node_modules/bs58/index.js": ((exports, module) => {
	var basex$1 = require_src$1();
	var ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
	module.exports = basex$1(ALPHABET$1);
}) });

//#endregion
//#region node_modules/@noble/hashes/esm/sha256.js
var sha256;
var init_sha256 = __esm({ "node_modules/@noble/hashes/esm/sha256.js": (() => {
	init_sha2();
	sha256 = sha256$1;
}) });

//#endregion
//#region node_modules/borsh/node_modules/base-x/src/index.js
var require_src = /* @__PURE__ */ __commonJS({ "node_modules/borsh/node_modules/base-x/src/index.js": ((exports, module) => {
	var _Buffer = require_safe_buffer().Buffer;
	function base(ALPHABET$2) {
		if (ALPHABET$2.length >= 255) throw new TypeError("Alphabet too long");
		var BASE_MAP = new Uint8Array(256);
		for (var j = 0; j < BASE_MAP.length; j++) BASE_MAP[j] = 255;
		for (var i$1 = 0; i$1 < ALPHABET$2.length; i$1++) {
			var x = ALPHABET$2.charAt(i$1);
			var xc = x.charCodeAt(0);
			if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
			BASE_MAP[xc] = i$1;
		}
		var BASE = ALPHABET$2.length;
		var LEADER = ALPHABET$2.charAt(0);
		var FACTOR = Math.log(BASE) / Math.log(256);
		var iFACTOR = Math.log(256) / Math.log(BASE);
		function encode(source) {
			if (Array.isArray(source) || source instanceof Uint8Array) source = _Buffer.from(source);
			if (!_Buffer.isBuffer(source)) throw new TypeError("Expected Buffer");
			if (source.length === 0) return "";
			var zeroes = 0;
			var length = 0;
			var pbegin = 0;
			var pend = source.length;
			while (pbegin !== pend && source[pbegin] === 0) {
				pbegin++;
				zeroes++;
			}
			var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
			var b58 = new Uint8Array(size);
			while (pbegin !== pend) {
				var carry = source[pbegin];
				var i$2 = 0;
				for (var it1 = size - 1; (carry !== 0 || i$2 < length) && it1 !== -1; it1--, i$2++) {
					carry += 256 * b58[it1] >>> 0;
					b58[it1] = carry % BASE >>> 0;
					carry = carry / BASE >>> 0;
				}
				if (carry !== 0) throw new Error("Non-zero carry");
				length = i$2;
				pbegin++;
			}
			var it2 = size - length;
			while (it2 !== size && b58[it2] === 0) it2++;
			var str = LEADER.repeat(zeroes);
			for (; it2 < size; ++it2) str += ALPHABET$2.charAt(b58[it2]);
			return str;
		}
		function decodeUnsafe(source) {
			if (typeof source !== "string") throw new TypeError("Expected String");
			if (source.length === 0) return _Buffer.alloc(0);
			var psz = 0;
			var zeroes = 0;
			var length = 0;
			while (source[psz] === LEADER) {
				zeroes++;
				psz++;
			}
			var size = (source.length - psz) * FACTOR + 1 >>> 0;
			var b256 = new Uint8Array(size);
			while (psz < source.length) {
				var charCode = source.charCodeAt(psz);
				if (charCode > 255) return;
				var carry = BASE_MAP[charCode];
				if (carry === 255) return;
				var i$2 = 0;
				for (var it3 = size - 1; (carry !== 0 || i$2 < length) && it3 !== -1; it3--, i$2++) {
					carry += BASE * b256[it3] >>> 0;
					b256[it3] = carry % 256 >>> 0;
					carry = carry / 256 >>> 0;
				}
				if (carry !== 0) throw new Error("Non-zero carry");
				length = i$2;
				psz++;
			}
			var it4 = size - length;
			while (it4 !== size && b256[it4] === 0) it4++;
			var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
			vch.fill(0, 0, zeroes);
			var j$1 = zeroes;
			while (it4 !== size) vch[j$1++] = b256[it4++];
			return vch;
		}
		function decode(string$1) {
			var buffer$1 = decodeUnsafe(string$1);
			if (buffer$1) return buffer$1;
			throw new Error("Non-base" + BASE + " character");
		}
		return {
			encode,
			decodeUnsafe,
			decode
		};
	}
	module.exports = base;
}) });

//#endregion
//#region node_modules/borsh/node_modules/bs58/index.js
var require_bs58 = /* @__PURE__ */ __commonJS({ "node_modules/borsh/node_modules/bs58/index.js": ((exports, module) => {
	var basex = require_src();
	var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
	module.exports = basex(ALPHABET);
}) });

//#endregion
//#region node_modules/text-encoding-utf-8/src/encoding.js
var encoding_exports = /* @__PURE__ */ __export({
	TextDecoder: () => TextDecoder$1,
	TextEncoder: () => TextEncoder$1
});
/**
* @param {number} a The number to test.
* @param {number} min The minimum value in the range, inclusive.
* @param {number} max The maximum value in the range, inclusive.
* @return {boolean} True if a >= min and a <= max.
*/
function inRange$1(a, min, max) {
	return min <= a && a <= max;
}
/**
* @param {*} o
* @return {Object}
*/
function ToDictionary(o) {
	if (o === void 0) return {};
	if (o === Object(o)) return o;
	throw TypeError("Could not convert argument to dictionary");
}
/**
* @param {string} string Input string of UTF-16 code units.
* @return {!Array.<number>} Code points.
*/
function stringToCodePoints(string$1) {
	var s = String(string$1);
	var n = s.length;
	var i$1 = 0;
	var u = [];
	while (i$1 < n) {
		var c = s.charCodeAt(i$1);
		if (c < 55296 || c > 57343) u.push(c);
		else if (56320 <= c && c <= 57343) u.push(65533);
		else if (55296 <= c && c <= 56319) if (i$1 === n - 1) u.push(65533);
		else {
			var d = string$1.charCodeAt(i$1 + 1);
			if (56320 <= d && d <= 57343) {
				var a = c & 1023;
				var b = d & 1023;
				u.push(65536 + (a << 10) + b);
				i$1 += 1;
			} else u.push(65533);
		}
		i$1 += 1;
	}
	return u;
}
/**
* @param {!Array.<number>} code_points Array of code points.
* @return {string} string String of UTF-16 code units.
*/
function codePointsToString(code_points) {
	var s = "";
	for (var i$1 = 0; i$1 < code_points.length; ++i$1) {
		var cp = code_points[i$1];
		if (cp <= 65535) s += String.fromCharCode(cp);
		else {
			cp -= 65536;
			s += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
		}
	}
	return s;
}
/**
* A stream represents an ordered sequence of tokens.
*
* @constructor
* @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the
* stream.
*/
function Stream(tokens) {
	/** @type {!Array.<number>} */
	this.tokens = [].slice.call(tokens);
}
/**
* @param {boolean} fatal If true, decoding errors raise an exception.
* @param {number=} opt_code_point Override the standard fallback code point.
* @return {number} The code point to insert on a decoding error.
*/
function decoderError(fatal, opt_code_point) {
	if (fatal) throw TypeError("Decoder error");
	return opt_code_point || 65533;
}
/** @interface */
function Decoder() {}
/** @interface */
function Encoder() {}
/**
* @constructor
* @param {string=} encoding The label of the encoding;
*     defaults to 'utf-8'.
* @param {Object=} options
*/
function TextDecoder$1(encoding$1, options) {
	if (!(this instanceof TextDecoder$1)) return new TextDecoder$1(encoding$1, options);
	encoding$1 = encoding$1 !== void 0 ? String(encoding$1).toLowerCase() : DEFAULT_ENCODING;
	if (encoding$1 !== DEFAULT_ENCODING) throw new Error("Encoding not supported. Only utf-8 is supported");
	options = ToDictionary(options);
	/** @private @type {boolean} */
	this._streaming = false;
	/** @private @type {boolean} */
	this._BOMseen = false;
	/** @private @type {?Decoder} */
	this._decoder = null;
	/** @private @type {boolean} */
	this._fatal = Boolean(options["fatal"]);
	/** @private @type {boolean} */
	this._ignoreBOM = Boolean(options["ignoreBOM"]);
	Object.defineProperty(this, "encoding", { value: "utf-8" });
	Object.defineProperty(this, "fatal", { value: this._fatal });
	Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
/**
* @constructor
* @param {string=} encoding The label of the encoding;
*     defaults to 'utf-8'.
* @param {Object=} options
*/
function TextEncoder$1(encoding$1, options) {
	if (!(this instanceof TextEncoder$1)) return new TextEncoder$1(encoding$1, options);
	encoding$1 = encoding$1 !== void 0 ? String(encoding$1).toLowerCase() : DEFAULT_ENCODING;
	if (encoding$1 !== DEFAULT_ENCODING) throw new Error("Encoding not supported. Only utf-8 is supported");
	options = ToDictionary(options);
	/** @private @type {boolean} */
	this._streaming = false;
	/** @private @type {?Encoder} */
	this._encoder = null;
	/** @private @type {{fatal: boolean}} */
	this._options = { fatal: Boolean(options["fatal"]) };
	Object.defineProperty(this, "encoding", { value: "utf-8" });
}
/**
* @constructor
* @implements {Decoder}
* @param {{fatal: boolean}} options
*/
function UTF8Decoder(options) {
	var fatal = options.fatal;
	var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
	/**
	* @param {Stream} stream The stream of bytes being decoded.
	* @param {number} bite The next byte read from the stream.
	* @return {?(number|!Array.<number>)} The next code point(s)
	*     decoded, or null if not enough data exists in the input
	*     stream to decode a complete code point.
	*/
	this.handler = function(stream, bite) {
		if (bite === end_of_stream && utf8_bytes_needed !== 0) {
			utf8_bytes_needed = 0;
			return decoderError(fatal);
		}
		if (bite === end_of_stream) return finished;
		if (utf8_bytes_needed === 0) {
			if (inRange$1(bite, 0, 127)) return bite;
			if (inRange$1(bite, 194, 223)) {
				utf8_bytes_needed = 1;
				utf8_code_point = bite - 192;
			} else if (inRange$1(bite, 224, 239)) {
				if (bite === 224) utf8_lower_boundary = 160;
				if (bite === 237) utf8_upper_boundary = 159;
				utf8_bytes_needed = 2;
				utf8_code_point = bite - 224;
			} else if (inRange$1(bite, 240, 244)) {
				if (bite === 240) utf8_lower_boundary = 144;
				if (bite === 244) utf8_upper_boundary = 143;
				utf8_bytes_needed = 3;
				utf8_code_point = bite - 240;
			} else return decoderError(fatal);
			utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
			return null;
		}
		if (!inRange$1(bite, utf8_lower_boundary, utf8_upper_boundary)) {
			utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
			utf8_lower_boundary = 128;
			utf8_upper_boundary = 191;
			stream.prepend(bite);
			return decoderError(fatal);
		}
		utf8_lower_boundary = 128;
		utf8_upper_boundary = 191;
		utf8_bytes_seen += 1;
		utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
		if (utf8_bytes_seen !== utf8_bytes_needed) return null;
		var code_point = utf8_code_point;
		utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
		return code_point;
	};
}
/**
* @constructor
* @implements {Encoder}
* @param {{fatal: boolean}} options
*/
function UTF8Encoder(options) {
	options.fatal;
	/**
	* @param {Stream} stream Input stream.
	* @param {number} code_point Next code point read from the stream.
	* @return {(number|!Array.<number>)} Byte(s) to emit.
	*/
	this.handler = function(stream, code_point) {
		if (code_point === end_of_stream) return finished;
		if (inRange$1(code_point, 0, 127)) return code_point;
		var count, offset;
		if (inRange$1(code_point, 128, 2047)) {
			count = 1;
			offset = 192;
		} else if (inRange$1(code_point, 2048, 65535)) {
			count = 2;
			offset = 224;
		} else if (inRange$1(code_point, 65536, 1114111)) {
			count = 3;
			offset = 240;
		}
		var bytes = [(code_point >> 6 * count) + offset];
		while (count > 0) {
			var temp = code_point >> 6 * (count - 1);
			bytes.push(128 | temp & 63);
			count -= 1;
		}
		return bytes;
	};
}
var end_of_stream, finished, DEFAULT_ENCODING;
var init_encoding = __esm({ "node_modules/text-encoding-utf-8/src/encoding.js": (() => {
	end_of_stream = -1;
	Stream.prototype = {
		endOfStream: function() {
			return !this.tokens.length;
		},
		read: function() {
			if (!this.tokens.length) return end_of_stream;
			return this.tokens.shift();
		},
		prepend: function(token) {
			if (Array.isArray(token)) {
				var tokens = token;
				while (tokens.length) this.tokens.unshift(tokens.pop());
			} else this.tokens.unshift(token);
		},
		push: function(token) {
			if (Array.isArray(token)) {
				var tokens = token;
				while (tokens.length) this.tokens.push(tokens.shift());
			} else this.tokens.push(token);
		}
	};
	finished = -1;
	Decoder.prototype = { handler: function(stream, bite) {} };
	Encoder.prototype = { handler: function(stream, code_point) {} };
	DEFAULT_ENCODING = "utf-8";
	TextDecoder$1.prototype = { decode: function decode(input, options) {
		var bytes;
		if (typeof input === "object" && input instanceof ArrayBuffer) bytes = new Uint8Array(input);
		else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
		else bytes = new Uint8Array(0);
		options = ToDictionary(options);
		if (!this._streaming) {
			this._decoder = new UTF8Decoder({ fatal: this._fatal });
			this._BOMseen = false;
		}
		this._streaming = Boolean(options["stream"]);
		var input_stream = new Stream(bytes);
		var code_points = [];
		/** @type {?(number|!Array.<number>)} */
		var result;
		while (!input_stream.endOfStream()) {
			result = this._decoder.handler(input_stream, input_stream.read());
			if (result === finished) break;
			if (result === null) continue;
			if (Array.isArray(result)) code_points.push.apply(code_points, result);
			else code_points.push(result);
		}
		if (!this._streaming) {
			do {
				result = this._decoder.handler(input_stream, input_stream.read());
				if (result === finished) break;
				if (result === null) continue;
				if (Array.isArray(result)) code_points.push.apply(code_points, result);
				else code_points.push(result);
			} while (!input_stream.endOfStream());
			this._decoder = null;
		}
		if (code_points.length) {
			if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) if (code_points[0] === 65279) {
				this._BOMseen = true;
				code_points.shift();
			} else this._BOMseen = true;
		}
		return codePointsToString(code_points);
	} };
	TextEncoder$1.prototype = { encode: function encode(opt_string, options) {
		opt_string = opt_string ? String(opt_string) : "";
		options = ToDictionary(options);
		if (!this._streaming) this._encoder = new UTF8Encoder(this._options);
		this._streaming = Boolean(options["stream"]);
		var bytes = [];
		var input_stream = new Stream(stringToCodePoints(opt_string));
		/** @type {?(number|!Array.<number>)} */
		var result;
		while (!input_stream.endOfStream()) {
			result = this._encoder.handler(input_stream, input_stream.read());
			if (result === finished) break;
			if (Array.isArray(result)) bytes.push.apply(bytes, result);
			else bytes.push(result);
		}
		if (!this._streaming) {
			while (true) {
				result = this._encoder.handler(input_stream, input_stream.read());
				if (result === finished) break;
				if (Array.isArray(result)) bytes.push.apply(bytes, result);
				else bytes.push(result);
			}
			this._encoder = null;
		}
		return new Uint8Array(bytes);
	} };
}) });

//#endregion
//#region node_modules/borsh/lib/index.js
var require_lib = /* @__PURE__ */ __commonJS({ "node_modules/borsh/lib/index.js": ((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: function() {
				return m[k];
			}
		});
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
		var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
		if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
		else for (var i$1 = decorators.length - 1; i$1 >= 0; i$1--) if (d = decorators[i$1]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
		return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __importStar = exports && exports.__importStar || function(mod$1) {
		if (mod$1 && mod$1.__esModule) return mod$1;
		var result = {};
		if (mod$1 != null) {
			for (var k in mod$1) if (k !== "default" && Object.hasOwnProperty.call(mod$1, k)) __createBinding(result, mod$1, k);
		}
		__setModuleDefault(result, mod$1);
		return result;
	};
	var __importDefault = exports && exports.__importDefault || function(mod$1) {
		return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;
	var bn_js_1 = __importDefault(require_bn());
	var bs58_1 = __importDefault(require_bs58());
	var encoding = __importStar((init_encoding(), __toCommonJS(encoding_exports)));
	var textDecoder = new (typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder)("utf-8", { fatal: true });
	function baseEncode(value) {
		if (typeof value === "string") value = Buffer.from(value, "utf8");
		return bs58_1.default.encode(Buffer.from(value));
	}
	exports.baseEncode = baseEncode;
	function baseDecode(value) {
		return Buffer.from(bs58_1.default.decode(value));
	}
	exports.baseDecode = baseDecode;
	var INITIAL_LENGTH = 1024;
	var BorshError = class extends Error {
		constructor(message) {
			super(message);
			this.fieldPath = [];
			this.originalMessage = message;
		}
		addToFieldPath(fieldName) {
			this.fieldPath.splice(0, 0, fieldName);
			this.message = this.originalMessage + ": " + this.fieldPath.join(".");
		}
	};
	exports.BorshError = BorshError;
	var BinaryWriter = class {
		constructor() {
			this.buf = Buffer.alloc(INITIAL_LENGTH);
			this.length = 0;
		}
		maybeResize() {
			if (this.buf.length < 16 + this.length) this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
		}
		writeU8(value) {
			this.maybeResize();
			this.buf.writeUInt8(value, this.length);
			this.length += 1;
		}
		writeU16(value) {
			this.maybeResize();
			this.buf.writeUInt16LE(value, this.length);
			this.length += 2;
		}
		writeU32(value) {
			this.maybeResize();
			this.buf.writeUInt32LE(value, this.length);
			this.length += 4;
		}
		writeU64(value) {
			this.maybeResize();
			this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
		}
		writeU128(value) {
			this.maybeResize();
			this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
		}
		writeU256(value) {
			this.maybeResize();
			this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
		}
		writeU512(value) {
			this.maybeResize();
			this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
		}
		writeBuffer(buffer$1) {
			this.buf = Buffer.concat([
				Buffer.from(this.buf.subarray(0, this.length)),
				buffer$1,
				Buffer.alloc(INITIAL_LENGTH)
			]);
			this.length += buffer$1.length;
		}
		writeString(str) {
			this.maybeResize();
			const b = Buffer.from(str, "utf8");
			this.writeU32(b.length);
			this.writeBuffer(b);
		}
		writeFixedArray(array$1) {
			this.writeBuffer(Buffer.from(array$1));
		}
		writeArray(array$1, fn) {
			this.maybeResize();
			this.writeU32(array$1.length);
			for (const elem of array$1) {
				this.maybeResize();
				fn(elem);
			}
		}
		toArray() {
			return this.buf.subarray(0, this.length);
		}
	};
	exports.BinaryWriter = BinaryWriter;
	function handlingRangeError(target, propertyKey, propertyDescriptor) {
		const originalMethod = propertyDescriptor.value;
		propertyDescriptor.value = function(...args) {
			try {
				return originalMethod.apply(this, args);
			} catch (e) {
				if (e instanceof RangeError) {
					const code = e.code;
					if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) throw new BorshError("Reached the end of buffer when deserializing");
				}
				throw e;
			}
		};
	}
	var BinaryReader = class {
		constructor(buf) {
			this.buf = buf;
			this.offset = 0;
		}
		readU8() {
			const value = this.buf.readUInt8(this.offset);
			this.offset += 1;
			return value;
		}
		readU16() {
			const value = this.buf.readUInt16LE(this.offset);
			this.offset += 2;
			return value;
		}
		readU32() {
			const value = this.buf.readUInt32LE(this.offset);
			this.offset += 4;
			return value;
		}
		readU64() {
			const buf = this.readBuffer(8);
			return new bn_js_1.default(buf, "le");
		}
		readU128() {
			const buf = this.readBuffer(16);
			return new bn_js_1.default(buf, "le");
		}
		readU256() {
			const buf = this.readBuffer(32);
			return new bn_js_1.default(buf, "le");
		}
		readU512() {
			const buf = this.readBuffer(64);
			return new bn_js_1.default(buf, "le");
		}
		readBuffer(len) {
			if (this.offset + len > this.buf.length) throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
			const result = this.buf.slice(this.offset, this.offset + len);
			this.offset += len;
			return result;
		}
		readString() {
			const len = this.readU32();
			const buf = this.readBuffer(len);
			try {
				return textDecoder.decode(buf);
			} catch (e) {
				throw new BorshError(`Error decoding UTF-8 string: ${e}`);
			}
		}
		readFixedArray(len) {
			return new Uint8Array(this.readBuffer(len));
		}
		readArray(fn) {
			const len = this.readU32();
			const result = Array();
			for (let i$1 = 0; i$1 < len; ++i$1) result.push(fn());
			return result;
		}
	};
	__decorate([handlingRangeError], BinaryReader.prototype, "readU8", null);
	__decorate([handlingRangeError], BinaryReader.prototype, "readU16", null);
	__decorate([handlingRangeError], BinaryReader.prototype, "readU32", null);
	__decorate([handlingRangeError], BinaryReader.prototype, "readU64", null);
	__decorate([handlingRangeError], BinaryReader.prototype, "readU128", null);
	__decorate([handlingRangeError], BinaryReader.prototype, "readU256", null);
	__decorate([handlingRangeError], BinaryReader.prototype, "readU512", null);
	__decorate([handlingRangeError], BinaryReader.prototype, "readString", null);
	__decorate([handlingRangeError], BinaryReader.prototype, "readFixedArray", null);
	__decorate([handlingRangeError], BinaryReader.prototype, "readArray", null);
	exports.BinaryReader = BinaryReader;
	function capitalizeFirstLetter(string$1) {
		return string$1.charAt(0).toUpperCase() + string$1.slice(1);
	}
	function serializeField(schema, fieldName, value, fieldType, writer) {
		try {
			if (typeof fieldType === "string") writer[`write${capitalizeFirstLetter(fieldType)}`](value);
			else if (fieldType instanceof Array) if (typeof fieldType[0] === "number") {
				if (value.length !== fieldType[0]) throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
				writer.writeFixedArray(value);
			} else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
				if (value.length !== fieldType[1]) throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
				for (let i$1 = 0; i$1 < fieldType[1]; i$1++) serializeField(schema, null, value[i$1], fieldType[0], writer);
			} else writer.writeArray(value, (item) => {
				serializeField(schema, fieldName, item, fieldType[0], writer);
			});
			else if (fieldType.kind !== void 0) switch (fieldType.kind) {
				case "option":
					if (value === null || value === void 0) writer.writeU8(0);
					else {
						writer.writeU8(1);
						serializeField(schema, fieldName, value, fieldType.type, writer);
					}
					break;
				case "map":
					writer.writeU32(value.size);
					value.forEach((val, key) => {
						serializeField(schema, fieldName, key, fieldType.key, writer);
						serializeField(schema, fieldName, val, fieldType.value, writer);
					});
					break;
				default: throw new BorshError(`FieldType ${fieldType} unrecognized`);
			}
			else serializeStruct(schema, value, writer);
		} catch (error) {
			if (error instanceof BorshError) error.addToFieldPath(fieldName);
			throw error;
		}
	}
	function serializeStruct(schema, obj, writer) {
		if (typeof obj.borshSerialize === "function") {
			obj.borshSerialize(writer);
			return;
		}
		const structSchema = schema.get(obj.constructor);
		if (!structSchema) throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
		if (structSchema.kind === "struct") structSchema.fields.map(([fieldName, fieldType]) => {
			serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
		});
		else if (structSchema.kind === "enum") {
			const name = obj[structSchema.field];
			for (let idx = 0; idx < structSchema.values.length; ++idx) {
				const [fieldName, fieldType] = structSchema.values[idx];
				if (fieldName === name) {
					writer.writeU8(idx);
					serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
					break;
				}
			}
		} else throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
	}
	function serialize$1(schema, obj, Writer = BinaryWriter) {
		const writer = new Writer();
		serializeStruct(schema, obj, writer);
		return writer.toArray();
	}
	exports.serialize = serialize$1;
	function deserializeField(schema, fieldName, fieldType, reader) {
		try {
			if (typeof fieldType === "string") return reader[`read${capitalizeFirstLetter(fieldType)}`]();
			if (fieldType instanceof Array) if (typeof fieldType[0] === "number") return reader.readFixedArray(fieldType[0]);
			else if (typeof fieldType[1] === "number") {
				const arr = [];
				for (let i$1 = 0; i$1 < fieldType[1]; i$1++) arr.push(deserializeField(schema, null, fieldType[0], reader));
				return arr;
			} else return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
			if (fieldType.kind === "option") {
				if (reader.readU8()) return deserializeField(schema, fieldName, fieldType.type, reader);
				return;
			}
			if (fieldType.kind === "map") {
				let map = /* @__PURE__ */ new Map();
				const length = reader.readU32();
				for (let i$1 = 0; i$1 < length; i$1++) {
					const key = deserializeField(schema, fieldName, fieldType.key, reader);
					const val = deserializeField(schema, fieldName, fieldType.value, reader);
					map.set(key, val);
				}
				return map;
			}
			return deserializeStruct(schema, fieldType, reader);
		} catch (error) {
			if (error instanceof BorshError) error.addToFieldPath(fieldName);
			throw error;
		}
	}
	function deserializeStruct(schema, classType, reader) {
		if (typeof classType.borshDeserialize === "function") return classType.borshDeserialize(reader);
		const structSchema = schema.get(classType);
		if (!structSchema) throw new BorshError(`Class ${classType.name} is missing in schema`);
		if (structSchema.kind === "struct") {
			const result = {};
			for (const [fieldName, fieldType] of schema.get(classType).fields) result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
			return new classType(result);
		}
		if (structSchema.kind === "enum") {
			const idx = reader.readU8();
			if (idx >= structSchema.values.length) throw new BorshError(`Enum index: ${idx} is out of range`);
			const [fieldName, fieldType] = structSchema.values[idx];
			const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
			return new classType({ [fieldName]: fieldValue });
		}
		throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
	}
	function deserialize$1(schema, classType, buffer$1, Reader = BinaryReader) {
		const reader = new Reader(buffer$1);
		const result = deserializeStruct(schema, classType, reader);
		if (reader.offset < buffer$1.length) throw new BorshError(`Unexpected ${buffer$1.length - reader.offset} bytes after deserialized data`);
		return result;
	}
	exports.deserialize = deserialize$1;
	function deserializeUnchecked$1(schema, classType, buffer$1, Reader = BinaryReader) {
		return deserializeStruct(schema, classType, new Reader(buffer$1));
	}
	exports.deserializeUnchecked = deserializeUnchecked$1;
}) });

//#endregion
//#region node_modules/@solana/buffer-layout/lib/Layout.js
/**
* Support for translating between Uint8Array instances and JavaScript
* native types.
*
* {@link module:Layout~Layout|Layout} is the basis of a class
* hierarchy that associates property names with sequences of encoded
* bytes.
*
* Layouts are supported for these scalar (numeric) types:
* * {@link module:Layout~UInt|Unsigned integers in little-endian
*   format} with {@link module:Layout.u8|8-bit}, {@link
*   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
*   {@link module:Layout.u32|32-bit}, {@link
*   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
*   representation ranges;
* * {@link module:Layout~UIntBE|Unsigned integers in big-endian
*   format} with {@link module:Layout.u16be|16-bit}, {@link
*   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
*   {@link module:Layout.u40be|40-bit}, and {@link
*   module:Layout.u48be|48-bit} representation ranges;
* * {@link module:Layout~Int|Signed integers in little-endian
*   format} with {@link module:Layout.s8|8-bit}, {@link
*   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
*   {@link module:Layout.s32|32-bit}, {@link
*   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
*   representation ranges;
* * {@link module:Layout~IntBE|Signed integers in big-endian format}
*   with {@link module:Layout.s16be|16-bit}, {@link
*   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
*   {@link module:Layout.s40be|40-bit}, and {@link
*   module:Layout.s48be|48-bit} representation ranges;
* * 64-bit integral values that decode to an exact (if magnitude is
*   less than 2^53) or nearby integral Number in {@link
*   module:Layout.nu64|unsigned little-endian}, {@link
*   module:Layout.nu64be|unsigned big-endian}, {@link
*   module:Layout.ns64|signed little-endian}, and {@link
*   module:Layout.ns64be|unsigned big-endian} encodings;
* * 32-bit floating point values with {@link
*   module:Layout.f32|little-endian} and {@link
*   module:Layout.f32be|big-endian} representations;
* * 64-bit floating point values with {@link
*   module:Layout.f64|little-endian} and {@link
*   module:Layout.f64be|big-endian} representations;
* * {@link module:Layout.const|Constants} that take no space in the
*   encoded expression.
*
* and for these aggregate types:
* * {@link module:Layout.seq|Sequence}s of instances of a {@link
*   module:Layout~Layout|Layout}, with JavaScript representation as
*   an Array and constant or data-dependent {@link
*   module:Layout~Sequence#count|length};
* * {@link module:Layout.struct|Structure}s that aggregate a
*   heterogeneous sequence of {@link module:Layout~Layout|Layout}
*   instances, with JavaScript representation as an Object;
* * {@link module:Layout.union|Union}s that support multiple {@link
*   module:Layout~VariantLayout|variant layouts} over a fixed
*   (padded) or variable (not padded) span of bytes, using an
*   unsigned integer at the start of the data or a separate {@link
*   module:Layout.unionLayoutDiscriminator|layout element} to
*   determine which layout to use when interpreting the buffer
*   contents;
* * {@link module:Layout.bits|BitStructure}s that contain a sequence
*   of individual {@link
*   module:Layout~BitStructure#addField|BitField}s packed into an 8,
*   16, 24, or 32-bit unsigned integer starting at the least- or
*   most-significant bit;
* * {@link module:Layout.cstr|C strings} of varying length;
* * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
*   module:Layout~Blob#length|length} raw data.
*
* All {@link module:Layout~Layout|Layout} instances are immutable
* after construction, to prevent internal state from becoming
* inconsistent.
*
* @local Layout
* @local ExternalLayout
* @local GreedyCount
* @local OffsetLayout
* @local UInt
* @local UIntBE
* @local Int
* @local IntBE
* @local NearUInt64
* @local NearUInt64BE
* @local NearInt64
* @local NearInt64BE
* @local Float
* @local FloatBE
* @local Double
* @local DoubleBE
* @local Sequence
* @local Structure
* @local UnionDiscriminator
* @local UnionLayoutDiscriminator
* @local Union
* @local VariantLayout
* @local BitStructure
* @local BitField
* @local Boolean
* @local Blob
* @local CString
* @local Constant
* @local bindConstructorLayout
* @module Layout
* @license MIT
* @author Peter A. Bigot
* @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
*/
var require_Layout = /* @__PURE__ */ __commonJS({ "node_modules/@solana/buffer-layout/lib/Layout.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;
	exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;
	var buffer_1 = require_buffer();
	function checkUint8Array(b) {
		if (!(b instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array");
	}
	exports.checkUint8Array = checkUint8Array;
	function uint8ArrayToBuffer(b) {
		checkUint8Array(b);
		return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
	}
	exports.uint8ArrayToBuffer = uint8ArrayToBuffer;
	/**
	* Base class for layout objects.
	*
	* **NOTE** This is an abstract base class; you can create instances
	* if it amuses you, but they won't support the {@link
	* Layout#encode|encode} or {@link Layout#decode|decode} functions.
	*
	* @param {Number} span - Initializer for {@link Layout#span|span}.  The
	* parameter must be an integer; a negative value signifies that the
	* span is {@link Layout#getSpan|value-specific}.
	*
	* @param {string} [property] - Initializer for {@link
	* Layout#property|property}.
	*
	* @abstract
	*/
	var Layout = class {
		constructor(span, property) {
			if (!Number.isInteger(span)) throw new TypeError("span must be an integer");
			/** The span of the layout in bytes.
			*
			* Positive values are generally expected.
			*
			* Zero will only appear in {@link Constant}s and in {@link
			* Sequence}s where the {@link Sequence#count|count} is zero.
			*
			* A negative value indicates that the span is value-specific, and
			* must be obtained using {@link Layout#getSpan|getSpan}. */
			this.span = span;
			/** The property name used when this layout is represented in an
			* Object.
			*
			* Used only for layouts that {@link Layout#decode|decode} to Object
			* instances.  If left undefined the span of the unnamed layout will
			* be treated as padding: it will not be mutated by {@link
			* Layout#encode|encode} nor represented as a property in the
			* decoded Object. */
			this.property = property;
		}
		/** Function to create an Object into which decoded properties will
		* be written.
		*
		* Used only for layouts that {@link Layout#decode|decode} to Object
		* instances, which means:
		* * {@link Structure}
		* * {@link Union}
		* * {@link VariantLayout}
		* * {@link BitStructure}
		*
		* If left undefined the JavaScript representation of these layouts
		* will be Object instances.
		*
		* See {@link bindConstructorLayout}.
		*/
		makeDestinationObject() {
			return {};
		}
		/**
		* Calculate the span of a specific instance of a layout.
		*
		* @param {Uint8Array} b - the buffer that contains an encoded instance.
		*
		* @param {Number} [offset] - the offset at which the encoded instance
		* starts.  If absent a zero offset is inferred.
		*
		* @return {Number} - the number of bytes covered by the layout
		* instance.  If this method is not overridden in a subclass the
		* definition-time constant {@link Layout#span|span} will be
		* returned.
		*
		* @throws {RangeError} - if the length of the value cannot be
		* determined.
		*/
		getSpan(b, offset) {
			if (0 > this.span) throw new RangeError("indeterminate span");
			return this.span;
		}
		/**
		* Replicate the layout using a new property.
		*
		* This function must be used to get a structurally-equivalent layout
		* with a different name since all {@link Layout} instances are
		* immutable.
		*
		* **NOTE** This is a shallow copy.  All fields except {@link
		* Layout#property|property} are strictly equal to the origin layout.
		*
		* @param {String} property - the value for {@link
		* Layout#property|property} in the replica.
		*
		* @returns {Layout} - the copy with {@link Layout#property|property}
		* set to `property`.
		*/
		replicate(property) {
			const rv = Object.create(this.constructor.prototype);
			Object.assign(rv, this);
			rv.property = property;
			return rv;
		}
		/**
		* Create an object from layout properties and an array of values.
		*
		* **NOTE** This function returns `undefined` if invoked on a layout
		* that does not return its value as an Object.  Objects are
		* returned for things that are a {@link Structure}, which includes
		* {@link VariantLayout|variant layouts} if they are structures, and
		* excludes {@link Union}s.  If you want this feature for a union
		* you must use {@link Union.getVariant|getVariant} to select the
		* desired layout.
		*
		* @param {Array} values - an array of values that correspond to the
		* default order for properties.  As with {@link Layout#decode|decode}
		* layout elements that have no property name are skipped when
		* iterating over the array values.  Only the top-level properties are
		* assigned; arguments are not assigned to properties of contained
		* layouts.  Any unused values are ignored.
		*
		* @return {(Object|undefined)}
		*/
		fromArray(values) {}
	};
	exports.Layout = Layout;
	function nameWithProperty(name, lo) {
		if (lo.property) return name + "[" + lo.property + "]";
		return name;
	}
	exports.nameWithProperty = nameWithProperty;
	/**
	* Augment a class so that instances can be encoded/decoded using a
	* given layout.
	*
	* Calling this function couples `Class` with `layout` in several ways:
	*
	* * `Class.layout_` becomes a static member property equal to `layout`;
	* * `layout.boundConstructor_` becomes a static member property equal
	*    to `Class`;
	* * The {@link Layout#makeDestinationObject|makeDestinationObject()}
	*   property of `layout` is set to a function that returns a `new
	*   Class()`;
	* * `Class.decode(b, offset)` becomes a static member function that
	*   delegates to {@link Layout#decode|layout.decode}.  The
	*   synthesized function may be captured and extended.
	* * `Class.prototype.encode(b, offset)` provides an instance member
	*   function that delegates to {@link Layout#encode|layout.encode}
	*   with `src` set to `this`.  The synthesized function may be
	*   captured and extended, but when the extension is invoked `this`
	*   must be explicitly bound to the instance.
	*
	* @param {class} Class - a JavaScript class with a nullary
	* constructor.
	*
	* @param {Layout} layout - the {@link Layout} instance used to encode
	* instances of `Class`.
	*/
	function bindConstructorLayout(Class, layout) {
		if ("function" !== typeof Class) throw new TypeError("Class must be constructor");
		if (Object.prototype.hasOwnProperty.call(Class, "layout_")) throw new Error("Class is already bound to a layout");
		if (!(layout && layout instanceof Layout)) throw new TypeError("layout must be a Layout");
		if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) throw new Error("layout is already bound to a constructor");
		Class.layout_ = layout;
		layout.boundConstructor_ = Class;
		layout.makeDestinationObject = (() => new Class());
		Object.defineProperty(Class.prototype, "encode", {
			value(b, offset) {
				return layout.encode(this, b, offset);
			},
			writable: true
		});
		Object.defineProperty(Class, "decode", {
			value(b, offset) {
				return layout.decode(b, offset);
			},
			writable: true
		});
	}
	exports.bindConstructorLayout = bindConstructorLayout;
	/**
	* An object that behaves like a layout but does not consume space
	* within its containing layout.
	*
	* This is primarily used to obtain metadata about a member, such as a
	* {@link OffsetLayout} that can provide data about a {@link
	* Layout#getSpan|value-specific span}.
	*
	* **NOTE** This is an abstract base class; you can create instances
	* if it amuses you, but they won't support {@link
	* ExternalLayout#isCount|isCount} or other {@link Layout} functions.
	*
	* @param {Number} span - initializer for {@link Layout#span|span}.
	* The parameter can range from 1 through 6.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @abstract
	* @augments {Layout}
	*/
	var ExternalLayout = class extends Layout {
		/**
		* Return `true` iff the external layout decodes to an unsigned
		* integer layout.
		*
		* In that case it can be used as the source of {@link
		* Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
		* or as {@link UnionLayoutDiscriminator#layout|external union
		* discriminators}.
		*
		* @abstract
		*/
		isCount() {
			throw new Error("ExternalLayout is abstract");
		}
	};
	exports.ExternalLayout = ExternalLayout;
	/**
	* An {@link ExternalLayout} that determines its {@link
	* Layout#decode|value} based on offset into and length of the buffer
	* on which it is invoked.
	*
	* *Factory*: {@link module:Layout.greedy|greedy}
	*
	* @param {Number} [elementSpan] - initializer for {@link
	* GreedyCount#elementSpan|elementSpan}.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {ExternalLayout}
	*/
	var GreedyCount = class extends ExternalLayout {
		constructor(elementSpan = 1, property) {
			if (!Number.isInteger(elementSpan) || 0 >= elementSpan) throw new TypeError("elementSpan must be a (positive) integer");
			super(-1, property);
			/** The layout for individual elements of the sequence.  The value
			* must be a positive integer.  If not provided, the value will be
			* 1. */
			this.elementSpan = elementSpan;
		}
		/** @override */
		isCount() {
			return true;
		}
		/** @override */
		decode(b, offset = 0) {
			checkUint8Array(b);
			const rem = b.length - offset;
			return Math.floor(rem / this.elementSpan);
		}
		/** @override */
		encode(src, b, offset) {
			return 0;
		}
	};
	exports.GreedyCount = GreedyCount;
	/**
	* An {@link ExternalLayout} that supports accessing a {@link Layout}
	* at a fixed offset from the start of another Layout.  The offset may
	* be before, within, or after the base layout.
	*
	* *Factory*: {@link module:Layout.offset|offset}
	*
	* @param {Layout} layout - initializer for {@link
	* OffsetLayout#layout|layout}, modulo `property`.
	*
	* @param {Number} [offset] - Initializes {@link
	* OffsetLayout#offset|offset}.  Defaults to zero.
	*
	* @param {string} [property] - Optional new property name for a
	* {@link Layout#replicate| replica} of `layout` to be used as {@link
	* OffsetLayout#layout|layout}.  If not provided the `layout` is used
	* unchanged.
	*
	* @augments {Layout}
	*/
	var OffsetLayout = class extends ExternalLayout {
		constructor(layout, offset = 0, property) {
			if (!(layout instanceof Layout)) throw new TypeError("layout must be a Layout");
			if (!Number.isInteger(offset)) throw new TypeError("offset must be integer or undefined");
			super(layout.span, property || layout.property);
			/** The subordinated layout. */
			this.layout = layout;
			/** The location of {@link OffsetLayout#layout} relative to the
			* start of another layout.
			*
			* The value may be positive or negative, but an error will thrown
			* if at the point of use it goes outside the span of the Uint8Array
			* being accessed.  */
			this.offset = offset;
		}
		/** @override */
		isCount() {
			return this.layout instanceof UInt || this.layout instanceof UIntBE;
		}
		/** @override */
		decode(b, offset = 0) {
			return this.layout.decode(b, offset + this.offset);
		}
		/** @override */
		encode(src, b, offset = 0) {
			return this.layout.encode(src, b, offset + this.offset);
		}
	};
	exports.OffsetLayout = OffsetLayout;
	/**
	* Represent an unsigned integer in little-endian format.
	*
	* *Factory*: {@link module:Layout.u8|u8}, {@link
	*  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link
	*  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link
	*  module:Layout.u48|u48}
	*
	* @param {Number} span - initializer for {@link Layout#span|span}.
	* The parameter can range from 1 through 6.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var UInt = class extends Layout {
		constructor(span, property) {
			super(span, property);
			if (6 < this.span) throw new RangeError("span must not exceed 6 bytes");
		}
		/** @override */
		decode(b, offset = 0) {
			return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
		}
		/** @override */
		encode(src, b, offset = 0) {
			uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);
			return this.span;
		}
	};
	exports.UInt = UInt;
	/**
	* Represent an unsigned integer in big-endian format.
	*
	* *Factory*: {@link module:Layout.u8be|u8be}, {@link
	* module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},
	* {@link module:Layout.u32be|u32be}, {@link
	* module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}
	*
	* @param {Number} span - initializer for {@link Layout#span|span}.
	* The parameter can range from 1 through 6.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var UIntBE = class extends Layout {
		constructor(span, property) {
			super(span, property);
			if (6 < this.span) throw new RangeError("span must not exceed 6 bytes");
		}
		/** @override */
		decode(b, offset = 0) {
			return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
		}
		/** @override */
		encode(src, b, offset = 0) {
			uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);
			return this.span;
		}
	};
	exports.UIntBE = UIntBE;
	/**
	* Represent a signed integer in little-endian format.
	*
	* *Factory*: {@link module:Layout.s8|s8}, {@link
	*  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link
	*  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link
	*  module:Layout.s48|s48}
	*
	* @param {Number} span - initializer for {@link Layout#span|span}.
	* The parameter can range from 1 through 6.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var Int = class extends Layout {
		constructor(span, property) {
			super(span, property);
			if (6 < this.span) throw new RangeError("span must not exceed 6 bytes");
		}
		/** @override */
		decode(b, offset = 0) {
			return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
		}
		/** @override */
		encode(src, b, offset = 0) {
			uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);
			return this.span;
		}
	};
	exports.Int = Int;
	/**
	* Represent a signed integer in big-endian format.
	*
	* *Factory*: {@link module:Layout.s8be|s8be}, {@link
	* module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},
	* {@link module:Layout.s32be|s32be}, {@link
	* module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}
	*
	* @param {Number} span - initializer for {@link Layout#span|span}.
	* The parameter can range from 1 through 6.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var IntBE = class extends Layout {
		constructor(span, property) {
			super(span, property);
			if (6 < this.span) throw new RangeError("span must not exceed 6 bytes");
		}
		/** @override */
		decode(b, offset = 0) {
			return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
		}
		/** @override */
		encode(src, b, offset = 0) {
			uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);
			return this.span;
		}
	};
	exports.IntBE = IntBE;
	var V2E32 = Math.pow(2, 32);
	function divmodInt64(src) {
		const hi32 = Math.floor(src / V2E32);
		return {
			hi32,
			lo32: src - hi32 * V2E32
		};
	}
	function roundedInt64(hi32, lo32) {
		return hi32 * V2E32 + lo32;
	}
	/**
	* Represent an unsigned 64-bit integer in little-endian format when
	* encoded and as a near integral JavaScript Number when decoded.
	*
	* *Factory*: {@link module:Layout.nu64|nu64}
	*
	* **NOTE** Values with magnitude greater than 2^52 may not decode to
	* the exact value of the encoded representation.
	*
	* @augments {Layout}
	*/
	var NearUInt64 = class extends Layout {
		constructor(property) {
			super(8, property);
		}
		/** @override */
		decode(b, offset = 0) {
			const buffer$1 = uint8ArrayToBuffer(b);
			const lo32 = buffer$1.readUInt32LE(offset);
			return roundedInt64(buffer$1.readUInt32LE(offset + 4), lo32);
		}
		/** @override */
		encode(src, b, offset = 0) {
			const split$1 = divmodInt64(src);
			const buffer$1 = uint8ArrayToBuffer(b);
			buffer$1.writeUInt32LE(split$1.lo32, offset);
			buffer$1.writeUInt32LE(split$1.hi32, offset + 4);
			return 8;
		}
	};
	exports.NearUInt64 = NearUInt64;
	/**
	* Represent an unsigned 64-bit integer in big-endian format when
	* encoded and as a near integral JavaScript Number when decoded.
	*
	* *Factory*: {@link module:Layout.nu64be|nu64be}
	*
	* **NOTE** Values with magnitude greater than 2^52 may not decode to
	* the exact value of the encoded representation.
	*
	* @augments {Layout}
	*/
	var NearUInt64BE = class extends Layout {
		constructor(property) {
			super(8, property);
		}
		/** @override */
		decode(b, offset = 0) {
			const buffer$1 = uint8ArrayToBuffer(b);
			return roundedInt64(buffer$1.readUInt32BE(offset), buffer$1.readUInt32BE(offset + 4));
		}
		/** @override */
		encode(src, b, offset = 0) {
			const split$1 = divmodInt64(src);
			const buffer$1 = uint8ArrayToBuffer(b);
			buffer$1.writeUInt32BE(split$1.hi32, offset);
			buffer$1.writeUInt32BE(split$1.lo32, offset + 4);
			return 8;
		}
	};
	exports.NearUInt64BE = NearUInt64BE;
	/**
	* Represent a signed 64-bit integer in little-endian format when
	* encoded and as a near integral JavaScript Number when decoded.
	*
	* *Factory*: {@link module:Layout.ns64|ns64}
	*
	* **NOTE** Values with magnitude greater than 2^52 may not decode to
	* the exact value of the encoded representation.
	*
	* @augments {Layout}
	*/
	var NearInt64 = class extends Layout {
		constructor(property) {
			super(8, property);
		}
		/** @override */
		decode(b, offset = 0) {
			const buffer$1 = uint8ArrayToBuffer(b);
			const lo32 = buffer$1.readUInt32LE(offset);
			return roundedInt64(buffer$1.readInt32LE(offset + 4), lo32);
		}
		/** @override */
		encode(src, b, offset = 0) {
			const split$1 = divmodInt64(src);
			const buffer$1 = uint8ArrayToBuffer(b);
			buffer$1.writeUInt32LE(split$1.lo32, offset);
			buffer$1.writeInt32LE(split$1.hi32, offset + 4);
			return 8;
		}
	};
	exports.NearInt64 = NearInt64;
	/**
	* Represent a signed 64-bit integer in big-endian format when
	* encoded and as a near integral JavaScript Number when decoded.
	*
	* *Factory*: {@link module:Layout.ns64be|ns64be}
	*
	* **NOTE** Values with magnitude greater than 2^52 may not decode to
	* the exact value of the encoded representation.
	*
	* @augments {Layout}
	*/
	var NearInt64BE = class extends Layout {
		constructor(property) {
			super(8, property);
		}
		/** @override */
		decode(b, offset = 0) {
			const buffer$1 = uint8ArrayToBuffer(b);
			return roundedInt64(buffer$1.readInt32BE(offset), buffer$1.readUInt32BE(offset + 4));
		}
		/** @override */
		encode(src, b, offset = 0) {
			const split$1 = divmodInt64(src);
			const buffer$1 = uint8ArrayToBuffer(b);
			buffer$1.writeInt32BE(split$1.hi32, offset);
			buffer$1.writeUInt32BE(split$1.lo32, offset + 4);
			return 8;
		}
	};
	exports.NearInt64BE = NearInt64BE;
	/**
	* Represent a 32-bit floating point number in little-endian format.
	*
	* *Factory*: {@link module:Layout.f32|f32}
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var Float = class extends Layout {
		constructor(property) {
			super(4, property);
		}
		/** @override */
		decode(b, offset = 0) {
			return uint8ArrayToBuffer(b).readFloatLE(offset);
		}
		/** @override */
		encode(src, b, offset = 0) {
			uint8ArrayToBuffer(b).writeFloatLE(src, offset);
			return 4;
		}
	};
	exports.Float = Float;
	/**
	* Represent a 32-bit floating point number in big-endian format.
	*
	* *Factory*: {@link module:Layout.f32be|f32be}
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var FloatBE = class extends Layout {
		constructor(property) {
			super(4, property);
		}
		/** @override */
		decode(b, offset = 0) {
			return uint8ArrayToBuffer(b).readFloatBE(offset);
		}
		/** @override */
		encode(src, b, offset = 0) {
			uint8ArrayToBuffer(b).writeFloatBE(src, offset);
			return 4;
		}
	};
	exports.FloatBE = FloatBE;
	/**
	* Represent a 64-bit floating point number in little-endian format.
	*
	* *Factory*: {@link module:Layout.f64|f64}
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var Double = class extends Layout {
		constructor(property) {
			super(8, property);
		}
		/** @override */
		decode(b, offset = 0) {
			return uint8ArrayToBuffer(b).readDoubleLE(offset);
		}
		/** @override */
		encode(src, b, offset = 0) {
			uint8ArrayToBuffer(b).writeDoubleLE(src, offset);
			return 8;
		}
	};
	exports.Double = Double;
	/**
	* Represent a 64-bit floating point number in big-endian format.
	*
	* *Factory*: {@link module:Layout.f64be|f64be}
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var DoubleBE = class extends Layout {
		constructor(property) {
			super(8, property);
		}
		/** @override */
		decode(b, offset = 0) {
			return uint8ArrayToBuffer(b).readDoubleBE(offset);
		}
		/** @override */
		encode(src, b, offset = 0) {
			uint8ArrayToBuffer(b).writeDoubleBE(src, offset);
			return 8;
		}
	};
	exports.DoubleBE = DoubleBE;
	/**
	* Represent a contiguous sequence of a specific layout as an Array.
	*
	* *Factory*: {@link module:Layout.seq|seq}
	*
	* @param {Layout} elementLayout - initializer for {@link
	* Sequence#elementLayout|elementLayout}.
	*
	* @param {(Number|ExternalLayout)} count - initializer for {@link
	* Sequence#count|count}.  The parameter must be either a positive
	* integer or an instance of {@link ExternalLayout}.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var Sequence = class extends Layout {
		constructor(elementLayout, count, property) {
			if (!(elementLayout instanceof Layout)) throw new TypeError("elementLayout must be a Layout");
			if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
			let span = -1;
			if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) span = count * elementLayout.span;
			super(span, property);
			/** The layout for individual elements of the sequence. */
			this.elementLayout = elementLayout;
			/** The number of elements in the sequence.
			*
			* This will be either a non-negative integer or an instance of
			* {@link ExternalLayout} for which {@link
			* ExternalLayout#isCount|isCount()} is `true`. */
			this.count = count;
		}
		/** @override */
		getSpan(b, offset = 0) {
			if (0 <= this.span) return this.span;
			let span = 0;
			let count = this.count;
			if (count instanceof ExternalLayout) count = count.decode(b, offset);
			if (0 < this.elementLayout.span) span = count * this.elementLayout.span;
			else {
				let idx = 0;
				while (idx < count) {
					span += this.elementLayout.getSpan(b, offset + span);
					++idx;
				}
			}
			return span;
		}
		/** @override */
		decode(b, offset = 0) {
			const rv = [];
			let i$1 = 0;
			let count = this.count;
			if (count instanceof ExternalLayout) count = count.decode(b, offset);
			while (i$1 < count) {
				rv.push(this.elementLayout.decode(b, offset));
				offset += this.elementLayout.getSpan(b, offset);
				i$1 += 1;
			}
			return rv;
		}
		/** Implement {@link Layout#encode|encode} for {@link Sequence}.
		*
		* **NOTE** If `src` is shorter than {@link Sequence#count|count} then
		* the unused space in the buffer is left unchanged.  If `src` is
		* longer than {@link Sequence#count|count} the unneeded elements are
		* ignored.
		*
		* **NOTE** If {@link Layout#count|count} is an instance of {@link
		* ExternalLayout} then the length of `src` will be encoded as the
		* count after `src` is encoded. */
		encode(src, b, offset = 0) {
			const elo = this.elementLayout;
			const span = src.reduce((span$1, v) => {
				return span$1 + elo.encode(v, b, offset + span$1);
			}, 0);
			if (this.count instanceof ExternalLayout) this.count.encode(src.length, b, offset);
			return span;
		}
	};
	exports.Sequence = Sequence;
	/**
	* Represent a contiguous sequence of arbitrary layout elements as an
	* Object.
	*
	* *Factory*: {@link module:Layout.struct|struct}
	*
	* **NOTE** The {@link Layout#span|span} of the structure is variable
	* if any layout in {@link Structure#fields|fields} has a variable
	* span.  When {@link Layout#encode|encoding} we must have a value for
	* all variable-length fields, or we wouldn't be able to figure out
	* how much space to use for storage.  We can only identify the value
	* for a field when it has a {@link Layout#property|property}.  As
	* such, although a structure may contain both unnamed fields and
	* variable-length fields, it cannot contain an unnamed
	* variable-length field.
	*
	* @param {Layout[]} fields - initializer for {@link
	* Structure#fields|fields}.  An error is raised if this contains a
	* variable-length field for which a {@link Layout#property|property}
	* is not defined.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @param {Boolean} [decodePrefixes] - initializer for {@link
	* Structure#decodePrefixes|property}.
	*
	* @throws {Error} - if `fields` contains an unnamed variable-length
	* layout.
	*
	* @augments {Layout}
	*/
	var Structure = class extends Layout {
		constructor(fields, property, decodePrefixes) {
			if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) throw new TypeError("fields must be array of Layout instances");
			if ("boolean" === typeof property && void 0 === decodePrefixes) {
				decodePrefixes = property;
				property = void 0;
			}
			for (const fd of fields) if (0 > fd.span && void 0 === fd.property) throw new Error("fields cannot contain unnamed variable-length layout");
			let span = -1;
			try {
				span = fields.reduce((span$1, fd) => span$1 + fd.getSpan(), 0);
			} catch (e) {}
			super(span, property);
			/** The sequence of {@link Layout} values that comprise the
			* structure.
			*
			* The individual elements need not be the same type, and may be
			* either scalar or aggregate layouts.  If a member layout leaves
			* its {@link Layout#property|property} undefined the
			* corresponding region of the buffer associated with the element
			* will not be mutated.
			*
			* @type {Layout[]} */
			this.fields = fields;
			/** Control behavior of {@link Layout#decode|decode()} given short
			* buffers.
			*
			* In some situations a structure many be extended with additional
			* fields over time, with older installations providing only a
			* prefix of the full structure.  If this property is `true`
			* decoding will accept those buffers and leave subsequent fields
			* undefined, as long as the buffer ends at a field boundary.
			* Defaults to `false`. */
			this.decodePrefixes = !!decodePrefixes;
		}
		/** @override */
		getSpan(b, offset = 0) {
			if (0 <= this.span) return this.span;
			let span = 0;
			try {
				span = this.fields.reduce((span$1, fd) => {
					const fsp = fd.getSpan(b, offset);
					offset += fsp;
					return span$1 + fsp;
				}, 0);
			} catch (e) {
				throw new RangeError("indeterminate span");
			}
			return span;
		}
		/** @override */
		decode(b, offset = 0) {
			checkUint8Array(b);
			const dest = this.makeDestinationObject();
			for (const fd of this.fields) {
				if (void 0 !== fd.property) dest[fd.property] = fd.decode(b, offset);
				offset += fd.getSpan(b, offset);
				if (this.decodePrefixes && b.length === offset) break;
			}
			return dest;
		}
		/** Implement {@link Layout#encode|encode} for {@link Structure}.
		*
		* If `src` is missing a property for a member with a defined {@link
		* Layout#property|property} the corresponding region of the buffer is
		* left unmodified. */
		encode(src, b, offset = 0) {
			const firstOffset = offset;
			let lastOffset = 0;
			let lastWrote = 0;
			for (const fd of this.fields) {
				let span = fd.span;
				lastWrote = 0 < span ? span : 0;
				if (void 0 !== fd.property) {
					const fv = src[fd.property];
					if (void 0 !== fv) {
						lastWrote = fd.encode(fv, b, offset);
						if (0 > span) span = fd.getSpan(b, offset);
					}
				}
				lastOffset = offset;
				offset += span;
			}
			return lastOffset + lastWrote - firstOffset;
		}
		/** @override */
		fromArray(values) {
			const dest = this.makeDestinationObject();
			for (const fd of this.fields) if (void 0 !== fd.property && 0 < values.length) dest[fd.property] = values.shift();
			return dest;
		}
		/**
		* Get access to the layout of a given property.
		*
		* @param {String} property - the structure member of interest.
		*
		* @return {Layout} - the layout associated with `property`, or
		* undefined if there is no such property.
		*/
		layoutFor(property) {
			if ("string" !== typeof property) throw new TypeError("property must be string");
			for (const fd of this.fields) if (fd.property === property) return fd;
		}
		/**
		* Get the offset of a structure member.
		*
		* @param {String} property - the structure member of interest.
		*
		* @return {Number} - the offset in bytes to the start of `property`
		* within the structure, or undefined if `property` is not a field
		* within the structure.  If the property is a member but follows a
		* variable-length structure member a negative number will be
		* returned.
		*/
		offsetOf(property) {
			if ("string" !== typeof property) throw new TypeError("property must be string");
			let offset = 0;
			for (const fd of this.fields) {
				if (fd.property === property) return offset;
				if (0 > fd.span) offset = -1;
				else if (0 <= offset) offset += fd.span;
			}
		}
	};
	exports.Structure = Structure;
	/**
	* An object that can provide a {@link
	* Union#discriminator|discriminator} API for {@link Union}.
	*
	* **NOTE** This is an abstract base class; you can create instances
	* if it amuses you, but they won't support the {@link
	* UnionDiscriminator#encode|encode} or {@link
	* UnionDiscriminator#decode|decode} functions.
	*
	* @param {string} [property] - Default for {@link
	* UnionDiscriminator#property|property}.
	*
	* @abstract
	*/
	var UnionDiscriminator = class {
		constructor(property) {
			/** The {@link Layout#property|property} to be used when the
			* discriminator is referenced in isolation (generally when {@link
			* Union#decode|Union decode} cannot delegate to a specific
			* variant). */
			this.property = property;
		}
		/** Analog to {@link Layout#decode|Layout decode} for union discriminators.
		*
		* The implementation of this method need not reference the buffer if
		* variant information is available through other means. */
		decode(b, offset) {
			throw new Error("UnionDiscriminator is abstract");
		}
		/** Analog to {@link Layout#decode|Layout encode} for union discriminators.
		*
		* The implementation of this method need not store the value if
		* variant information is maintained through other means. */
		encode(src, b, offset) {
			throw new Error("UnionDiscriminator is abstract");
		}
	};
	exports.UnionDiscriminator = UnionDiscriminator;
	/**
	* An object that can provide a {@link
	* UnionDiscriminator|discriminator API} for {@link Union} using an
	* unsigned integral {@link Layout} instance located either inside or
	* outside the union.
	*
	* @param {ExternalLayout} layout - initializes {@link
	* UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link
	* ExternalLayout#isCount|isCount()}.
	*
	* @param {string} [property] - Default for {@link
	* UnionDiscriminator#property|property}, superseding the property
	* from `layout`, but defaulting to `variant` if neither `property`
	* nor layout provide a property name.
	*
	* @augments {UnionDiscriminator}
	*/
	var UnionLayoutDiscriminator = class extends UnionDiscriminator {
		constructor(layout, property) {
			if (!(layout instanceof ExternalLayout && layout.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
			super(property || layout.property || "variant");
			/** The {@link ExternalLayout} used to access the discriminator
			* value. */
			this.layout = layout;
		}
		/** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
		decode(b, offset) {
			return this.layout.decode(b, offset);
		}
		/** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
		encode(src, b, offset) {
			return this.layout.encode(src, b, offset);
		}
	};
	exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
	/**
	* Represent any number of span-compatible layouts.
	*
	* *Factory*: {@link module:Layout.union|union}
	*
	* If the union has a {@link Union#defaultLayout|default layout} that
	* layout must have a non-negative {@link Layout#span|span}.  The span
	* of a fixed-span union includes its {@link
	* Union#discriminator|discriminator} if the variant is a {@link
	* Union#usesPrefixDiscriminator|prefix of the union}, plus the span
	* of its {@link Union#defaultLayout|default layout}.
	*
	* If the union does not have a default layout then the encoded span
	* of the union depends on the encoded span of its variant (which may
	* be fixed or variable).
	*
	* {@link VariantLayout#layout|Variant layout}s are added through
	* {@link Union#addVariant|addVariant}.  If the union has a default
	* layout, the span of the {@link VariantLayout#layout|layout
	* contained by the variant} must not exceed the span of the {@link
	* Union#defaultLayout|default layout} (minus the span of a {@link
	* Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The
	* span of the variant will equal the span of the union itself.
	*
	* The variant for a buffer can only be identified from the {@link
	* Union#discriminator|discriminator} {@link
	* UnionDiscriminator#property|property} (in the case of the {@link
	* Union#defaultLayout|default layout}), or by using {@link
	* Union#getVariant|getVariant} and examining the resulting {@link
	* VariantLayout} instance.
	*
	* A variant compatible with a JavaScript object can be identified
	* using {@link Union#getSourceVariant|getSourceVariant}.
	*
	* @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to
	* identify the layout used to interpret the union contents.  The
	* parameter must be an instance of {@link UnionDiscriminator}, an
	* {@link ExternalLayout} that satisfies {@link
	* ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link
	* UIntBE}).  When a non-external layout element is passed the layout
	* appears at the start of the union.  In all cases the (synthesized)
	* {@link UnionDiscriminator} instance is recorded as {@link
	* Union#discriminator|discriminator}.
	*
	* @param {(Layout|null)} defaultLayout - initializer for {@link
	* Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.
	* If `null` there is no default layout: the union has data-dependent
	* length and attempts to decode or encode unrecognized variants will
	* throw an exception.  A {@link Layout} instance must have a
	* non-negative {@link Layout#span|span}, and if it lacks a {@link
	* Layout#property|property} the {@link
	* Union#defaultLayout|defaultLayout} will be a {@link
	* Layout#replicate|replica} with property `content`.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var Union = class extends Layout {
		constructor(discr, defaultLayout, property) {
			let discriminator;
			if (discr instanceof UInt || discr instanceof UIntBE) discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
			else if (discr instanceof ExternalLayout && discr.isCount()) discriminator = new UnionLayoutDiscriminator(discr);
			else if (!(discr instanceof UnionDiscriminator)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
			else discriminator = discr;
			if (void 0 === defaultLayout) defaultLayout = null;
			if (!(null === defaultLayout || defaultLayout instanceof Layout)) throw new TypeError("defaultLayout must be null or a Layout");
			if (null !== defaultLayout) {
				if (0 > defaultLayout.span) throw new Error("defaultLayout must have constant span");
				if (void 0 === defaultLayout.property) defaultLayout = defaultLayout.replicate("content");
			}
			let span = -1;
			if (defaultLayout) {
				span = defaultLayout.span;
				if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) span += discriminator.layout.span;
			}
			super(span, property);
			/** The interface for the discriminator value in isolation.
			*
			* This a {@link UnionDiscriminator} either passed to the
			* constructor or synthesized from the `discr` constructor
			* argument.  {@link
			* Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be
			* `true` iff the `discr` parameter was a non-offset {@link
			* Layout} instance. */
			this.discriminator = discriminator;
			/** `true` if the {@link Union#discriminator|discriminator} is the
			* first field in the union.
			*
			* If `false` the discriminator is obtained from somewhere
			* else. */
			this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
			/** The layout for non-discriminator content when the value of the
			* discriminator is not recognized.
			*
			* This is the value passed to the constructor.  It is
			* structurally equivalent to the second component of {@link
			* Union#layout|layout} but may have a different property
			* name. */
			this.defaultLayout = defaultLayout;
			/** A registry of allowed variants.
			*
			* The keys are unsigned integers which should be compatible with
			* {@link Union.discriminator|discriminator}.  The property value
			* is the corresponding {@link VariantLayout} instances assigned
			* to this union by {@link Union#addVariant|addVariant}.
			*
			* **NOTE** The registry remains mutable so that variants can be
			* {@link Union#addVariant|added} at any time.  Users should not
			* manipulate the content of this property. */
			this.registry = {};
			let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
			/** Function to infer the variant selected by a source object.
			*
			* Defaults to {@link
			* Union#defaultGetSourceVariant|defaultGetSourceVariant} but may
			* be overridden using {@link
			* Union#configGetSourceVariant|configGetSourceVariant}.
			*
			* @param {Object} src - as with {@link
			* Union#defaultGetSourceVariant|defaultGetSourceVariant}.
			*
			* @returns {(undefined|VariantLayout)} The default variant
			* (`undefined`) or first registered variant that uses a property
			* available in `src`. */
			this.getSourceVariant = function(src) {
				return boundGetSourceVariant(src);
			};
			/** Function to override the implementation of {@link
			* Union#getSourceVariant|getSourceVariant}.
			*
			* Use this if the desired variant cannot be identified using the
			* algorithm of {@link
			* Union#defaultGetSourceVariant|defaultGetSourceVariant}.
			*
			* **NOTE** The provided function will be invoked bound to this
			* Union instance, providing local access to {@link
			* Union#registry|registry}.
			*
			* @param {Function} gsv - a function that follows the API of
			* {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */
			this.configGetSourceVariant = function(gsv) {
				boundGetSourceVariant = gsv.bind(this);
			};
		}
		/** @override */
		getSpan(b, offset = 0) {
			if (0 <= this.span) return this.span;
			const vlo = this.getVariant(b, offset);
			if (!vlo) throw new Error("unable to determine span for unrecognized variant");
			return vlo.getSpan(b, offset);
		}
		/**
		* Method to infer a registered Union variant compatible with `src`.
		*
		* The first satisfied rule in the following sequence defines the
		* return value:
		* * If `src` has properties matching the Union discriminator and
		*   the default layout, `undefined` is returned regardless of the
		*   value of the discriminator property (this ensures the default
		*   layout will be used);
		* * If `src` has a property matching the Union discriminator, the
		*   value of the discriminator identifies a registered variant, and
		*   either (a) the variant has no layout, or (b) `src` has the
		*   variant's property, then the variant is returned (because the
		*   source satisfies the constraints of the variant it identifies);
		* * If `src` does not have a property matching the Union
		*   discriminator, but does have a property matching a registered
		*   variant, then the variant is returned (because the source
		*   matches a variant without an explicit conflict);
		* * An error is thrown (because we either can't identify a variant,
		*   or we were explicitly told the variant but can't satisfy it).
		*
		* @param {Object} src - an object presumed to be compatible with
		* the content of the Union.
		*
		* @return {(undefined|VariantLayout)} - as described above.
		*
		* @throws {Error} - if `src` cannot be associated with a default or
		* registered variant.
		*/
		defaultGetSourceVariant(src) {
			if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
				if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) return;
				const vlo = this.registry[src[this.discriminator.property]];
				if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) return vlo;
			} else for (const tag in this.registry) {
				const vlo = this.registry[tag];
				if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) return vlo;
			}
			throw new Error("unable to infer src variant");
		}
		/** Implement {@link Layout#decode|decode} for {@link Union}.
		*
		* If the variant is {@link Union#addVariant|registered} the return
		* value is an instance of that variant, with no explicit
		* discriminator.  Otherwise the {@link Union#defaultLayout|default
		* layout} is used to decode the content. */
		decode(b, offset = 0) {
			let dest;
			const dlo = this.discriminator;
			const discr = dlo.decode(b, offset);
			const clo = this.registry[discr];
			if (void 0 === clo) {
				const defaultLayout = this.defaultLayout;
				let contentOffset = 0;
				if (this.usesPrefixDiscriminator) contentOffset = dlo.layout.span;
				dest = this.makeDestinationObject();
				dest[dlo.property] = discr;
				dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);
			} else dest = clo.decode(b, offset);
			return dest;
		}
		/** Implement {@link Layout#encode|encode} for {@link Union}.
		*
		* This API assumes the `src` object is consistent with the union's
		* {@link Union#defaultLayout|default layout}.  To encode variants
		* use the appropriate variant-specific {@link VariantLayout#encode}
		* method. */
		encode(src, b, offset = 0) {
			const vlo = this.getSourceVariant(src);
			if (void 0 === vlo) {
				const dlo = this.discriminator;
				const clo = this.defaultLayout;
				let contentOffset = 0;
				if (this.usesPrefixDiscriminator) contentOffset = dlo.layout.span;
				dlo.encode(src[dlo.property], b, offset);
				return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
			}
			return vlo.encode(src, b, offset);
		}
		/** Register a new variant structure within a union.  The newly
		* created variant is returned.
		*
		* @param {Number} variant - initializer for {@link
		* VariantLayout#variant|variant}.
		*
		* @param {Layout} layout - initializer for {@link
		* VariantLayout#layout|layout}.
		*
		* @param {String} property - initializer for {@link
		* Layout#property|property}.
		*
		* @return {VariantLayout} */
		addVariant(variant, layout, property) {
			const rv = new VariantLayout(this, variant, layout, property);
			this.registry[variant] = rv;
			return rv;
		}
		/**
		* Get the layout associated with a registered variant.
		*
		* If `vb` does not produce a registered variant the function returns
		* `undefined`.
		*
		* @param {(Number|Uint8Array)} vb - either the variant number, or a
		* buffer from which the discriminator is to be read.
		*
		* @param {Number} offset - offset into `vb` for the start of the
		* union.  Used only when `vb` is an instance of {Uint8Array}.
		*
		* @return {({VariantLayout}|undefined)}
		*/
		getVariant(vb, offset = 0) {
			let variant;
			if (vb instanceof Uint8Array) variant = this.discriminator.decode(vb, offset);
			else variant = vb;
			return this.registry[variant];
		}
	};
	exports.Union = Union;
	/**
	* Represent a specific variant within a containing union.
	*
	* **NOTE** The {@link Layout#span|span} of the variant may include
	* the span of the {@link Union#discriminator|discriminator} used to
	* identify it, but values read and written using the variant strictly
	* conform to the content of {@link VariantLayout#layout|layout}.
	*
	* **NOTE** User code should not invoke this constructor directly.  Use
	* the union {@link Union#addVariant|addVariant} helper method.
	*
	* @param {Union} union - initializer for {@link
	* VariantLayout#union|union}.
	*
	* @param {Number} variant - initializer for {@link
	* VariantLayout#variant|variant}.
	*
	* @param {Layout} [layout] - initializer for {@link
	* VariantLayout#layout|layout}.  If absent the variant carries no
	* data.
	*
	* @param {String} [property] - initializer for {@link
	* Layout#property|property}.  Unlike many other layouts, variant
	* layouts normally include a property name so they can be identified
	* within their containing {@link Union}.  The property identifier may
	* be absent only if `layout` is is absent.
	*
	* @augments {Layout}
	*/
	var VariantLayout = class extends Layout {
		constructor(union$1, variant, layout, property) {
			if (!(union$1 instanceof Union)) throw new TypeError("union must be a Union");
			if (!Number.isInteger(variant) || 0 > variant) throw new TypeError("variant must be a (non-negative) integer");
			if ("string" === typeof layout && void 0 === property) {
				property = layout;
				layout = null;
			}
			if (layout) {
				if (!(layout instanceof Layout)) throw new TypeError("layout must be a Layout");
				if (null !== union$1.defaultLayout && 0 <= layout.span && layout.span > union$1.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
				if ("string" !== typeof property) throw new TypeError("variant must have a String property");
			}
			let span = union$1.span;
			if (0 > union$1.span) {
				span = layout ? layout.span : 0;
				if (0 <= span && union$1.usesPrefixDiscriminator) span += union$1.discriminator.layout.span;
			}
			super(span, property);
			/** The {@link Union} to which this variant belongs. */
			this.union = union$1;
			/** The unsigned integral value identifying this variant within
			* the {@link Union#discriminator|discriminator} of the containing
			* union. */
			this.variant = variant;
			/** The {@link Layout} to be used when reading/writing the
			* non-discriminator part of the {@link
			* VariantLayout#union|union}.  If `null` the variant carries no
			* data. */
			this.layout = layout || null;
		}
		/** @override */
		getSpan(b, offset = 0) {
			if (0 <= this.span) return this.span;
			let contentOffset = 0;
			if (this.union.usesPrefixDiscriminator) contentOffset = this.union.discriminator.layout.span;
			let span = 0;
			if (this.layout) span = this.layout.getSpan(b, offset + contentOffset);
			return contentOffset + span;
		}
		/** @override */
		decode(b, offset = 0) {
			const dest = this.makeDestinationObject();
			if (this !== this.union.getVariant(b, offset)) throw new Error("variant mismatch");
			let contentOffset = 0;
			if (this.union.usesPrefixDiscriminator) contentOffset = this.union.discriminator.layout.span;
			if (this.layout) dest[this.property] = this.layout.decode(b, offset + contentOffset);
			else if (this.property) dest[this.property] = true;
			else if (this.union.usesPrefixDiscriminator) dest[this.union.discriminator.property] = this.variant;
			return dest;
		}
		/** @override */
		encode(src, b, offset = 0) {
			let contentOffset = 0;
			if (this.union.usesPrefixDiscriminator) contentOffset = this.union.discriminator.layout.span;
			if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) throw new TypeError("variant lacks property " + this.property);
			this.union.discriminator.encode(this.variant, b, offset);
			let span = contentOffset;
			if (this.layout) {
				this.layout.encode(src[this.property], b, offset + contentOffset);
				span += this.layout.getSpan(b, offset + contentOffset);
				if (0 <= this.union.span && span > this.union.span) throw new Error("encoded variant overruns containing union");
			}
			return span;
		}
		/** Delegate {@link Layout#fromArray|fromArray} to {@link
		* VariantLayout#layout|layout}. */
		fromArray(values) {
			if (this.layout) return this.layout.fromArray(values);
		}
	};
	exports.VariantLayout = VariantLayout;
	/** JavaScript chose to define bitwise operations as operating on
	* signed 32-bit values in 2's complement form, meaning any integer
	* with bit 31 set is going to look negative.  For right shifts that's
	* not a problem, because `>>>` is a logical shift, but for every
	* other bitwise operator we have to compensate for possible negative
	* results. */
	function fixBitwiseResult(v) {
		if (0 > v) v += 4294967296;
		return v;
	}
	/**
	* Contain a sequence of bit fields as an unsigned integer.
	*
	* *Factory*: {@link module:Layout.bits|bits}
	*
	* This is a container element; within it there are {@link BitField}
	* instances that provide the extracted properties.  The container
	* simply defines the aggregate representation and its bit ordering.
	* The representation is an object containing properties with numeric
	* or {@link Boolean} values.
	*
	* {@link BitField}s are added with the {@link
	* BitStructure#addField|addField} and {@link
	* BitStructure#addBoolean|addBoolean} methods.
	
	* @param {Layout} word - initializer for {@link
	* BitStructure#word|word}.  The parameter must be an instance of
	* {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.
	*
	* @param {bool} [msb] - `true` if the bit numbering starts at the
	* most significant bit of the containing word; `false` (default) if
	* it starts at the least significant bit of the containing word.  If
	* the parameter at this position is a string and `property` is
	* `undefined` the value of this argument will instead be used as the
	* value of `property`.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var BitStructure = class extends Layout {
		constructor(word, msb, property) {
			if (!(word instanceof UInt || word instanceof UIntBE)) throw new TypeError("word must be a UInt or UIntBE layout");
			if ("string" === typeof msb && void 0 === property) {
				property = msb;
				msb = false;
			}
			if (4 < word.span) throw new RangeError("word cannot exceed 32 bits");
			super(word.span, property);
			/** The layout used for the packed value.  {@link BitField}
			* instances are packed sequentially depending on {@link
			* BitStructure#msb|msb}. */
			this.word = word;
			/** Whether the bit sequences are packed starting at the most
			* significant bit growing down (`true`), or the least significant
			* bit growing up (`false`).
			*
			* **NOTE** Regardless of this value, the least significant bit of
			* any {@link BitField} value is the least significant bit of the
			* corresponding section of the packed value. */
			this.msb = !!msb;
			/** The sequence of {@link BitField} layouts that comprise the
			* packed structure.
			*
			* **NOTE** The array remains mutable to allow fields to be {@link
			* BitStructure#addField|added} after construction.  Users should
			* not manipulate the content of this property.*/
			this.fields = [];
			let value = 0;
			this._packedSetValue = function(v) {
				value = fixBitwiseResult(v);
				return this;
			};
			this._packedGetValue = function() {
				return value;
			};
		}
		/** @override */
		decode(b, offset = 0) {
			const dest = this.makeDestinationObject();
			const value = this.word.decode(b, offset);
			this._packedSetValue(value);
			for (const fd of this.fields) if (void 0 !== fd.property) dest[fd.property] = fd.decode(b);
			return dest;
		}
		/** Implement {@link Layout#encode|encode} for {@link BitStructure}.
		*
		* If `src` is missing a property for a member with a defined {@link
		* Layout#property|property} the corresponding region of the packed
		* value is left unmodified.  Unused bits are also left unmodified. */
		encode(src, b, offset = 0) {
			const value = this.word.decode(b, offset);
			this._packedSetValue(value);
			for (const fd of this.fields) if (void 0 !== fd.property) {
				const fv = src[fd.property];
				if (void 0 !== fv) fd.encode(fv);
			}
			return this.word.encode(this._packedGetValue(), b, offset);
		}
		/** Register a new bitfield with a containing bit structure.  The
		* resulting bitfield is returned.
		*
		* @param {Number} bits - initializer for {@link BitField#bits|bits}.
		*
		* @param {string} property - initializer for {@link
		* Layout#property|property}.
		*
		* @return {BitField} */
		addField(bits, property) {
			const bf = new BitField(this, bits, property);
			this.fields.push(bf);
			return bf;
		}
		/** As with {@link BitStructure#addField|addField} for single-bit
		* fields with `boolean` value representation.
		*
		* @param {string} property - initializer for {@link
		* Layout#property|property}.
		*
		* @return {Boolean} */
		addBoolean(property) {
			const bf = new Boolean$1(this, property);
			this.fields.push(bf);
			return bf;
		}
		/**
		* Get access to the bit field for a given property.
		*
		* @param {String} property - the bit field of interest.
		*
		* @return {BitField} - the field associated with `property`, or
		* undefined if there is no such property.
		*/
		fieldFor(property) {
			if ("string" !== typeof property) throw new TypeError("property must be string");
			for (const fd of this.fields) if (fd.property === property) return fd;
		}
	};
	exports.BitStructure = BitStructure;
	/**
	* Represent a sequence of bits within a {@link BitStructure}.
	*
	* All bit field values are represented as unsigned integers.
	*
	* **NOTE** User code should not invoke this constructor directly.
	* Use the container {@link BitStructure#addField|addField} helper
	* method.
	*
	* **NOTE** BitField instances are not instances of {@link Layout}
	* since {@link Layout#span|span} measures 8-bit units.
	*
	* @param {BitStructure} container - initializer for {@link
	* BitField#container|container}.
	*
	* @param {Number} bits - initializer for {@link BitField#bits|bits}.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*/
	var BitField = class {
		constructor(container, bits, property) {
			if (!(container instanceof BitStructure)) throw new TypeError("container must be a BitStructure");
			if (!Number.isInteger(bits) || 0 >= bits) throw new TypeError("bits must be positive integer");
			const totalBits = 8 * container.span;
			const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
			if (bits + usedBits > totalBits) throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
			/** The {@link BitStructure} instance to which this bit field
			* belongs. */
			this.container = container;
			/** The span of this value in bits. */
			this.bits = bits;
			/** A mask of {@link BitField#bits|bits} bits isolating value bits
			* that fit within the field.
			*
			* That is, it masks a value that has not yet been shifted into
			* position within its containing packed integer. */
			this.valueMask = (1 << bits) - 1;
			if (32 === bits) this.valueMask = 4294967295;
			/** The offset of the value within the containing packed unsigned
			* integer.  The least significant bit of the packed value is at
			* offset zero, regardless of bit ordering used. */
			this.start = usedBits;
			if (this.container.msb) this.start = totalBits - usedBits - bits;
			/** A mask of {@link BitField#bits|bits} isolating the field value
			* within the containing packed unsigned integer. */
			this.wordMask = fixBitwiseResult(this.valueMask << this.start);
			/** The property name used when this bitfield is represented in an
			* Object.
			*
			* Intended to be functionally equivalent to {@link
			* Layout#property}.
			*
			* If left undefined the corresponding span of bits will be
			* treated as padding: it will not be mutated by {@link
			* Layout#encode|encode} nor represented as a property in the
			* decoded Object. */
			this.property = property;
		}
		/** Store a value into the corresponding subsequence of the containing
		* bit field. */
		decode(b, offset) {
			return fixBitwiseResult(this.container._packedGetValue() & this.wordMask) >>> this.start;
		}
		/** Store a value into the corresponding subsequence of the containing
		* bit field.
		*
		* **NOTE** This is not a specialization of {@link
		* Layout#encode|Layout.encode} and there is no return value. */
		encode(value) {
			if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
			const word = this.container._packedGetValue();
			const wordValue = fixBitwiseResult(value << this.start);
			this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
		}
	};
	exports.BitField = BitField;
	/**
	* Represent a single bit within a {@link BitStructure} as a
	* JavaScript boolean.
	*
	* **NOTE** User code should not invoke this constructor directly.
	* Use the container {@link BitStructure#addBoolean|addBoolean} helper
	* method.
	*
	* @param {BitStructure} container - initializer for {@link
	* BitField#container|container}.
	*
	* @param {string} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {BitField}
	*/
	var Boolean$1 = class extends BitField {
		constructor(container, property) {
			super(container, 1, property);
		}
		/** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
		*
		* @returns {boolean} */
		decode(b, offset) {
			return !!super.decode(b, offset);
		}
		/** @override */
		encode(value) {
			if ("boolean" === typeof value) value = +value;
			super.encode(value);
		}
	};
	exports.Boolean = Boolean$1;
	/**
	* Contain a fixed-length block of arbitrary data, represented as a
	* Uint8Array.
	*
	* *Factory*: {@link module:Layout.blob|blob}
	*
	* @param {(Number|ExternalLayout)} length - initializes {@link
	* Blob#length|length}.
	*
	* @param {String} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var Blob = class extends Layout {
		constructor(length, property) {
			if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
			let span = -1;
			if (!(length instanceof ExternalLayout)) span = length;
			super(span, property);
			/** The number of bytes in the blob.
			*
			* This may be a non-negative integer, or an instance of {@link
			* ExternalLayout} that satisfies {@link
			* ExternalLayout#isCount|isCount()}. */
			this.length = length;
		}
		/** @override */
		getSpan(b, offset) {
			let span = this.span;
			if (0 > span) span = this.length.decode(b, offset);
			return span;
		}
		/** @override */
		decode(b, offset = 0) {
			let span = this.span;
			if (0 > span) span = this.length.decode(b, offset);
			return uint8ArrayToBuffer(b).slice(offset, offset + span);
		}
		/** Implement {@link Layout#encode|encode} for {@link Blob}.
		*
		* **NOTE** If {@link Layout#count|count} is an instance of {@link
		* ExternalLayout} then the length of `src` will be encoded as the
		* count after `src` is encoded. */
		encode(src, b, offset) {
			let span = this.length;
			if (this.length instanceof ExternalLayout) span = src.length;
			if (!(src instanceof Uint8Array && span === src.length)) throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
			if (offset + span > b.length) throw new RangeError("encoding overruns Uint8Array");
			const srcBuffer = uint8ArrayToBuffer(src);
			uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset, span, "hex");
			if (this.length instanceof ExternalLayout) this.length.encode(span, b, offset);
			return span;
		}
	};
	exports.Blob = Blob;
	/**
	* Contain a `NUL`-terminated UTF8 string.
	*
	* *Factory*: {@link module:Layout.cstr|cstr}
	*
	* **NOTE** Any UTF8 string that incorporates a zero-valued byte will
	* not be correctly decoded by this layout.
	*
	* @param {String} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var CString = class extends Layout {
		constructor(property) {
			super(-1, property);
		}
		/** @override */
		getSpan(b, offset = 0) {
			checkUint8Array(b);
			let idx = offset;
			while (idx < b.length && 0 !== b[idx]) idx += 1;
			return 1 + idx - offset;
		}
		/** @override */
		decode(b, offset = 0) {
			const span = this.getSpan(b, offset);
			return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString("utf-8");
		}
		/** @override */
		encode(src, b, offset = 0) {
			if ("string" !== typeof src) src = String(src);
			const srcb = buffer_1.Buffer.from(src, "utf8");
			const span = srcb.length;
			if (offset + span > b.length) throw new RangeError("encoding overruns Buffer");
			const buffer$1 = uint8ArrayToBuffer(b);
			srcb.copy(buffer$1, offset);
			buffer$1[offset + span] = 0;
			return span + 1;
		}
	};
	exports.CString = CString;
	/**
	* Contain a UTF8 string with implicit length.
	*
	* *Factory*: {@link module:Layout.utf8|utf8}
	*
	* **NOTE** Because the length is implicit in the size of the buffer
	* this layout should be used only in isolation, or in a situation
	* where the length can be expressed by operating on a slice of the
	* containing buffer.
	*
	* @param {Number} [maxSpan] - the maximum length allowed for encoded
	* string content.  If not provided there is no bound on the allowed
	* content.
	*
	* @param {String} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var UTF8 = class extends Layout {
		constructor(maxSpan, property) {
			if ("string" === typeof maxSpan && void 0 === property) {
				property = maxSpan;
				maxSpan = void 0;
			}
			if (void 0 === maxSpan) maxSpan = -1;
			else if (!Number.isInteger(maxSpan)) throw new TypeError("maxSpan must be an integer");
			super(-1, property);
			/** The maximum span of the layout in bytes.
			*
			* Positive values are generally expected.  Zero is abnormal.
			* Attempts to encode or decode a value that exceeds this length
			* will throw a `RangeError`.
			*
			* A negative value indicates that there is no bound on the length
			* of the content. */
			this.maxSpan = maxSpan;
		}
		/** @override */
		getSpan(b, offset = 0) {
			checkUint8Array(b);
			return b.length - offset;
		}
		/** @override */
		decode(b, offset = 0) {
			const span = this.getSpan(b, offset);
			if (0 <= this.maxSpan && this.maxSpan < span) throw new RangeError("text length exceeds maxSpan");
			return uint8ArrayToBuffer(b).slice(offset, offset + span).toString("utf-8");
		}
		/** @override */
		encode(src, b, offset = 0) {
			if ("string" !== typeof src) src = String(src);
			const srcb = buffer_1.Buffer.from(src, "utf8");
			const span = srcb.length;
			if (0 <= this.maxSpan && this.maxSpan < span) throw new RangeError("text length exceeds maxSpan");
			if (offset + span > b.length) throw new RangeError("encoding overruns Buffer");
			srcb.copy(uint8ArrayToBuffer(b), offset);
			return span;
		}
	};
	exports.UTF8 = UTF8;
	/**
	* Contain a constant value.
	*
	* This layout may be used in cases where a JavaScript value can be
	* inferred without an expression in the binary encoding.  An example
	* would be a {@link VariantLayout|variant layout} where the content
	* is implied by the union {@link Union#discriminator|discriminator}.
	*
	* @param {Object|Number|String} value - initializer for {@link
	* Constant#value|value}.  If the value is an object (or array) and
	* the application intends the object to remain unchanged regardless
	* of what is done to values decoded by this layout, the value should
	* be frozen prior passing it to this constructor.
	*
	* @param {String} [property] - initializer for {@link
	* Layout#property|property}.
	*
	* @augments {Layout}
	*/
	var Constant = class extends Layout {
		constructor(value, property) {
			super(0, property);
			/** The value produced by this constant when the layout is {@link
			* Constant#decode|decoded}.
			*
			* Any JavaScript value including `null` and `undefined` is
			* permitted.
			*
			* **WARNING** If `value` passed in the constructor was not
			* frozen, it is possible for users of decoded values to change
			* the content of the value. */
			this.value = value;
		}
		/** @override */
		decode(b, offset) {
			return this.value;
		}
		/** @override */
		encode(src, b, offset) {
			return 0;
		}
	};
	exports.Constant = Constant;
	/** Factory for {@link GreedyCount}. */
	exports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));
	/** Factory for {@link OffsetLayout}. */
	exports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));
	/** Factory for {@link UInt|unsigned int layouts} spanning one
	* byte. */
	exports.u8 = ((property) => new UInt(1, property));
	/** Factory for {@link UInt|little-endian unsigned int layouts}
	* spanning two bytes. */
	exports.u16 = ((property) => new UInt(2, property));
	/** Factory for {@link UInt|little-endian unsigned int layouts}
	* spanning three bytes. */
	exports.u24 = ((property) => new UInt(3, property));
	/** Factory for {@link UInt|little-endian unsigned int layouts}
	* spanning four bytes. */
	exports.u32 = ((property) => new UInt(4, property));
	/** Factory for {@link UInt|little-endian unsigned int layouts}
	* spanning five bytes. */
	exports.u40 = ((property) => new UInt(5, property));
	/** Factory for {@link UInt|little-endian unsigned int layouts}
	* spanning six bytes. */
	exports.u48 = ((property) => new UInt(6, property));
	/** Factory for {@link NearUInt64|little-endian unsigned int
	* layouts} interpreted as Numbers. */
	exports.nu64 = ((property) => new NearUInt64(property));
	/** Factory for {@link UInt|big-endian unsigned int layouts}
	* spanning two bytes. */
	exports.u16be = ((property) => new UIntBE(2, property));
	/** Factory for {@link UInt|big-endian unsigned int layouts}
	* spanning three bytes. */
	exports.u24be = ((property) => new UIntBE(3, property));
	/** Factory for {@link UInt|big-endian unsigned int layouts}
	* spanning four bytes. */
	exports.u32be = ((property) => new UIntBE(4, property));
	/** Factory for {@link UInt|big-endian unsigned int layouts}
	* spanning five bytes. */
	exports.u40be = ((property) => new UIntBE(5, property));
	/** Factory for {@link UInt|big-endian unsigned int layouts}
	* spanning six bytes. */
	exports.u48be = ((property) => new UIntBE(6, property));
	/** Factory for {@link NearUInt64BE|big-endian unsigned int
	* layouts} interpreted as Numbers. */
	exports.nu64be = ((property) => new NearUInt64BE(property));
	/** Factory for {@link Int|signed int layouts} spanning one
	* byte. */
	exports.s8 = ((property) => new Int(1, property));
	/** Factory for {@link Int|little-endian signed int layouts}
	* spanning two bytes. */
	exports.s16 = ((property) => new Int(2, property));
	/** Factory for {@link Int|little-endian signed int layouts}
	* spanning three bytes. */
	exports.s24 = ((property) => new Int(3, property));
	/** Factory for {@link Int|little-endian signed int layouts}
	* spanning four bytes. */
	exports.s32 = ((property) => new Int(4, property));
	/** Factory for {@link Int|little-endian signed int layouts}
	* spanning five bytes. */
	exports.s40 = ((property) => new Int(5, property));
	/** Factory for {@link Int|little-endian signed int layouts}
	* spanning six bytes. */
	exports.s48 = ((property) => new Int(6, property));
	/** Factory for {@link NearInt64|little-endian signed int layouts}
	* interpreted as Numbers. */
	exports.ns64 = ((property) => new NearInt64(property));
	/** Factory for {@link Int|big-endian signed int layouts}
	* spanning two bytes. */
	exports.s16be = ((property) => new IntBE(2, property));
	/** Factory for {@link Int|big-endian signed int layouts}
	* spanning three bytes. */
	exports.s24be = ((property) => new IntBE(3, property));
	/** Factory for {@link Int|big-endian signed int layouts}
	* spanning four bytes. */
	exports.s32be = ((property) => new IntBE(4, property));
	/** Factory for {@link Int|big-endian signed int layouts}
	* spanning five bytes. */
	exports.s40be = ((property) => new IntBE(5, property));
	/** Factory for {@link Int|big-endian signed int layouts}
	* spanning six bytes. */
	exports.s48be = ((property) => new IntBE(6, property));
	/** Factory for {@link NearInt64BE|big-endian signed int layouts}
	* interpreted as Numbers. */
	exports.ns64be = ((property) => new NearInt64BE(property));
	/** Factory for {@link Float|little-endian 32-bit floating point} values. */
	exports.f32 = ((property) => new Float(property));
	/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */
	exports.f32be = ((property) => new FloatBE(property));
	/** Factory for {@link Double|little-endian 64-bit floating point} values. */
	exports.f64 = ((property) => new Double(property));
	/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */
	exports.f64be = ((property) => new DoubleBE(property));
	/** Factory for {@link Structure} values. */
	exports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));
	/** Factory for {@link BitStructure} values. */
	exports.bits = ((word, msb, property) => new BitStructure(word, msb, property));
	/** Factory for {@link Sequence} values. */
	exports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));
	/** Factory for {@link Union} values. */
	exports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));
	/** Factory for {@link UnionLayoutDiscriminator} values. */
	exports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));
	/** Factory for {@link Blob} values. */
	exports.blob = ((length, property) => new Blob(length, property));
	/** Factory for {@link CString} values. */
	exports.cstr = ((property) => new CString(property));
	/** Factory for {@link UTF8} values. */
	exports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));
	/** Factory for {@link Constant} values. */
	exports.constant = ((value, property) => new Constant(value, property));
}) });

//#endregion
//#region node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.browser.mjs
function getHumanReadableErrorMessage(code, context = {}) {
	const messageFormatString = SolanaErrorMessages[code];
	if (messageFormatString.length === 0) return "";
	let state;
	function commitStateUpTo(endIndex) {
		if (state[TYPE] === 2) {
			const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
			fragments.push(variableName in context ? `${context[variableName]}` : `$${variableName}`);
		} else if (state[TYPE] === 1) fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
	}
	const fragments = [];
	messageFormatString.split("").forEach((char, ii) => {
		if (ii === 0) {
			state = {
				[START_INDEX]: 0,
				[TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
			};
			return;
		}
		let nextState;
		switch (state[TYPE]) {
			case 0:
				nextState = {
					[START_INDEX]: ii,
					[TYPE]: 1
				};
				break;
			case 1:
				if (char === "\\") nextState = {
					[START_INDEX]: ii,
					[TYPE]: 0
				};
				else if (char === "$") nextState = {
					[START_INDEX]: ii,
					[TYPE]: 2
				};
				break;
			case 2:
				if (char === "\\") nextState = {
					[START_INDEX]: ii,
					[TYPE]: 0
				};
				else if (char === "$") nextState = {
					[START_INDEX]: ii,
					[TYPE]: 2
				};
				else if (!char.match(/\w/)) nextState = {
					[START_INDEX]: ii,
					[TYPE]: 1
				};
				break;
		}
		if (nextState) {
			if (state !== nextState) commitStateUpTo(ii);
			state = nextState;
		}
	});
	commitStateUpTo();
	return fragments.join("");
}
function getErrorMessage(code, context = {}) {
	return getHumanReadableErrorMessage(code, context);
}
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, SOLANA_ERROR__INVALID_NONCE, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SOLANA_ERROR__MALFORMED_BIGINT_STRING, SOLANA_ERROR__MALFORMED_NUMBER_STRING, SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, SOLANA_ERROR__JSON_RPC__PARSE_ERROR, SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR, SOLANA_ERROR__JSON_RPC__INVALID_PARAMS, SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND, SOLANA_ERROR__JSON_RPC__INVALID_REQUEST, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH, SOLANA_ERROR__JSON_RPC__SCAN_ERROR, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS, SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SOLANA_ERROR__ADDRESSES__MALFORMED_PDA, SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE, SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED, SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER, SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT, SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED, SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT, SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION, SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT, SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC, SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE, SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY, SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER, SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR, SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS, SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS, SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING, SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE, SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT, SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP, SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX, SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION, SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE, SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS, SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT, SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED, SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_CONSTANT, SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE, SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING, SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED, SolanaErrorMessages, START_INDEX, TYPE, SolanaError;
var init_index_browser$3 = __esm({ "node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.browser.mjs": (() => {
	SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
	SOLANA_ERROR__INVALID_NONCE = 2;
	SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
	SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
	SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
	SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
	SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
	SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
	SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
	SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;
	SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
	SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
	SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
	SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
	SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
	SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
	SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
	SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
	SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
	SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
	SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
	SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
	SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
	SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
	SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
	SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
	SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
	SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
	SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;
	SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
	SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
	SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
	SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
	SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
	SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
	SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
	SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
	SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
	SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
	SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
	SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
	SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
	SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
	SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
	SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
	SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
	SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
	SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
	SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
	SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
	SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
	SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
	SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
	SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
	SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
	SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
	SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
	SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
	SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
	SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
	SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
	SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
	SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
	SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
	SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
	SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
	SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
	SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
	SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
	SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
	SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
	SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
	SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
	SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
	SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
	SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
	SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
	SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
	SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
	SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
	SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
	SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
	SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
	SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
	SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
	SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
	SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
	SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
	SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
	SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
	SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
	SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
	SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
	SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
	SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
	SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
	SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
	SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
	SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
	SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
	SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
	SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
	SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
	SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
	SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
	SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
	SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
	SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
	SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
	SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
	SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
	SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
	SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
	SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
	SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
	SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
	SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
	SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
	SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
	SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
	SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
	SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
	SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
	SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
	SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
	SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
	SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
	SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
	SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
	SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
	SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
	SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
	SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
	SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
	SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
	SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
	SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
	SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;
	SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;
	SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
	SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
	SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
	SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
	SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
	SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
	SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
	SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
	SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
	SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
	SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
	SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
	SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
	SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
	SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
	SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
	SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
	SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
	SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
	SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
	SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
	SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
	SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
	SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
	SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
	SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
	SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
	SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
	SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
	SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
	SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
	SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
	SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
	SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
	SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
	SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
	SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
	SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
	SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
	SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
	SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
	SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
	SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
	SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
	SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
	SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
	SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
	SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
	SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
	SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
	SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
	SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
	SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
	SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
	SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
	SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
	SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
	SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
	SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
	SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
	SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
	SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
	SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
	SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;
	SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;
	SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
	SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
	SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;
	SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;
	SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;
	SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
	SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
	SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
	SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;
	SolanaErrorMessages = {
		[SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
		[SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
		[SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
		[SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
		[SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
		[SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
		[SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
		[SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
		[SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
		[SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
		[SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
		[SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
		[SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
		[SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
		[SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
		[SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
		[SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
		[SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
		[SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
		[SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
		[SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
		[SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
		[SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
		[SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
		[SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
		[SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
		[SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
		[SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
		[SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
		[SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
		[SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
		[SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
		[SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
		[SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
		[SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
		[SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
		[SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
		[SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
		[SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
		[SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
		[SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
		[SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
		[SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
		[SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
		[SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
		[SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
		[SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
		[SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
		[SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
		[SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
		[SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
		[SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
		[SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
		[SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
		[SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
		[SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
		[SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
		[SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
		[SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
		[SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
		[SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
		[SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
		[SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
		[SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
		[SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
		[SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
		[SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
		[SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
		[SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
		[SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
		[SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
		[SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
		[SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
		[SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
		[SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
		[SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
		[SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
		[SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
		[SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
		[SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
		[SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
		[SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
		[SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
		[SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
		[SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
		[SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
		[SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
		[SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
		[SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
		[SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
		[SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
		[SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
		[SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
		[SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
		[SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
		[SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
		[SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
		[SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
		[SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
		[SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
		[SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
		[SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
		[SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
		[SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
		[SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
		[SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
		[SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
		[SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
		[SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
		[SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
		[SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
		[SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
		[SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
		[SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
		[SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
		[SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
		[SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
		[SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
		[SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
		[SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
		[SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
		[SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
		[SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
		[SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
		[SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
		[SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
		[SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
		[SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
		[SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
		[SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
		[SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
		[SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
		[SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
		[SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
		[SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
		[SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
		[SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
		[SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
		[SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
		[SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
		[SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
		[SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
		[SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
		[SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
		[SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
		[SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
		[SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
		[SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
		[SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
		[SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
		[SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
		[SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
		[SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
		[SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
		[SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
		[SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
		[SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
		[SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
		[SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
		[SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
		[SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
		[SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
		[SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
		[SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
		[SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
		[SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
		[SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
		[SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
		[SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
		[SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
		[SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
		[SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
		[SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
		[SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
		[SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
		[SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
		[SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
		[SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
		[SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
		[SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
		[SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
		[SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
		[SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
		[SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
		[SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
		[SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
		[SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
		[SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
		[SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
		[SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
		[SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
		[SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
		[SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
		[SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
		[SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
		[SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
		[SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
		[SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
		[SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
		[SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
		[SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
		[SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
		[SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
		[SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
		[SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
		[SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
		[SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
		[SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
		[SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
		[SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
		[SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
		[SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
		[SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
	};
	START_INDEX = "i";
	TYPE = "t";
	SolanaError = class extends Error {
		/**
		* Indicates the root cause of this {@link SolanaError}, if any.
		*
		* For example, a transaction error might have an instruction error as its root cause. In this
		* case, you will be able to access the instruction error on the transaction error as `cause`.
		*/
		cause = this.cause;
		/**
		* Contains context that can assist in understanding or recovering from a {@link SolanaError}.
		*/
		context;
		constructor(...[code, contextAndErrorOptions]) {
			let context;
			let errorOptions;
			if (contextAndErrorOptions) {
				const { cause, ...contextRest } = contextAndErrorOptions;
				if (cause) errorOptions = { cause };
				if (Object.keys(contextRest).length > 0) context = contextRest;
			}
			const message = getErrorMessage(code, context);
			super(message, errorOptions);
			this.context = {
				__code: code,
				...context
			};
			this.name = "SolanaError";
		}
	};
}) });

//#endregion
//#region node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.browser.mjs
function getEncodedSize(value, encoder) {
	return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder(encoder) {
	return Object.freeze({
		...encoder,
		encode: (value) => {
			const bytes = new Uint8Array(getEncodedSize(value, encoder));
			encoder.write(value, bytes, 0);
			return bytes;
		}
	});
}
function createDecoder(decoder) {
	return Object.freeze({
		...decoder,
		decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]
	});
}
function isFixedSize(codec) {
	return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function combineCodec(encoder, decoder) {
	if (isFixedSize(encoder) !== isFixedSize(decoder)) throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
	if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
		decoderFixedSize: decoder.fixedSize,
		encoderFixedSize: encoder.fixedSize
	});
	if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
		decoderMaxSize: decoder.maxSize,
		encoderMaxSize: encoder.maxSize
	});
	return {
		...decoder,
		...encoder,
		decode: decoder.decode,
		encode: encoder.encode,
		read: decoder.read,
		write: encoder.write
	};
}
function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {
	if (bytes.length - offset <= 0) throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, { codecDescription });
}
function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {
	const bytesLength = bytes.length - offset;
	if (bytesLength < expected) throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
		bytesLength,
		codecDescription,
		expected
	});
}
var init_index_browser$2 = __esm({ "node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.browser.mjs": (() => {
	init_index_browser$3();
}) });

//#endregion
//#region node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.browser.mjs
function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
	if (value < min || value > max) throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
		codecDescription,
		max,
		min,
		value
	});
}
function isLittleEndian(config) {
	return config?.endian === 1 ? false : true;
}
function numberEncoderFactory(input) {
	return createEncoder({
		fixedSize: input.size,
		write(value, bytes, offset) {
			if (input.range) assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
			const arrayBuffer = new ArrayBuffer(input.size);
			input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
			bytes.set(new Uint8Array(arrayBuffer), offset);
			return offset + input.size;
		}
	});
}
function numberDecoderFactory(input) {
	return createDecoder({
		fixedSize: input.size,
		read(bytes, offset = 0) {
			assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);
			assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);
			const view = new DataView(toArrayBuffer(bytes, offset, input.size));
			return [input.get(view, isLittleEndian(input.config)), offset + input.size];
		}
	});
}
function toArrayBuffer(bytes, offset, length) {
	const bytesOffset = bytes.byteOffset + (offset ?? 0);
	const bytesLength = length ?? bytes.byteLength;
	return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getU64Encoder, getU64Decoder, getU64Codec;
var init_index_browser$1 = __esm({ "node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.browser.mjs": (() => {
	init_index_browser$3();
	init_index_browser$2();
	getU64Encoder = (config = {}) => numberEncoderFactory({
		config,
		name: "u64",
		range: [0n, BigInt("0xffffffffffffffff")],
		set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
		size: 8
	});
	getU64Decoder = (config = {}) => numberDecoderFactory({
		config,
		get: (view, le) => view.getBigUint64(0, le),
		name: "u64",
		size: 8
	});
	getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));
}) });

//#endregion
//#region node_modules/superstruct/dist/index.mjs
/**
* Check if a value is an iterator.
*/
function isIterable(x) {
	return isObject(x) && typeof x[Symbol.iterator] === "function";
}
/**
* Check if a value is a plain object.
*/
function isObject(x) {
	return typeof x === "object" && x != null;
}
/**
* Check if a value is a non-array object.
*/
function isNonArrayObject(x) {
	return isObject(x) && !Array.isArray(x);
}
/**
* Return a value as a printable string.
*/
function print(value) {
	if (typeof value === "symbol") return value.toString();
	return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
/**
* Shifts (removes and returns) the first value from the `input` iterator.
* Like `Array.prototype.shift()` but for an `Iterator`.
*/
function shiftIterator(input) {
	const { done, value } = input.next();
	return done ? void 0 : value;
}
/**
* Convert a single validation result to a failure.
*/
function toFailure(result, context, struct, value) {
	if (result === true) return;
	else if (result === false) result = {};
	else if (typeof result === "string") result = { message: result };
	const { path, branch } = context;
	const { type: type$1 } = struct;
	const { refinement, message = `Expected a value of type \`${type$1}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
	return {
		value,
		type: type$1,
		refinement,
		key: path[path.length - 1],
		path,
		branch,
		...result,
		message
	};
}
/**
* Convert a validation result to an iterable of failures.
*/
function* toFailures(result, context, struct, value) {
	if (!isIterable(result)) result = [result];
	for (const r of result) {
		const failure = toFailure(r, context, struct, value);
		if (failure) yield failure;
	}
}
/**
* Check a value against a struct, traversing deeply into nested values, and
* returning an iterator of failures or success.
*/
function* run(value, struct, options = {}) {
	const { path = [], branch = [value], coerce: coerce$1 = false, mask: mask$1 = false } = options;
	const ctx = {
		path,
		branch,
		mask: mask$1
	};
	if (coerce$1) value = struct.coercer(value, ctx);
	let status = "valid";
	for (const failure of struct.validator(value, ctx)) {
		failure.explanation = options.message;
		status = "not_valid";
		yield [failure, void 0];
	}
	for (let [k, v, s] of struct.entries(value, ctx)) {
		const ts = run(v, s, {
			path: k === void 0 ? path : [...path, k],
			branch: k === void 0 ? branch : [...branch, v],
			coerce: coerce$1,
			mask: mask$1,
			message: options.message
		});
		for (const t of ts) if (t[0]) {
			status = t[0].refinement != null ? "not_refined" : "not_valid";
			yield [t[0], void 0];
		} else if (coerce$1) {
			v = t[1];
			if (k === void 0) value = v;
			else if (value instanceof Map) value.set(k, v);
			else if (value instanceof Set) value.add(v);
			else if (isObject(value)) {
				if (v !== void 0 || k in value) value[k] = v;
			}
		}
	}
	if (status !== "not_valid") for (const failure of struct.refiner(value, ctx)) {
		failure.explanation = options.message;
		status = "not_refined";
		yield [failure, void 0];
	}
	if (status === "valid") yield [void 0, value];
}
/**
* Assert that a value passes a struct, throwing if it doesn't.
*/
function assert(value, struct, message) {
	const result = validate$1(value, struct, { message });
	if (result[0]) throw result[0];
}
/**
* Create a value with the coercion logic of struct and validate it.
*/
function create(value, struct, message) {
	const result = validate$1(value, struct, {
		coerce: true,
		message
	});
	if (result[0]) throw result[0];
	else return result[1];
}
/**
* Mask a value, returning only the subset of properties defined by a struct.
*/
function mask(value, struct, message) {
	const result = validate$1(value, struct, {
		coerce: true,
		mask: true,
		message
	});
	if (result[0]) throw result[0];
	else return result[1];
}
/**
* Check if a value passes a struct.
*/
function is(value, struct) {
	return !validate$1(value, struct)[0];
}
/**
* Validate a value against a struct, returning an error if invalid, or the
* value (with potential coercion) if valid.
*/
function validate$1(value, struct, options = {}) {
	const tuples = run(value, struct, options);
	const tuple$1 = shiftIterator(tuples);
	if (tuple$1[0]) return [new StructError(tuple$1[0], function* () {
		for (const t of tuples) if (t[0]) yield t[0];
	}), void 0];
	else return [void 0, tuple$1[1]];
}
/**
* Define a new struct type with a custom validation function.
*/
function define(name, validator) {
	return new Struct$1({
		type: name,
		schema: null,
		validator
	});
}
/**
* Ensure that any value passes validation.
*/
function any() {
	return define("any", () => true);
}
function array(Element) {
	return new Struct$1({
		type: "array",
		schema: Element,
		*entries(value) {
			if (Element && Array.isArray(value)) for (const [i$1, v] of value.entries()) yield [
				i$1,
				v,
				Element
			];
		},
		coercer(value) {
			return Array.isArray(value) ? value.slice() : value;
		},
		validator(value) {
			return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
		}
	});
}
/**
* Ensure that a value is a boolean.
*/
function boolean() {
	return define("boolean", (value) => {
		return typeof value === "boolean";
	});
}
/**
* Ensure that a value is an instance of a specific class.
*/
function instance(Class) {
	return define("instance", (value) => {
		return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
	});
}
function literal(constant) {
	const description = print(constant);
	const t = typeof constant;
	return new Struct$1({
		type: "literal",
		schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
		validator(value) {
			return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
		}
	});
}
/**
* Ensure that no value ever passes validation.
*/
function never() {
	return define("never", () => false);
}
/**
* Augment an existing struct to allow `null` values.
*/
function nullable(struct) {
	return new Struct$1({
		...struct,
		validator: (value, ctx) => value === null || struct.validator(value, ctx),
		refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
	});
}
/**
* Ensure that a value is a number.
*/
function number() {
	return define("number", (value) => {
		return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
	});
}
/**
* Augment a struct to allow `undefined` values.
*/
function optional(struct) {
	return new Struct$1({
		...struct,
		validator: (value, ctx) => value === void 0 || struct.validator(value, ctx),
		refiner: (value, ctx) => value === void 0 || struct.refiner(value, ctx)
	});
}
/**
* Ensure that a value is an object with keys and values of specific types, but
* without ensuring any specific shape of properties.
*
* Like TypeScript's `Record` utility.
*/
function record(Key, Value) {
	return new Struct$1({
		type: "record",
		schema: null,
		*entries(value) {
			if (isObject(value)) for (const k in value) {
				const v = value[k];
				yield [
					k,
					k,
					Key
				];
				yield [
					k,
					v,
					Value
				];
			}
		},
		validator(value) {
			return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
		},
		coercer(value) {
			return isNonArrayObject(value) ? { ...value } : value;
		}
	});
}
/**
* Ensure that a value is a string.
*/
function string() {
	return define("string", (value) => {
		return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
	});
}
/**
* Ensure that a value is a tuple of a specific length, and that each of its
* elements is of a specific type.
*/
function tuple(Structs) {
	const Never = never();
	return new Struct$1({
		type: "tuple",
		schema: null,
		*entries(value) {
			if (Array.isArray(value)) {
				const length = Math.max(Structs.length, value.length);
				for (let i$1 = 0; i$1 < length; i$1++) yield [
					i$1,
					value[i$1],
					Structs[i$1] || Never
				];
			}
		},
		validator(value) {
			return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
		},
		coercer(value) {
			return Array.isArray(value) ? value.slice() : value;
		}
	});
}
/**
* Ensure that a value has a set of known properties of specific types.
*
* Note: Unrecognized properties are allowed and untouched. This is similar to
* how TypeScript's structural typing works.
*/
function type(schema) {
	const keys = Object.keys(schema);
	return new Struct$1({
		type: "type",
		schema,
		*entries(value) {
			if (isObject(value)) for (const k of keys) yield [
				k,
				value[k],
				schema[k]
			];
		},
		validator(value) {
			return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
		},
		coercer(value) {
			return isNonArrayObject(value) ? { ...value } : value;
		}
	});
}
/**
* Ensure that a value matches one of a set of types.
*/
function union(Structs) {
	const description = Structs.map((s) => s.type).join(" | ");
	return new Struct$1({
		type: "union",
		schema: null,
		coercer(value, ctx) {
			for (const S of Structs) {
				const [error, coerced] = S.validate(value, {
					coerce: true,
					mask: ctx.mask
				});
				if (!error) return coerced;
			}
			return value;
		},
		validator(value, ctx) {
			const failures = [];
			for (const S of Structs) {
				const [ ...tuples] = run(value, S, ctx);
				const [first] = tuples;
				if (!first[0]) return [];
				else for (const [failure] of tuples) if (failure) failures.push(failure);
			}
			return [`Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`, ...failures];
		}
	});
}
/**
* Ensure that any value passes validation, without widening its type to `any`.
*/
function unknown() {
	return define("unknown", () => true);
}
/**
* Augment a `Struct` to add an additional coercion step to its input.
*
* This allows you to transform input data before validating it, to increase the
* likelihood that it passes validation‚Äîfor example for default values, parsing
* different formats, etc.
*
* Note: You must use `create(value, Struct)` on the value to have the coercion
* take effect! Using simply `assert()` or `is()` will not use coercion.
*/
function coerce(struct, condition, coercer) {
	return new Struct$1({
		...struct,
		coercer: (value, ctx) => {
			return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
		}
	});
}
var StructError, Struct$1;
var init_dist = __esm({ "node_modules/superstruct/dist/index.mjs": (() => {
	StructError = class extends TypeError {
		constructor(failure, failures) {
			let cached;
			const { message, explanation, ...rest } = failure;
			const { path } = failure;
			const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
			super(explanation ?? msg);
			if (explanation != null) this.cause = msg;
			Object.assign(this, rest);
			this.name = this.constructor.name;
			this.failures = () => {
				return cached ?? (cached = [failure, ...failures()]);
			};
		}
	};
	Struct$1 = class {
		constructor(props) {
			const { type: type$1, schema, validator, refiner, coercer = (value) => value, entries = function* () {} } = props;
			this.type = type$1;
			this.schema = schema;
			this.entries = entries;
			this.coercer = coercer;
			if (validator) this.validator = (value, context) => {
				return toFailures(validator(value, context), context, this, value);
			};
			else this.validator = () => [];
			if (refiner) this.refiner = (value, context) => {
				return toFailures(refiner(value, context), context, this, value);
			};
			else this.refiner = () => [];
		}
		/**
		* Assert that a value passes the struct's validation, throwing if it doesn't.
		*/
		assert(value, message) {
			return assert(value, this, message);
		}
		/**
		* Create a value with the struct's coercion logic, then validate it.
		*/
		create(value, message) {
			return create(value, this, message);
		}
		/**
		* Check if a value passes the struct's validation.
		*/
		is(value) {
			return is(value, this);
		}
		/**
		* Mask a value, coercing and validating it, but returning only the subset of
		* properties defined by the struct's schema. Masking applies recursively to
		* props of `object` structs only.
		*/
		mask(value, message) {
			return mask(value, this, message);
		}
		/**
		* Validate a value with the struct's validation logic, returning a tuple
		* representing the result.
		*
		* You may optionally pass `true` for the `coerce` argument to coerce
		* the value before attempting to validate it. If you do, the result will
		* contain the coerced result when successful. Also, `mask` will turn on
		* masking of the unknown `object` props recursively if passed.
		*/
		validate(value, options = {}) {
			return validate$1(value, this, options);
		}
	};
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/rng.js
function rng() {
	if (!getRandomValues) {
		getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
		if (!getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
	}
	return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({ "node_modules/uuid/dist/esm-browser/rng.js": (() => {
	;
	rnds8 = new Uint8Array(16);
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({ "node_modules/uuid/dist/esm-browser/regex.js": (() => {
	regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid$2) {
	return typeof uuid$2 === "string" && regex_default.test(uuid$2);
}
var validate_default;
var init_validate = __esm({ "node_modules/uuid/dist/esm-browser/validate.js": (() => {
	init_regex();
	validate_default = validate;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/stringify.js
function stringify(arr) {
	var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	var uuid$2 = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
	if (!validate_default(uuid$2)) throw TypeError("Stringified UUID is invalid");
	return uuid$2;
}
var byteToHex, i, stringify_default;
var init_stringify = __esm({ "node_modules/uuid/dist/esm-browser/stringify.js": (() => {
	init_validate();
	byteToHex = [];
	for (i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).substr(1));
	stringify_default = stringify;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset) {
	var i$1 = buf && offset || 0;
	var b = buf || new Array(16);
	options = options || {};
	var node = options.node || _nodeId;
	var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
	if (node == null || clockseq == null) {
		var seedBytes = options.random || (options.rng || rng)();
		if (node == null) node = _nodeId = [
			seedBytes[0] | 1,
			seedBytes[1],
			seedBytes[2],
			seedBytes[3],
			seedBytes[4],
			seedBytes[5]
		];
		if (clockseq == null) clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
	}
	var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
	var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
	var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
	if (dt < 0 && options.clockseq === void 0) clockseq = clockseq + 1 & 16383;
	if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) nsecs = 0;
	if (nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
	_lastMSecs = msecs;
	_lastNSecs = nsecs;
	_clockseq = clockseq;
	msecs += 0xb1d069b5400;
	var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
	b[i$1++] = tl >>> 24 & 255;
	b[i$1++] = tl >>> 16 & 255;
	b[i$1++] = tl >>> 8 & 255;
	b[i$1++] = tl & 255;
	var tmh = msecs / 4294967296 * 1e4 & 268435455;
	b[i$1++] = tmh >>> 8 & 255;
	b[i$1++] = tmh & 255;
	b[i$1++] = tmh >>> 24 & 15 | 16;
	b[i$1++] = tmh >>> 16 & 255;
	b[i$1++] = clockseq >>> 8 | 128;
	b[i$1++] = clockseq & 255;
	for (var n = 0; n < 6; ++n) b[i$1 + n] = node[n];
	return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({ "node_modules/uuid/dist/esm-browser/v1.js": (() => {
	init_rng();
	init_stringify();
	;
	;
	_lastMSecs = 0;
	_lastNSecs = 0;
	v1_default = v1;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid$2) {
	if (!validate_default(uuid$2)) throw TypeError("Invalid UUID");
	var v;
	var arr = new Uint8Array(16);
	arr[0] = (v = parseInt(uuid$2.slice(0, 8), 16)) >>> 24;
	arr[1] = v >>> 16 & 255;
	arr[2] = v >>> 8 & 255;
	arr[3] = v & 255;
	arr[4] = (v = parseInt(uuid$2.slice(9, 13), 16)) >>> 8;
	arr[5] = v & 255;
	arr[6] = (v = parseInt(uuid$2.slice(14, 18), 16)) >>> 8;
	arr[7] = v & 255;
	arr[8] = (v = parseInt(uuid$2.slice(19, 23), 16)) >>> 8;
	arr[9] = v & 255;
	arr[10] = (v = parseInt(uuid$2.slice(24, 36), 16)) / 1099511627776 & 255;
	arr[11] = v / 4294967296 & 255;
	arr[12] = v >>> 24 & 255;
	arr[13] = v >>> 16 & 255;
	arr[14] = v >>> 8 & 255;
	arr[15] = v & 255;
	return arr;
}
var parse_default;
var init_parse = __esm({ "node_modules/uuid/dist/esm-browser/parse.js": (() => {
	init_validate();
	parse_default = parse;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
	str = unescape(encodeURIComponent(str));
	var bytes = [];
	for (var i$1 = 0; i$1 < str.length; ++i$1) bytes.push(str.charCodeAt(i$1));
	return bytes;
}
function v35_default(name, version$1, hashfunc) {
	function generateUUID(value, namespace, buf, offset) {
		if (typeof value === "string") value = stringToBytes(value);
		if (typeof namespace === "string") namespace = parse_default(namespace);
		if (namespace.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
		var bytes = new Uint8Array(16 + value.length);
		bytes.set(namespace);
		bytes.set(value, namespace.length);
		bytes = hashfunc(bytes);
		bytes[6] = bytes[6] & 15 | version$1;
		bytes[8] = bytes[8] & 63 | 128;
		if (buf) {
			offset = offset || 0;
			for (var i$1 = 0; i$1 < 16; ++i$1) buf[offset + i$1] = bytes[i$1];
			return buf;
		}
		return stringify_default(bytes);
	}
	try {
		generateUUID.name = name;
	} catch (err) {}
	generateUUID.DNS = DNS;
	generateUUID.URL = URL;
	return generateUUID;
}
var DNS, URL;
var init_v35 = __esm({ "node_modules/uuid/dist/esm-browser/v35.js": (() => {
	init_stringify();
	init_parse();
	DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
	URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
	if (typeof bytes === "string") {
		var msg = unescape(encodeURIComponent(bytes));
		bytes = new Uint8Array(msg.length);
		for (var i$1 = 0; i$1 < msg.length; ++i$1) bytes[i$1] = msg.charCodeAt(i$1);
	}
	return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
	var output = [];
	var length32 = input.length * 32;
	var hexTab = "0123456789abcdef";
	for (var i$1 = 0; i$1 < length32; i$1 += 8) {
		var x = input[i$1 >> 5] >>> i$1 % 32 & 255;
		var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
		output.push(hex);
	}
	return output;
}
/**
* Calculate output length with padding and bit length
*/
function getOutputLength(inputLength8) {
	return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
	x[len >> 5] |= 128 << len % 32;
	x[getOutputLength(len) - 1] = len;
	var a = 1732584193;
	var b = -271733879;
	var c = -1732584194;
	var d = 271733878;
	for (var i$1 = 0; i$1 < x.length; i$1 += 16) {
		var olda = a;
		var oldb = b;
		var oldc = c;
		var oldd = d;
		a = md5ff(a, b, c, d, x[i$1], 7, -680876936);
		d = md5ff(d, a, b, c, x[i$1 + 1], 12, -389564586);
		c = md5ff(c, d, a, b, x[i$1 + 2], 17, 606105819);
		b = md5ff(b, c, d, a, x[i$1 + 3], 22, -1044525330);
		a = md5ff(a, b, c, d, x[i$1 + 4], 7, -176418897);
		d = md5ff(d, a, b, c, x[i$1 + 5], 12, 1200080426);
		c = md5ff(c, d, a, b, x[i$1 + 6], 17, -1473231341);
		b = md5ff(b, c, d, a, x[i$1 + 7], 22, -45705983);
		a = md5ff(a, b, c, d, x[i$1 + 8], 7, 1770035416);
		d = md5ff(d, a, b, c, x[i$1 + 9], 12, -1958414417);
		c = md5ff(c, d, a, b, x[i$1 + 10], 17, -42063);
		b = md5ff(b, c, d, a, x[i$1 + 11], 22, -1990404162);
		a = md5ff(a, b, c, d, x[i$1 + 12], 7, 1804603682);
		d = md5ff(d, a, b, c, x[i$1 + 13], 12, -40341101);
		c = md5ff(c, d, a, b, x[i$1 + 14], 17, -1502002290);
		b = md5ff(b, c, d, a, x[i$1 + 15], 22, 1236535329);
		a = md5gg(a, b, c, d, x[i$1 + 1], 5, -165796510);
		d = md5gg(d, a, b, c, x[i$1 + 6], 9, -1069501632);
		c = md5gg(c, d, a, b, x[i$1 + 11], 14, 643717713);
		b = md5gg(b, c, d, a, x[i$1], 20, -373897302);
		a = md5gg(a, b, c, d, x[i$1 + 5], 5, -701558691);
		d = md5gg(d, a, b, c, x[i$1 + 10], 9, 38016083);
		c = md5gg(c, d, a, b, x[i$1 + 15], 14, -660478335);
		b = md5gg(b, c, d, a, x[i$1 + 4], 20, -405537848);
		a = md5gg(a, b, c, d, x[i$1 + 9], 5, 568446438);
		d = md5gg(d, a, b, c, x[i$1 + 14], 9, -1019803690);
		c = md5gg(c, d, a, b, x[i$1 + 3], 14, -187363961);
		b = md5gg(b, c, d, a, x[i$1 + 8], 20, 1163531501);
		a = md5gg(a, b, c, d, x[i$1 + 13], 5, -1444681467);
		d = md5gg(d, a, b, c, x[i$1 + 2], 9, -51403784);
		c = md5gg(c, d, a, b, x[i$1 + 7], 14, 1735328473);
		b = md5gg(b, c, d, a, x[i$1 + 12], 20, -1926607734);
		a = md5hh(a, b, c, d, x[i$1 + 5], 4, -378558);
		d = md5hh(d, a, b, c, x[i$1 + 8], 11, -2022574463);
		c = md5hh(c, d, a, b, x[i$1 + 11], 16, 1839030562);
		b = md5hh(b, c, d, a, x[i$1 + 14], 23, -35309556);
		a = md5hh(a, b, c, d, x[i$1 + 1], 4, -1530992060);
		d = md5hh(d, a, b, c, x[i$1 + 4], 11, 1272893353);
		c = md5hh(c, d, a, b, x[i$1 + 7], 16, -155497632);
		b = md5hh(b, c, d, a, x[i$1 + 10], 23, -1094730640);
		a = md5hh(a, b, c, d, x[i$1 + 13], 4, 681279174);
		d = md5hh(d, a, b, c, x[i$1], 11, -358537222);
		c = md5hh(c, d, a, b, x[i$1 + 3], 16, -722521979);
		b = md5hh(b, c, d, a, x[i$1 + 6], 23, 76029189);
		a = md5hh(a, b, c, d, x[i$1 + 9], 4, -640364487);
		d = md5hh(d, a, b, c, x[i$1 + 12], 11, -421815835);
		c = md5hh(c, d, a, b, x[i$1 + 15], 16, 530742520);
		b = md5hh(b, c, d, a, x[i$1 + 2], 23, -995338651);
		a = md5ii(a, b, c, d, x[i$1], 6, -198630844);
		d = md5ii(d, a, b, c, x[i$1 + 7], 10, 1126891415);
		c = md5ii(c, d, a, b, x[i$1 + 14], 15, -1416354905);
		b = md5ii(b, c, d, a, x[i$1 + 5], 21, -57434055);
		a = md5ii(a, b, c, d, x[i$1 + 12], 6, 1700485571);
		d = md5ii(d, a, b, c, x[i$1 + 3], 10, -1894986606);
		c = md5ii(c, d, a, b, x[i$1 + 10], 15, -1051523);
		b = md5ii(b, c, d, a, x[i$1 + 1], 21, -2054922799);
		a = md5ii(a, b, c, d, x[i$1 + 8], 6, 1873313359);
		d = md5ii(d, a, b, c, x[i$1 + 15], 10, -30611744);
		c = md5ii(c, d, a, b, x[i$1 + 6], 15, -1560198380);
		b = md5ii(b, c, d, a, x[i$1 + 13], 21, 1309151649);
		a = md5ii(a, b, c, d, x[i$1 + 4], 6, -145523070);
		d = md5ii(d, a, b, c, x[i$1 + 11], 10, -1120210379);
		c = md5ii(c, d, a, b, x[i$1 + 2], 15, 718787259);
		b = md5ii(b, c, d, a, x[i$1 + 9], 21, -343485551);
		a = safeAdd(a, olda);
		b = safeAdd(b, oldb);
		c = safeAdd(c, oldc);
		d = safeAdd(d, oldd);
	}
	return [
		a,
		b,
		c,
		d
	];
}
function bytesToWords(input) {
	if (input.length === 0) return [];
	var length8 = input.length * 8;
	var output = new Uint32Array(getOutputLength(length8));
	for (var i$1 = 0; i$1 < length8; i$1 += 8) output[i$1 >> 5] |= (input[i$1 / 8] & 255) << i$1 % 32;
	return output;
}
function safeAdd(x, y) {
	var lsw = (x & 65535) + (y & 65535);
	return (x >> 16) + (y >> 16) + (lsw >> 16) << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
	return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
	return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
	return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
	return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
	return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
	return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default;
var init_md5 = __esm({ "node_modules/uuid/dist/esm-browser/md5.js": (() => {
	md5_default = md5;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({ "node_modules/uuid/dist/esm-browser/v3.js": (() => {
	init_v35();
	init_md5();
	v3 = v35_default("v3", 48, md5_default);
	v3_default = v3;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
	options = options || {};
	var rnds = options.random || (options.rng || rng)();
	rnds[6] = rnds[6] & 15 | 64;
	rnds[8] = rnds[8] & 63 | 128;
	if (buf) {
		offset = offset || 0;
		for (var i$1 = 0; i$1 < 16; ++i$1) buf[offset + i$1] = rnds[i$1];
		return buf;
	}
	return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({ "node_modules/uuid/dist/esm-browser/v4.js": (() => {
	init_rng();
	init_stringify();
	v4_default = v4;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
	switch (s) {
		case 0: return x & y ^ ~x & z;
		case 1: return x ^ y ^ z;
		case 2: return x & y ^ x & z ^ y & z;
		case 3: return x ^ y ^ z;
	}
}
function ROTL(x, n) {
	return x << n | x >>> 32 - n;
}
function sha1(bytes) {
	var K = [
		1518500249,
		1859775393,
		2400959708,
		3395469782
	];
	var H = [
		1732584193,
		4023233417,
		2562383102,
		271733878,
		3285377520
	];
	if (typeof bytes === "string") {
		var msg = unescape(encodeURIComponent(bytes));
		bytes = [];
		for (var i$1 = 0; i$1 < msg.length; ++i$1) bytes.push(msg.charCodeAt(i$1));
	} else if (!Array.isArray(bytes)) bytes = Array.prototype.slice.call(bytes);
	bytes.push(128);
	var l = bytes.length / 4 + 2;
	var N = Math.ceil(l / 16);
	var M = new Array(N);
	for (var _i = 0; _i < N; ++_i) {
		var arr = new Uint32Array(16);
		for (var j = 0; j < 16; ++j) arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
		M[_i] = arr;
	}
	M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
	M[N - 1][14] = Math.floor(M[N - 1][14]);
	M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
	for (var _i2 = 0; _i2 < N; ++_i2) {
		var W = new Uint32Array(80);
		for (var t = 0; t < 16; ++t) W[t] = M[_i2][t];
		for (var _t = 16; _t < 80; ++_t) W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
		var a = H[0];
		var b = H[1];
		var c = H[2];
		var d = H[3];
		var e = H[4];
		for (var _t2 = 0; _t2 < 80; ++_t2) {
			var s = Math.floor(_t2 / 20);
			var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
			e = d;
			d = c;
			c = ROTL(b, 30) >>> 0;
			b = a;
			a = T;
		}
		H[0] = H[0] + a >>> 0;
		H[1] = H[1] + b >>> 0;
		H[2] = H[2] + c >>> 0;
		H[3] = H[3] + d >>> 0;
		H[4] = H[4] + e >>> 0;
	}
	return [
		H[0] >> 24 & 255,
		H[0] >> 16 & 255,
		H[0] >> 8 & 255,
		H[0] & 255,
		H[1] >> 24 & 255,
		H[1] >> 16 & 255,
		H[1] >> 8 & 255,
		H[1] & 255,
		H[2] >> 24 & 255,
		H[2] >> 16 & 255,
		H[2] >> 8 & 255,
		H[2] & 255,
		H[3] >> 24 & 255,
		H[3] >> 16 & 255,
		H[3] >> 8 & 255,
		H[3] & 255,
		H[4] >> 24 & 255,
		H[4] >> 16 & 255,
		H[4] >> 8 & 255,
		H[4] & 255
	];
}
var sha1_default;
var init_sha1 = __esm({ "node_modules/uuid/dist/esm-browser/sha1.js": (() => {
	sha1_default = sha1;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({ "node_modules/uuid/dist/esm-browser/v5.js": (() => {
	init_v35();
	init_sha1();
	v5 = v35_default("v5", 80, sha1_default);
	v5_default = v5;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({ "node_modules/uuid/dist/esm-browser/nil.js": (() => {
	nil_default = "00000000-0000-0000-0000-000000000000";
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/version.js
function version(uuid$2) {
	if (!validate_default(uuid$2)) throw TypeError("Invalid UUID");
	return parseInt(uuid$2.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({ "node_modules/uuid/dist/esm-browser/version.js": (() => {
	init_validate();
	version_default = version;
}) });

//#endregion
//#region node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = /* @__PURE__ */ __export({
	NIL: () => nil_default,
	parse: () => parse_default,
	stringify: () => stringify_default,
	v1: () => v1_default,
	v3: () => v3_default,
	v4: () => v4_default,
	v5: () => v5_default,
	validate: () => validate_default,
	version: () => version_default
});
var init_esm_browser = __esm({ "node_modules/uuid/dist/esm-browser/index.js": (() => {
	init_v1();
	init_v3();
	init_v4();
	init_v5();
	init_nil();
	init_version();
	init_validate();
	init_stringify();
	init_parse();
}) });

//#endregion
//#region node_modules/jayson/lib/generateRequest.js
var require_generateRequest = /* @__PURE__ */ __commonJS({ "node_modules/jayson/lib/generateRequest.js": ((exports, module) => {
	var uuid$1 = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
	/**
	*  Generates a JSON-RPC 1.0 or 2.0 request
	*  @param {String} method Name of method to call
	*  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value
	*  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation
	*  @param {Object} [options]
	*  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)
	*  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
	*  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID
	*  @throws {TypeError} If any of the parameters are invalid
	*  @return {Object} A JSON-RPC 1.0 or 2.0 request
	*  @memberOf Utils
	*/
	var generateRequest$1 = function(method, params, id, options) {
		if (typeof method !== "string") throw new TypeError(method + " must be a string");
		options = options || {};
		const version$1 = typeof options.version === "number" ? options.version : 2;
		if (version$1 !== 1 && version$1 !== 2) throw new TypeError(version$1 + " must be 1 or 2");
		const request = { method };
		if (version$1 === 2) request.jsonrpc = "2.0";
		if (params) {
			if (typeof params !== "object" && !Array.isArray(params)) throw new TypeError(params + " must be an object, array or omitted");
			request.params = params;
		}
		if (typeof id === "undefined") request.id = (typeof options.generator === "function" ? options.generator : function() {
			return uuid$1();
		})(request, options);
		else if (version$1 === 2 && id === null) {
			if (options.notificationIdNull) request.id = null;
		} else request.id = id;
		return request;
	};
	module.exports = generateRequest$1;
}) });

//#endregion
//#region node_modules/jayson/lib/client/browser/index.js
var require_browser = /* @__PURE__ */ __commonJS({ "node_modules/jayson/lib/client/browser/index.js": ((exports, module) => {
	var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
	var generateRequest = require_generateRequest();
	/**
	* Constructor for a Jayson Browser Client that does not depend any node.js core libraries
	* @class ClientBrowser
	* @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback
	* @param {Object} [options]
	* @param {Function} [options.reviver] Reviver function for JSON
	* @param {Function} [options.replacer] Replacer function for JSON
	* @param {Number} [options.version=2] JSON-RPC version to use (1|2)
	* @param {Function} [options.generator] Function to use for generating request IDs
	*  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
	* @return {ClientBrowser}
	*/
	var ClientBrowser = function(callServer, options) {
		if (!(this instanceof ClientBrowser)) return new ClientBrowser(callServer, options);
		if (!options) options = {};
		this.options = {
			reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
			replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
			generator: typeof options.generator !== "undefined" ? options.generator : function() {
				return uuid();
			},
			version: typeof options.version !== "undefined" ? options.version : 2,
			notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
		};
		this.callServer = callServer;
	};
	module.exports = ClientBrowser;
	/**
	*  Creates a request and dispatches it if given a callback.
	*  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String
	*  @param {Array|Object} [params] Parameters for the method
	*  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request
	*  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.
	*  @throws {TypeError} Invalid parameters
	*  @return {Object} JSON-RPC 1.0 or 2.0 compatible request
	*/
	ClientBrowser.prototype.request = function(method, params, id, callback) {
		const self = this;
		let request = null;
		const isBatch = Array.isArray(method) && typeof params === "function";
		if (this.options.version === 1 && isBatch) throw new TypeError("JSON-RPC 1.0 does not support batching");
		if (isBatch || !isBatch && method && typeof method === "object" && typeof params === "function") {
			callback = params;
			request = method;
		} else {
			if (typeof id === "function") {
				callback = id;
				id = void 0;
			}
			const hasCallback = typeof callback === "function";
			try {
				request = generateRequest(method, params, id, {
					generator: this.options.generator,
					version: this.options.version,
					notificationIdNull: this.options.notificationIdNull
				});
			} catch (err) {
				if (hasCallback) return callback(err);
				throw err;
			}
			if (!hasCallback) return request;
		}
		let message;
		try {
			message = JSON.stringify(request, this.options.replacer);
		} catch (err) {
			return callback(err);
		}
		this.callServer(message, function(err, response) {
			self._parseResponse(err, response, callback);
		});
		return request;
	};
	/**
	* Parses a response from a server
	* @param {Object} err Error to pass on that is unrelated to the actual response
	* @param {String} responseText JSON-RPC 1.0 or 2.0 response
	* @param {Function} callback Callback that will receive different arguments depending on the amount of parameters
	* @private
	*/
	ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
		if (err) {
			callback(err);
			return;
		}
		if (!responseText) return callback();
		let response;
		try {
			response = JSON.parse(responseText, this.options.reviver);
		} catch (err$1) {
			return callback(err$1);
		}
		if (callback.length === 3) if (Array.isArray(response)) {
			const isError = function(res) {
				return typeof res.error !== "undefined";
			};
			const isNotError = function(res) {
				return !isError(res);
			};
			return callback(null, response.filter(isError), response.filter(isNotError));
		} else return callback(null, response.error, response.result);
		callback(null, response);
	};
}) });

//#endregion
//#region node_modules/eventemitter3/index.js
var require_eventemitter3 = /* @__PURE__ */ __commonJS({ "node_modules/eventemitter3/index.js": ((exports, module) => {
	var has = Object.prototype.hasOwnProperty, prefix = "~";
	/**
	* Constructor to create a storage for our `EE` objects.
	* An `Events` instance is a plain object whose properties are event names.
	*
	* @constructor
	* @private
	*/
	function Events() {}
	if (Object.create) {
		Events.prototype = Object.create(null);
		if (!new Events().__proto__) prefix = false;
	}
	/**
	* Representation of a single event listener.
	*
	* @param {Function} fn The listener function.
	* @param {*} context The context to invoke the listener with.
	* @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	* @constructor
	* @private
	*/
	function EE(fn, context, once) {
		this.fn = fn;
		this.context = context;
		this.once = once || false;
	}
	/**
	* Add a listener for a given event.
	*
	* @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	* @param {(String|Symbol)} event The event name.
	* @param {Function} fn The listener function.
	* @param {*} context The context to invoke the listener with.
	* @param {Boolean} once Specify if the listener is a one-time listener.
	* @returns {EventEmitter}
	* @private
	*/
	function addListener(emitter, event, fn, context, once) {
		if (typeof fn !== "function") throw new TypeError("The listener must be a function");
		var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
		if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
		else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
		else emitter._events[evt] = [emitter._events[evt], listener];
		return emitter;
	}
	/**
	* Clear event by name.
	*
	* @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	* @param {(String|Symbol)} evt The Event name.
	* @private
	*/
	function clearEvent(emitter, evt) {
		if (--emitter._eventsCount === 0) emitter._events = new Events();
		else delete emitter._events[evt];
	}
	/**
	* Minimal `EventEmitter` interface that is molded against the Node.js
	* `EventEmitter` interface.
	*
	* @constructor
	* @public
	*/
	function EventEmitter$2() {
		this._events = new Events();
		this._eventsCount = 0;
	}
	/**
	* Return an array listing the events for which the emitter has registered
	* listeners.
	*
	* @returns {Array}
	* @public
	*/
	EventEmitter$2.prototype.eventNames = function eventNames() {
		var names = [], events, name;
		if (this._eventsCount === 0) return names;
		for (name in events = this._events) if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
		if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
		return names;
	};
	/**
	* Return the listeners registered for a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @returns {Array} The registered listeners.
	* @public
	*/
	EventEmitter$2.prototype.listeners = function listeners(event) {
		var evt = prefix ? prefix + event : event, handlers = this._events[evt];
		if (!handlers) return [];
		if (handlers.fn) return [handlers.fn];
		for (var i$1 = 0, l = handlers.length, ee = new Array(l); i$1 < l; i$1++) ee[i$1] = handlers[i$1].fn;
		return ee;
	};
	/**
	* Return the number of listeners listening to a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @returns {Number} The number of listeners.
	* @public
	*/
	EventEmitter$2.prototype.listenerCount = function listenerCount(event) {
		var evt = prefix ? prefix + event : event, listeners = this._events[evt];
		if (!listeners) return 0;
		if (listeners.fn) return 1;
		return listeners.length;
	};
	/**
	* Calls each of the listeners registered for a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @returns {Boolean} `true` if the event had listeners, else `false`.
	* @public
	*/
	EventEmitter$2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
		var evt = prefix ? prefix + event : event;
		if (!this._events[evt]) return false;
		var listeners = this._events[evt], len = arguments.length, args, i$1;
		if (listeners.fn) {
			if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
			switch (len) {
				case 1: return listeners.fn.call(listeners.context), true;
				case 2: return listeners.fn.call(listeners.context, a1), true;
				case 3: return listeners.fn.call(listeners.context, a1, a2), true;
				case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
				case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
				case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
			}
			for (i$1 = 1, args = new Array(len - 1); i$1 < len; i$1++) args[i$1 - 1] = arguments[i$1];
			listeners.fn.apply(listeners.context, args);
		} else {
			var length = listeners.length, j;
			for (i$1 = 0; i$1 < length; i$1++) {
				if (listeners[i$1].once) this.removeListener(event, listeners[i$1].fn, void 0, true);
				switch (len) {
					case 1:
						listeners[i$1].fn.call(listeners[i$1].context);
						break;
					case 2:
						listeners[i$1].fn.call(listeners[i$1].context, a1);
						break;
					case 3:
						listeners[i$1].fn.call(listeners[i$1].context, a1, a2);
						break;
					case 4:
						listeners[i$1].fn.call(listeners[i$1].context, a1, a2, a3);
						break;
					default:
						if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j];
						listeners[i$1].fn.apply(listeners[i$1].context, args);
				}
			}
		}
		return true;
	};
	/**
	* Add a listener for a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @param {Function} fn The listener function.
	* @param {*} [context=this] The context to invoke the listener with.
	* @returns {EventEmitter} `this`.
	* @public
	*/
	EventEmitter$2.prototype.on = function on(event, fn, context) {
		return addListener(this, event, fn, context, false);
	};
	/**
	* Add a one-time listener for a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @param {Function} fn The listener function.
	* @param {*} [context=this] The context to invoke the listener with.
	* @returns {EventEmitter} `this`.
	* @public
	*/
	EventEmitter$2.prototype.once = function once(event, fn, context) {
		return addListener(this, event, fn, context, true);
	};
	/**
	* Remove the listeners of a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @param {Function} fn Only remove the listeners that match this function.
	* @param {*} context Only remove the listeners that have this context.
	* @param {Boolean} once Only remove one-time listeners.
	* @returns {EventEmitter} `this`.
	* @public
	*/
	EventEmitter$2.prototype.removeListener = function removeListener(event, fn, context, once) {
		var evt = prefix ? prefix + event : event;
		if (!this._events[evt]) return this;
		if (!fn) {
			clearEvent(this, evt);
			return this;
		}
		var listeners = this._events[evt];
		if (listeners.fn) {
			if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
		} else {
			for (var i$1 = 0, events = [], length = listeners.length; i$1 < length; i$1++) if (listeners[i$1].fn !== fn || once && !listeners[i$1].once || context && listeners[i$1].context !== context) events.push(listeners[i$1]);
			if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
			else clearEvent(this, evt);
		}
		return this;
	};
	/**
	* Remove all listeners, or those of the specified event.
	*
	* @param {(String|Symbol)} [event] The event name.
	* @returns {EventEmitter} `this`.
	* @public
	*/
	EventEmitter$2.prototype.removeAllListeners = function removeAllListeners(event) {
		var evt;
		if (event) {
			evt = prefix ? prefix + event : event;
			if (this._events[evt]) clearEvent(this, evt);
		} else {
			this._events = new Events();
			this._eventsCount = 0;
		}
		return this;
	};
	EventEmitter$2.prototype.off = EventEmitter$2.prototype.removeListener;
	EventEmitter$2.prototype.addListener = EventEmitter$2.prototype.on;
	EventEmitter$2.prefixed = prefix;
	EventEmitter$2.EventEmitter = EventEmitter$2;
	if ("undefined" !== typeof module) module.exports = EventEmitter$2;
}) });

//#endregion
//#region node_modules/eventemitter3/index.mjs
var import_eventemitter3, eventemitter3_default;
var init_eventemitter3 = __esm({ "node_modules/eventemitter3/index.mjs": (() => {
	import_eventemitter3 = /* @__PURE__ */ __toESM(require_eventemitter3(), 1);
	eventemitter3_default = import_eventemitter3.default;
}) });

//#endregion
//#region node_modules/rpc-websockets/dist/index.browser.mjs
function WebSocket(address, options) {
	return new WebSocketBrowserImpl(address, options);
}
var import_buffer$1, WebSocketBrowserImpl, DefaultDataPack, CommonClient;
var init_index_browser = __esm({ "node_modules/rpc-websockets/dist/index.browser.mjs": (() => {
	import_buffer$1 = require_buffer();
	init_eventemitter3();
	WebSocketBrowserImpl = class extends import_eventemitter3.default {
		socket;
		/** Instantiate a WebSocket class
		* @constructor
		* @param {String} address - url to a websocket server
		* @param {WebSocketBrowserOptions} options - websocket options
		* @return {WebSocketBrowserImpl} - returns a WebSocket instance
		*/
		constructor(address, options) {
			super();
			this.socket = new window.WebSocket(address, options.protocols);
			this.socket.onopen = () => this.emit("open");
			this.socket.onmessage = (event) => this.emit("message", event.data);
			this.socket.onerror = (error) => this.emit("error", error);
			this.socket.onclose = (event) => {
				this.emit("close", event.code, event.reason);
			};
		}
		/**
		* Sends data through a websocket connection
		* @method
		* @param {(String|Object)} data - data to be sent via websocket
		* @param {Object} optionsOrCallback - ws options
		* @param {Function} callback - a callback called once the data is sent
		* @return {Undefined}
		*/
		send(data, optionsOrCallback, callback) {
			const cb = callback || optionsOrCallback;
			try {
				this.socket.send(data);
				cb();
			} catch (error) {
				cb(error);
			}
		}
		/**
		* Closes an underlying socket
		* @method
		* @param {Number} code - status code explaining why the connection is being closed
		* @param {String} reason - a description why the connection is closing
		* @return {Undefined}
		* @throws {Error}
		*/
		close(code, reason) {
			this.socket.close(code, reason);
		}
		addEventListener(type$1, listener, options) {
			this.socket.addEventListener(type$1, listener, options);
		}
	};
	DefaultDataPack = class {
		encode(value) {
			return JSON.stringify(value);
		}
		decode(value) {
			return JSON.parse(value);
		}
	};
	CommonClient = class extends import_eventemitter3.default {
		address;
		rpc_id;
		queue;
		options;
		autoconnect;
		ready;
		reconnect;
		reconnect_timer_id;
		reconnect_interval;
		max_reconnects;
		rest_options;
		current_reconnects;
		generate_request_id;
		socket;
		webSocketFactory;
		dataPack;
		/**
		* Instantiate a Client class.
		* @constructor
		* @param {webSocketFactory} webSocketFactory - factory method for WebSocket
		* @param {String} address - url to a websocket server
		* @param {Object} options - ws options object with reconnect parameters
		* @param {Function} generate_request_id - custom generation request Id
		* @param {DataPack} dataPack - data pack contains encoder and decoder
		* @return {CommonClient}
		*/
		constructor(webSocketFactory, address = "ws://localhost:8080", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id, dataPack) {
			super();
			this.webSocketFactory = webSocketFactory;
			this.queue = {};
			this.rpc_id = 0;
			this.address = address;
			this.autoconnect = autoconnect;
			this.ready = false;
			this.reconnect = reconnect;
			this.reconnect_timer_id = void 0;
			this.reconnect_interval = reconnect_interval;
			this.max_reconnects = max_reconnects;
			this.rest_options = rest_options;
			this.current_reconnects = 0;
			this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === "number" ? ++this.rpc_id : Number(this.rpc_id) + 1);
			if (!dataPack) this.dataPack = new DefaultDataPack();
			else this.dataPack = dataPack;
			if (this.autoconnect) this._connect(this.address, {
				autoconnect: this.autoconnect,
				reconnect: this.reconnect,
				reconnect_interval: this.reconnect_interval,
				max_reconnects: this.max_reconnects,
				...this.rest_options
			});
		}
		/**
		* Connects to a defined server if not connected already.
		* @method
		* @return {Undefined}
		*/
		connect() {
			if (this.socket) return;
			this._connect(this.address, {
				autoconnect: this.autoconnect,
				reconnect: this.reconnect,
				reconnect_interval: this.reconnect_interval,
				max_reconnects: this.max_reconnects,
				...this.rest_options
			});
		}
		/**
		* Calls a registered RPC method on server.
		* @method
		* @param {String} method - RPC method name
		* @param {Object|Array} params - optional method parameters
		* @param {Number} timeout - RPC reply timeout value
		* @param {Object} ws_opts - options passed to ws
		* @return {Promise}
		*/
		call(method, params, timeout, ws_opts) {
			if (!ws_opts && "object" === typeof timeout) {
				ws_opts = timeout;
				timeout = null;
			}
			return new Promise((resolve, reject) => {
				if (!this.ready) return reject(/* @__PURE__ */ new Error("socket not ready"));
				const rpc_id = this.generate_request_id(method, params);
				const message = {
					jsonrpc: "2.0",
					method,
					params: params || void 0,
					id: rpc_id
				};
				this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {
					if (error) return reject(error);
					this.queue[rpc_id] = { promise: [resolve, reject] };
					if (timeout) this.queue[rpc_id].timeout = setTimeout(() => {
						delete this.queue[rpc_id];
						reject(/* @__PURE__ */ new Error("reply timeout"));
					}, timeout);
				});
			});
		}
		/**
		* Logins with the other side of the connection.
		* @method
		* @param {Object} params - Login credentials object
		* @return {Promise}
		*/
		async login(params) {
			const resp = await this.call("rpc.login", params);
			if (!resp) throw new Error("authentication failed");
			return resp;
		}
		/**
		* Fetches a list of client's methods registered on server.
		* @method
		* @return {Array}
		*/
		async listMethods() {
			return await this.call("__listMethods");
		}
		/**
		* Sends a JSON-RPC 2.0 notification to server.
		* @method
		* @param {String} method - RPC method name
		* @param {Object} params - optional method parameters
		* @return {Promise}
		*/
		notify(method, params) {
			return new Promise((resolve, reject) => {
				if (!this.ready) return reject(/* @__PURE__ */ new Error("socket not ready"));
				const message = {
					jsonrpc: "2.0",
					method,
					params
				};
				this.socket.send(this.dataPack.encode(message), (error) => {
					if (error) return reject(error);
					resolve();
				});
			});
		}
		/**
		* Subscribes for a defined event.
		* @method
		* @param {String|Array} event - event name
		* @return {Undefined}
		* @throws {Error}
		*/
		async subscribe(event) {
			if (typeof event === "string") event = [event];
			const result = await this.call("rpc.on", event);
			if (typeof event === "string" && result[event] !== "ok") throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
			return result;
		}
		/**
		* Unsubscribes from a defined event.
		* @method
		* @param {String|Array} event - event name
		* @return {Undefined}
		* @throws {Error}
		*/
		async unsubscribe(event) {
			if (typeof event === "string") event = [event];
			const result = await this.call("rpc.off", event);
			if (typeof event === "string" && result[event] !== "ok") throw new Error("Failed unsubscribing from an event with: " + result);
			return result;
		}
		/**
		* Closes a WebSocket connection gracefully.
		* @method
		* @param {Number} code - socket close code
		* @param {String} data - optional data to be sent before closing
		* @return {Undefined}
		*/
		close(code, data) {
			if (this.socket) this.socket.close(code || 1e3, data);
		}
		/**
		* Enable / disable automatic reconnection.
		* @method
		* @param {Boolean} reconnect - enable / disable reconnection
		* @return {Undefined}
		*/
		setAutoReconnect(reconnect) {
			this.reconnect = reconnect;
		}
		/**
		* Set the interval between reconnection attempts.
		* @method
		* @param {Number} interval - reconnection interval in milliseconds
		* @return {Undefined}
		*/
		setReconnectInterval(interval) {
			this.reconnect_interval = interval;
		}
		/**
		* Set the maximum number of reconnection attempts.
		* @method
		* @param {Number} max_reconnects - maximum reconnection attempts
		* @return {Undefined}
		*/
		setMaxReconnects(max_reconnects) {
			this.max_reconnects = max_reconnects;
		}
		/**
		* Get the current number of reconnection attempts made.
		* @method
		* @return {Number} current reconnection attempts
		*/
		getCurrentReconnects() {
			return this.current_reconnects;
		}
		/**
		* Get the maximum number of reconnection attempts.
		* @method
		* @return {Number} maximum reconnection attempts
		*/
		getMaxReconnects() {
			return this.max_reconnects;
		}
		/**
		* Check if the client is currently attempting to reconnect.
		* @method
		* @return {Boolean} true if reconnection is in progress
		*/
		isReconnecting() {
			return this.reconnect_timer_id !== void 0;
		}
		/**
		* Check if the client will attempt to reconnect on the next close event.
		* @method
		* @return {Boolean} true if reconnection will be attempted
		*/
		willReconnect() {
			return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);
		}
		/**
		* Connection/Message handler.
		* @method
		* @private
		* @param {String} address - WebSocket API address
		* @param {Object} options - ws options object
		* @return {Undefined}
		*/
		_connect(address, options) {
			clearTimeout(this.reconnect_timer_id);
			this.socket = this.webSocketFactory(address, options);
			this.socket.addEventListener("open", () => {
				this.ready = true;
				this.emit("open");
				this.current_reconnects = 0;
			});
			this.socket.addEventListener("message", ({ data: message }) => {
				if (message instanceof ArrayBuffer) message = import_buffer$1.Buffer.from(message).toString();
				try {
					message = this.dataPack.decode(message);
				} catch (error) {
					return;
				}
				if (message.notification && this.listeners(message.notification).length) {
					if (!Object.keys(message.params).length) return this.emit(message.notification);
					const args = [message.notification];
					if (message.params.constructor === Object) args.push(message.params);
					else for (let i$1 = 0; i$1 < message.params.length; i$1++) args.push(message.params[i$1]);
					return Promise.resolve().then(() => {
						this.emit.apply(this, args);
					});
				}
				if (!this.queue[message.id]) {
					if (message.method) return Promise.resolve().then(() => {
						this.emit(message.method, message?.params);
					});
					return;
				}
				if ("error" in message === "result" in message) this.queue[message.id].promise[1](/* @__PURE__ */ new Error("Server response malformed. Response must include either \"result\" or \"error\", but not both."));
				if (this.queue[message.id].timeout) clearTimeout(this.queue[message.id].timeout);
				if (message.error) this.queue[message.id].promise[1](message.error);
				else this.queue[message.id].promise[0](message.result);
				delete this.queue[message.id];
			});
			this.socket.addEventListener("error", (error) => this.emit("error", error));
			this.socket.addEventListener("close", ({ code, reason }) => {
				if (this.ready) setTimeout(() => this.emit("close", code, reason), 0);
				this.ready = false;
				this.socket = void 0;
				if (code === 1e3) return;
				this.current_reconnects++;
				if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0)) this.reconnect_timer_id = setTimeout(() => this._connect(address, options), this.reconnect_interval);
				else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) setTimeout(() => this.emit("max_reconnects_reached", code, reason), 1);
			});
		}
	};
}) });

//#endregion
//#region node_modules/@noble/hashes/esm/sha3.js
/** `keccakf1600` internal function, additionally allows to adjust round count. */
function keccakP(s, rounds = 24) {
	const B = new Uint32Array(10);
	for (let round = 24 - rounds; round < 24; round++) {
		for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
		for (let x = 0; x < 10; x += 2) {
			const idx1 = (x + 8) % 10;
			const idx0 = (x + 2) % 10;
			const B0 = B[idx0];
			const B1 = B[idx0 + 1];
			const Th = rotlH(B0, B1, 1) ^ B[idx1];
			const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
			for (let y = 0; y < 50; y += 10) {
				s[x + y] ^= Th;
				s[x + y + 1] ^= Tl;
			}
		}
		let curH = s[2];
		let curL = s[3];
		for (let t = 0; t < 24; t++) {
			const shift = SHA3_ROTL[t];
			const Th = rotlH(curH, curL, shift);
			const Tl = rotlL(curH, curL, shift);
			const PI = SHA3_PI[t];
			curH = s[PI];
			curL = s[PI + 1];
			s[PI] = Th;
			s[PI + 1] = Tl;
		}
		for (let y = 0; y < 50; y += 10) {
			for (let x = 0; x < 10; x++) B[x] = s[y + x];
			for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
		}
		s[0] ^= SHA3_IOTA_H[round];
		s[1] ^= SHA3_IOTA_L[round];
	}
	clean(B);
}
var _0n$1, _1n$1, _2n$2, _7n, _256n, _0x71n, SHA3_PI, SHA3_ROTL, _SHA3_IOTA, IOTAS, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, keccak_256;
var init_sha3 = __esm({ "node_modules/@noble/hashes/esm/sha3.js": (() => {
	init__u64();
	init_utils$1();
	_0n$1 = BigInt(0);
	_1n$1 = BigInt(1);
	_2n$2 = BigInt(2);
	_7n = BigInt(7);
	_256n = BigInt(256);
	_0x71n = BigInt(113);
	SHA3_PI = [];
	SHA3_ROTL = [];
	_SHA3_IOTA = [];
	for (let round = 0, R = _1n$1, x = 1, y = 0; round < 24; round++) {
		[x, y] = [y, (2 * x + 3 * y) % 5];
		SHA3_PI.push(2 * (5 * y + x));
		SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
		let t = _0n$1;
		for (let j = 0; j < 7; j++) {
			R = (R << _1n$1 ^ (R >> _7n) * _0x71n) % _256n;
			if (R & _2n$2) t ^= _1n$1 << (_1n$1 << /* @__PURE__ */ BigInt(j)) - _1n$1;
		}
		_SHA3_IOTA.push(t);
	}
	IOTAS = split(_SHA3_IOTA, true);
	SHA3_IOTA_H = IOTAS[0];
	SHA3_IOTA_L = IOTAS[1];
	rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
	rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
	Keccak = class Keccak extends Hash {
		constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
			super();
			this.pos = 0;
			this.posOut = 0;
			this.finished = false;
			this.destroyed = false;
			this.enableXOF = false;
			this.blockLen = blockLen;
			this.suffix = suffix;
			this.outputLen = outputLen;
			this.enableXOF = enableXOF;
			this.rounds = rounds;
			anumber(outputLen);
			if (!(0 < blockLen && blockLen < 200)) throw new Error("only keccak-f1600 function is supported");
			this.state = new Uint8Array(200);
			this.state32 = u32(this.state);
		}
		clone() {
			return this._cloneInto();
		}
		keccak() {
			swap32IfBE(this.state32);
			keccakP(this.state32, this.rounds);
			swap32IfBE(this.state32);
			this.posOut = 0;
			this.pos = 0;
		}
		update(data) {
			aexists(this);
			data = toBytes(data);
			abytes(data);
			const { blockLen, state } = this;
			const len = data.length;
			for (let pos = 0; pos < len;) {
				const take = Math.min(blockLen - this.pos, len - pos);
				for (let i$1 = 0; i$1 < take; i$1++) state[this.pos++] ^= data[pos++];
				if (this.pos === blockLen) this.keccak();
			}
			return this;
		}
		finish() {
			if (this.finished) return;
			this.finished = true;
			const { state, suffix, pos, blockLen } = this;
			state[pos] ^= suffix;
			if ((suffix & 128) !== 0 && pos === blockLen - 1) this.keccak();
			state[blockLen - 1] ^= 128;
			this.keccak();
		}
		writeInto(out) {
			aexists(this, false);
			abytes(out);
			this.finish();
			const bufferOut = this.state;
			const { blockLen } = this;
			for (let pos = 0, len = out.length; pos < len;) {
				if (this.posOut >= blockLen) this.keccak();
				const take = Math.min(blockLen - this.posOut, len - pos);
				out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
				this.posOut += take;
				pos += take;
			}
			return out;
		}
		xofInto(out) {
			if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
			return this.writeInto(out);
		}
		xof(bytes) {
			anumber(bytes);
			return this.xofInto(new Uint8Array(bytes));
		}
		digestInto(out) {
			aoutput(out, this);
			if (this.finished) throw new Error("digest() was already called");
			this.writeInto(out);
			this.destroy();
			return out;
		}
		digest() {
			return this.digestInto(new Uint8Array(this.outputLen));
		}
		destroy() {
			this.destroyed = true;
			clean(this.state);
		}
		_cloneInto(to) {
			const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
			to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
			to.state32.set(this.state32);
			to.pos = this.pos;
			to.posOut = this.posOut;
			to.finished = this.finished;
			to.rounds = rounds;
			to.suffix = suffix;
			to.outputLen = outputLen;
			to.enableXOF = enableXOF;
			to.destroyed = this.destroyed;
			return to;
		}
	};
	gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));
	keccak_256 = /* @__PURE__ */ (() => gen(1, 136, 256 / 8))();
}) });

//#endregion
//#region node_modules/@noble/hashes/esm/hmac.js
var HMAC, hmac;
var init_hmac = __esm({ "node_modules/@noble/hashes/esm/hmac.js": (() => {
	init_utils$1();
	HMAC = class extends Hash {
		constructor(hash, _key) {
			super();
			this.finished = false;
			this.destroyed = false;
			ahash(hash);
			const key = toBytes(_key);
			this.iHash = hash.create();
			if (typeof this.iHash.update !== "function") throw new Error("Expected instance of class which extends utils.Hash");
			this.blockLen = this.iHash.blockLen;
			this.outputLen = this.iHash.outputLen;
			const blockLen = this.blockLen;
			const pad = new Uint8Array(blockLen);
			pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
			for (let i$1 = 0; i$1 < pad.length; i$1++) pad[i$1] ^= 54;
			this.iHash.update(pad);
			this.oHash = hash.create();
			for (let i$1 = 0; i$1 < pad.length; i$1++) pad[i$1] ^= 106;
			this.oHash.update(pad);
			clean(pad);
		}
		update(buf) {
			aexists(this);
			this.iHash.update(buf);
			return this;
		}
		digestInto(out) {
			aexists(this);
			abytes(out, this.outputLen);
			this.finished = true;
			this.iHash.digestInto(out);
			this.oHash.update(out);
			this.oHash.digestInto(out);
			this.destroy();
		}
		digest() {
			const out = new Uint8Array(this.oHash.outputLen);
			this.digestInto(out);
			return out;
		}
		_cloneInto(to) {
			to || (to = Object.create(Object.getPrototypeOf(this), {}));
			const { oHash, iHash, finished: finished$1, destroyed, blockLen, outputLen } = this;
			to = to;
			to.finished = finished$1;
			to.destroyed = destroyed;
			to.blockLen = blockLen;
			to.outputLen = outputLen;
			to.oHash = oHash._cloneInto(to.oHash);
			to.iHash = iHash._cloneInto(to.iHash);
			return to;
		}
		clone() {
			return this._cloneInto();
		}
		destroy() {
			this.destroyed = true;
			this.oHash.destroy();
			this.iHash.destroy();
		}
	};
	hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
	hmac.create = (hash, key) => new HMAC(hash, key);
}) });

//#endregion
//#region node_modules/@noble/curves/esm/abstract/weierstrass.js
/**
* Splits scalar for GLV endomorphism.
*/
function _splitEndoScalar(k, basis, n) {
	const [[a1, b1], [a2, b2]] = basis;
	const c1 = divNearest(b2 * k, n);
	const c2 = divNearest(-b1 * k, n);
	let k1 = k - c1 * a1 - c2 * a2;
	let k2 = -c1 * b1 - c2 * b2;
	const k1neg = k1 < _0n;
	const k2neg = k2 < _0n;
	if (k1neg) k1 = -k1;
	if (k2neg) k2 = -k2;
	const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n;
	if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) throw new Error("splitScalar (endomorphism): failed, k=" + k);
	return {
		k1neg,
		k1,
		k2neg,
		k2
	};
}
function validateSigFormat(format) {
	if (![
		"compact",
		"recovered",
		"der"
	].includes(format)) throw new Error("Signature format must be \"compact\", \"recovered\", or \"der\"");
	return format;
}
function validateSigOpts(opts, def) {
	const optsn = {};
	for (let optName of Object.keys(def)) optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
	_abool2(optsn.lowS, "lowS");
	_abool2(optsn.prehash, "prehash");
	if (optsn.format !== void 0) validateSigFormat(optsn.format);
	return optsn;
}
function _normFnElement(Fn$1, key) {
	const { BYTES: expected } = Fn$1;
	let num;
	if (typeof key === "bigint") num = key;
	else {
		let bytes = ensureBytes("private key", key);
		try {
			num = Fn$1.fromBytes(bytes);
		} catch (error) {
			throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
		}
	}
	if (!Fn$1.isValidNot0(num)) throw new Error("invalid private key: out of range [1..N-1]");
	return num;
}
/**
* Creates weierstrass Point constructor, based on specified curve options.
*
* @example
```js
const opts = {
p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
h: BigInt(1),
a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
};
const p256_Point = weierstrass(opts);
```
*/
function weierstrassN(params, extraOpts = {}) {
	const validated = _createCurveFields("weierstrass", params, extraOpts);
	const { Fp: Fp$1, Fn: Fn$1 } = validated;
	let CURVE = validated.CURVE;
	const { h: cofactor, n: CURVE_ORDER } = CURVE;
	_validateObject(extraOpts, {}, {
		allowInfinityPoint: "boolean",
		clearCofactor: "function",
		isTorsionFree: "function",
		fromBytes: "function",
		toBytes: "function",
		endo: "object",
		wrapPrivateKey: "boolean"
	});
	const { endo } = extraOpts;
	if (endo) {
		if (!Fp$1.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) throw new Error("invalid endo: expected \"beta\": bigint and \"basises\": array");
	}
	const lengths = getWLengths(Fp$1, Fn$1);
	function assertCompressionIsSupported() {
		if (!Fp$1.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
	}
	function pointToBytes(_c, point, isCompressed) {
		const { x, y } = point.toAffine();
		const bx = Fp$1.toBytes(x);
		_abool2(isCompressed, "isCompressed");
		if (isCompressed) {
			assertCompressionIsSupported();
			return concatBytes(pprefix(!Fp$1.isOdd(y)), bx);
		} else return concatBytes(Uint8Array.of(4), bx, Fp$1.toBytes(y));
	}
	function pointFromBytes(bytes) {
		_abytes2(bytes, void 0, "Point");
		const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
		const length = bytes.length;
		const head = bytes[0];
		const tail = bytes.subarray(1);
		if (length === comp && (head === 2 || head === 3)) {
			const x = Fp$1.fromBytes(tail);
			if (!Fp$1.isValid(x)) throw new Error("bad point: is not on curve, wrong x");
			const y2 = weierstrassEquation(x);
			let y;
			try {
				y = Fp$1.sqrt(y2);
			} catch (sqrtError) {
				const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
				throw new Error("bad point: is not on curve, sqrt error" + err);
			}
			assertCompressionIsSupported();
			const isYOdd = Fp$1.isOdd(y);
			if ((head & 1) === 1 !== isYOdd) y = Fp$1.neg(y);
			return {
				x,
				y
			};
		} else if (length === uncomp && head === 4) {
			const L = Fp$1.BYTES;
			const x = Fp$1.fromBytes(tail.subarray(0, L));
			const y = Fp$1.fromBytes(tail.subarray(L, L * 2));
			if (!isValidXY(x, y)) throw new Error("bad point: is not on curve");
			return {
				x,
				y
			};
		} else throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
	}
	const encodePoint = extraOpts.toBytes || pointToBytes;
	const decodePoint = extraOpts.fromBytes || pointFromBytes;
	function weierstrassEquation(x) {
		const x2 = Fp$1.sqr(x);
		const x3 = Fp$1.mul(x2, x);
		return Fp$1.add(Fp$1.add(x3, Fp$1.mul(x, CURVE.a)), CURVE.b);
	}
	/** Checks whether equation holds for given x, y: y¬≤ == x¬≥ + ax + b */
	function isValidXY(x, y) {
		const left = Fp$1.sqr(y);
		const right = weierstrassEquation(x);
		return Fp$1.eql(left, right);
	}
	if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error("bad curve params: generator point");
	const _4a3 = Fp$1.mul(Fp$1.pow(CURVE.a, _3n), _4n);
	const _27b2 = Fp$1.mul(Fp$1.sqr(CURVE.b), BigInt(27));
	if (Fp$1.is0(Fp$1.add(_4a3, _27b2))) throw new Error("bad curve params: a or b");
	/** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */
	function acoord(title, n, banZero = false) {
		if (!Fp$1.isValid(n) || banZero && Fp$1.is0(n)) throw new Error(`bad point coordinate ${title}`);
		return n;
	}
	function aprjpoint(other) {
		if (!(other instanceof Point)) throw new Error("ProjectivePoint expected");
	}
	function splitEndoScalarN(k) {
		if (!endo || !endo.basises) throw new Error("no endo");
		return _splitEndoScalar(k, endo.basises, Fn$1.ORDER);
	}
	const toAffineMemo = memoized((p, iz) => {
		const { X, Y, Z } = p;
		if (Fp$1.eql(Z, Fp$1.ONE)) return {
			x: X,
			y: Y
		};
		const is0 = p.is0();
		if (iz == null) iz = is0 ? Fp$1.ONE : Fp$1.inv(Z);
		const x = Fp$1.mul(X, iz);
		const y = Fp$1.mul(Y, iz);
		const zz = Fp$1.mul(Z, iz);
		if (is0) return {
			x: Fp$1.ZERO,
			y: Fp$1.ZERO
		};
		if (!Fp$1.eql(zz, Fp$1.ONE)) throw new Error("invZ was invalid");
		return {
			x,
			y
		};
	});
	const assertValidMemo = memoized((p) => {
		if (p.is0()) {
			if (extraOpts.allowInfinityPoint && !Fp$1.is0(p.Y)) return;
			throw new Error("bad point: ZERO");
		}
		const { x, y } = p.toAffine();
		if (!Fp$1.isValid(x) || !Fp$1.isValid(y)) throw new Error("bad point: x or y not field elements");
		if (!isValidXY(x, y)) throw new Error("bad point: equation left != right");
		if (!p.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
		return true;
	});
	function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
		k2p = new Point(Fp$1.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
		k1p = negateCt(k1neg, k1p);
		k2p = negateCt(k2neg, k2p);
		return k1p.add(k2p);
	}
	/**
	* Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ‚àã (x=X/Z, y=Y/Z).
	* Default Point works in 2d / affine coordinates: (x, y).
	* We're doing calculations in projective, because its operations don't require costly inversion.
	*/
	class Point {
		/** Does NOT validate if the point is valid. Use `.assertValidity()`. */
		constructor(X, Y, Z) {
			this.X = acoord("x", X);
			this.Y = acoord("y", Y, true);
			this.Z = acoord("z", Z);
			Object.freeze(this);
		}
		static CURVE() {
			return CURVE;
		}
		/** Does NOT validate if the point is valid. Use `.assertValidity()`. */
		static fromAffine(p) {
			const { x, y } = p || {};
			if (!p || !Fp$1.isValid(x) || !Fp$1.isValid(y)) throw new Error("invalid affine point");
			if (p instanceof Point) throw new Error("projective point not allowed");
			if (Fp$1.is0(x) && Fp$1.is0(y)) return Point.ZERO;
			return new Point(x, y, Fp$1.ONE);
		}
		static fromBytes(bytes) {
			const P = Point.fromAffine(decodePoint(_abytes2(bytes, void 0, "point")));
			P.assertValidity();
			return P;
		}
		static fromHex(hex) {
			return Point.fromBytes(ensureBytes("pointHex", hex));
		}
		get x() {
			return this.toAffine().x;
		}
		get y() {
			return this.toAffine().y;
		}
		/**
		*
		* @param windowSize
		* @param isLazy true will defer table computation until the first multiplication
		* @returns
		*/
		precompute(windowSize = 8, isLazy = true) {
			wnaf.createCache(this, windowSize);
			if (!isLazy) this.multiply(_3n);
			return this;
		}
		/** A point on curve is valid if it conforms to equation. */
		assertValidity() {
			assertValidMemo(this);
		}
		hasEvenY() {
			const { y } = this.toAffine();
			if (!Fp$1.isOdd) throw new Error("Field doesn't support isOdd");
			return !Fp$1.isOdd(y);
		}
		/** Compare one point to another. */
		equals(other) {
			aprjpoint(other);
			const { X: X1, Y: Y1, Z: Z1 } = this;
			const { X: X2, Y: Y2, Z: Z2 } = other;
			const U1 = Fp$1.eql(Fp$1.mul(X1, Z2), Fp$1.mul(X2, Z1));
			const U2 = Fp$1.eql(Fp$1.mul(Y1, Z2), Fp$1.mul(Y2, Z1));
			return U1 && U2;
		}
		/** Flips point to one corresponding to (x, -y) in Affine coordinates. */
		negate() {
			return new Point(this.X, Fp$1.neg(this.Y), this.Z);
		}
		double() {
			const { a, b } = CURVE;
			const b3 = Fp$1.mul(b, _3n);
			const { X: X1, Y: Y1, Z: Z1 } = this;
			let X3 = Fp$1.ZERO, Y3 = Fp$1.ZERO, Z3 = Fp$1.ZERO;
			let t0 = Fp$1.mul(X1, X1);
			let t1 = Fp$1.mul(Y1, Y1);
			let t2 = Fp$1.mul(Z1, Z1);
			let t3 = Fp$1.mul(X1, Y1);
			t3 = Fp$1.add(t3, t3);
			Z3 = Fp$1.mul(X1, Z1);
			Z3 = Fp$1.add(Z3, Z3);
			X3 = Fp$1.mul(a, Z3);
			Y3 = Fp$1.mul(b3, t2);
			Y3 = Fp$1.add(X3, Y3);
			X3 = Fp$1.sub(t1, Y3);
			Y3 = Fp$1.add(t1, Y3);
			Y3 = Fp$1.mul(X3, Y3);
			X3 = Fp$1.mul(t3, X3);
			Z3 = Fp$1.mul(b3, Z3);
			t2 = Fp$1.mul(a, t2);
			t3 = Fp$1.sub(t0, t2);
			t3 = Fp$1.mul(a, t3);
			t3 = Fp$1.add(t3, Z3);
			Z3 = Fp$1.add(t0, t0);
			t0 = Fp$1.add(Z3, t0);
			t0 = Fp$1.add(t0, t2);
			t0 = Fp$1.mul(t0, t3);
			Y3 = Fp$1.add(Y3, t0);
			t2 = Fp$1.mul(Y1, Z1);
			t2 = Fp$1.add(t2, t2);
			t0 = Fp$1.mul(t2, t3);
			X3 = Fp$1.sub(X3, t0);
			Z3 = Fp$1.mul(t2, t1);
			Z3 = Fp$1.add(Z3, Z3);
			Z3 = Fp$1.add(Z3, Z3);
			return new Point(X3, Y3, Z3);
		}
		add(other) {
			aprjpoint(other);
			const { X: X1, Y: Y1, Z: Z1 } = this;
			const { X: X2, Y: Y2, Z: Z2 } = other;
			let X3 = Fp$1.ZERO, Y3 = Fp$1.ZERO, Z3 = Fp$1.ZERO;
			const a = CURVE.a;
			const b3 = Fp$1.mul(CURVE.b, _3n);
			let t0 = Fp$1.mul(X1, X2);
			let t1 = Fp$1.mul(Y1, Y2);
			let t2 = Fp$1.mul(Z1, Z2);
			let t3 = Fp$1.add(X1, Y1);
			let t4 = Fp$1.add(X2, Y2);
			t3 = Fp$1.mul(t3, t4);
			t4 = Fp$1.add(t0, t1);
			t3 = Fp$1.sub(t3, t4);
			t4 = Fp$1.add(X1, Z1);
			let t5 = Fp$1.add(X2, Z2);
			t4 = Fp$1.mul(t4, t5);
			t5 = Fp$1.add(t0, t2);
			t4 = Fp$1.sub(t4, t5);
			t5 = Fp$1.add(Y1, Z1);
			X3 = Fp$1.add(Y2, Z2);
			t5 = Fp$1.mul(t5, X3);
			X3 = Fp$1.add(t1, t2);
			t5 = Fp$1.sub(t5, X3);
			Z3 = Fp$1.mul(a, t4);
			X3 = Fp$1.mul(b3, t2);
			Z3 = Fp$1.add(X3, Z3);
			X3 = Fp$1.sub(t1, Z3);
			Z3 = Fp$1.add(t1, Z3);
			Y3 = Fp$1.mul(X3, Z3);
			t1 = Fp$1.add(t0, t0);
			t1 = Fp$1.add(t1, t0);
			t2 = Fp$1.mul(a, t2);
			t4 = Fp$1.mul(b3, t4);
			t1 = Fp$1.add(t1, t2);
			t2 = Fp$1.sub(t0, t2);
			t2 = Fp$1.mul(a, t2);
			t4 = Fp$1.add(t4, t2);
			t0 = Fp$1.mul(t1, t4);
			Y3 = Fp$1.add(Y3, t0);
			t0 = Fp$1.mul(t5, t4);
			X3 = Fp$1.mul(t3, X3);
			X3 = Fp$1.sub(X3, t0);
			t0 = Fp$1.mul(t3, t1);
			Z3 = Fp$1.mul(t5, Z3);
			Z3 = Fp$1.add(Z3, t0);
			return new Point(X3, Y3, Z3);
		}
		subtract(other) {
			return this.add(other.negate());
		}
		is0() {
			return this.equals(Point.ZERO);
		}
		/**
		* Constant time multiplication.
		* Uses wNAF method. Windowed method may be 10% faster,
		* but takes 2x longer to generate and consumes 2x memory.
		* Uses precomputes when available.
		* Uses endomorphism for Koblitz curves.
		* @param scalar by which the point would be multiplied
		* @returns New point
		*/
		multiply(scalar) {
			const { endo: endo$1 } = extraOpts;
			if (!Fn$1.isValidNot0(scalar)) throw new Error("invalid scalar: out of range");
			let point, fake;
			const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));
			/** See docs for {@link EndomorphismOpts} */
			if (endo$1) {
				const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
				const { p: k1p, f: k1f } = mul(k1);
				const { p: k2p, f: k2f } = mul(k2);
				fake = k1f.add(k2f);
				point = finishEndo(endo$1.beta, k1p, k2p, k1neg, k2neg);
			} else {
				const { p, f: f$1 } = mul(scalar);
				point = p;
				fake = f$1;
			}
			return normalizeZ(Point, [point, fake])[0];
		}
		/**
		* Non-constant-time multiplication. Uses double-and-add algorithm.
		* It's faster, but should only be used when you don't care about
		* an exposed secret key e.g. sig verification, which works over *public* keys.
		*/
		multiplyUnsafe(sc) {
			const { endo: endo$1 } = extraOpts;
			const p = this;
			if (!Fn$1.isValid(sc)) throw new Error("invalid scalar: out of range");
			if (sc === _0n || p.is0()) return Point.ZERO;
			if (sc === _1n) return p;
			if (wnaf.hasCache(this)) return this.multiply(sc);
			if (endo$1) {
				const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
				const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2);
				return finishEndo(endo$1.beta, p1, p2, k1neg, k2neg);
			} else return wnaf.unsafe(p, sc);
		}
		multiplyAndAddUnsafe(Q, a, b) {
			const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
			return sum.is0() ? void 0 : sum;
		}
		/**
		* Converts Projective point to affine (x, y) coordinates.
		* @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
		*/
		toAffine(invertedZ) {
			return toAffineMemo(this, invertedZ);
		}
		/**
		* Checks whether Point is free of torsion elements (is in prime subgroup).
		* Always torsion-free for cofactor=1 curves.
		*/
		isTorsionFree() {
			const { isTorsionFree } = extraOpts;
			if (cofactor === _1n) return true;
			if (isTorsionFree) return isTorsionFree(Point, this);
			return wnaf.unsafe(this, CURVE_ORDER).is0();
		}
		clearCofactor() {
			const { clearCofactor } = extraOpts;
			if (cofactor === _1n) return this;
			if (clearCofactor) return clearCofactor(Point, this);
			return this.multiplyUnsafe(cofactor);
		}
		isSmallOrder() {
			return this.multiplyUnsafe(cofactor).is0();
		}
		toBytes(isCompressed = true) {
			_abool2(isCompressed, "isCompressed");
			this.assertValidity();
			return encodePoint(Point, this, isCompressed);
		}
		toHex(isCompressed = true) {
			return bytesToHex(this.toBytes(isCompressed));
		}
		toString() {
			return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
		}
		get px() {
			return this.X;
		}
		get py() {
			return this.X;
		}
		get pz() {
			return this.Z;
		}
		toRawBytes(isCompressed = true) {
			return this.toBytes(isCompressed);
		}
		_setWindowSize(windowSize) {
			this.precompute(windowSize);
		}
		static normalizeZ(points) {
			return normalizeZ(Point, points);
		}
		static msm(points, scalars) {
			return pippenger(Point, Fn$1, points, scalars);
		}
		static fromPrivateKey(privateKey) {
			return Point.BASE.multiply(_normFnElement(Fn$1, privateKey));
		}
	}
	Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp$1.ONE);
	Point.ZERO = new Point(Fp$1.ZERO, Fp$1.ONE, Fp$1.ZERO);
	Point.Fp = Fp$1;
	Point.Fn = Fn$1;
	const bits = Fn$1.BITS;
	const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
	Point.BASE.precompute(8);
	return Point;
}
function pprefix(hasEvenY) {
	return Uint8Array.of(hasEvenY ? 2 : 3);
}
function getWLengths(Fp$1, Fn$1) {
	return {
		secretKey: Fn$1.BYTES,
		publicKey: 1 + Fp$1.BYTES,
		publicKeyUncompressed: 1 + 2 * Fp$1.BYTES,
		publicKeyHasPrefix: true,
		signature: 2 * Fn$1.BYTES
	};
}
/**
* Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.
* This helper ensures no signature functionality is present. Less code, smaller bundle size.
*/
function ecdh(Point, ecdhOpts = {}) {
	const { Fn: Fn$1 } = Point;
	const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
	const lengths = Object.assign(getWLengths(Point.Fp, Fn$1), { seed: getMinHashLength(Fn$1.ORDER) });
	function isValidSecretKey(secretKey) {
		try {
			return !!_normFnElement(Fn$1, secretKey);
		} catch (error) {
			return false;
		}
	}
	function isValidPublicKey(publicKey$1, isCompressed) {
		const { publicKey: comp, publicKeyUncompressed } = lengths;
		try {
			const l = publicKey$1.length;
			if (isCompressed === true && l !== comp) return false;
			if (isCompressed === false && l !== publicKeyUncompressed) return false;
			return !!Point.fromBytes(publicKey$1);
		} catch (error) {
			return false;
		}
	}
	/**
	* Produces cryptographically secure secret key from random of size
	* (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
	*/
	function randomSecretKey(seed = randomBytes_(lengths.seed)) {
		return mapHashToField(_abytes2(seed, lengths.seed, "seed"), Fn$1.ORDER);
	}
	/**
	* Computes public key for a secret key. Checks for validity of the secret key.
	* @param isCompressed whether to return compact (default), or full key
	* @returns Public key, full when isCompressed=false; short when isCompressed=true
	*/
	function getPublicKey$1(secretKey, isCompressed = true) {
		return Point.BASE.multiply(_normFnElement(Fn$1, secretKey)).toBytes(isCompressed);
	}
	function keygen(seed) {
		const secretKey = randomSecretKey(seed);
		return {
			secretKey,
			publicKey: getPublicKey$1(secretKey)
		};
	}
	/**
	* Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
	*/
	function isProbPub(item) {
		if (typeof item === "bigint") return false;
		if (item instanceof Point) return true;
		const { secretKey, publicKey: publicKey$1, publicKeyUncompressed } = lengths;
		if (Fn$1.allowedLengths || secretKey === publicKey$1) return void 0;
		const l = ensureBytes("key", item).length;
		return l === publicKey$1 || l === publicKeyUncompressed;
	}
	/**
	* ECDH (Elliptic Curve Diffie Hellman).
	* Computes shared public key from secret key A and public key B.
	* Checks: 1) secret key validity 2) shared key is on-curve.
	* Does NOT hash the result.
	* @param isCompressed whether to return compact (default), or full key
	* @returns shared public key
	*/
	function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
		if (isProbPub(secretKeyA) === true) throw new Error("first arg must be private key");
		if (isProbPub(publicKeyB) === false) throw new Error("second arg must be public key");
		const s = _normFnElement(Fn$1, secretKeyA);
		return Point.fromHex(publicKeyB).multiply(s).toBytes(isCompressed);
	}
	const utils = {
		isValidSecretKey,
		isValidPublicKey,
		randomSecretKey,
		isValidPrivateKey: isValidSecretKey,
		randomPrivateKey: randomSecretKey,
		normPrivateKeyToScalar: (key) => _normFnElement(Fn$1, key),
		precompute(windowSize = 8, point = Point.BASE) {
			return point.precompute(windowSize, false);
		}
	};
	return Object.freeze({
		getPublicKey: getPublicKey$1,
		getSharedSecret,
		keygen,
		Point,
		utils,
		lengths
	});
}
/**
* Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.
* We need `hash` for 2 features:
* 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`
* 2. k generation in `sign`, using HMAC-drbg(hash)
*
* ECDSAOpts are only rarely needed.
*
* @example
* ```js
* const p256_Point = weierstrass(...);
* const p256_sha256 = ecdsa(p256_Point, sha256);
* const p256_sha224 = ecdsa(p256_Point, sha224);
* const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });
* ```
*/
function ecdsa(Point, hash, ecdsaOpts = {}) {
	ahash(hash);
	_validateObject(ecdsaOpts, {}, {
		hmac: "function",
		lowS: "boolean",
		randomBytes: "function",
		bits2int: "function",
		bits2int_modN: "function"
	});
	const randomBytes$1 = ecdsaOpts.randomBytes || randomBytes;
	const hmac$1 = ecdsaOpts.hmac || ((key, ...msgs) => hmac(hash, key, concatBytes(...msgs)));
	const { Fp: Fp$1, Fn: Fn$1 } = Point;
	const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn$1;
	const { keygen, getPublicKey: getPublicKey$1, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
	const defaultSigOpts = {
		prehash: false,
		lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
		format: void 0,
		extraEntropy: false
	};
	const defaultSigOpts_format = "compact";
	function isBiggerThanHalfOrder(number$1) {
		return number$1 > CURVE_ORDER >> _1n;
	}
	function validateRS(title, num) {
		if (!Fn$1.isValidNot0(num)) throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
		return num;
	}
	function validateSigLength(bytes, format) {
		validateSigFormat(format);
		const size = lengths.signature;
		return _abytes2(bytes, format === "compact" ? size : format === "recovered" ? size + 1 : void 0, `${format} signature`);
	}
	/**
	* ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.
	*/
	class Signature {
		constructor(r, s, recovery) {
			this.r = validateRS("r", r);
			this.s = validateRS("s", s);
			if (recovery != null) this.recovery = recovery;
			Object.freeze(this);
		}
		static fromBytes(bytes, format = defaultSigOpts_format) {
			validateSigLength(bytes, format);
			let recid;
			if (format === "der") {
				const { r: r$1, s: s$1 } = DER.toSig(_abytes2(bytes));
				return new Signature(r$1, s$1);
			}
			if (format === "recovered") {
				recid = bytes[0];
				format = "compact";
				bytes = bytes.subarray(1);
			}
			const L = Fn$1.BYTES;
			const r = bytes.subarray(0, L);
			const s = bytes.subarray(L, L * 2);
			return new Signature(Fn$1.fromBytes(r), Fn$1.fromBytes(s), recid);
		}
		static fromHex(hex, format) {
			return this.fromBytes(hexToBytes(hex), format);
		}
		addRecoveryBit(recovery) {
			return new Signature(this.r, this.s, recovery);
		}
		recoverPublicKey(messageHash) {
			const FIELD_ORDER = Fp$1.ORDER;
			const { r, s, recovery: rec } = this;
			if (rec == null || ![
				0,
				1,
				2,
				3
			].includes(rec)) throw new Error("recovery id invalid");
			if (CURVE_ORDER * _2n$1 < FIELD_ORDER && rec > 1) throw new Error("recovery id is ambiguous for h>1 curve");
			const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
			if (!Fp$1.isValid(radj)) throw new Error("recovery id 2 or 3 invalid");
			const x = Fp$1.toBytes(radj);
			const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));
			const ir = Fn$1.inv(radj);
			const h = bits2int_modN(ensureBytes("msgHash", messageHash));
			const u1 = Fn$1.create(-h * ir);
			const u2 = Fn$1.create(s * ir);
			const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
			if (Q.is0()) throw new Error("point at infinify");
			Q.assertValidity();
			return Q;
		}
		hasHighS() {
			return isBiggerThanHalfOrder(this.s);
		}
		toBytes(format = defaultSigOpts_format) {
			validateSigFormat(format);
			if (format === "der") return hexToBytes(DER.hexFromSig(this));
			const r = Fn$1.toBytes(this.r);
			const s = Fn$1.toBytes(this.s);
			if (format === "recovered") {
				if (this.recovery == null) throw new Error("recovery bit must be present");
				return concatBytes(Uint8Array.of(this.recovery), r, s);
			}
			return concatBytes(r, s);
		}
		toHex(format) {
			return bytesToHex(this.toBytes(format));
		}
		assertValidity() {}
		static fromCompact(hex) {
			return Signature.fromBytes(ensureBytes("sig", hex), "compact");
		}
		static fromDER(hex) {
			return Signature.fromBytes(ensureBytes("sig", hex), "der");
		}
		normalizeS() {
			return this.hasHighS() ? new Signature(this.r, Fn$1.neg(this.s), this.recovery) : this;
		}
		toDERRawBytes() {
			return this.toBytes("der");
		}
		toDERHex() {
			return bytesToHex(this.toBytes("der"));
		}
		toCompactRawBytes() {
			return this.toBytes("compact");
		}
		toCompactHex() {
			return bytesToHex(this.toBytes("compact"));
		}
	}
	const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
		if (bytes.length > 8192) throw new Error("input is too large");
		const num = bytesToNumberBE(bytes);
		const delta = bytes.length * 8 - fnBits;
		return delta > 0 ? num >> BigInt(delta) : num;
	};
	const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
		return Fn$1.create(bits2int(bytes));
	};
	const ORDER_MASK = bitMask(fnBits);
	/** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */
	function int2octets(num) {
		aInRange("num < 2^" + fnBits, num, _0n, ORDER_MASK);
		return Fn$1.toBytes(num);
	}
	function validateMsgAndHash(message, prehash) {
		_abytes2(message, void 0, "message");
		return prehash ? _abytes2(hash(message), void 0, "prehashed message") : message;
	}
	/**
	* Steps A, D of RFC6979 3.2.
	* Creates RFC6979 seed; converts msg/privKey to numbers.
	* Used only in sign, not in verify.
	*
	* Warning: we cannot assume here that message has same amount of bytes as curve order,
	* this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.
	*/
	function prepSig(message, privateKey, opts) {
		if (["recovered", "canonical"].some((k) => k in opts)) throw new Error("sign() legacy options not supported");
		const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
		message = validateMsgAndHash(message, prehash);
		const h1int = bits2int_modN(message);
		const d = _normFnElement(Fn$1, privateKey);
		const seedArgs = [int2octets(d), int2octets(h1int)];
		if (extraEntropy != null && extraEntropy !== false) {
			const e = extraEntropy === true ? randomBytes$1(lengths.secretKey) : extraEntropy;
			seedArgs.push(ensureBytes("extraEntropy", e));
		}
		const seed = concatBytes(...seedArgs);
		const m = h1int;
		function k2sig(kBytes) {
			const k = bits2int(kBytes);
			if (!Fn$1.isValidNot0(k)) return;
			const ik = Fn$1.inv(k);
			const q = Point.BASE.multiply(k).toAffine();
			const r = Fn$1.create(q.x);
			if (r === _0n) return;
			const s = Fn$1.create(ik * Fn$1.create(m + r * d));
			if (s === _0n) return;
			let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
			let normS = s;
			if (lowS && isBiggerThanHalfOrder(s)) {
				normS = Fn$1.neg(s);
				recovery ^= 1;
			}
			return new Signature(r, normS, recovery);
		}
		return {
			seed,
			k2sig
		};
	}
	/**
	* Signs message hash with a secret key.
	*
	* ```
	* sign(m, d) where
	*   k = rfc6979_hmac_drbg(m, d)
	*   (x, y) = G √ó k
	*   r = x mod n
	*   s = (m + dr) / k mod n
	* ```
	*/
	function sign$1(message, secretKey, opts = {}) {
		message = ensureBytes("message", message);
		const { seed, k2sig } = prepSig(message, secretKey, opts);
		return createHmacDrbg(hash.outputLen, Fn$1.BYTES, hmac$1)(seed, k2sig);
	}
	function tryParsingSig(sg) {
		let sig = void 0;
		const isHex = typeof sg === "string" || isBytes(sg);
		const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
		if (!isHex && !isObj) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
		if (isObj) sig = new Signature(sg.r, sg.s);
		else if (isHex) {
			try {
				sig = Signature.fromBytes(ensureBytes("sig", sg), "der");
			} catch (derError) {
				if (!(derError instanceof DER.Err)) throw derError;
			}
			if (!sig) try {
				sig = Signature.fromBytes(ensureBytes("sig", sg), "compact");
			} catch (error) {
				return false;
			}
		}
		if (!sig) return false;
		return sig;
	}
	/**
	* Verifies a signature against message and public key.
	* Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.
	* Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
	*
	* ```
	* verify(r, s, h, P) where
	*   u1 = hs^-1 mod n
	*   u2 = rs^-1 mod n
	*   R = u1‚ãÖG + u2‚ãÖP
	*   mod(R.x, n) == r
	* ```
	*/
	function verify$1(signature$1, message, publicKey$1, opts = {}) {
		const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
		publicKey$1 = ensureBytes("publicKey", publicKey$1);
		message = validateMsgAndHash(ensureBytes("message", message), prehash);
		if ("strict" in opts) throw new Error("options.strict was renamed to lowS");
		const sig = format === void 0 ? tryParsingSig(signature$1) : Signature.fromBytes(ensureBytes("sig", signature$1), format);
		if (sig === false) return false;
		try {
			const P = Point.fromBytes(publicKey$1);
			if (lowS && sig.hasHighS()) return false;
			const { r, s } = sig;
			const h = bits2int_modN(message);
			const is$1 = Fn$1.inv(s);
			const u1 = Fn$1.create(h * is$1);
			const u2 = Fn$1.create(r * is$1);
			const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
			if (R.is0()) return false;
			return Fn$1.create(R.x) === r;
		} catch (e) {
			return false;
		}
	}
	function recoverPublicKey(signature$1, message, opts = {}) {
		const { prehash } = validateSigOpts(opts, defaultSigOpts);
		message = validateMsgAndHash(message, prehash);
		return Signature.fromBytes(signature$1, "recovered").recoverPublicKey(message).toBytes();
	}
	return Object.freeze({
		keygen,
		getPublicKey: getPublicKey$1,
		getSharedSecret,
		utils,
		lengths,
		Point,
		sign: sign$1,
		verify: verify$1,
		recoverPublicKey,
		Signature,
		hash
	});
}
function _weierstrass_legacy_opts_to_new(c) {
	const CURVE = {
		a: c.a,
		b: c.b,
		p: c.Fp.ORDER,
		n: c.n,
		h: c.h,
		Gx: c.Gx,
		Gy: c.Gy
	};
	const Fp$1 = c.Fp;
	let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
	return {
		CURVE,
		curveOpts: {
			Fp: Fp$1,
			Fn: Field(CURVE.n, {
				BITS: c.nBitLength,
				allowedLengths,
				modFromBytes: c.wrapPrivateKey
			}),
			allowInfinityPoint: c.allowInfinityPoint,
			endo: c.endo,
			isTorsionFree: c.isTorsionFree,
			clearCofactor: c.clearCofactor,
			fromBytes: c.fromBytes,
			toBytes: c.toBytes
		}
	};
}
function _ecdsa_legacy_opts_to_new(c) {
	const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
	const ecdsaOpts = {
		hmac: c.hmac,
		randomBytes: c.randomBytes,
		lowS: c.lowS,
		bits2int: c.bits2int,
		bits2int_modN: c.bits2int_modN
	};
	return {
		CURVE,
		curveOpts,
		hash: c.hash,
		ecdsaOpts
	};
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
	const Point = _ecdsa.Point;
	return Object.assign({}, _ecdsa, {
		ProjectivePoint: Point,
		CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS))
	});
}
function weierstrass(c) {
	const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
	return _ecdsa_new_output_to_legacy(c, ecdsa(weierstrassN(CURVE, curveOpts), hash, ecdsaOpts));
}
var divNearest, DERErr, DER, _0n, _1n, _2n$1, _3n, _4n;
var init_weierstrass = __esm({ "node_modules/@noble/curves/esm/abstract/weierstrass.js": (() => {
	init_hmac();
	init_utils$1();
	init_utils();
	init_curve();
	init_modular();
	divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n$1) / den;
	DERErr = class extends Error {
		constructor(m = "") {
			super(m);
		}
	};
	DER = {
		Err: DERErr,
		_tlv: {
			encode: (tag, data) => {
				const { Err: E } = DER;
				if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
				if (data.length & 1) throw new E("tlv.encode: unpadded data");
				const dataLen = data.length / 2;
				const len = numberToHexUnpadded(dataLen);
				if (len.length / 2 & 128) throw new E("tlv.encode: long form length too big");
				const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
				return numberToHexUnpadded(tag) + lenLen + len + data;
			},
			decode(tag, data) {
				const { Err: E } = DER;
				let pos = 0;
				if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
				if (data.length < 2 || data[pos++] !== tag) throw new E("tlv.decode: wrong tlv");
				const first = data[pos++];
				const isLong = !!(first & 128);
				let length = 0;
				if (!isLong) length = first;
				else {
					const lenLen = first & 127;
					if (!lenLen) throw new E("tlv.decode(long): indefinite length not supported");
					if (lenLen > 4) throw new E("tlv.decode(long): byte length is too big");
					const lengthBytes = data.subarray(pos, pos + lenLen);
					if (lengthBytes.length !== lenLen) throw new E("tlv.decode: length bytes not complete");
					if (lengthBytes[0] === 0) throw new E("tlv.decode(long): zero leftmost byte");
					for (const b of lengthBytes) length = length << 8 | b;
					pos += lenLen;
					if (length < 128) throw new E("tlv.decode(long): not minimal encoding");
				}
				const v = data.subarray(pos, pos + length);
				if (v.length !== length) throw new E("tlv.decode: wrong value length");
				return {
					v,
					l: data.subarray(pos + length)
				};
			}
		},
		_int: {
			encode(num) {
				const { Err: E } = DER;
				if (num < _0n) throw new E("integer: negative integers are not allowed");
				let hex = numberToHexUnpadded(num);
				if (Number.parseInt(hex[0], 16) & 8) hex = "00" + hex;
				if (hex.length & 1) throw new E("unexpected DER parsing assertion: unpadded hex");
				return hex;
			},
			decode(data) {
				const { Err: E } = DER;
				if (data[0] & 128) throw new E("invalid signature integer: negative");
				if (data[0] === 0 && !(data[1] & 128)) throw new E("invalid signature integer: unnecessary leading zero");
				return bytesToNumberBE(data);
			}
		},
		toSig(hex) {
			const { Err: E, _int: int, _tlv: tlv } = DER;
			const data = ensureBytes("signature", hex);
			const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
			if (seqLeftBytes.length) throw new E("invalid signature: left bytes after parsing");
			const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
			const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
			if (sLeftBytes.length) throw new E("invalid signature: left bytes after parsing");
			return {
				r: int.decode(rBytes),
				s: int.decode(sBytes)
			};
		},
		hexFromSig(sig) {
			const { _tlv: tlv, _int: int } = DER;
			const seq = tlv.encode(2, int.encode(sig.r)) + tlv.encode(2, int.encode(sig.s));
			return tlv.encode(48, seq);
		}
	};
	_0n = BigInt(0), _1n = BigInt(1), _2n$1 = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
}) });

//#endregion
//#region node_modules/@noble/curves/esm/_shortw_utils.js
/** @deprecated use new `weierstrass()` and `ecdsa()` methods */
function createCurve(curveDef, defHash) {
	const create$1 = (hash) => weierstrass({
		...curveDef,
		hash
	});
	return {
		...create$1(defHash),
		create: create$1
	};
}
var init__shortw_utils = __esm({ "node_modules/@noble/curves/esm/_shortw_utils.js": (() => {
	init_weierstrass();
}) });

//#endregion
//#region node_modules/@noble/curves/esm/secp256k1.js
/**
* ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
* (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
*/
function sqrtMod(y) {
	const P = secp256k1_CURVE.p;
	const _3n$3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
	const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
	const b2 = y * y * y % P;
	const b3 = b2 * b2 * y % P;
	const b11 = pow2(pow2(pow2(b3, _3n$3, P) * b3 % P, _3n$3, P) * b3 % P, _2n, P) * b2 % P;
	const b22 = pow2(b11, _11n, P) * b11 % P;
	const b44 = pow2(b22, _22n, P) * b22 % P;
	const b88 = pow2(b44, _44n, P) * b44 % P;
	const root = pow2(pow2(pow2(pow2(pow2(pow2(b88, _88n, P) * b88 % P, _44n, P) * b44 % P, _3n$3, P) * b3 % P, _23n, P) * b22 % P, _6n, P) * b2 % P, _2n, P);
	if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error("Cannot find square root");
	return root;
}
var secp256k1_CURVE, secp256k1_ENDO, _2n, Fpk1, secp256k1;
var init_secp256k1 = __esm({ "node_modules/@noble/curves/esm/secp256k1.js": (() => {
	init_sha2();
	init__shortw_utils();
	init_modular();
	secp256k1_CURVE = {
		p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
		n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
		h: BigInt(1),
		a: BigInt(0),
		b: BigInt(7),
		Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
		Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
	};
	secp256k1_ENDO = {
		beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
		basises: [[BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")], [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]
	};
	_2n = /* @__PURE__ */ BigInt(2);
	Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
	secp256k1 = createCurve({
		...secp256k1_CURVE,
		Fp: Fpk1,
		lowS: true,
		endo: secp256k1_ENDO
	}, sha256$1);
}) });

//#endregion
//#region node_modules/@solana/web3.js/lib/index.browser.esm.js
var index_browser_esm_exports = /* @__PURE__ */ __export({
	Account: () => Account,
	AddressLookupTableAccount: () => AddressLookupTableAccount,
	AddressLookupTableInstruction: () => AddressLookupTableInstruction,
	AddressLookupTableProgram: () => AddressLookupTableProgram,
	Authorized: () => Authorized,
	BLOCKHASH_CACHE_TIMEOUT_MS: () => BLOCKHASH_CACHE_TIMEOUT_MS,
	BPF_LOADER_DEPRECATED_PROGRAM_ID: () => BPF_LOADER_DEPRECATED_PROGRAM_ID,
	BPF_LOADER_PROGRAM_ID: () => BPF_LOADER_PROGRAM_ID,
	BpfLoader: () => BpfLoader,
	COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,
	ComputeBudgetInstruction: () => ComputeBudgetInstruction,
	ComputeBudgetProgram: () => ComputeBudgetProgram,
	Connection: () => Connection,
	Ed25519Program: () => Ed25519Program,
	Enum: () => Enum,
	EpochSchedule: () => EpochSchedule,
	FeeCalculatorLayout: () => FeeCalculatorLayout,
	Keypair: () => Keypair,
	LAMPORTS_PER_SOL: () => LAMPORTS_PER_SOL,
	LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => LOOKUP_TABLE_INSTRUCTION_LAYOUTS,
	Loader: () => Loader,
	Lockup: () => Lockup,
	MAX_SEED_LENGTH: () => MAX_SEED_LENGTH,
	Message: () => Message,
	MessageAccountKeys: () => MessageAccountKeys,
	MessageV0: () => MessageV0,
	NONCE_ACCOUNT_LENGTH: () => NONCE_ACCOUNT_LENGTH,
	NonceAccount: () => NonceAccount,
	PACKET_DATA_SIZE: () => PACKET_DATA_SIZE,
	PUBLIC_KEY_LENGTH: () => PUBLIC_KEY_LENGTH,
	PublicKey: () => PublicKey,
	SIGNATURE_LENGTH_IN_BYTES: () => SIGNATURE_LENGTH_IN_BYTES,
	SOLANA_SCHEMA: () => SOLANA_SCHEMA,
	STAKE_CONFIG_ID: () => STAKE_CONFIG_ID,
	STAKE_INSTRUCTION_LAYOUTS: () => STAKE_INSTRUCTION_LAYOUTS,
	SYSTEM_INSTRUCTION_LAYOUTS: () => SYSTEM_INSTRUCTION_LAYOUTS,
	SYSVAR_CLOCK_PUBKEY: () => SYSVAR_CLOCK_PUBKEY,
	SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => SYSVAR_EPOCH_SCHEDULE_PUBKEY,
	SYSVAR_INSTRUCTIONS_PUBKEY: () => SYSVAR_INSTRUCTIONS_PUBKEY,
	SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
	SYSVAR_RENT_PUBKEY: () => SYSVAR_RENT_PUBKEY,
	SYSVAR_REWARDS_PUBKEY: () => SYSVAR_REWARDS_PUBKEY,
	SYSVAR_SLOT_HASHES_PUBKEY: () => SYSVAR_SLOT_HASHES_PUBKEY,
	SYSVAR_SLOT_HISTORY_PUBKEY: () => SYSVAR_SLOT_HISTORY_PUBKEY,
	SYSVAR_STAKE_HISTORY_PUBKEY: () => SYSVAR_STAKE_HISTORY_PUBKEY,
	Secp256k1Program: () => Secp256k1Program,
	SendTransactionError: () => SendTransactionError,
	SolanaJSONRPCError: () => SolanaJSONRPCError,
	SolanaJSONRPCErrorCode: () => SolanaJSONRPCErrorCode,
	StakeAuthorizationLayout: () => StakeAuthorizationLayout,
	StakeInstruction: () => StakeInstruction,
	StakeProgram: () => StakeProgram,
	Struct: () => Struct,
	SystemInstruction: () => SystemInstruction,
	SystemProgram: () => SystemProgram,
	Transaction: () => Transaction,
	TransactionExpiredBlockheightExceededError: () => TransactionExpiredBlockheightExceededError,
	TransactionExpiredNonceInvalidError: () => TransactionExpiredNonceInvalidError,
	TransactionExpiredTimeoutError: () => TransactionExpiredTimeoutError,
	TransactionInstruction: () => TransactionInstruction,
	TransactionMessage: () => TransactionMessage,
	TransactionStatus: () => TransactionStatus,
	VALIDATOR_INFO_KEY: () => VALIDATOR_INFO_KEY,
	VERSION_PREFIX_MASK: () => VERSION_PREFIX_MASK,
	VOTE_PROGRAM_ID: () => VOTE_PROGRAM_ID,
	ValidatorInfo: () => ValidatorInfo,
	VersionedMessage: () => VersionedMessage,
	VersionedTransaction: () => VersionedTransaction,
	VoteAccount: () => VoteAccount,
	VoteAuthorizationLayout: () => VoteAuthorizationLayout,
	VoteInit: () => VoteInit,
	VoteInstruction: () => VoteInstruction,
	VoteProgram: () => VoteProgram,
	clusterApiUrl: () => clusterApiUrl,
	sendAndConfirmRawTransaction: () => sendAndConfirmRawTransaction,
	sendAndConfirmTransaction: () => sendAndConfirmTransaction
});
function isOnCurve(publicKey$1) {
	try {
		ed25519.ExtendedPoint.fromHex(publicKey$1);
		return true;
	} catch {
		return false;
	}
}
/**
* Value to be converted into public key
*/
/**
* JSON object representation of PublicKey class
*/
function isPublicKeyData(value) {
	return value._bn !== void 0;
}
function getAlloc(type$1, fields) {
	const getItemAlloc = (item) => {
		if (item.span >= 0) return item.span;
		else if (typeof item.alloc === "function") return item.alloc(fields[item.property]);
		else if ("count" in item && "elementLayout" in item) {
			const field = fields[item.property];
			if (Array.isArray(field)) return field.length * getItemAlloc(item.elementLayout);
		} else if ("fields" in item) return getAlloc({ layout: item }, fields[item.property]);
		return 0;
	};
	let alloc = 0;
	type$1.layout.fields.forEach((item) => {
		alloc += getItemAlloc(item);
	});
	return alloc;
}
function decodeLength(bytes) {
	let len = 0;
	let size = 0;
	for (;;) {
		let elem = bytes.shift();
		len |= (elem & 127) << size * 7;
		size += 1;
		if ((elem & 128) === 0) break;
	}
	return len;
}
function encodeLength(bytes, len) {
	let rem_len = len;
	for (;;) {
		let elem = rem_len & 127;
		rem_len >>= 7;
		if (rem_len == 0) {
			bytes.push(elem);
			break;
		} else {
			elem |= 128;
			bytes.push(elem);
		}
	}
}
function assert$1(condition, message) {
	if (!condition) throw new Error(message || "Assertion failed");
}
/**
* Delegates to `Array#shift`, but throws if the array is zero-length.
*/
function guardedShift(byteArray) {
	if (byteArray.length === 0) throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
	return byteArray.shift();
}
/**
* Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of
* the array.
*/
function guardedSplice(byteArray, ...args) {
	const [start] = args;
	if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
	return byteArray.splice(...args);
}
/**
* Sign, send and confirm a transaction.
*
* If `commitment` option is not specified, defaults to 'max' commitment.
*
* @param {Connection} connection
* @param {Transaction} transaction
* @param {Array<Signer>} signers
* @param {ConfirmOptions} [options]
* @returns {Promise<TransactionSignature>}
*/
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
	const sendOptions = options && {
		skipPreflight: options.skipPreflight,
		preflightCommitment: options.preflightCommitment || options.commitment,
		maxRetries: options.maxRetries,
		minContextSlot: options.minContextSlot
	};
	const signature$1 = await connection.sendTransaction(transaction, signers, sendOptions);
	let status;
	if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) status = (await connection.confirmTransaction({
		abortSignal: options?.abortSignal,
		signature: signature$1,
		blockhash: transaction.recentBlockhash,
		lastValidBlockHeight: transaction.lastValidBlockHeight
	}, options && options.commitment)).value;
	else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
		const { nonceInstruction } = transaction.nonceInfo;
		const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
		status = (await connection.confirmTransaction({
			abortSignal: options?.abortSignal,
			minContextSlot: transaction.minNonceContextSlot,
			nonceAccountPubkey,
			nonceValue: transaction.nonceInfo.nonce,
			signature: signature$1
		}, options && options.commitment)).value;
	} else {
		if (options?.abortSignal != null) console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
		status = (await connection.confirmTransaction(signature$1, options && options.commitment)).value;
	}
	if (status.err) {
		if (signature$1 != null) throw new SendTransactionError({
			action: "send",
			signature: signature$1,
			transactionMessage: `Status: (${JSON.stringify(status)})`
		});
		throw new Error(`Transaction ${signature$1} failed (${JSON.stringify(status)})`);
	}
	return signature$1;
}
function sleep(ms) {
	return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
* @internal
*/
/**
* Populate a buffer of instruction data using an InstructionType
* @internal
*/
function encodeData(type$1, fields) {
	const allocLength = type$1.layout.span >= 0 ? type$1.layout.span : getAlloc(type$1, fields);
	const data = import_buffer.Buffer.alloc(allocLength);
	const layoutFields = Object.assign({ instruction: type$1.index }, fields);
	type$1.layout.encode(layoutFields, data);
	return data;
}
/**
* Decode instruction data buffer using an InstructionType
* @internal
*/
function decodeData$1(type$1, buffer$1) {
	let data;
	try {
		data = type$1.layout.decode(buffer$1);
	} catch (err) {
		throw new Error("invalid instruction; " + err);
	}
	if (data.instruction !== type$1.index) throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type$1.index}`);
	return data;
}
function u64(property) {
	const layout = (0, import_Layout$1.blob)(8, property);
	const decode = layout.decode.bind(layout);
	const encode = layout.encode.bind(layout);
	const bigIntLayout = layout;
	const codec = getU64Codec();
	bigIntLayout.decode = (buffer$1, offset) => {
		const src = decode(buffer$1, offset);
		return codec.decode(src);
	};
	bigIntLayout.encode = (bigInt, buffer$1, offset) => {
		return encode(codec.encode(bigInt), buffer$1, offset);
	};
	return bigIntLayout;
}
function getDefaultExportFromCjs(x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function requireFastStableStringify() {
	if (hasRequiredFastStableStringify) return fastStableStringify$1;
	hasRequiredFastStableStringify = 1;
	var objToString = Object.prototype.toString;
	var objKeys = Object.keys || function(obj) {
		var keys = [];
		for (var name in obj) keys.push(name);
		return keys;
	};
	function stringify$1(val, isArrayProp) {
		var i$1, max, str, keys, key, propVal, toStr;
		if (val === true) return "true";
		if (val === false) return "false";
		switch (typeof val) {
			case "object": if (val === null) return null;
			else if (val.toJSON && typeof val.toJSON === "function") return stringify$1(val.toJSON(), isArrayProp);
			else {
				toStr = objToString.call(val);
				if (toStr === "[object Array]") {
					str = "[";
					max = val.length - 1;
					for (i$1 = 0; i$1 < max; i$1++) str += stringify$1(val[i$1], true) + ",";
					if (max > -1) str += stringify$1(val[i$1], true);
					return str + "]";
				} else if (toStr === "[object Object]") {
					keys = objKeys(val).sort();
					max = keys.length;
					str = "";
					i$1 = 0;
					while (i$1 < max) {
						key = keys[i$1];
						propVal = stringify$1(val[key], false);
						if (propVal !== void 0) {
							if (str) str += ",";
							str += JSON.stringify(key) + ":" + propVal;
						}
						i$1++;
					}
					return "{" + str + "}";
				} else return JSON.stringify(val);
			}
			case "function":
			case "undefined": return isArrayProp ? null : void 0;
			case "string": return JSON.stringify(val);
			default: return isFinite(val) ? val : null;
		}
	}
	fastStableStringify$1 = function(val) {
		var returnVal = stringify$1(val, false);
		if (returnVal !== void 0) return "" + returnVal;
	};
	return fastStableStringify$1;
}
function trailingZeros(n) {
	let trailingZeros$1 = 0;
	while (n > 1) {
		n /= 2;
		trailingZeros$1++;
	}
	return trailingZeros$1;
}
function nextPowerOfTwo(n) {
	if (n === 0) return 1;
	n--;
	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;
	n |= n >> 32;
	return n + 1;
}
/**
* @internal
*/
/**
* Decode account data buffer using an AccountType
* @internal
*/
function decodeData(type$1, data) {
	let decoded;
	try {
		decoded = type$1.layout.decode(data);
	} catch (err) {
		throw new Error("invalid instruction; " + err);
	}
	if (decoded.typeIndex !== type$1.index) throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type$1.index}`);
	return decoded;
}
function makeWebsocketUrl(endpoint$1) {
	const matches = endpoint$1.match(URL_RE);
	if (matches == null) throw TypeError(`Failed to validate endpoint URL \`${endpoint$1}\``);
	const [_, hostish, portWithColon, rest] = matches;
	const protocol = endpoint$1.startsWith("https:") ? "wss:" : "ws:";
	const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
	return `${protocol}//${hostish}${startPort == null ? "" : `:${startPort + 1}`}${rest}`;
}
/**
* HACK.
* Copied from rpc-websockets/dist/lib/client.
* Otherwise, `yarn build` fails with:
* https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d
*/
/** @internal */
/** @internal */
/** @internal */
/** @internal */
/** @internal */
/**
* @internal
* Every subscription contains the args used to open the subscription with
* the server, and a list of callers interested in notifications.
*/
/**
* @internal
* A subscription may be in various states of connectedness. Only when it is
* fully connected will it have a server subscription id associated with it.
* This id can be returned to the server to unsubscribe the client entirely.
*/
/**
* A type that encapsulates a subscription's RPC method
* names and notification (callback) signature.
*/
/**
* @internal
* Utility type that keeps tagged unions intact while omitting properties.
*/
/**
* @internal
* This type represents a single subscribable 'topic.' It's made up of:
*
* - The args used to open the subscription with the server,
* - The state of the subscription, in terms of its connectedness, and
* - The set of callbacks to call when the server publishes notifications
*
* This record gets indexed by `SubscriptionConfigHash` and is used to
* set up subscriptions, fan out notifications, and track subscription state.
*/
/**
* @internal
*/
/**
* Extra contextual information for RPC responses
*/
/**
* Options for sending transactions
*/
/**
* Options for confirming transactions
*/
/**
* Options for getConfirmedSignaturesForAddress2
*/
/**
* Options for getSignaturesForAddress
*/
/**
* RPC Response with extra contextual information
*/
/**
* A strategy for confirming transactions that uses the last valid
* block height for a given blockhash to check for transaction expiration.
*/
/**
* A strategy for confirming durable nonce transactions.
*/
/**
* Properties shared by all transaction confirmation strategies
*/
/**
* This type represents all transaction confirmation strategies
*/
function assertEndpointUrl(putativeUrl) {
	if (/^https?:/.test(putativeUrl) === false) throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
	return putativeUrl;
}
/** @internal */
function extractCommitmentFromConfig(commitmentOrConfig) {
	let commitment;
	let config;
	if (typeof commitmentOrConfig === "string") commitment = commitmentOrConfig;
	else if (commitmentOrConfig) {
		const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;
		commitment = specifiedCommitment;
		config = specifiedConfig;
	}
	return {
		commitment,
		config
	};
}
/**
* @internal
*/
function applyDefaultMemcmpEncodingToFilters(filters) {
	return filters.map((filter) => "memcmp" in filter ? {
		...filter,
		memcmp: {
			...filter.memcmp,
			encoding: filter.memcmp.encoding ?? "base58"
		}
	} : filter);
}
/**
* @internal
*/
function createRpcResult(result) {
	return union([type({
		jsonrpc: literal("2.0"),
		id: string(),
		result
	}), type({
		jsonrpc: literal("2.0"),
		id: string(),
		error: type({
			code: unknown(),
			message: string(),
			data: optional(any())
		})
	})]);
}
/**
* @internal
*/
function jsonRpcResult(schema) {
	return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
		if ("error" in value) return value;
		else return {
			...value,
			result: create(value.result, schema)
		};
	});
}
/**
* @internal
*/
function jsonRpcResultAndContext(value) {
	return jsonRpcResult(type({
		context: type({ slot: number() }),
		value
	}));
}
/**
* @internal
*/
function notificationResultAndContext(value) {
	return type({
		context: type({ slot: number() }),
		value
	});
}
/**
* @internal
*/
function versionedMessageFromResponse(version$1, response) {
	if (version$1 === 0) return new MessageV0({
		header: response.header,
		staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey(accountKey)),
		recentBlockhash: response.recentBlockhash,
		compiledInstructions: response.instructions.map((ix) => ({
			programIdIndex: ix.programIdIndex,
			accountKeyIndexes: ix.accounts,
			data: import_bs58.default.decode(ix.data)
		})),
		addressTableLookups: response.addressTableLookups
	});
	else return new Message(response);
}
/**
* A performance sample
*/
function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
	const fetch = customFetch ? customFetch : fetchImpl;
	let agent;
	if (httpAgent != null) console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
	let fetchWithMiddleware;
	if (fetchMiddleware) fetchWithMiddleware = async (info, init) => {
		return await fetch(...await new Promise((resolve, reject) => {
			try {
				fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
			} catch (error) {
				reject(error);
			}
		}));
	};
	return new import_browser.default(async (request, callback) => {
		const options = {
			method: "POST",
			body: request,
			agent,
			headers: Object.assign({ "Content-Type": "application/json" }, httpHeaders || {}, COMMON_HTTP_HEADERS)
		};
		try {
			let too_many_requests_retries = 5;
			let res;
			let waitTime = 500;
			for (;;) {
				if (fetchWithMiddleware) res = await fetchWithMiddleware(url, options);
				else res = await fetch(url, options);
				if (res.status !== 429) break;
				if (disableRetryOnRateLimit === true) break;
				too_many_requests_retries -= 1;
				if (too_many_requests_retries === 0) break;
				console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
				await sleep(waitTime);
				waitTime *= 2;
			}
			const text = await res.text();
			if (res.ok) callback(null, text);
			else callback(/* @__PURE__ */ new Error(`${res.status} ${res.statusText}: ${text}`));
		} catch (err) {
			if (err instanceof Error) callback(err);
		}
	}, {});
}
function createRpcRequest(client) {
	return (method, args) => {
		return new Promise((resolve, reject) => {
			client.request(method, args, (err, response) => {
				if (err) {
					reject(err);
					return;
				}
				resolve(response);
			});
		});
	};
}
function createRpcBatchRequest(client) {
	return (requests) => {
		return new Promise((resolve, reject) => {
			if (requests.length === 0) resolve([]);
			const batch = requests.map((params) => {
				return client.request(params.methodName, params.args);
			});
			client.request(batch, (err, response) => {
				if (err) {
					reject(err);
					return;
				}
				resolve(response);
			});
		});
	};
}
function parseAuthorizedVoter({ authorizedVoter, epoch }) {
	return {
		epoch,
		authorizedVoter: new PublicKey(authorizedVoter)
	};
}
function parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {
	return {
		authorizedPubkey: new PublicKey(authorizedPubkey),
		epochOfLastAuthorizedSwitch,
		targetEpoch
	};
}
function getPriorVoters({ buf, idx, isEmpty }) {
	if (isEmpty) return [];
	return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
}
/**
* Retrieves the RPC API URL for the specified cluster
* @param {Cluster} [cluster="devnet"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'
* @param {boolean} [tls="http"] - Use TLS when connecting to cluster.
*
* @returns {string} URL string of the RPC endpoint
*/
function clusterApiUrl(cluster, tls) {
	const key = tls === false ? "http" : "https";
	if (!cluster) return endpoint[key]["devnet"];
	const url = endpoint[key][cluster];
	if (!url) throw new Error(`Unknown ${key} cluster: ${cluster}`);
	return url;
}
/**
* Send and confirm a raw transaction
*
* If `commitment` option is not specified, defaults to 'max' commitment.
*
* @param {Connection} connection
* @param {Buffer} rawTransaction
* @param {TransactionConfirmationStrategy} confirmationStrategy
* @param {ConfirmOptions} [options]
* @returns {Promise<TransactionSignature>}
*/
/**
* @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`
* is no longer supported and will be removed in a future version.
*/
async function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
	let confirmationStrategy;
	let options;
	if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "lastValidBlockHeight")) {
		confirmationStrategy = confirmationStrategyOrConfirmOptions;
		options = maybeConfirmOptions;
	} else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "nonceValue")) {
		confirmationStrategy = confirmationStrategyOrConfirmOptions;
		options = maybeConfirmOptions;
	} else options = confirmationStrategyOrConfirmOptions;
	const sendOptions = options && {
		skipPreflight: options.skipPreflight,
		preflightCommitment: options.preflightCommitment || options.commitment,
		minContextSlot: options.minContextSlot
	};
	const signature$1 = await connection.sendRawTransaction(rawTransaction, sendOptions);
	const commitment = options && options.commitment;
	const status = (await (confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature$1, commitment))).value;
	if (status.err) {
		if (signature$1 != null) throw new SendTransactionError({
			action: sendOptions?.skipPreflight ? "send" : "simulate",
			signature: signature$1,
			transactionMessage: `Status: (${JSON.stringify(status)})`
		});
		throw new Error(`Raw transaction ${signature$1} failed (${JSON.stringify(status)})`);
	}
	return signature$1;
}
var import_buffer, import_bn, import_bs58, import_lib, import_Layout, import_Layout$1, import_browser, generatePrivateKey, generateKeypair, getPublicKey, sign, verify, toBuffer, Struct, Enum, SOLANA_SCHEMA, _PublicKey, MAX_SEED_LENGTH, PUBLIC_KEY_LENGTH, uniquePublicKeyCounter, PublicKey, Account, BPF_LOADER_DEPRECATED_PROGRAM_ID, PACKET_DATA_SIZE, VERSION_PREFIX_MASK, SIGNATURE_LENGTH_IN_BYTES, TransactionExpiredBlockheightExceededError, TransactionExpiredTimeoutError, TransactionExpiredNonceInvalidError, MessageAccountKeys, publicKey, signature, rustString, authorized, lockup, voteInit, voteAuthorizeWithSeedArgs, CompiledKeys, END_OF_BUFFER_ERROR_MESSAGE, Message, MessageV0, VersionedMessage, TransactionStatus, DEFAULT_SIGNATURE, TransactionInstruction, Transaction, TransactionMessage, VersionedTransaction, MS_PER_SLOT, SYSVAR_CLOCK_PUBKEY, SYSVAR_EPOCH_SCHEDULE_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY, SYSVAR_RECENT_BLOCKHASHES_PUBKEY, SYSVAR_RENT_PUBKEY, SYSVAR_REWARDS_PUBKEY, SYSVAR_SLOT_HASHES_PUBKEY, SYSVAR_SLOT_HISTORY_PUBKEY, SYSVAR_STAKE_HISTORY_PUBKEY, SendTransactionError, SolanaJSONRPCErrorCode, SolanaJSONRPCError, FeeCalculatorLayout, NonceAccountLayout, NONCE_ACCOUNT_LENGTH, NonceAccount, SystemInstruction, SYSTEM_INSTRUCTION_LAYOUTS, SystemProgram, CHUNK_SIZE, Loader, BPF_LOADER_PROGRAM_ID, BpfLoader, fastStableStringify$1, hasRequiredFastStableStringify, fastStableStringify, MINIMUM_SLOT_PER_EPOCH, EpochSchedule, fetchImpl, RpcWebSocketClient, LOOKUP_TABLE_META_SIZE, AddressLookupTableAccount, LookupTableMetaLayout, URL_RE, PublicKeyFromString, RawAccountDataResult, BufferFromRawAccountData, BLOCKHASH_CACHE_TIMEOUT_MS, UnknownRpcResult, GetInflationGovernorResult, GetInflationRewardResult, GetRecentPrioritizationFeesResult, GetInflationRateResult, GetEpochInfoResult, GetEpochScheduleResult, GetLeaderScheduleResult, TransactionErrorResult, SignatureStatusResult, SignatureReceivedResult, VersionResult, ParsedInstructionStruct, PartiallyDecodedInstructionStruct, SimulatedTransactionResponseStruct, BlockProductionResponseStruct, GetInflationGovernorRpcResult, GetInflationRateRpcResult, GetRecentPrioritizationFeesRpcResult, GetEpochInfoRpcResult, GetEpochScheduleRpcResult, GetLeaderScheduleRpcResult, SlotRpcResult, GetSupplyRpcResult, TokenAmountResult, GetTokenLargestAccountsResult, GetTokenAccountsByOwner, ParsedAccountDataResult, GetParsedTokenAccountsByOwner, GetLargestAccountsRpcResult, AccountInfoResult, KeyedAccountInfoResult, ParsedOrRawAccountData, ParsedAccountInfoResult, KeyedParsedAccountInfoResult, StakeActivationResult, GetConfirmedSignaturesForAddress2RpcResult, GetSignaturesForAddressRpcResult, AccountNotificationResult, ProgramAccountInfoResult, ProgramAccountNotificationResult, SlotInfoResult, SlotNotificationResult, SlotUpdateResult, SlotUpdateNotificationResult, SignatureNotificationResult, RootNotificationResult, ContactInfoResult, VoteAccountInfoResult, GetVoteAccounts, ConfirmationStatus, GetSignatureStatusesRpcResult, GetMinimumBalanceForRentExemptionRpcResult, AddressTableLookupStruct, ConfirmedTransactionResult, AnnotatedAccountKey, ConfirmedTransactionAccountsModeResult, ParsedInstructionResult, RawInstructionResult, ParsedOrRawInstruction, ParsedConfirmedTransactionResult, TokenBalanceResult, LoadedAddressesResult, ConfirmedTransactionMetaResult, ParsedConfirmedTransactionMetaResult, TransactionVersionStruct, RewardsResult, GetBlockRpcResult, GetNoneModeBlockRpcResult, GetAccountsModeBlockRpcResult, GetParsedBlockRpcResult, GetParsedAccountsModeBlockRpcResult, GetParsedNoneModeBlockRpcResult, GetConfirmedBlockRpcResult, GetBlockSignaturesRpcResult, GetTransactionRpcResult, GetParsedTransactionRpcResult, GetLatestBlockhashRpcResult, IsBlockhashValidRpcResult, GetRecentPerformanceSamplesRpcResult, GetFeeCalculatorRpcResult, RequestAirdropRpcResult, SendTransactionRpcResult, LogsNotificationResult, COMMON_HTTP_HEADERS, Connection, Keypair, LOOKUP_TABLE_INSTRUCTION_LAYOUTS, AddressLookupTableInstruction, AddressLookupTableProgram, ComputeBudgetInstruction, COMPUTE_BUDGET_INSTRUCTION_LAYOUTS, ComputeBudgetProgram, PRIVATE_KEY_BYTES$1, PUBLIC_KEY_BYTES$1, SIGNATURE_BYTES, ED25519_INSTRUCTION_LAYOUT, Ed25519Program, ecdsaSign, publicKeyCreate, PRIVATE_KEY_BYTES, ETHEREUM_ADDRESS_BYTES, PUBLIC_KEY_BYTES, SIGNATURE_OFFSETS_SERIALIZED_SIZE, SECP256K1_INSTRUCTION_LAYOUT, Secp256k1Program, _Lockup, STAKE_CONFIG_ID, Authorized, Lockup, StakeInstruction, STAKE_INSTRUCTION_LAYOUTS, StakeAuthorizationLayout, StakeProgram, VoteInit, VoteInstruction, VOTE_INSTRUCTION_LAYOUTS, VoteAuthorizationLayout, VoteProgram, VALIDATOR_INFO_KEY, InfoString, ValidatorInfo, VOTE_PROGRAM_ID, VoteAccountLayout, VoteAccount, endpoint, LAMPORTS_PER_SOL;
var init_index_browser_esm = __esm({ "node_modules/@solana/web3.js/lib/index.browser.esm.js": (() => {
	import_buffer = require_buffer();
	init_ed25519();
	import_bn = /* @__PURE__ */ __toESM(require_bn());
	import_bs58 = /* @__PURE__ */ __toESM(require_bs58$1());
	init_sha256();
	import_lib = require_lib();
	import_Layout = /* @__PURE__ */ __toESM(require_Layout());
	import_Layout$1 = require_Layout();
	init_index_browser$1();
	init_dist();
	import_browser = /* @__PURE__ */ __toESM(require_browser());
	init_index_browser();
	init_sha3();
	init_secp256k1();
	generatePrivateKey = ed25519.utils.randomPrivateKey;
	generateKeypair = () => {
		const privateScalar = ed25519.utils.randomPrivateKey();
		const publicKey$1 = getPublicKey(privateScalar);
		const secretKey = new Uint8Array(64);
		secretKey.set(privateScalar);
		secretKey.set(publicKey$1, 32);
		return {
			publicKey: publicKey$1,
			secretKey
		};
	};
	getPublicKey = ed25519.getPublicKey;
	sign = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));
	verify = ed25519.verify;
	toBuffer = (arr) => {
		if (import_buffer.Buffer.isBuffer(arr)) return arr;
		else if (arr instanceof Uint8Array) return import_buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
		else return import_buffer.Buffer.from(arr);
	};
	Struct = class {
		constructor(properties) {
			Object.assign(this, properties);
		}
		encode() {
			return import_buffer.Buffer.from((0, import_lib.serialize)(SOLANA_SCHEMA, this));
		}
		static decode(data) {
			return (0, import_lib.deserialize)(SOLANA_SCHEMA, this, data);
		}
		static decodeUnchecked(data) {
			return (0, import_lib.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
		}
	};
	Enum = class extends Struct {
		constructor(properties) {
			super(properties);
			this.enum = "";
			if (Object.keys(properties).length !== 1) throw new Error("Enum can only take single value");
			Object.keys(properties).map((key) => {
				this.enum = key;
			});
		}
	};
	SOLANA_SCHEMA = /* @__PURE__ */ new Map();
	;
	MAX_SEED_LENGTH = 32;
	PUBLIC_KEY_LENGTH = 32;
	uniquePublicKeyCounter = 1;
	PublicKey = class PublicKey extends Struct {
		/**
		* Create a new PublicKey object
		* @param value ed25519 public key as buffer or base-58 encoded string
		*/
		constructor(value) {
			super({});
			/** @internal */
			this._bn = void 0;
			if (isPublicKeyData(value)) this._bn = value._bn;
			else {
				if (typeof value === "string") {
					const decoded = import_bs58.default.decode(value);
					if (decoded.length != PUBLIC_KEY_LENGTH) throw new Error(`Invalid public key input`);
					this._bn = new import_bn.default(decoded);
				} else this._bn = new import_bn.default(value);
				if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) throw new Error(`Invalid public key input`);
			}
		}
		/**
		* Returns a unique PublicKey for tests and benchmarks using a counter
		*/
		static unique() {
			const key = new PublicKey(uniquePublicKeyCounter);
			uniquePublicKeyCounter += 1;
			return new PublicKey(key.toBuffer());
		}
		/**
		* Default public key value. The base58-encoded string representation is all ones (as seen below)
		* The underlying BN number is 32 bytes that are all zeros
		*/
		/**
		* Checks if two publicKeys are equal
		*/
		equals(publicKey$1) {
			return this._bn.eq(publicKey$1._bn);
		}
		/**
		* Return the base-58 representation of the public key
		*/
		toBase58() {
			return import_bs58.default.encode(this.toBytes());
		}
		toJSON() {
			return this.toBase58();
		}
		/**
		* Return the byte array representation of the public key in big endian
		*/
		toBytes() {
			const buf = this.toBuffer();
			return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
		}
		/**
		* Return the Buffer representation of the public key in big endian
		*/
		toBuffer() {
			const b = this._bn.toArrayLike(import_buffer.Buffer);
			if (b.length === PUBLIC_KEY_LENGTH) return b;
			const zeroPad = import_buffer.Buffer.alloc(32);
			b.copy(zeroPad, 32 - b.length);
			return zeroPad;
		}
		get [Symbol.toStringTag]() {
			return `PublicKey(${this.toString()})`;
		}
		/**
		* Return the base-58 representation of the public key
		*/
		toString() {
			return this.toBase58();
		}
		/**
		* Derive a public key from another key, a seed, and a program ID.
		* The program ID will also serve as the owner of the public key, giving
		* it permission to write data to the account.
		*/
		static async createWithSeed(fromPublicKey, seed, programId) {
			return new PublicKey(sha256(import_buffer.Buffer.concat([
				fromPublicKey.toBuffer(),
				import_buffer.Buffer.from(seed),
				programId.toBuffer()
			])));
		}
		/**
		* Derive a program address from seeds and a program ID.
		*/
		static createProgramAddressSync(seeds, programId) {
			let buffer$1 = import_buffer.Buffer.alloc(0);
			seeds.forEach(function(seed) {
				if (seed.length > MAX_SEED_LENGTH) throw new TypeError(`Max seed length exceeded`);
				buffer$1 = import_buffer.Buffer.concat([buffer$1, toBuffer(seed)]);
			});
			buffer$1 = import_buffer.Buffer.concat([
				buffer$1,
				programId.toBuffer(),
				import_buffer.Buffer.from("ProgramDerivedAddress")
			]);
			const publicKeyBytes = sha256(buffer$1);
			if (isOnCurve(publicKeyBytes)) throw new Error(`Invalid seeds, address must fall off the curve`);
			return new PublicKey(publicKeyBytes);
		}
		/**
		* Async version of createProgramAddressSync
		* For backwards compatibility
		*
		* @deprecated Use {@link createProgramAddressSync} instead
		*/
		static async createProgramAddress(seeds, programId) {
			return this.createProgramAddressSync(seeds, programId);
		}
		/**
		* Find a valid program address
		*
		* Valid program addresses must fall off the ed25519 curve.  This function
		* iterates a nonce until it finds one that when combined with the seeds
		* results in a valid program address.
		*/
		static findProgramAddressSync(seeds, programId) {
			let nonce = 255;
			let address;
			while (nonce != 0) {
				try {
					const seedsWithNonce = seeds.concat(import_buffer.Buffer.from([nonce]));
					address = this.createProgramAddressSync(seedsWithNonce, programId);
				} catch (err) {
					if (err instanceof TypeError) throw err;
					nonce--;
					continue;
				}
				return [address, nonce];
			}
			throw new Error(`Unable to find a viable program address nonce`);
		}
		/**
		* Async version of findProgramAddressSync
		* For backwards compatibility
		*
		* @deprecated Use {@link findProgramAddressSync} instead
		*/
		static async findProgramAddress(seeds, programId) {
			return this.findProgramAddressSync(seeds, programId);
		}
		/**
		* Check that a pubkey is on the ed25519 curve.
		*/
		static isOnCurve(pubkeyData) {
			return isOnCurve(new PublicKey(pubkeyData).toBytes());
		}
	};
	_PublicKey = PublicKey;
	PublicKey.default = new _PublicKey("11111111111111111111111111111111");
	SOLANA_SCHEMA.set(PublicKey, {
		kind: "struct",
		fields: [["_bn", "u256"]]
	});
	Account = class {
		/**
		* Create a new Account object
		*
		* If the secretKey parameter is not provided a new key pair is randomly
		* created for the account
		*
		* @param secretKey Secret key for the account
		*/
		constructor(secretKey) {
			/** @internal */
			this._publicKey = void 0;
			/** @internal */
			this._secretKey = void 0;
			if (secretKey) {
				const secretKeyBuffer = toBuffer(secretKey);
				if (secretKey.length !== 64) throw new Error("bad secret key size");
				this._publicKey = secretKeyBuffer.slice(32, 64);
				this._secretKey = secretKeyBuffer.slice(0, 32);
			} else {
				this._secretKey = toBuffer(generatePrivateKey());
				this._publicKey = toBuffer(getPublicKey(this._secretKey));
			}
		}
		/**
		* The public key for this account
		*/
		get publicKey() {
			return new PublicKey(this._publicKey);
		}
		/**
		* The **unencrypted** secret key for this account. The first 32 bytes
		* is the private scalar and the last 32 bytes is the public key.
		* Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
		*/
		get secretKey() {
			return import_buffer.Buffer.concat([this._secretKey, this._publicKey], 64);
		}
	};
	BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
	PACKET_DATA_SIZE = 1232;
	VERSION_PREFIX_MASK = 127;
	SIGNATURE_LENGTH_IN_BYTES = 64;
	TransactionExpiredBlockheightExceededError = class extends Error {
		constructor(signature$1) {
			super(`Signature ${signature$1} has expired: block height exceeded.`);
			this.signature = void 0;
			this.signature = signature$1;
		}
	};
	Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", { value: "TransactionExpiredBlockheightExceededError" });
	TransactionExpiredTimeoutError = class extends Error {
		constructor(signature$1, timeoutSeconds) {
			super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature$1} using the Solana Explorer or CLI tools.`);
			this.signature = void 0;
			this.signature = signature$1;
		}
	};
	Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", { value: "TransactionExpiredTimeoutError" });
	TransactionExpiredNonceInvalidError = class extends Error {
		constructor(signature$1) {
			super(`Signature ${signature$1} has expired: the nonce is no longer valid.`);
			this.signature = void 0;
			this.signature = signature$1;
		}
	};
	Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", { value: "TransactionExpiredNonceInvalidError" });
	MessageAccountKeys = class {
		constructor(staticAccountKeys, accountKeysFromLookups) {
			this.staticAccountKeys = void 0;
			this.accountKeysFromLookups = void 0;
			this.staticAccountKeys = staticAccountKeys;
			this.accountKeysFromLookups = accountKeysFromLookups;
		}
		keySegments() {
			const keySegments = [this.staticAccountKeys];
			if (this.accountKeysFromLookups) {
				keySegments.push(this.accountKeysFromLookups.writable);
				keySegments.push(this.accountKeysFromLookups.readonly);
			}
			return keySegments;
		}
		get(index) {
			for (const keySegment of this.keySegments()) if (index < keySegment.length) return keySegment[index];
			else index -= keySegment.length;
		}
		get length() {
			return this.keySegments().flat().length;
		}
		compileInstructions(instructions) {
			if (this.length > 256) throw new Error("Account index overflow encountered during compilation");
			const keyIndexMap = /* @__PURE__ */ new Map();
			this.keySegments().flat().forEach((key, index) => {
				keyIndexMap.set(key.toBase58(), index);
			});
			const findKeyIndex = (key) => {
				const keyIndex = keyIndexMap.get(key.toBase58());
				if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
				return keyIndex;
			};
			return instructions.map((instruction) => {
				return {
					programIdIndex: findKeyIndex(instruction.programId),
					accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
					data: instruction.data
				};
			});
		}
	};
	publicKey = (property = "publicKey") => {
		return import_Layout.blob(32, property);
	};
	signature = (property = "signature") => {
		return import_Layout.blob(64, property);
	};
	rustString = (property = "string") => {
		const rsl = import_Layout.struct([
			import_Layout.u32("length"),
			import_Layout.u32("lengthPadding"),
			import_Layout.blob(import_Layout.offset(import_Layout.u32(), -8), "chars")
		], property);
		const _decode = rsl.decode.bind(rsl);
		const _encode = rsl.encode.bind(rsl);
		const rslShim = rsl;
		rslShim.decode = (b, offset) => {
			return _decode(b, offset)["chars"].toString();
		};
		rslShim.encode = (str, b, offset) => {
			return _encode({ chars: import_buffer.Buffer.from(str, "utf8") }, b, offset);
		};
		rslShim.alloc = (str) => {
			return import_Layout.u32().span + import_Layout.u32().span + import_buffer.Buffer.from(str, "utf8").length;
		};
		return rslShim;
	};
	authorized = (property = "authorized") => {
		return import_Layout.struct([publicKey("staker"), publicKey("withdrawer")], property);
	};
	lockup = (property = "lockup") => {
		return import_Layout.struct([
			import_Layout.ns64("unixTimestamp"),
			import_Layout.ns64("epoch"),
			publicKey("custodian")
		], property);
	};
	voteInit = (property = "voteInit") => {
		return import_Layout.struct([
			publicKey("nodePubkey"),
			publicKey("authorizedVoter"),
			publicKey("authorizedWithdrawer"),
			import_Layout.u8("commission")
		], property);
	};
	voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
		return import_Layout.struct([
			import_Layout.u32("voteAuthorizationType"),
			publicKey("currentAuthorityDerivedKeyOwnerPubkey"),
			rustString("currentAuthorityDerivedKeySeed"),
			publicKey("newAuthorized")
		], property);
	};
	CompiledKeys = class CompiledKeys {
		constructor(payer, keyMetaMap) {
			this.payer = void 0;
			this.keyMetaMap = void 0;
			this.payer = payer;
			this.keyMetaMap = keyMetaMap;
		}
		static compile(instructions, payer) {
			const keyMetaMap = /* @__PURE__ */ new Map();
			const getOrInsertDefault = (pubkey) => {
				const address = pubkey.toBase58();
				let keyMeta = keyMetaMap.get(address);
				if (keyMeta === void 0) {
					keyMeta = {
						isSigner: false,
						isWritable: false,
						isInvoked: false
					};
					keyMetaMap.set(address, keyMeta);
				}
				return keyMeta;
			};
			const payerKeyMeta = getOrInsertDefault(payer);
			payerKeyMeta.isSigner = true;
			payerKeyMeta.isWritable = true;
			for (const ix of instructions) {
				getOrInsertDefault(ix.programId).isInvoked = true;
				for (const accountMeta of ix.keys) {
					const keyMeta = getOrInsertDefault(accountMeta.pubkey);
					keyMeta.isSigner ||= accountMeta.isSigner;
					keyMeta.isWritable ||= accountMeta.isWritable;
				}
			}
			return new CompiledKeys(payer, keyMetaMap);
		}
		getMessageComponents() {
			const mapEntries = [...this.keyMetaMap.entries()];
			assert$1(mapEntries.length <= 256, "Max static account keys length exceeded");
			const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
			const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
			const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
			const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
			const header = {
				numRequiredSignatures: writableSigners.length + readonlySigners.length,
				numReadonlySignedAccounts: readonlySigners.length,
				numReadonlyUnsignedAccounts: readonlyNonSigners.length
			};
			{
				assert$1(writableSigners.length > 0, "Expected at least one writable signer key");
				const [payerAddress] = writableSigners[0];
				assert$1(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
			}
			return [header, [
				...writableSigners.map(([address]) => new PublicKey(address)),
				...readonlySigners.map(([address]) => new PublicKey(address)),
				...writableNonSigners.map(([address]) => new PublicKey(address)),
				...readonlyNonSigners.map(([address]) => new PublicKey(address))
			]];
		}
		extractTableLookup(lookupTable) {
			const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
			const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
			if (writableIndexes.length === 0 && readonlyIndexes.length === 0) return;
			return [{
				accountKey: lookupTable.key,
				writableIndexes,
				readonlyIndexes
			}, {
				writable: drainedWritableKeys,
				readonly: drainedReadonlyKeys
			}];
		}
		/** @internal */
		drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
			const lookupTableIndexes = new Array();
			const drainedKeys = new Array();
			for (const [address, keyMeta] of this.keyMetaMap.entries()) if (keyMetaFilter(keyMeta)) {
				const key = new PublicKey(address);
				const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
				if (lookupTableIndex >= 0) {
					assert$1(lookupTableIndex < 256, "Max lookup table index exceeded");
					lookupTableIndexes.push(lookupTableIndex);
					drainedKeys.push(key);
					this.keyMetaMap.delete(address);
				}
			}
			return [lookupTableIndexes, drainedKeys];
		}
	};
	END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
	Message = class Message {
		constructor(args) {
			this.header = void 0;
			this.accountKeys = void 0;
			this.recentBlockhash = void 0;
			this.instructions = void 0;
			this.indexToProgramIds = /* @__PURE__ */ new Map();
			this.header = args.header;
			this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
			this.recentBlockhash = args.recentBlockhash;
			this.instructions = args.instructions;
			this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
		}
		get version() {
			return "legacy";
		}
		get staticAccountKeys() {
			return this.accountKeys;
		}
		get compiledInstructions() {
			return this.instructions.map((ix) => ({
				programIdIndex: ix.programIdIndex,
				accountKeyIndexes: ix.accounts,
				data: import_bs58.default.decode(ix.data)
			}));
		}
		get addressTableLookups() {
			return [];
		}
		getAccountKeys() {
			return new MessageAccountKeys(this.staticAccountKeys);
		}
		static compile(args) {
			const [header, staticAccountKeys] = CompiledKeys.compile(args.instructions, args.payerKey).getMessageComponents();
			const instructions = new MessageAccountKeys(staticAccountKeys).compileInstructions(args.instructions).map((ix) => ({
				programIdIndex: ix.programIdIndex,
				accounts: ix.accountKeyIndexes,
				data: import_bs58.default.encode(ix.data)
			}));
			return new Message({
				header,
				accountKeys: staticAccountKeys,
				recentBlockhash: args.recentBlockhash,
				instructions
			});
		}
		isAccountSigner(index) {
			return index < this.header.numRequiredSignatures;
		}
		isAccountWritable(index) {
			const numSignedAccounts = this.header.numRequiredSignatures;
			if (index >= this.header.numRequiredSignatures) return index - numSignedAccounts < this.accountKeys.length - numSignedAccounts - this.header.numReadonlyUnsignedAccounts;
			else return index < numSignedAccounts - this.header.numReadonlySignedAccounts;
		}
		isProgramId(index) {
			return this.indexToProgramIds.has(index);
		}
		programIds() {
			return [...this.indexToProgramIds.values()];
		}
		nonProgramIds() {
			return this.accountKeys.filter((_, index) => !this.isProgramId(index));
		}
		serialize() {
			const numKeys = this.accountKeys.length;
			let keyCount = [];
			encodeLength(keyCount, numKeys);
			const instructions = this.instructions.map((instruction) => {
				const { accounts, programIdIndex } = instruction;
				const data = Array.from(import_bs58.default.decode(instruction.data));
				let keyIndicesCount = [];
				encodeLength(keyIndicesCount, accounts.length);
				let dataCount = [];
				encodeLength(dataCount, data.length);
				return {
					programIdIndex,
					keyIndicesCount: import_buffer.Buffer.from(keyIndicesCount),
					keyIndices: accounts,
					dataLength: import_buffer.Buffer.from(dataCount),
					data
				};
			});
			let instructionCount = [];
			encodeLength(instructionCount, instructions.length);
			let instructionBuffer = import_buffer.Buffer.alloc(PACKET_DATA_SIZE);
			import_buffer.Buffer.from(instructionCount).copy(instructionBuffer);
			let instructionBufferLength = instructionCount.length;
			instructions.forEach((instruction) => {
				const length$1 = import_Layout.struct([
					import_Layout.u8("programIdIndex"),
					import_Layout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"),
					import_Layout.seq(import_Layout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"),
					import_Layout.blob(instruction.dataLength.length, "dataLength"),
					import_Layout.seq(import_Layout.u8("userdatum"), instruction.data.length, "data")
				]).encode(instruction, instructionBuffer, instructionBufferLength);
				instructionBufferLength += length$1;
			});
			instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
			const signDataLayout = import_Layout.struct([
				import_Layout.blob(1, "numRequiredSignatures"),
				import_Layout.blob(1, "numReadonlySignedAccounts"),
				import_Layout.blob(1, "numReadonlyUnsignedAccounts"),
				import_Layout.blob(keyCount.length, "keyCount"),
				import_Layout.seq(publicKey("key"), numKeys, "keys"),
				publicKey("recentBlockhash")
			]);
			const transaction = {
				numRequiredSignatures: import_buffer.Buffer.from([this.header.numRequiredSignatures]),
				numReadonlySignedAccounts: import_buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
				numReadonlyUnsignedAccounts: import_buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
				keyCount: import_buffer.Buffer.from(keyCount),
				keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
				recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
			};
			let signData = import_buffer.Buffer.alloc(2048);
			const length = signDataLayout.encode(transaction, signData);
			instructionBuffer.copy(signData, length);
			return signData.slice(0, length + instructionBuffer.length);
		}
		/**
		* Decode a compiled message into a Message object.
		*/
		static from(buffer$1) {
			let byteArray = [...buffer$1];
			const numRequiredSignatures = guardedShift(byteArray);
			if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
			const numReadonlySignedAccounts = guardedShift(byteArray);
			const numReadonlyUnsignedAccounts = guardedShift(byteArray);
			const accountCount = decodeLength(byteArray);
			let accountKeys = [];
			for (let i$1 = 0; i$1 < accountCount; i$1++) {
				const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
				accountKeys.push(new PublicKey(import_buffer.Buffer.from(account)));
			}
			const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
			const instructionCount = decodeLength(byteArray);
			let instructions = [];
			for (let i$1 = 0; i$1 < instructionCount; i$1++) {
				const programIdIndex = guardedShift(byteArray);
				const accounts = guardedSplice(byteArray, 0, decodeLength(byteArray));
				const dataSlice = guardedSplice(byteArray, 0, decodeLength(byteArray));
				const data = import_bs58.default.encode(import_buffer.Buffer.from(dataSlice));
				instructions.push({
					programIdIndex,
					accounts,
					data
				});
			}
			return new Message({
				header: {
					numRequiredSignatures,
					numReadonlySignedAccounts,
					numReadonlyUnsignedAccounts
				},
				recentBlockhash: import_bs58.default.encode(import_buffer.Buffer.from(recentBlockhash)),
				accountKeys,
				instructions
			});
		}
	};
	MessageV0 = class MessageV0 {
		constructor(args) {
			this.header = void 0;
			this.staticAccountKeys = void 0;
			this.recentBlockhash = void 0;
			this.compiledInstructions = void 0;
			this.addressTableLookups = void 0;
			this.header = args.header;
			this.staticAccountKeys = args.staticAccountKeys;
			this.recentBlockhash = args.recentBlockhash;
			this.compiledInstructions = args.compiledInstructions;
			this.addressTableLookups = args.addressTableLookups;
		}
		get version() {
			return 0;
		}
		get numAccountKeysFromLookups() {
			let count = 0;
			for (const lookup of this.addressTableLookups) count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
			return count;
		}
		getAccountKeys(args) {
			let accountKeysFromLookups;
			if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
				if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
				accountKeysFromLookups = args.accountKeysFromLookups;
			} else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
			else if (this.addressTableLookups.length > 0) throw new Error("Failed to get account keys because address table lookups were not resolved");
			return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
		}
		isAccountSigner(index) {
			return index < this.header.numRequiredSignatures;
		}
		isAccountWritable(index) {
			const numSignedAccounts = this.header.numRequiredSignatures;
			const numStaticAccountKeys = this.staticAccountKeys.length;
			if (index >= numStaticAccountKeys) return index - numStaticAccountKeys < this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
			else if (index >= this.header.numRequiredSignatures) return index - numSignedAccounts < numStaticAccountKeys - numSignedAccounts - this.header.numReadonlyUnsignedAccounts;
			else return index < numSignedAccounts - this.header.numReadonlySignedAccounts;
		}
		resolveAddressTableLookups(addressLookupTableAccounts) {
			const accountKeysFromLookups = {
				writable: [],
				readonly: []
			};
			for (const tableLookup of this.addressTableLookups) {
				const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
				if (!tableAccount) throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
				for (const index of tableLookup.writableIndexes) if (index < tableAccount.state.addresses.length) accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
				else throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
				for (const index of tableLookup.readonlyIndexes) if (index < tableAccount.state.addresses.length) accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
				else throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
			}
			return accountKeysFromLookups;
		}
		static compile(args) {
			const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
			const addressTableLookups = new Array();
			const accountKeysFromLookups = {
				writable: new Array(),
				readonly: new Array()
			};
			const lookupTableAccounts = args.addressLookupTableAccounts || [];
			for (const lookupTable of lookupTableAccounts) {
				const extractResult = compiledKeys.extractTableLookup(lookupTable);
				if (extractResult !== void 0) {
					const [addressTableLookup, { writable, readonly }] = extractResult;
					addressTableLookups.push(addressTableLookup);
					accountKeysFromLookups.writable.push(...writable);
					accountKeysFromLookups.readonly.push(...readonly);
				}
			}
			const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
			const compiledInstructions = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups).compileInstructions(args.instructions);
			return new MessageV0({
				header,
				staticAccountKeys,
				recentBlockhash: args.recentBlockhash,
				compiledInstructions,
				addressTableLookups
			});
		}
		serialize() {
			const encodedStaticAccountKeysLength = Array();
			encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
			const serializedInstructions = this.serializeInstructions();
			const encodedInstructionsLength = Array();
			encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
			const serializedAddressTableLookups = this.serializeAddressTableLookups();
			const encodedAddressTableLookupsLength = Array();
			encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
			const messageLayout = import_Layout.struct([
				import_Layout.u8("prefix"),
				import_Layout.struct([
					import_Layout.u8("numRequiredSignatures"),
					import_Layout.u8("numReadonlySignedAccounts"),
					import_Layout.u8("numReadonlyUnsignedAccounts")
				], "header"),
				import_Layout.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"),
				import_Layout.seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"),
				publicKey("recentBlockhash"),
				import_Layout.blob(encodedInstructionsLength.length, "instructionsLength"),
				import_Layout.blob(serializedInstructions.length, "serializedInstructions"),
				import_Layout.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"),
				import_Layout.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")
			]);
			const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
			const serializedMessageLength = messageLayout.encode({
				prefix: 128,
				header: this.header,
				staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
				staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
				recentBlockhash: import_bs58.default.decode(this.recentBlockhash),
				instructionsLength: new Uint8Array(encodedInstructionsLength),
				serializedInstructions,
				addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
				serializedAddressTableLookups
			}, serializedMessage);
			return serializedMessage.slice(0, serializedMessageLength);
		}
		serializeInstructions() {
			let serializedLength = 0;
			const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
			for (const instruction of this.compiledInstructions) {
				const encodedAccountKeyIndexesLength = Array();
				encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
				const encodedDataLength = Array();
				encodeLength(encodedDataLength, instruction.data.length);
				const instructionLayout = import_Layout.struct([
					import_Layout.u8("programIdIndex"),
					import_Layout.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"),
					import_Layout.seq(import_Layout.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"),
					import_Layout.blob(encodedDataLength.length, "encodedDataLength"),
					import_Layout.blob(instruction.data.length, "data")
				]);
				serializedLength += instructionLayout.encode({
					programIdIndex: instruction.programIdIndex,
					encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
					accountKeyIndexes: instruction.accountKeyIndexes,
					encodedDataLength: new Uint8Array(encodedDataLength),
					data: instruction.data
				}, serializedInstructions, serializedLength);
			}
			return serializedInstructions.slice(0, serializedLength);
		}
		serializeAddressTableLookups() {
			let serializedLength = 0;
			const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
			for (const lookup of this.addressTableLookups) {
				const encodedWritableIndexesLength = Array();
				encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
				const encodedReadonlyIndexesLength = Array();
				encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
				const addressTableLookupLayout = import_Layout.struct([
					publicKey("accountKey"),
					import_Layout.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"),
					import_Layout.seq(import_Layout.u8(), lookup.writableIndexes.length, "writableIndexes"),
					import_Layout.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"),
					import_Layout.seq(import_Layout.u8(), lookup.readonlyIndexes.length, "readonlyIndexes")
				]);
				serializedLength += addressTableLookupLayout.encode({
					accountKey: lookup.accountKey.toBytes(),
					encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
					writableIndexes: lookup.writableIndexes,
					encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
					readonlyIndexes: lookup.readonlyIndexes
				}, serializedAddressTableLookups, serializedLength);
			}
			return serializedAddressTableLookups.slice(0, serializedLength);
		}
		static deserialize(serializedMessage) {
			let byteArray = [...serializedMessage];
			const prefix$1 = guardedShift(byteArray);
			const maskedPrefix = prefix$1 & VERSION_PREFIX_MASK;
			assert$1(prefix$1 !== maskedPrefix, `Expected versioned message but received legacy message`);
			const version$1 = maskedPrefix;
			assert$1(version$1 === 0, `Expected versioned message with version 0 but found version ${version$1}`);
			const header = {
				numRequiredSignatures: guardedShift(byteArray),
				numReadonlySignedAccounts: guardedShift(byteArray),
				numReadonlyUnsignedAccounts: guardedShift(byteArray)
			};
			const staticAccountKeys = [];
			const staticAccountKeysLength = decodeLength(byteArray);
			for (let i$1 = 0; i$1 < staticAccountKeysLength; i$1++) staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));
			const recentBlockhash = import_bs58.default.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
			const instructionCount = decodeLength(byteArray);
			const compiledInstructions = [];
			for (let i$1 = 0; i$1 < instructionCount; i$1++) {
				const programIdIndex = guardedShift(byteArray);
				const accountKeyIndexes = guardedSplice(byteArray, 0, decodeLength(byteArray));
				const dataLength = decodeLength(byteArray);
				const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));
				compiledInstructions.push({
					programIdIndex,
					accountKeyIndexes,
					data
				});
			}
			const addressTableLookupsCount = decodeLength(byteArray);
			const addressTableLookups = [];
			for (let i$1 = 0; i$1 < addressTableLookupsCount; i$1++) {
				const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
				const writableIndexes = guardedSplice(byteArray, 0, decodeLength(byteArray));
				const readonlyIndexes = guardedSplice(byteArray, 0, decodeLength(byteArray));
				addressTableLookups.push({
					accountKey,
					writableIndexes,
					readonlyIndexes
				});
			}
			return new MessageV0({
				header,
				staticAccountKeys,
				recentBlockhash,
				compiledInstructions,
				addressTableLookups
			});
		}
	};
	VersionedMessage = {
		deserializeMessageVersion(serializedMessage) {
			const prefix$1 = serializedMessage[0];
			const maskedPrefix = prefix$1 & VERSION_PREFIX_MASK;
			if (maskedPrefix === prefix$1) return "legacy";
			return maskedPrefix;
		},
		deserialize: (serializedMessage) => {
			const version$1 = VersionedMessage.deserializeMessageVersion(serializedMessage);
			if (version$1 === "legacy") return Message.from(serializedMessage);
			if (version$1 === 0) return MessageV0.deserialize(serializedMessage);
			else throw new Error(`Transaction message version ${version$1} deserialization is not supported`);
		}
	};
	TransactionStatus = /* @__PURE__ */ function(TransactionStatus$1) {
		TransactionStatus$1[TransactionStatus$1["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
		TransactionStatus$1[TransactionStatus$1["PROCESSED"] = 1] = "PROCESSED";
		TransactionStatus$1[TransactionStatus$1["TIMED_OUT"] = 2] = "TIMED_OUT";
		TransactionStatus$1[TransactionStatus$1["NONCE_INVALID"] = 3] = "NONCE_INVALID";
		return TransactionStatus$1;
	}({});
	DEFAULT_SIGNATURE = import_buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
	TransactionInstruction = class {
		constructor(opts) {
			/**
			* Public keys to include in this transaction
			* Boolean represents whether this pubkey needs to sign the transaction
			*/
			this.keys = void 0;
			/**
			* Program Id to execute
			*/
			this.programId = void 0;
			/**
			* Program input
			*/
			this.data = import_buffer.Buffer.alloc(0);
			this.programId = opts.programId;
			this.keys = opts.keys;
			if (opts.data) this.data = opts.data;
		}
		/**
		* @internal
		*/
		toJSON() {
			return {
				keys: this.keys.map(({ pubkey, isSigner, isWritable }) => ({
					pubkey: pubkey.toJSON(),
					isSigner,
					isWritable
				})),
				programId: this.programId.toJSON(),
				data: [...this.data]
			};
		}
	};
	Transaction = class Transaction {
		/**
		* The first (payer) Transaction signature
		*
		* @returns {Buffer | null} Buffer of payer's signature
		*/
		get signature() {
			if (this.signatures.length > 0) return this.signatures[0].signature;
			return null;
		}
		/**
		* The transaction fee payer
		*/
		/**
		* @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
		* Please supply a `TransactionBlockhashCtor` instead.
		*/
		/**
		* Construct an empty Transaction
		*/
		constructor(opts) {
			/**
			* Signatures for the transaction.  Typically created by invoking the
			* `sign()` method
			*/
			this.signatures = [];
			this.feePayer = void 0;
			/**
			* The instructions to atomically execute
			*/
			this.instructions = [];
			/**
			* A recent transaction id. Must be populated by the caller
			*/
			this.recentBlockhash = void 0;
			/**
			* the last block chain can advance to before tx is declared expired
			* */
			this.lastValidBlockHeight = void 0;
			/**
			* Optional Nonce information. If populated, transaction will use a durable
			* Nonce hash instead of a recentBlockhash. Must be populated by the caller
			*/
			this.nonceInfo = void 0;
			/**
			* If this is a nonce transaction this represents the minimum slot from which
			* to evaluate if the nonce has advanced when attempting to confirm the
			* transaction. This protects against a case where the transaction confirmation
			* logic loads the nonce account from an old slot and assumes the mismatch in
			* nonce value implies that the nonce has been advanced.
			*/
			this.minNonceContextSlot = void 0;
			/**
			* @internal
			*/
			this._message = void 0;
			/**
			* @internal
			*/
			this._json = void 0;
			if (!opts) return;
			if (opts.feePayer) this.feePayer = opts.feePayer;
			if (opts.signatures) this.signatures = opts.signatures;
			if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
				const { minContextSlot, nonceInfo } = opts;
				this.minNonceContextSlot = minContextSlot;
				this.nonceInfo = nonceInfo;
			} else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
				const { blockhash, lastValidBlockHeight } = opts;
				this.recentBlockhash = blockhash;
				this.lastValidBlockHeight = lastValidBlockHeight;
			} else {
				const { recentBlockhash, nonceInfo } = opts;
				if (nonceInfo) this.nonceInfo = nonceInfo;
				this.recentBlockhash = recentBlockhash;
			}
		}
		/**
		* @internal
		*/
		toJSON() {
			return {
				recentBlockhash: this.recentBlockhash || null,
				feePayer: this.feePayer ? this.feePayer.toJSON() : null,
				nonceInfo: this.nonceInfo ? {
					nonce: this.nonceInfo.nonce,
					nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
				} : null,
				instructions: this.instructions.map((instruction) => instruction.toJSON()),
				signers: this.signatures.map(({ publicKey: publicKey$1 }) => {
					return publicKey$1.toJSON();
				})
			};
		}
		/**
		* Add one or more instructions to this Transaction
		*
		* @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
		*/
		add(...items) {
			if (items.length === 0) throw new Error("No instructions");
			items.forEach((item) => {
				if ("instructions" in item) this.instructions = this.instructions.concat(item.instructions);
				else if ("data" in item && "programId" in item && "keys" in item) this.instructions.push(item);
				else this.instructions.push(new TransactionInstruction(item));
			});
			return this;
		}
		/**
		* Compile transaction data
		*/
		compileMessage() {
			if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
			let recentBlockhash;
			let instructions;
			if (this.nonceInfo) {
				recentBlockhash = this.nonceInfo.nonce;
				if (this.instructions[0] != this.nonceInfo.nonceInstruction) instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
				else instructions = this.instructions;
			} else {
				recentBlockhash = this.recentBlockhash;
				instructions = this.instructions;
			}
			if (!recentBlockhash) throw new Error("Transaction recentBlockhash required");
			if (instructions.length < 1) console.warn("No instructions provided");
			let feePayer;
			if (this.feePayer) feePayer = this.feePayer;
			else if (this.signatures.length > 0 && this.signatures[0].publicKey) feePayer = this.signatures[0].publicKey;
			else throw new Error("Transaction fee payer required");
			for (let i$1 = 0; i$1 < instructions.length; i$1++) if (instructions[i$1].programId === void 0) throw new Error(`Transaction instruction index ${i$1} has undefined program id`);
			const programIds = [];
			const accountMetas = [];
			instructions.forEach((instruction) => {
				instruction.keys.forEach((accountMeta) => {
					accountMetas.push({ ...accountMeta });
				});
				const programId = instruction.programId.toString();
				if (!programIds.includes(programId)) programIds.push(programId);
			});
			programIds.forEach((programId) => {
				accountMetas.push({
					pubkey: new PublicKey(programId),
					isSigner: false,
					isWritable: false
				});
			});
			const uniqueMetas = [];
			accountMetas.forEach((accountMeta) => {
				const pubkeyString = accountMeta.pubkey.toString();
				const uniqueIndex = uniqueMetas.findIndex((x) => {
					return x.pubkey.toString() === pubkeyString;
				});
				if (uniqueIndex > -1) {
					uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
					uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
				} else uniqueMetas.push(accountMeta);
			});
			uniqueMetas.sort(function(x, y) {
				if (x.isSigner !== y.isSigner) return x.isSigner ? -1 : 1;
				if (x.isWritable !== y.isWritable) return x.isWritable ? -1 : 1;
				return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", {
					localeMatcher: "best fit",
					usage: "sort",
					sensitivity: "variant",
					ignorePunctuation: false,
					numeric: false,
					caseFirst: "lower"
				});
			});
			const feePayerIndex = uniqueMetas.findIndex((x) => {
				return x.pubkey.equals(feePayer);
			});
			if (feePayerIndex > -1) {
				const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
				payerMeta.isSigner = true;
				payerMeta.isWritable = true;
				uniqueMetas.unshift(payerMeta);
			} else uniqueMetas.unshift({
				pubkey: feePayer,
				isSigner: true,
				isWritable: true
			});
			for (const signature$1 of this.signatures) {
				const uniqueIndex = uniqueMetas.findIndex((x) => {
					return x.pubkey.equals(signature$1.publicKey);
				});
				if (uniqueIndex > -1) {
					if (!uniqueMetas[uniqueIndex].isSigner) {
						uniqueMetas[uniqueIndex].isSigner = true;
						console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
					}
				} else throw new Error(`unknown signer: ${signature$1.publicKey.toString()}`);
			}
			let numRequiredSignatures = 0;
			let numReadonlySignedAccounts = 0;
			let numReadonlyUnsignedAccounts = 0;
			const signedKeys = [];
			const unsignedKeys = [];
			uniqueMetas.forEach(({ pubkey, isSigner, isWritable }) => {
				if (isSigner) {
					signedKeys.push(pubkey.toString());
					numRequiredSignatures += 1;
					if (!isWritable) numReadonlySignedAccounts += 1;
				} else {
					unsignedKeys.push(pubkey.toString());
					if (!isWritable) numReadonlyUnsignedAccounts += 1;
				}
			});
			const accountKeys = signedKeys.concat(unsignedKeys);
			const compiledInstructions = instructions.map((instruction) => {
				const { data, programId } = instruction;
				return {
					programIdIndex: accountKeys.indexOf(programId.toString()),
					accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
					data: import_bs58.default.encode(data)
				};
			});
			compiledInstructions.forEach((instruction) => {
				assert$1(instruction.programIdIndex >= 0);
				instruction.accounts.forEach((keyIndex) => assert$1(keyIndex >= 0));
			});
			return new Message({
				header: {
					numRequiredSignatures,
					numReadonlySignedAccounts,
					numReadonlyUnsignedAccounts
				},
				accountKeys,
				recentBlockhash,
				instructions: compiledInstructions
			});
		}
		/**
		* @internal
		*/
		_compile() {
			const message = this.compileMessage();
			const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
			if (this.signatures.length === signedKeys.length) {
				if (this.signatures.every((pair, index) => {
					return signedKeys[index].equals(pair.publicKey);
				})) return message;
			}
			this.signatures = signedKeys.map((publicKey$1) => ({
				signature: null,
				publicKey: publicKey$1
			}));
			return message;
		}
		/**
		* Get a buffer of the Transaction data that need to be covered by signatures
		*/
		serializeMessage() {
			return this._compile().serialize();
		}
		/**
		* Get the estimated fee associated with a transaction
		*
		* @param {Connection} connection Connection to RPC Endpoint.
		*
		* @returns {Promise<number | null>} The estimated fee for the transaction
		*/
		async getEstimatedFee(connection) {
			return (await connection.getFeeForMessage(this.compileMessage())).value;
		}
		/**
		* Specify the public keys which will be used to sign the Transaction.
		* The first signer will be used as the transaction fee payer account.
		*
		* Signatures can be added with either `partialSign` or `addSignature`
		*
		* @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
		* specified and it can be set in the Transaction constructor or with the
		* `feePayer` property.
		*/
		setSigners(...signers) {
			if (signers.length === 0) throw new Error("No signers");
			const seen = /* @__PURE__ */ new Set();
			this.signatures = signers.filter((publicKey$1) => {
				const key = publicKey$1.toString();
				if (seen.has(key)) return false;
				else {
					seen.add(key);
					return true;
				}
			}).map((publicKey$1) => ({
				signature: null,
				publicKey: publicKey$1
			}));
		}
		/**
		* Sign the Transaction with the specified signers. Multiple signatures may
		* be applied to a Transaction. The first signature is considered "primary"
		* and is used identify and confirm transactions.
		*
		* If the Transaction `feePayer` is not set, the first signer will be used
		* as the transaction fee payer account.
		*
		* Transaction fields should not be modified after the first call to `sign`,
		* as doing so may invalidate the signature and cause the Transaction to be
		* rejected.
		*
		* The Transaction must be assigned a valid `recentBlockhash` before invoking this method
		*
		* @param {Array<Signer>} signers Array of signers that will sign the transaction
		*/
		sign(...signers) {
			if (signers.length === 0) throw new Error("No signers");
			const seen = /* @__PURE__ */ new Set();
			const uniqueSigners = [];
			for (const signer of signers) {
				const key = signer.publicKey.toString();
				if (seen.has(key)) continue;
				else {
					seen.add(key);
					uniqueSigners.push(signer);
				}
			}
			this.signatures = uniqueSigners.map((signer) => ({
				signature: null,
				publicKey: signer.publicKey
			}));
			const message = this._compile();
			this._partialSign(message, ...uniqueSigners);
		}
		/**
		* Partially sign a transaction with the specified accounts. All accounts must
		* correspond to either the fee payer or a signer account in the transaction
		* instructions.
		*
		* All the caveats from the `sign` method apply to `partialSign`
		*
		* @param {Array<Signer>} signers Array of signers that will sign the transaction
		*/
		partialSign(...signers) {
			if (signers.length === 0) throw new Error("No signers");
			const seen = /* @__PURE__ */ new Set();
			const uniqueSigners = [];
			for (const signer of signers) {
				const key = signer.publicKey.toString();
				if (seen.has(key)) continue;
				else {
					seen.add(key);
					uniqueSigners.push(signer);
				}
			}
			const message = this._compile();
			this._partialSign(message, ...uniqueSigners);
		}
		/**
		* @internal
		*/
		_partialSign(message, ...signers) {
			const signData = message.serialize();
			signers.forEach((signer) => {
				const signature$1 = sign(signData, signer.secretKey);
				this._addSignature(signer.publicKey, toBuffer(signature$1));
			});
		}
		/**
		* Add an externally created signature to a transaction. The public key
		* must correspond to either the fee payer or a signer account in the transaction
		* instructions.
		*
		* @param {PublicKey} pubkey Public key that will be added to the transaction.
		* @param {Buffer} signature An externally created signature to add to the transaction.
		*/
		addSignature(pubkey, signature$1) {
			this._compile();
			this._addSignature(pubkey, signature$1);
		}
		/**
		* @internal
		*/
		_addSignature(pubkey, signature$1) {
			assert$1(signature$1.length === 64);
			const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
			if (index < 0) throw new Error(`unknown signer: ${pubkey.toString()}`);
			this.signatures[index].signature = import_buffer.Buffer.from(signature$1);
		}
		/**
		* Verify signatures of a Transaction
		* Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
		* If no boolean is provided, we expect a fully signed Transaction by default.
		*
		* @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
		*/
		verifySignatures(requireAllSignatures = true) {
			return !this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
		}
		/**
		* @internal
		*/
		_getMessageSignednessErrors(message, requireAllSignatures) {
			const errors = {};
			for (const { signature: signature$1, publicKey: publicKey$1 } of this.signatures) if (signature$1 === null) {
				if (requireAllSignatures) (errors.missing ||= []).push(publicKey$1);
			} else if (!verify(signature$1, message, publicKey$1.toBytes())) (errors.invalid ||= []).push(publicKey$1);
			return errors.invalid || errors.missing ? errors : void 0;
		}
		/**
		* Serialize the Transaction in the wire format.
		*
		* @param {Buffer} [config] Config of transaction.
		*
		* @returns {Buffer} Signature of transaction in wire format.
		*/
		serialize(config) {
			const { requireAllSignatures, verifySignatures } = Object.assign({
				requireAllSignatures: true,
				verifySignatures: true
			}, config);
			const signData = this.serializeMessage();
			if (verifySignatures) {
				const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
				if (sigErrors) {
					let errorMessage = "Signature verification failed.";
					if (sigErrors.invalid) errorMessage += `\nInvalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
					if (sigErrors.missing) errorMessage += `\nMissing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
					throw new Error(errorMessage);
				}
			}
			return this._serialize(signData);
		}
		/**
		* @internal
		*/
		_serialize(signData) {
			const { signatures } = this;
			const signatureCount = [];
			encodeLength(signatureCount, signatures.length);
			const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
			const wireTransaction = import_buffer.Buffer.alloc(transactionLength);
			assert$1(signatures.length < 256);
			import_buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
			signatures.forEach(({ signature: signature$1 }, index) => {
				if (signature$1 !== null) {
					assert$1(signature$1.length === 64, `signature has invalid length`);
					import_buffer.Buffer.from(signature$1).copy(wireTransaction, signatureCount.length + index * 64);
				}
			});
			signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
			assert$1(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
			return wireTransaction;
		}
		/**
		* Deprecated method
		* @internal
		*/
		get keys() {
			assert$1(this.instructions.length === 1);
			return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
		}
		/**
		* Deprecated method
		* @internal
		*/
		get programId() {
			assert$1(this.instructions.length === 1);
			return this.instructions[0].programId;
		}
		/**
		* Deprecated method
		* @internal
		*/
		get data() {
			assert$1(this.instructions.length === 1);
			return this.instructions[0].data;
		}
		/**
		* Parse a wire transaction into a Transaction object.
		*
		* @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
		*
		* @returns {Transaction} Transaction associated with the signature
		*/
		static from(buffer$1) {
			let byteArray = [...buffer$1];
			const signatureCount = decodeLength(byteArray);
			let signatures = [];
			for (let i$1 = 0; i$1 < signatureCount; i$1++) {
				const signature$1 = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
				signatures.push(import_bs58.default.encode(import_buffer.Buffer.from(signature$1)));
			}
			return Transaction.populate(Message.from(byteArray), signatures);
		}
		/**
		* Populate Transaction object from message and signatures
		*
		* @param {Message} message Message of transaction
		* @param {Array<string>} signatures List of signatures to assign to the transaction
		*
		* @returns {Transaction} The populated Transaction
		*/
		static populate(message, signatures = []) {
			const transaction = new Transaction();
			transaction.recentBlockhash = message.recentBlockhash;
			if (message.header.numRequiredSignatures > 0) transaction.feePayer = message.accountKeys[0];
			signatures.forEach((signature$1, index) => {
				const sigPubkeyPair = {
					signature: signature$1 == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature$1),
					publicKey: message.accountKeys[index]
				};
				transaction.signatures.push(sigPubkeyPair);
			});
			message.instructions.forEach((instruction) => {
				const keys = instruction.accounts.map((account) => {
					const pubkey = message.accountKeys[account];
					return {
						pubkey,
						isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
						isWritable: message.isAccountWritable(account)
					};
				});
				transaction.instructions.push(new TransactionInstruction({
					keys,
					programId: message.accountKeys[instruction.programIdIndex],
					data: import_bs58.default.decode(instruction.data)
				}));
			});
			transaction._message = message;
			transaction._json = transaction.toJSON();
			return transaction;
		}
	};
	TransactionMessage = class TransactionMessage {
		constructor(args) {
			this.payerKey = void 0;
			this.instructions = void 0;
			this.recentBlockhash = void 0;
			this.payerKey = args.payerKey;
			this.instructions = args.instructions;
			this.recentBlockhash = args.recentBlockhash;
		}
		static decompile(message, args) {
			const { header, compiledInstructions, recentBlockhash } = message;
			const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;
			const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
			assert$1(numWritableSignedAccounts > 0, "Message header is invalid");
			const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
			assert$1(numWritableUnsignedAccounts >= 0, "Message header is invalid");
			const accountKeys = message.getAccountKeys(args);
			const payerKey = accountKeys.get(0);
			if (payerKey === void 0) throw new Error("Failed to decompile message because no account keys were found");
			const instructions = [];
			for (const compiledIx of compiledInstructions) {
				const keys = [];
				for (const keyIndex of compiledIx.accountKeyIndexes) {
					const pubkey = accountKeys.get(keyIndex);
					if (pubkey === void 0) throw new Error(`Failed to find key for account key index ${keyIndex}`);
					const isSigner = keyIndex < numRequiredSignatures;
					let isWritable;
					if (isSigner) isWritable = keyIndex < numWritableSignedAccounts;
					else if (keyIndex < accountKeys.staticAccountKeys.length) isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
					else isWritable = keyIndex - accountKeys.staticAccountKeys.length < accountKeys.accountKeysFromLookups.writable.length;
					keys.push({
						pubkey,
						isSigner: keyIndex < header.numRequiredSignatures,
						isWritable
					});
				}
				const programId = accountKeys.get(compiledIx.programIdIndex);
				if (programId === void 0) throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
				instructions.push(new TransactionInstruction({
					programId,
					data: toBuffer(compiledIx.data),
					keys
				}));
			}
			return new TransactionMessage({
				payerKey,
				instructions,
				recentBlockhash
			});
		}
		compileToLegacyMessage() {
			return Message.compile({
				payerKey: this.payerKey,
				recentBlockhash: this.recentBlockhash,
				instructions: this.instructions
			});
		}
		compileToV0Message(addressLookupTableAccounts) {
			return MessageV0.compile({
				payerKey: this.payerKey,
				recentBlockhash: this.recentBlockhash,
				instructions: this.instructions,
				addressLookupTableAccounts
			});
		}
	};
	VersionedTransaction = class VersionedTransaction {
		get version() {
			return this.message.version;
		}
		constructor(message, signatures) {
			this.signatures = void 0;
			this.message = void 0;
			if (signatures !== void 0) {
				assert$1(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
				this.signatures = signatures;
			} else {
				const defaultSignatures = [];
				for (let i$1 = 0; i$1 < message.header.numRequiredSignatures; i$1++) defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
				this.signatures = defaultSignatures;
			}
			this.message = message;
		}
		serialize() {
			const serializedMessage = this.message.serialize();
			const encodedSignaturesLength = Array();
			encodeLength(encodedSignaturesLength, this.signatures.length);
			const transactionLayout = import_Layout.struct([
				import_Layout.blob(encodedSignaturesLength.length, "encodedSignaturesLength"),
				import_Layout.seq(signature(), this.signatures.length, "signatures"),
				import_Layout.blob(serializedMessage.length, "serializedMessage")
			]);
			const serializedTransaction = new Uint8Array(2048);
			const serializedTransactionLength = transactionLayout.encode({
				encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
				signatures: this.signatures,
				serializedMessage
			}, serializedTransaction);
			return serializedTransaction.slice(0, serializedTransactionLength);
		}
		static deserialize(serializedTransaction) {
			let byteArray = [...serializedTransaction];
			const signatures = [];
			const signaturesLength = decodeLength(byteArray);
			for (let i$1 = 0; i$1 < signaturesLength; i$1++) signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));
			return new VersionedTransaction(VersionedMessage.deserialize(new Uint8Array(byteArray)), signatures);
		}
		sign(signers) {
			const messageData = this.message.serialize();
			const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
			for (const signer of signers) {
				const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(signer.publicKey));
				assert$1(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
				this.signatures[signerIndex] = sign(messageData, signer.secretKey);
			}
		}
		addSignature(publicKey$1, signature$1) {
			assert$1(signature$1.byteLength === 64, "Signature must be 64 bytes long");
			const signerIndex = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex((pubkey) => pubkey.equals(publicKey$1));
			assert$1(signerIndex >= 0, `Can not add signature; \`${publicKey$1.toBase58()}\` is not required to sign this transaction`);
			this.signatures[signerIndex] = signature$1;
		}
	};
	MS_PER_SLOT = 1e3 / (160 / 64);
	SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
	SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
	SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
	SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
	SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
	SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
	SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
	SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
	SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
	SendTransactionError = class extends Error {
		constructor({ action, signature: signature$1, transactionMessage, logs }) {
			const maybeLogsOutput = logs ? `Logs: \n${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
			const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
			let message;
			switch (action) {
				case "send":
					message = `Transaction ${signature$1} resulted in an error. \n${transactionMessage}. ` + maybeLogsOutput + guideText;
					break;
				case "simulate":
					message = `Simulation failed. \nMessage: ${transactionMessage}. \n` + maybeLogsOutput + guideText;
					break;
				default: message = `Unknown action '${((a) => a)(action)}'`;
			}
			super(message);
			this.signature = void 0;
			this.transactionMessage = void 0;
			this.transactionLogs = void 0;
			this.signature = signature$1;
			this.transactionMessage = transactionMessage;
			this.transactionLogs = logs ? logs : void 0;
		}
		get transactionError() {
			return {
				message: this.transactionMessage,
				logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
			};
		}
		get logs() {
			const cachedLogs = this.transactionLogs;
			if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) return;
			return cachedLogs;
		}
		async getLogs(connection) {
			if (!Array.isArray(this.transactionLogs)) this.transactionLogs = new Promise((resolve, reject) => {
				connection.getTransaction(this.signature).then((tx) => {
					if (tx && tx.meta && tx.meta.logMessages) {
						const logs = tx.meta.logMessages;
						this.transactionLogs = logs;
						resolve(logs);
					} else reject(/* @__PURE__ */ new Error("Log messages not found"));
				}).catch(reject);
			});
			return await this.transactionLogs;
		}
	};
	SolanaJSONRPCErrorCode = {
		JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
		JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
		JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
		JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
		JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
		JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
		JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
		JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
		JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
		JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
		JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
		JSON_RPC_SCAN_ERROR: -32012,
		JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
		JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
		JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
		JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
	};
	SolanaJSONRPCError = class extends Error {
		constructor({ code, message, data }, customMessage) {
			super(customMessage != null ? `${customMessage}: ${message}` : message);
			this.code = void 0;
			this.data = void 0;
			this.code = code;
			this.data = data;
			this.name = "SolanaJSONRPCError";
		}
	};
	FeeCalculatorLayout = import_Layout.nu64("lamportsPerSignature");
	NonceAccountLayout = import_Layout.struct([
		import_Layout.u32("version"),
		import_Layout.u32("state"),
		publicKey("authorizedPubkey"),
		publicKey("nonce"),
		import_Layout.struct([FeeCalculatorLayout], "feeCalculator")
	]);
	NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
	NonceAccount = class NonceAccount {
		/**
		* @internal
		*/
		constructor(args) {
			this.authorizedPubkey = void 0;
			this.nonce = void 0;
			this.feeCalculator = void 0;
			this.authorizedPubkey = args.authorizedPubkey;
			this.nonce = args.nonce;
			this.feeCalculator = args.feeCalculator;
		}
		/**
		* Deserialize NonceAccount from the account data.
		*
		* @param buffer account data
		* @return NonceAccount
		*/
		static fromAccountData(buffer$1) {
			const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer$1), 0);
			return new NonceAccount({
				authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
				nonce: new PublicKey(nonceAccount.nonce).toString(),
				feeCalculator: nonceAccount.feeCalculator
			});
		}
	};
	SystemInstruction = class {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Decode a system instruction and retrieve the instruction type.
		*/
		static decodeInstructionType(instruction) {
			this.checkProgramId(instruction.programId);
			const typeIndex = import_Layout.u32("instruction").decode(instruction.data);
			let type$1;
			for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) if (layout.index == typeIndex) {
				type$1 = ixType;
				break;
			}
			if (!type$1) throw new Error("Instruction type incorrect; not a SystemInstruction");
			return type$1;
		}
		/**
		* Decode a create account system instruction and retrieve the instruction params.
		*/
		static decodeCreateAccount(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 2);
			const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
			return {
				fromPubkey: instruction.keys[0].pubkey,
				newAccountPubkey: instruction.keys[1].pubkey,
				lamports,
				space,
				programId: new PublicKey(programId)
			};
		}
		/**
		* Decode a transfer system instruction and retrieve the instruction params.
		*/
		static decodeTransfer(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 2);
			const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
			return {
				fromPubkey: instruction.keys[0].pubkey,
				toPubkey: instruction.keys[1].pubkey,
				lamports
			};
		}
		/**
		* Decode a transfer with seed system instruction and retrieve the instruction params.
		*/
		static decodeTransferWithSeed(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 3);
			const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
			return {
				fromPubkey: instruction.keys[0].pubkey,
				basePubkey: instruction.keys[1].pubkey,
				toPubkey: instruction.keys[2].pubkey,
				lamports,
				seed,
				programId: new PublicKey(programId)
			};
		}
		/**
		* Decode an allocate system instruction and retrieve the instruction params.
		*/
		static decodeAllocate(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 1);
			const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
			return {
				accountPubkey: instruction.keys[0].pubkey,
				space
			};
		}
		/**
		* Decode an allocate with seed system instruction and retrieve the instruction params.
		*/
		static decodeAllocateWithSeed(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 1);
			const { base: base$2, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
			return {
				accountPubkey: instruction.keys[0].pubkey,
				basePubkey: new PublicKey(base$2),
				seed,
				space,
				programId: new PublicKey(programId)
			};
		}
		/**
		* Decode an assign system instruction and retrieve the instruction params.
		*/
		static decodeAssign(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 1);
			const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
			return {
				accountPubkey: instruction.keys[0].pubkey,
				programId: new PublicKey(programId)
			};
		}
		/**
		* Decode an assign with seed system instruction and retrieve the instruction params.
		*/
		static decodeAssignWithSeed(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 1);
			const { base: base$2, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
			return {
				accountPubkey: instruction.keys[0].pubkey,
				basePubkey: new PublicKey(base$2),
				seed,
				programId: new PublicKey(programId)
			};
		}
		/**
		* Decode a create account with seed system instruction and retrieve the instruction params.
		*/
		static decodeCreateWithSeed(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 2);
			const { base: base$2, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
			return {
				fromPubkey: instruction.keys[0].pubkey,
				newAccountPubkey: instruction.keys[1].pubkey,
				basePubkey: new PublicKey(base$2),
				seed,
				lamports,
				space,
				programId: new PublicKey(programId)
			};
		}
		/**
		* Decode a nonce initialize system instruction and retrieve the instruction params.
		*/
		static decodeNonceInitialize(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 3);
			const { authorized: authorized$1 } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
			return {
				noncePubkey: instruction.keys[0].pubkey,
				authorizedPubkey: new PublicKey(authorized$1)
			};
		}
		/**
		* Decode a nonce advance system instruction and retrieve the instruction params.
		*/
		static decodeNonceAdvance(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 3);
			decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
			return {
				noncePubkey: instruction.keys[0].pubkey,
				authorizedPubkey: instruction.keys[2].pubkey
			};
		}
		/**
		* Decode a nonce withdraw system instruction and retrieve the instruction params.
		*/
		static decodeNonceWithdraw(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 5);
			const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
			return {
				noncePubkey: instruction.keys[0].pubkey,
				toPubkey: instruction.keys[1].pubkey,
				authorizedPubkey: instruction.keys[4].pubkey,
				lamports
			};
		}
		/**
		* Decode a nonce authorize system instruction and retrieve the instruction params.
		*/
		static decodeNonceAuthorize(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 2);
			const { authorized: authorized$1 } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
			return {
				noncePubkey: instruction.keys[0].pubkey,
				authorizedPubkey: instruction.keys[1].pubkey,
				newAuthorizedPubkey: new PublicKey(authorized$1)
			};
		}
		/**
		* @internal
		*/
		static checkProgramId(programId) {
			if (!programId.equals(SystemProgram.programId)) throw new Error("invalid instruction; programId is not SystemProgram");
		}
		/**
		* @internal
		*/
		static checkKeyLength(keys, expectedLength) {
			if (keys.length < expectedLength) throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
		}
	};
	SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
		Create: {
			index: 0,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				import_Layout.ns64("lamports"),
				import_Layout.ns64("space"),
				publicKey("programId")
			])
		},
		Assign: {
			index: 1,
			layout: import_Layout.struct([import_Layout.u32("instruction"), publicKey("programId")])
		},
		Transfer: {
			index: 2,
			layout: import_Layout.struct([import_Layout.u32("instruction"), u64("lamports")])
		},
		CreateWithSeed: {
			index: 3,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				publicKey("base"),
				rustString("seed"),
				import_Layout.ns64("lamports"),
				import_Layout.ns64("space"),
				publicKey("programId")
			])
		},
		AdvanceNonceAccount: {
			index: 4,
			layout: import_Layout.struct([import_Layout.u32("instruction")])
		},
		WithdrawNonceAccount: {
			index: 5,
			layout: import_Layout.struct([import_Layout.u32("instruction"), import_Layout.ns64("lamports")])
		},
		InitializeNonceAccount: {
			index: 6,
			layout: import_Layout.struct([import_Layout.u32("instruction"), publicKey("authorized")])
		},
		AuthorizeNonceAccount: {
			index: 7,
			layout: import_Layout.struct([import_Layout.u32("instruction"), publicKey("authorized")])
		},
		Allocate: {
			index: 8,
			layout: import_Layout.struct([import_Layout.u32("instruction"), import_Layout.ns64("space")])
		},
		AllocateWithSeed: {
			index: 9,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				publicKey("base"),
				rustString("seed"),
				import_Layout.ns64("space"),
				publicKey("programId")
			])
		},
		AssignWithSeed: {
			index: 10,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				publicKey("base"),
				rustString("seed"),
				publicKey("programId")
			])
		},
		TransferWithSeed: {
			index: 11,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				u64("lamports"),
				rustString("seed"),
				publicKey("programId")
			])
		},
		UpgradeNonceAccount: {
			index: 12,
			layout: import_Layout.struct([import_Layout.u32("instruction")])
		}
	});
	SystemProgram = class SystemProgram {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Public key that identifies the System program
		*/
		/**
		* Generate a transaction instruction that creates a new account
		*/
		static createAccount(params) {
			const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
			const data = encodeData(type$1, {
				lamports: params.lamports,
				space: params.space,
				programId: toBuffer(params.programId.toBuffer())
			});
			return new TransactionInstruction({
				keys: [{
					pubkey: params.fromPubkey,
					isSigner: true,
					isWritable: true
				}, {
					pubkey: params.newAccountPubkey,
					isSigner: true,
					isWritable: true
				}],
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction instruction that transfers lamports from one account to another
		*/
		static transfer(params) {
			let data;
			let keys;
			if ("basePubkey" in params) {
				const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
				data = encodeData(type$1, {
					lamports: BigInt(params.lamports),
					seed: params.seed,
					programId: toBuffer(params.programId.toBuffer())
				});
				keys = [
					{
						pubkey: params.fromPubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: params.basePubkey,
						isSigner: true,
						isWritable: false
					},
					{
						pubkey: params.toPubkey,
						isSigner: false,
						isWritable: true
					}
				];
			} else {
				const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
				data = encodeData(type$1, { lamports: BigInt(params.lamports) });
				keys = [{
					pubkey: params.fromPubkey,
					isSigner: true,
					isWritable: true
				}, {
					pubkey: params.toPubkey,
					isSigner: false,
					isWritable: true
				}];
			}
			return new TransactionInstruction({
				keys,
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction instruction that assigns an account to a program
		*/
		static assign(params) {
			let data;
			let keys;
			if ("basePubkey" in params) {
				const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
				data = encodeData(type$1, {
					base: toBuffer(params.basePubkey.toBuffer()),
					seed: params.seed,
					programId: toBuffer(params.programId.toBuffer())
				});
				keys = [{
					pubkey: params.accountPubkey,
					isSigner: false,
					isWritable: true
				}, {
					pubkey: params.basePubkey,
					isSigner: true,
					isWritable: false
				}];
			} else {
				const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
				data = encodeData(type$1, { programId: toBuffer(params.programId.toBuffer()) });
				keys = [{
					pubkey: params.accountPubkey,
					isSigner: true,
					isWritable: true
				}];
			}
			return new TransactionInstruction({
				keys,
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction instruction that creates a new account at
		*   an address generated with `from`, a seed, and programId
		*/
		static createAccountWithSeed(params) {
			const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
			const data = encodeData(type$1, {
				base: toBuffer(params.basePubkey.toBuffer()),
				seed: params.seed,
				lamports: params.lamports,
				space: params.space,
				programId: toBuffer(params.programId.toBuffer())
			});
			let keys = [{
				pubkey: params.fromPubkey,
				isSigner: true,
				isWritable: true
			}, {
				pubkey: params.newAccountPubkey,
				isSigner: false,
				isWritable: true
			}];
			if (!params.basePubkey.equals(params.fromPubkey)) keys.push({
				pubkey: params.basePubkey,
				isSigner: true,
				isWritable: false
			});
			return new TransactionInstruction({
				keys,
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction that creates a new Nonce account
		*/
		static createNonceAccount(params) {
			const transaction = new Transaction();
			if ("basePubkey" in params && "seed" in params) transaction.add(SystemProgram.createAccountWithSeed({
				fromPubkey: params.fromPubkey,
				newAccountPubkey: params.noncePubkey,
				basePubkey: params.basePubkey,
				seed: params.seed,
				lamports: params.lamports,
				space: NONCE_ACCOUNT_LENGTH,
				programId: this.programId
			}));
			else transaction.add(SystemProgram.createAccount({
				fromPubkey: params.fromPubkey,
				newAccountPubkey: params.noncePubkey,
				lamports: params.lamports,
				space: NONCE_ACCOUNT_LENGTH,
				programId: this.programId
			}));
			const initParams = {
				noncePubkey: params.noncePubkey,
				authorizedPubkey: params.authorizedPubkey
			};
			transaction.add(this.nonceInitialize(initParams));
			return transaction;
		}
		/**
		* Generate an instruction to initialize a Nonce account
		*/
		static nonceInitialize(params) {
			const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
			const data = encodeData(type$1, { authorized: toBuffer(params.authorizedPubkey.toBuffer()) });
			return new TransactionInstruction({
				keys: [
					{
						pubkey: params.noncePubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: SYSVAR_RENT_PUBKEY,
						isSigner: false,
						isWritable: false
					}
				],
				programId: this.programId,
				data
			});
		}
		/**
		* Generate an instruction to advance the nonce in a Nonce account
		*/
		static nonceAdvance(params) {
			const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
			const data = encodeData(type$1);
			return new TransactionInstruction({
				keys: [
					{
						pubkey: params.noncePubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: params.authorizedPubkey,
						isSigner: true,
						isWritable: false
					}
				],
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction instruction that withdraws lamports from a Nonce account
		*/
		static nonceWithdraw(params) {
			const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
			const data = encodeData(type$1, { lamports: params.lamports });
			return new TransactionInstruction({
				keys: [
					{
						pubkey: params.noncePubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: params.toPubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: SYSVAR_RENT_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: params.authorizedPubkey,
						isSigner: true,
						isWritable: false
					}
				],
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction instruction that authorizes a new PublicKey as the authority
		* on a Nonce account.
		*/
		static nonceAuthorize(params) {
			const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
			const data = encodeData(type$1, { authorized: toBuffer(params.newAuthorizedPubkey.toBuffer()) });
			return new TransactionInstruction({
				keys: [{
					pubkey: params.noncePubkey,
					isSigner: false,
					isWritable: true
				}, {
					pubkey: params.authorizedPubkey,
					isSigner: true,
					isWritable: false
				}],
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction instruction that allocates space in an account without funding
		*/
		static allocate(params) {
			let data;
			let keys;
			if ("basePubkey" in params) {
				const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
				data = encodeData(type$1, {
					base: toBuffer(params.basePubkey.toBuffer()),
					seed: params.seed,
					space: params.space,
					programId: toBuffer(params.programId.toBuffer())
				});
				keys = [{
					pubkey: params.accountPubkey,
					isSigner: false,
					isWritable: true
				}, {
					pubkey: params.basePubkey,
					isSigner: true,
					isWritable: false
				}];
			} else {
				const type$1 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
				data = encodeData(type$1, { space: params.space });
				keys = [{
					pubkey: params.accountPubkey,
					isSigner: true,
					isWritable: true
				}];
			}
			return new TransactionInstruction({
				keys,
				programId: this.programId,
				data
			});
		}
	};
	SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
	CHUNK_SIZE = PACKET_DATA_SIZE - 300;
	Loader = class Loader {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Amount of program data placed in each load Transaction
		*/
		/**
		* Minimum number of signatures required to load a program not including
		* retries
		*
		* Can be used to calculate transaction fees
		*/
		static getMinNumSignatures(dataLength) {
			return 2 * (Math.ceil(dataLength / Loader.chunkSize) + 1 + 1);
		}
		/**
		* Loads a generic program
		*
		* @param connection The connection to use
		* @param payer System account that pays to load the program
		* @param program Account to load the program into
		* @param programId Public key that identifies the loader
		* @param data Program octets
		* @return true if program was loaded successfully, false if program was already loaded
		*/
		static async load(connection, payer, program, programId, data) {
			{
				const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
				const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
				let transaction = null;
				if (programInfo !== null) {
					if (programInfo.executable) {
						console.error("Program load failed, account is already executable");
						return false;
					}
					if (programInfo.data.length !== data.length) {
						transaction = transaction || new Transaction();
						transaction.add(SystemProgram.allocate({
							accountPubkey: program.publicKey,
							space: data.length
						}));
					}
					if (!programInfo.owner.equals(programId)) {
						transaction = transaction || new Transaction();
						transaction.add(SystemProgram.assign({
							accountPubkey: program.publicKey,
							programId
						}));
					}
					if (programInfo.lamports < balanceNeeded) {
						transaction = transaction || new Transaction();
						transaction.add(SystemProgram.transfer({
							fromPubkey: payer.publicKey,
							toPubkey: program.publicKey,
							lamports: balanceNeeded - programInfo.lamports
						}));
					}
				} else transaction = new Transaction().add(SystemProgram.createAccount({
					fromPubkey: payer.publicKey,
					newAccountPubkey: program.publicKey,
					lamports: balanceNeeded > 0 ? balanceNeeded : 1,
					space: data.length,
					programId
				}));
				if (transaction !== null) await sendAndConfirmTransaction(connection, transaction, [payer, program], { commitment: "confirmed" });
			}
			const dataLayout = import_Layout.struct([
				import_Layout.u32("instruction"),
				import_Layout.u32("offset"),
				import_Layout.u32("bytesLength"),
				import_Layout.u32("bytesLengthPadding"),
				import_Layout.seq(import_Layout.u8("byte"), import_Layout.offset(import_Layout.u32(), -8), "bytes")
			]);
			const chunkSize = Loader.chunkSize;
			let offset = 0;
			let array$1 = data;
			let transactions = [];
			while (array$1.length > 0) {
				const bytes = array$1.slice(0, chunkSize);
				const data$1 = import_buffer.Buffer.alloc(chunkSize + 16);
				dataLayout.encode({
					instruction: 0,
					offset,
					bytes,
					bytesLength: 0,
					bytesLengthPadding: 0
				}, data$1);
				const transaction = new Transaction().add({
					keys: [{
						pubkey: program.publicKey,
						isSigner: true,
						isWritable: true
					}],
					programId,
					data: data$1
				});
				transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], { commitment: "confirmed" }));
				if (connection._rpcEndpoint.includes("solana.com")) await sleep(1e3 / 4);
				offset += chunkSize;
				array$1 = array$1.slice(chunkSize);
			}
			await Promise.all(transactions);
			{
				const dataLayout$1 = import_Layout.struct([import_Layout.u32("instruction")]);
				const data$1 = import_buffer.Buffer.alloc(dataLayout$1.span);
				dataLayout$1.encode({ instruction: 1 }, data$1);
				const transaction = new Transaction().add({
					keys: [{
						pubkey: program.publicKey,
						isSigner: true,
						isWritable: true
					}, {
						pubkey: SYSVAR_RENT_PUBKEY,
						isSigner: false,
						isWritable: false
					}],
					programId,
					data: data$1
				});
				const deployCommitment = "processed";
				const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], { preflightCommitment: deployCommitment });
				const { context, value } = await connection.confirmTransaction({
					signature: finalizeSignature,
					lastValidBlockHeight: transaction.lastValidBlockHeight,
					blockhash: transaction.recentBlockhash
				}, deployCommitment);
				if (value.err) throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
				while (true) {
					try {
						if (await connection.getSlot({ commitment: deployCommitment }) > context.slot) break;
					} catch {}
					await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
				}
			}
			return true;
		}
	};
	Loader.chunkSize = CHUNK_SIZE;
	BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
	BpfLoader = class {
		/**
		* Minimum number of signatures required to load a program not including
		* retries
		*
		* Can be used to calculate transaction fees
		*/
		static getMinNumSignatures(dataLength) {
			return Loader.getMinNumSignatures(dataLength);
		}
		/**
		* Load a SBF program
		*
		* @param connection The connection to use
		* @param payer Account that will pay program loading fees
		* @param program Account to load the program into
		* @param elf The entire ELF containing the SBF program
		* @param loaderProgramId The program id of the BPF loader to use
		* @return true if program was loaded successfully, false if program was already loaded
		*/
		static load(connection, payer, program, elf, loaderProgramId) {
			return Loader.load(connection, payer, program, loaderProgramId, elf);
		}
	};
	;
	;
	fastStableStringify = /* @__PURE__ */ getDefaultExportFromCjs(/* @__PURE__ */ requireFastStableStringify());
	MINIMUM_SLOT_PER_EPOCH = 32;
	EpochSchedule = class {
		constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
			/** The maximum number of slots in each epoch */
			this.slotsPerEpoch = void 0;
			/** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */
			this.leaderScheduleSlotOffset = void 0;
			/** Indicates whether epochs start short and grow */
			this.warmup = void 0;
			/** The first epoch with `slotsPerEpoch` slots */
			this.firstNormalEpoch = void 0;
			/** The first slot of `firstNormalEpoch` */
			this.firstNormalSlot = void 0;
			this.slotsPerEpoch = slotsPerEpoch;
			this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
			this.warmup = warmup;
			this.firstNormalEpoch = firstNormalEpoch;
			this.firstNormalSlot = firstNormalSlot;
		}
		getEpoch(slot) {
			return this.getEpochAndSlotIndex(slot)[0];
		}
		getEpochAndSlotIndex(slot) {
			if (slot < this.firstNormalSlot) {
				const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
				return [epoch, slot - (this.getSlotsInEpoch(epoch) - MINIMUM_SLOT_PER_EPOCH)];
			} else {
				const normalSlotIndex = slot - this.firstNormalSlot;
				const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
				return [this.firstNormalEpoch + normalEpochIndex, normalSlotIndex % this.slotsPerEpoch];
			}
		}
		getFirstSlotInEpoch(epoch) {
			if (epoch <= this.firstNormalEpoch) return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
			else return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
		}
		getLastSlotInEpoch(epoch) {
			return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
		}
		getSlotsInEpoch(epoch) {
			if (epoch < this.firstNormalEpoch) return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
			else return this.slotsPerEpoch;
		}
	};
	fetchImpl = globalThis.fetch;
	RpcWebSocketClient = class extends CommonClient {
		constructor(address, options, generate_request_id) {
			const webSocketFactory = (url) => {
				const rpc = WebSocket(url, {
					autoconnect: true,
					max_reconnects: 5,
					reconnect: true,
					reconnect_interval: 1e3,
					...options
				});
				if ("socket" in rpc) this.underlyingSocket = rpc.socket;
				else this.underlyingSocket = rpc;
				return rpc;
			};
			super(webSocketFactory, address, options, generate_request_id);
			this.underlyingSocket = void 0;
		}
		call(...args) {
			const readyState = this.underlyingSocket?.readyState;
			if (readyState === 1) return super.call(...args);
			return Promise.reject(/* @__PURE__ */ new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
		}
		notify(...args) {
			const readyState = this.underlyingSocket?.readyState;
			if (readyState === 1) return super.notify(...args);
			return Promise.reject(/* @__PURE__ */ new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
		}
	};
	LOOKUP_TABLE_META_SIZE = 56;
	AddressLookupTableAccount = class {
		constructor(args) {
			this.key = void 0;
			this.state = void 0;
			this.key = args.key;
			this.state = args.state;
		}
		isActive() {
			const U64_MAX = BigInt("0xffffffffffffffff");
			return this.state.deactivationSlot === U64_MAX;
		}
		static deserialize(accountData) {
			const meta = decodeData(LookupTableMetaLayout, accountData);
			const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
			assert$1(serializedAddressesLen >= 0, "lookup table is invalid");
			assert$1(serializedAddressesLen % 32 === 0, "lookup table is invalid");
			const numSerializedAddresses = serializedAddressesLen / 32;
			const { addresses } = import_Layout.struct([import_Layout.seq(publicKey(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
			return {
				deactivationSlot: meta.deactivationSlot,
				lastExtendedSlot: meta.lastExtendedSlot,
				lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
				authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : void 0,
				addresses: addresses.map((address) => new PublicKey(address))
			};
		}
	};
	LookupTableMetaLayout = {
		index: 1,
		layout: import_Layout.struct([
			import_Layout.u32("typeIndex"),
			u64("deactivationSlot"),
			import_Layout.nu64("lastExtendedSlot"),
			import_Layout.u8("lastExtendedStartIndex"),
			import_Layout.u8(),
			import_Layout.seq(publicKey(), import_Layout.offset(import_Layout.u8(), -1), "authority")
		])
	};
	URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
	PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));
	RawAccountDataResult = tuple([string(), literal("base64")]);
	BufferFromRawAccountData = coerce(instance(import_buffer.Buffer), RawAccountDataResult, (value) => import_buffer.Buffer.from(value[0], "base64"));
	BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
	UnknownRpcResult = createRpcResult(unknown());
	GetInflationGovernorResult = type({
		foundation: number(),
		foundationTerm: number(),
		initial: number(),
		taper: number(),
		terminal: number()
	});
	GetInflationRewardResult = jsonRpcResult(array(nullable(type({
		epoch: number(),
		effectiveSlot: number(),
		amount: number(),
		postBalance: number(),
		commission: optional(nullable(number()))
	}))));
	GetRecentPrioritizationFeesResult = array(type({
		slot: number(),
		prioritizationFee: number()
	}));
	GetInflationRateResult = type({
		total: number(),
		validator: number(),
		foundation: number(),
		epoch: number()
	});
	GetEpochInfoResult = type({
		epoch: number(),
		slotIndex: number(),
		slotsInEpoch: number(),
		absoluteSlot: number(),
		blockHeight: optional(number()),
		transactionCount: optional(number())
	});
	GetEpochScheduleResult = type({
		slotsPerEpoch: number(),
		leaderScheduleSlotOffset: number(),
		warmup: boolean(),
		firstNormalEpoch: number(),
		firstNormalSlot: number()
	});
	GetLeaderScheduleResult = record(string(), array(number()));
	TransactionErrorResult = nullable(union([type({}), string()]));
	SignatureStatusResult = type({ err: TransactionErrorResult });
	SignatureReceivedResult = literal("receivedSignature");
	VersionResult = type({
		"solana-core": string(),
		"feature-set": optional(number())
	});
	ParsedInstructionStruct = type({
		program: string(),
		programId: PublicKeyFromString,
		parsed: unknown()
	});
	PartiallyDecodedInstructionStruct = type({
		programId: PublicKeyFromString,
		accounts: array(PublicKeyFromString),
		data: string()
	});
	SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
		err: nullable(union([type({}), string()])),
		logs: nullable(array(string())),
		accounts: optional(nullable(array(nullable(type({
			executable: boolean(),
			owner: string(),
			lamports: number(),
			data: array(string()),
			rentEpoch: optional(number())
		}))))),
		unitsConsumed: optional(number()),
		returnData: optional(nullable(type({
			programId: string(),
			data: tuple([string(), literal("base64")])
		}))),
		innerInstructions: optional(nullable(array(type({
			index: number(),
			instructions: array(union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
		}))))
	}));
	BlockProductionResponseStruct = jsonRpcResultAndContext(type({
		byIdentity: record(string(), array(number())),
		range: type({
			firstSlot: number(),
			lastSlot: number()
		})
	}));
	GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
	GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
	GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
	GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
	GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
	GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
	SlotRpcResult = jsonRpcResult(number());
	GetSupplyRpcResult = jsonRpcResultAndContext(type({
		total: number(),
		circulating: number(),
		nonCirculating: number(),
		nonCirculatingAccounts: array(PublicKeyFromString)
	}));
	TokenAmountResult = type({
		amount: string(),
		uiAmount: nullable(number()),
		decimals: number(),
		uiAmountString: optional(string())
	});
	GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
		address: PublicKeyFromString,
		amount: string(),
		uiAmount: nullable(number()),
		decimals: number(),
		uiAmountString: optional(string())
	})));
	GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
		pubkey: PublicKeyFromString,
		account: type({
			executable: boolean(),
			owner: PublicKeyFromString,
			lamports: number(),
			data: BufferFromRawAccountData,
			rentEpoch: number()
		})
	})));
	ParsedAccountDataResult = type({
		program: string(),
		parsed: unknown(),
		space: number()
	});
	GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
		pubkey: PublicKeyFromString,
		account: type({
			executable: boolean(),
			owner: PublicKeyFromString,
			lamports: number(),
			data: ParsedAccountDataResult,
			rentEpoch: number()
		})
	})));
	GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
		lamports: number(),
		address: PublicKeyFromString
	})));
	AccountInfoResult = type({
		executable: boolean(),
		owner: PublicKeyFromString,
		lamports: number(),
		data: BufferFromRawAccountData,
		rentEpoch: number()
	});
	KeyedAccountInfoResult = type({
		pubkey: PublicKeyFromString,
		account: AccountInfoResult
	});
	ParsedOrRawAccountData = coerce(union([instance(import_buffer.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
		if (Array.isArray(value)) return create(value, BufferFromRawAccountData);
		else return value;
	});
	ParsedAccountInfoResult = type({
		executable: boolean(),
		owner: PublicKeyFromString,
		lamports: number(),
		data: ParsedOrRawAccountData,
		rentEpoch: number()
	});
	KeyedParsedAccountInfoResult = type({
		pubkey: PublicKeyFromString,
		account: ParsedAccountInfoResult
	});
	StakeActivationResult = type({
		state: union([
			literal("active"),
			literal("inactive"),
			literal("activating"),
			literal("deactivating")
		]),
		active: number(),
		inactive: number()
	});
	GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
		signature: string(),
		slot: number(),
		err: TransactionErrorResult,
		memo: nullable(string()),
		blockTime: optional(nullable(number()))
	})));
	GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
		signature: string(),
		slot: number(),
		err: TransactionErrorResult,
		memo: nullable(string()),
		blockTime: optional(nullable(number()))
	})));
	AccountNotificationResult = type({
		subscription: number(),
		result: notificationResultAndContext(AccountInfoResult)
	});
	ProgramAccountInfoResult = type({
		pubkey: PublicKeyFromString,
		account: AccountInfoResult
	});
	ProgramAccountNotificationResult = type({
		subscription: number(),
		result: notificationResultAndContext(ProgramAccountInfoResult)
	});
	SlotInfoResult = type({
		parent: number(),
		slot: number(),
		root: number()
	});
	SlotNotificationResult = type({
		subscription: number(),
		result: SlotInfoResult
	});
	SlotUpdateResult = union([
		type({
			type: union([
				literal("firstShredReceived"),
				literal("completed"),
				literal("optimisticConfirmation"),
				literal("root")
			]),
			slot: number(),
			timestamp: number()
		}),
		type({
			type: literal("createdBank"),
			parent: number(),
			slot: number(),
			timestamp: number()
		}),
		type({
			type: literal("frozen"),
			slot: number(),
			timestamp: number(),
			stats: type({
				numTransactionEntries: number(),
				numSuccessfulTransactions: number(),
				numFailedTransactions: number(),
				maxTransactionsPerEntry: number()
			})
		}),
		type({
			type: literal("dead"),
			slot: number(),
			timestamp: number(),
			err: string()
		})
	]);
	SlotUpdateNotificationResult = type({
		subscription: number(),
		result: SlotUpdateResult
	});
	SignatureNotificationResult = type({
		subscription: number(),
		result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
	});
	RootNotificationResult = type({
		subscription: number(),
		result: number()
	});
	ContactInfoResult = type({
		pubkey: string(),
		gossip: nullable(string()),
		tpu: nullable(string()),
		rpc: nullable(string()),
		version: nullable(string())
	});
	VoteAccountInfoResult = type({
		votePubkey: string(),
		nodePubkey: string(),
		activatedStake: number(),
		epochVoteAccount: boolean(),
		epochCredits: array(tuple([
			number(),
			number(),
			number()
		])),
		commission: number(),
		lastVote: number(),
		rootSlot: nullable(number())
	});
	GetVoteAccounts = jsonRpcResult(type({
		current: array(VoteAccountInfoResult),
		delinquent: array(VoteAccountInfoResult)
	}));
	ConfirmationStatus = union([
		literal("processed"),
		literal("confirmed"),
		literal("finalized")
	]);
	GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(type({
		slot: number(),
		confirmations: nullable(number()),
		err: TransactionErrorResult,
		confirmationStatus: optional(ConfirmationStatus)
	}))));
	GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());
	AddressTableLookupStruct = type({
		accountKey: PublicKeyFromString,
		writableIndexes: array(number()),
		readonlyIndexes: array(number())
	});
	ConfirmedTransactionResult = type({
		signatures: array(string()),
		message: type({
			accountKeys: array(string()),
			header: type({
				numRequiredSignatures: number(),
				numReadonlySignedAccounts: number(),
				numReadonlyUnsignedAccounts: number()
			}),
			instructions: array(type({
				accounts: array(number()),
				data: string(),
				programIdIndex: number()
			})),
			recentBlockhash: string(),
			addressTableLookups: optional(array(AddressTableLookupStruct))
		})
	});
	AnnotatedAccountKey = type({
		pubkey: PublicKeyFromString,
		signer: boolean(),
		writable: boolean(),
		source: optional(union([literal("transaction"), literal("lookupTable")]))
	});
	ConfirmedTransactionAccountsModeResult = type({
		accountKeys: array(AnnotatedAccountKey),
		signatures: array(string())
	});
	ParsedInstructionResult = type({
		parsed: unknown(),
		program: string(),
		programId: PublicKeyFromString
	});
	RawInstructionResult = type({
		accounts: array(PublicKeyFromString),
		data: string(),
		programId: PublicKeyFromString
	});
	ParsedOrRawInstruction = coerce(union([RawInstructionResult, ParsedInstructionResult]), union([type({
		parsed: unknown(),
		program: string(),
		programId: string()
	}), type({
		accounts: array(string()),
		data: string(),
		programId: string()
	})]), (value) => {
		if ("accounts" in value) return create(value, RawInstructionResult);
		else return create(value, ParsedInstructionResult);
	});
	ParsedConfirmedTransactionResult = type({
		signatures: array(string()),
		message: type({
			accountKeys: array(AnnotatedAccountKey),
			instructions: array(ParsedOrRawInstruction),
			recentBlockhash: string(),
			addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
		})
	});
	TokenBalanceResult = type({
		accountIndex: number(),
		mint: string(),
		owner: optional(string()),
		programId: optional(string()),
		uiTokenAmount: TokenAmountResult
	});
	LoadedAddressesResult = type({
		writable: array(PublicKeyFromString),
		readonly: array(PublicKeyFromString)
	});
	ConfirmedTransactionMetaResult = type({
		err: TransactionErrorResult,
		fee: number(),
		innerInstructions: optional(nullable(array(type({
			index: number(),
			instructions: array(type({
				accounts: array(number()),
				data: string(),
				programIdIndex: number()
			}))
		})))),
		preBalances: array(number()),
		postBalances: array(number()),
		logMessages: optional(nullable(array(string()))),
		preTokenBalances: optional(nullable(array(TokenBalanceResult))),
		postTokenBalances: optional(nullable(array(TokenBalanceResult))),
		loadedAddresses: optional(LoadedAddressesResult),
		computeUnitsConsumed: optional(number()),
		costUnits: optional(number())
	});
	ParsedConfirmedTransactionMetaResult = type({
		err: TransactionErrorResult,
		fee: number(),
		innerInstructions: optional(nullable(array(type({
			index: number(),
			instructions: array(ParsedOrRawInstruction)
		})))),
		preBalances: array(number()),
		postBalances: array(number()),
		logMessages: optional(nullable(array(string()))),
		preTokenBalances: optional(nullable(array(TokenBalanceResult))),
		postTokenBalances: optional(nullable(array(TokenBalanceResult))),
		loadedAddresses: optional(LoadedAddressesResult),
		computeUnitsConsumed: optional(number()),
		costUnits: optional(number())
	});
	TransactionVersionStruct = union([literal(0), literal("legacy")]);
	RewardsResult = type({
		pubkey: string(),
		lamports: number(),
		postBalance: nullable(number()),
		rewardType: nullable(string()),
		commission: optional(nullable(number()))
	});
	GetBlockRpcResult = jsonRpcResult(nullable(type({
		blockhash: string(),
		previousBlockhash: string(),
		parentSlot: number(),
		transactions: array(type({
			transaction: ConfirmedTransactionResult,
			meta: nullable(ConfirmedTransactionMetaResult),
			version: optional(TransactionVersionStruct)
		})),
		rewards: optional(array(RewardsResult)),
		blockTime: nullable(number()),
		blockHeight: nullable(number())
	})));
	GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
		blockhash: string(),
		previousBlockhash: string(),
		parentSlot: number(),
		rewards: optional(array(RewardsResult)),
		blockTime: nullable(number()),
		blockHeight: nullable(number())
	})));
	GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
		blockhash: string(),
		previousBlockhash: string(),
		parentSlot: number(),
		transactions: array(type({
			transaction: ConfirmedTransactionAccountsModeResult,
			meta: nullable(ConfirmedTransactionMetaResult),
			version: optional(TransactionVersionStruct)
		})),
		rewards: optional(array(RewardsResult)),
		blockTime: nullable(number()),
		blockHeight: nullable(number())
	})));
	GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
		blockhash: string(),
		previousBlockhash: string(),
		parentSlot: number(),
		transactions: array(type({
			transaction: ParsedConfirmedTransactionResult,
			meta: nullable(ParsedConfirmedTransactionMetaResult),
			version: optional(TransactionVersionStruct)
		})),
		rewards: optional(array(RewardsResult)),
		blockTime: nullable(number()),
		blockHeight: nullable(number())
	})));
	GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
		blockhash: string(),
		previousBlockhash: string(),
		parentSlot: number(),
		transactions: array(type({
			transaction: ConfirmedTransactionAccountsModeResult,
			meta: nullable(ParsedConfirmedTransactionMetaResult),
			version: optional(TransactionVersionStruct)
		})),
		rewards: optional(array(RewardsResult)),
		blockTime: nullable(number()),
		blockHeight: nullable(number())
	})));
	GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
		blockhash: string(),
		previousBlockhash: string(),
		parentSlot: number(),
		rewards: optional(array(RewardsResult)),
		blockTime: nullable(number()),
		blockHeight: nullable(number())
	})));
	GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
		blockhash: string(),
		previousBlockhash: string(),
		parentSlot: number(),
		transactions: array(type({
			transaction: ConfirmedTransactionResult,
			meta: nullable(ConfirmedTransactionMetaResult)
		})),
		rewards: optional(array(RewardsResult)),
		blockTime: nullable(number())
	})));
	GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
		blockhash: string(),
		previousBlockhash: string(),
		parentSlot: number(),
		signatures: array(string()),
		blockTime: nullable(number())
	})));
	GetTransactionRpcResult = jsonRpcResult(nullable(type({
		slot: number(),
		meta: nullable(ConfirmedTransactionMetaResult),
		blockTime: optional(nullable(number())),
		transaction: ConfirmedTransactionResult,
		version: optional(TransactionVersionStruct)
	})));
	GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
		slot: number(),
		transaction: ParsedConfirmedTransactionResult,
		meta: nullable(ParsedConfirmedTransactionMetaResult),
		blockTime: optional(nullable(number())),
		version: optional(TransactionVersionStruct)
	})));
	GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
		blockhash: string(),
		lastValidBlockHeight: number()
	}));
	IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());
	GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(type({
		slot: number(),
		numTransactions: number(),
		numSlots: number(),
		samplePeriodSecs: number()
	})));
	GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({ feeCalculator: type({ lamportsPerSignature: number() }) })));
	RequestAirdropRpcResult = jsonRpcResult(string());
	SendTransactionRpcResult = jsonRpcResult(string());
	LogsNotificationResult = type({
		result: notificationResultAndContext(type({
			err: TransactionErrorResult,
			logs: array(string()),
			signature: string()
		})),
		subscription: number()
	});
	COMMON_HTTP_HEADERS = { "solana-client": `js/1.0.0-maintenance` };
	Connection = class {
		/**
		* Establish a JSON RPC connection
		*
		* @param endpoint URL to the fullnode JSON RPC endpoint
		* @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
		*/
		constructor(endpoint$1, _commitmentOrConfig) {
			/** @internal */
			this._commitment = void 0;
			/** @internal */
			this._confirmTransactionInitialTimeout = void 0;
			/** @internal */
			this._rpcEndpoint = void 0;
			/** @internal */
			this._rpcWsEndpoint = void 0;
			/** @internal */
			this._rpcClient = void 0;
			/** @internal */
			this._rpcRequest = void 0;
			/** @internal */
			this._rpcBatchRequest = void 0;
			/** @internal */
			this._rpcWebSocket = void 0;
			/** @internal */
			this._rpcWebSocketConnected = false;
			/** @internal */
			this._rpcWebSocketHeartbeat = null;
			/** @internal */
			this._rpcWebSocketIdleTimeout = null;
			/** @internal
			* A number that we increment every time an active connection closes.
			* Used to determine whether the same socket connection that was open
			* when an async operation started is the same one that's active when
			* its continuation fires.
			*
			*/
			this._rpcWebSocketGeneration = 0;
			/** @internal */
			this._disableBlockhashCaching = false;
			/** @internal */
			this._pollingBlockhash = false;
			/** @internal */
			this._blockhashInfo = {
				latestBlockhash: null,
				lastFetch: 0,
				transactionSignatures: [],
				simulatedSignatures: []
			};
			/** @internal */
			this._nextClientSubscriptionId = 0;
			/** @internal */
			this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
			/** @internal */
			this._subscriptionHashByClientSubscriptionId = {};
			/** @internal */
			this._subscriptionStateChangeCallbacksByHash = {};
			/** @internal */
			this._subscriptionCallbacksByServerSubscriptionId = {};
			/** @internal */
			this._subscriptionsByHash = {};
			/**
			* Special case.
			* After a signature is processed, RPCs automatically dispose of the
			* subscription on the server side. We need to track which of these
			* subscriptions have been disposed in such a way, so that we know
			* whether the client is dealing with a not-yet-processed signature
			* (in which case we must tear down the server subscription) or an
			* already-processed signature (in which case the client can simply
			* clear out the subscription locally without telling the server).
			*
			* NOTE: There is a proposal to eliminate this special case, here:
			* https://github.com/solana-labs/solana/issues/18892
			*/
			/** @internal */
			this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
			this.getBlockHeight = (() => {
				const requestPromises = {};
				return async (commitmentOrConfig) => {
					const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
					const args = this._buildArgs([], commitment, void 0, config);
					const requestHash = fastStableStringify(args);
					requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
						try {
							const res = create(await this._rpcRequest("getBlockHeight", args), jsonRpcResult(number()));
							if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get block height information");
							return res.result;
						} finally {
							delete requestPromises[requestHash];
						}
					})();
					return await requestPromises[requestHash];
				};
			})();
			let wsEndpoint;
			let httpHeaders;
			let fetch;
			let fetchMiddleware;
			let disableRetryOnRateLimit;
			let httpAgent;
			if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") this._commitment = _commitmentOrConfig;
			else if (_commitmentOrConfig) {
				this._commitment = _commitmentOrConfig.commitment;
				this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
				wsEndpoint = _commitmentOrConfig.wsEndpoint;
				httpHeaders = _commitmentOrConfig.httpHeaders;
				fetch = _commitmentOrConfig.fetch;
				fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
				disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
				httpAgent = _commitmentOrConfig.httpAgent;
			}
			this._rpcEndpoint = assertEndpointUrl(endpoint$1);
			this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint$1);
			this._rpcClient = createRpcClient(endpoint$1, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
			this._rpcRequest = createRpcRequest(this._rpcClient);
			this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
			this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
				autoconnect: false,
				max_reconnects: Infinity
			});
			this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
			this._rpcWebSocket.on("error", this._wsOnError.bind(this));
			this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
			this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
			this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
			this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
			this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
			this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
			this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
			this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
		}
		/**
		* The default commitment used for requests
		*/
		get commitment() {
			return this._commitment;
		}
		/**
		* The RPC endpoint
		*/
		get rpcEndpoint() {
			return this._rpcEndpoint;
		}
		/**
		* Fetch the balance for the specified public key, return with context
		*/
		async getBalanceAndContext(publicKey$1, commitmentOrConfig) {
			/** @internal */
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([publicKey$1.toBase58()], commitment, void 0, config);
			const res = create(await this._rpcRequest("getBalance", args), jsonRpcResultAndContext(number()));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey$1.toBase58()}`);
			return res.result;
		}
		/**
		* Fetch the balance for the specified public key
		*/
		async getBalance(publicKey$1, commitmentOrConfig) {
			return await this.getBalanceAndContext(publicKey$1, commitmentOrConfig).then((x) => x.value).catch((e) => {
				throw new Error("failed to get balance of account " + publicKey$1.toBase58() + ": " + e);
			});
		}
		/**
		* Fetch the estimated production time of a block
		*/
		async getBlockTime(slot) {
			const res = create(await this._rpcRequest("getBlockTime", [slot]), jsonRpcResult(nullable(number())));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
			return res.result;
		}
		/**
		* Fetch the lowest slot that the node has information about in its ledger.
		* This value may increase over time if the node is configured to purge older ledger data
		*/
		async getMinimumLedgerSlot() {
			const res = create(await this._rpcRequest("minimumLedgerSlot", []), jsonRpcResult(number()));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
			return res.result;
		}
		/**
		* Fetch the slot of the lowest confirmed block that has not been purged from the ledger
		*/
		async getFirstAvailableBlock() {
			const res = create(await this._rpcRequest("getFirstAvailableBlock", []), SlotRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get first available block");
			return res.result;
		}
		/**
		* Fetch information about the current supply
		*/
		async getSupply(config) {
			let configArg = {};
			if (typeof config === "string") configArg = { commitment: config };
			else if (config) configArg = {
				...config,
				commitment: config && config.commitment || this.commitment
			};
			else configArg = { commitment: this.commitment };
			const res = create(await this._rpcRequest("getSupply", [configArg]), GetSupplyRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get supply");
			return res.result;
		}
		/**
		* Fetch the current supply of a token mint
		*/
		async getTokenSupply(tokenMintAddress, commitment) {
			const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
			const res = create(await this._rpcRequest("getTokenSupply", args), jsonRpcResultAndContext(TokenAmountResult));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get token supply");
			return res.result;
		}
		/**
		* Fetch the current balance of a token account
		*/
		async getTokenAccountBalance(tokenAddress, commitment) {
			const args = this._buildArgs([tokenAddress.toBase58()], commitment);
			const res = create(await this._rpcRequest("getTokenAccountBalance", args), jsonRpcResultAndContext(TokenAmountResult));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
			return res.result;
		}
		/**
		* Fetch all the token accounts owned by the specified account
		*
		* @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
		*/
		async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			let _args = [ownerAddress.toBase58()];
			if ("mint" in filter) _args.push({ mint: filter.mint.toBase58() });
			else _args.push({ programId: filter.programId.toBase58() });
			const args = this._buildArgs(_args, commitment, "base64", config);
			const res = create(await this._rpcRequest("getTokenAccountsByOwner", args), GetTokenAccountsByOwner);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
			return res.result;
		}
		/**
		* Fetch parsed token accounts owned by the specified account
		*
		* @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
		*/
		async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
			let _args = [ownerAddress.toBase58()];
			if ("mint" in filter) _args.push({ mint: filter.mint.toBase58() });
			else _args.push({ programId: filter.programId.toBase58() });
			const args = this._buildArgs(_args, commitment, "jsonParsed");
			const res = create(await this._rpcRequest("getTokenAccountsByOwner", args), GetParsedTokenAccountsByOwner);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
			return res.result;
		}
		/**
		* Fetch the 20 largest accounts with their current balances
		*/
		async getLargestAccounts(config) {
			const arg = {
				...config,
				commitment: config && config.commitment || this.commitment
			};
			const args = arg.filter || arg.commitment ? [arg] : [];
			const res = create(await this._rpcRequest("getLargestAccounts", args), GetLargestAccountsRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
			return res.result;
		}
		/**
		* Fetch the 20 largest token accounts with their current balances
		* for a given mint.
		*/
		async getTokenLargestAccounts(mintAddress, commitment) {
			const args = this._buildArgs([mintAddress.toBase58()], commitment);
			const res = create(await this._rpcRequest("getTokenLargestAccounts", args), GetTokenLargestAccountsResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
			return res.result;
		}
		/**
		* Fetch all the account info for the specified public key, return with context
		*/
		async getAccountInfoAndContext(publicKey$1, commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([publicKey$1.toBase58()], commitment, "base64", config);
			const res = create(await this._rpcRequest("getAccountInfo", args), jsonRpcResultAndContext(nullable(AccountInfoResult)));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey$1.toBase58()}`);
			return res.result;
		}
		/**
		* Fetch parsed account info for the specified public key
		*/
		async getParsedAccountInfo(publicKey$1, commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([publicKey$1.toBase58()], commitment, "jsonParsed", config);
			const res = create(await this._rpcRequest("getAccountInfo", args), jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey$1.toBase58()}`);
			return res.result;
		}
		/**
		* Fetch all the account info for the specified public key
		*/
		async getAccountInfo(publicKey$1, commitmentOrConfig) {
			try {
				return (await this.getAccountInfoAndContext(publicKey$1, commitmentOrConfig)).value;
			} catch (e) {
				throw new Error("failed to get info about account " + publicKey$1.toBase58() + ": " + e);
			}
		}
		/**
		* Fetch all the account info for multiple accounts specified by an array of public keys, return with context
		*/
		async getMultipleParsedAccounts(publicKeys, rawConfig) {
			const { commitment, config } = extractCommitmentFromConfig(rawConfig);
			const keys = publicKeys.map((key) => key.toBase58());
			const args = this._buildArgs([keys], commitment, "jsonParsed", config);
			const res = create(await this._rpcRequest("getMultipleAccounts", args), jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
			return res.result;
		}
		/**
		* Fetch all the account info for multiple accounts specified by an array of public keys, return with context
		*/
		async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const keys = publicKeys.map((key) => key.toBase58());
			const args = this._buildArgs([keys], commitment, "base64", config);
			const res = create(await this._rpcRequest("getMultipleAccounts", args), jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
			return res.result;
		}
		/**
		* Fetch all the account info for multiple accounts specified by an array of public keys
		*/
		async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
			return (await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig)).value;
		}
		/**
		* Returns epoch activation information for a stake account that has been delegated
		*
		* @deprecated Deprecated since RPC v1.18; will be removed in a future version.
		*/
		async getStakeActivation(publicKey$1, commitmentOrConfig, epoch) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([publicKey$1.toBase58()], commitment, void 0, {
				...config,
				epoch: epoch != null ? epoch : config?.epoch
			});
			const res = create(await this._rpcRequest("getStakeActivation", args), jsonRpcResult(StakeActivationResult));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey$1.toBase58()}`);
			return res.result;
		}
		/**
		* Fetch all the accounts owned by the specified program id
		*
		* @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
		*/
		async getProgramAccounts(programId, configOrCommitment) {
			const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);
			const { encoding: encoding$1, ...configWithoutEncoding } = config || {};
			const args = this._buildArgs([programId.toBase58()], commitment, encoding$1 || "base64", {
				...configWithoutEncoding,
				...configWithoutEncoding.filters ? { filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters) } : null
			});
			const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
			const baseSchema = array(KeyedAccountInfoResult);
			const res = configWithoutEncoding.withContext === true ? create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : create(unsafeRes, jsonRpcResult(baseSchema));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
			return res.result;
		}
		/**
		* Fetch and parse all the accounts owned by the specified program id
		*
		* @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
		*/
		async getParsedProgramAccounts(programId, configOrCommitment) {
			const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);
			const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
			const res = create(await this._rpcRequest("getProgramAccounts", args), jsonRpcResult(array(KeyedParsedAccountInfoResult)));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
			return res.result;
		}
		/** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
		async confirmTransaction(strategy, commitment) {
			let rawSignature;
			if (typeof strategy == "string") rawSignature = strategy;
			else {
				const config = strategy;
				if (config.abortSignal?.aborted) return Promise.reject(config.abortSignal.reason);
				rawSignature = config.signature;
			}
			let decodedSignature;
			try {
				decodedSignature = import_bs58.default.decode(rawSignature);
			} catch (err) {
				throw new Error("signature must be base58 encoded: " + rawSignature);
			}
			assert$1(decodedSignature.length === 64, "signature has invalid length");
			if (typeof strategy === "string") return await this.confirmTransactionUsingLegacyTimeoutStrategy({
				commitment: commitment || this.commitment,
				signature: rawSignature
			});
			else if ("lastValidBlockHeight" in strategy) return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
				commitment: commitment || this.commitment,
				strategy
			});
			else return await this.confirmTransactionUsingDurableNonceStrategy({
				commitment: commitment || this.commitment,
				strategy
			});
		}
		getCancellationPromise(signal) {
			return new Promise((_, reject) => {
				if (signal == null) return;
				if (signal.aborted) reject(signal.reason);
				else signal.addEventListener("abort", () => {
					reject(signal.reason);
				});
			});
		}
		getTransactionConfirmationPromise({ commitment, signature: signature$1 }) {
			let signatureSubscriptionId;
			let disposeSignatureSubscriptionStateChangeObserver;
			let done = false;
			const confirmationPromise = new Promise((resolve, reject) => {
				try {
					signatureSubscriptionId = this.onSignature(signature$1, (result, context) => {
						signatureSubscriptionId = void 0;
						const response = {
							context,
							value: result
						};
						resolve({
							__type: TransactionStatus.PROCESSED,
							response
						});
					}, commitment);
					const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
						if (signatureSubscriptionId == null) resolveSubscriptionSetup();
						else disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
							if (nextState === "subscribed") resolveSubscriptionSetup();
						});
					});
					(async () => {
						await subscriptionSetupPromise;
						if (done) return;
						const response = await this.getSignatureStatus(signature$1);
						if (done) return;
						if (response == null) return;
						const { context, value } = response;
						if (value == null) return;
						if (value?.err) reject(value.err);
						else {
							switch (commitment) {
								case "confirmed":
								case "single":
								case "singleGossip":
									if (value.confirmationStatus === "processed") return;
									break;
								case "finalized":
								case "max":
								case "root":
									if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") return;
									break;
								case "processed":
								case "recent":
							}
							done = true;
							resolve({
								__type: TransactionStatus.PROCESSED,
								response: {
									context,
									value
								}
							});
						}
					})();
				} catch (err) {
					reject(err);
				}
			});
			const abortConfirmation = () => {
				if (disposeSignatureSubscriptionStateChangeObserver) {
					disposeSignatureSubscriptionStateChangeObserver();
					disposeSignatureSubscriptionStateChangeObserver = void 0;
				}
				if (signatureSubscriptionId != null) {
					this.removeSignatureListener(signatureSubscriptionId);
					signatureSubscriptionId = void 0;
				}
			};
			return {
				abortConfirmation,
				confirmationPromise
			};
		}
		async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature: signature$1 } }) {
			let done = false;
			const expiryPromise = new Promise((resolve) => {
				const checkBlockHeight = async () => {
					try {
						return await this.getBlockHeight(commitment);
					} catch (_e) {
						return -1;
					}
				};
				(async () => {
					let currentBlockHeight = await checkBlockHeight();
					if (done) return;
					while (currentBlockHeight <= lastValidBlockHeight) {
						await sleep(1e3);
						if (done) return;
						currentBlockHeight = await checkBlockHeight();
						if (done) return;
					}
					resolve({ __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED });
				})();
			});
			const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({
				commitment,
				signature: signature$1
			});
			const cancellationPromise = this.getCancellationPromise(abortSignal);
			let result;
			try {
				const outcome = await Promise.race([
					cancellationPromise,
					confirmationPromise,
					expiryPromise
				]);
				if (outcome.__type === TransactionStatus.PROCESSED) result = outcome.response;
				else throw new TransactionExpiredBlockheightExceededError(signature$1);
			} finally {
				done = true;
				abortConfirmation();
			}
			return result;
		}
		async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature: signature$1 } }) {
			let done = false;
			const expiryPromise = new Promise((resolve) => {
				let currentNonceValue = nonceValue;
				let lastCheckedSlot = null;
				const getCurrentNonceValue = async () => {
					try {
						const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {
							commitment,
							minContextSlot
						});
						lastCheckedSlot = context.slot;
						return nonceAccount?.nonce;
					} catch (e) {
						return currentNonceValue;
					}
				};
				(async () => {
					currentNonceValue = await getCurrentNonceValue();
					if (done) return;
					while (true) {
						if (nonceValue !== currentNonceValue) {
							resolve({
								__type: TransactionStatus.NONCE_INVALID,
								slotInWhichNonceDidAdvance: lastCheckedSlot
							});
							return;
						}
						await sleep(2e3);
						if (done) return;
						currentNonceValue = await getCurrentNonceValue();
						if (done) return;
					}
				})();
			});
			const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({
				commitment,
				signature: signature$1
			});
			const cancellationPromise = this.getCancellationPromise(abortSignal);
			let result;
			try {
				const outcome = await Promise.race([
					cancellationPromise,
					confirmationPromise,
					expiryPromise
				]);
				if (outcome.__type === TransactionStatus.PROCESSED) result = outcome.response;
				else {
					let signatureStatus;
					while (true) {
						const status = await this.getSignatureStatus(signature$1);
						if (status == null) break;
						if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
							await sleep(400);
							continue;
						}
						signatureStatus = status;
						break;
					}
					if (signatureStatus?.value) {
						const commitmentForStatus = commitment || "finalized";
						const { confirmationStatus } = signatureStatus.value;
						switch (commitmentForStatus) {
							case "processed":
							case "recent":
								if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") throw new TransactionExpiredNonceInvalidError(signature$1);
								break;
							case "confirmed":
							case "single":
							case "singleGossip":
								if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") throw new TransactionExpiredNonceInvalidError(signature$1);
								break;
							case "finalized":
							case "max":
							case "root":
								if (confirmationStatus !== "finalized") throw new TransactionExpiredNonceInvalidError(signature$1);
								break;
							default: ((_) => {})(commitmentForStatus);
						}
						result = {
							context: signatureStatus.context,
							value: { err: signatureStatus.value.err }
						};
					} else throw new TransactionExpiredNonceInvalidError(signature$1);
				}
			} finally {
				done = true;
				abortConfirmation();
			}
			return result;
		}
		async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature: signature$1 }) {
			let timeoutId;
			const expiryPromise = new Promise((resolve) => {
				let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
				switch (commitment) {
					case "processed":
					case "recent":
					case "single":
					case "confirmed":
					case "singleGossip":
						timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
						break;
				}
				timeoutId = setTimeout(() => resolve({
					__type: TransactionStatus.TIMED_OUT,
					timeoutMs
				}), timeoutMs);
			});
			const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({
				commitment,
				signature: signature$1
			});
			let result;
			try {
				const outcome = await Promise.race([confirmationPromise, expiryPromise]);
				if (outcome.__type === TransactionStatus.PROCESSED) result = outcome.response;
				else throw new TransactionExpiredTimeoutError(signature$1, outcome.timeoutMs / 1e3);
			} finally {
				clearTimeout(timeoutId);
				abortConfirmation();
			}
			return result;
		}
		/**
		* Return the list of nodes that are currently participating in the cluster
		*/
		async getClusterNodes() {
			const res = create(await this._rpcRequest("getClusterNodes", []), jsonRpcResult(array(ContactInfoResult)));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
			return res.result;
		}
		/**
		* Return the list of nodes that are currently participating in the cluster
		*/
		async getVoteAccounts(commitment) {
			const args = this._buildArgs([], commitment);
			const res = create(await this._rpcRequest("getVoteAccounts", args), GetVoteAccounts);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
			return res.result;
		}
		/**
		* Fetch the current slot that the node is processing
		*/
		async getSlot(commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([], commitment, void 0, config);
			const res = create(await this._rpcRequest("getSlot", args), jsonRpcResult(number()));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get slot");
			return res.result;
		}
		/**
		* Fetch the current slot leader of the cluster
		*/
		async getSlotLeader(commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([], commitment, void 0, config);
			const res = create(await this._rpcRequest("getSlotLeader", args), jsonRpcResult(string()));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
			return res.result;
		}
		/**
		* Fetch `limit` number of slot leaders starting from `startSlot`
		*
		* @param startSlot fetch slot leaders starting from this slot
		* @param limit number of slot leaders to return
		*/
		async getSlotLeaders(startSlot, limit) {
			const args = [startSlot, limit];
			const res = create(await this._rpcRequest("getSlotLeaders", args), jsonRpcResult(array(PublicKeyFromString)));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
			return res.result;
		}
		/**
		* Fetch the current status of a signature
		*/
		async getSignatureStatus(signature$1, config) {
			const { context, value: values } = await this.getSignatureStatuses([signature$1], config);
			assert$1(values.length === 1);
			return {
				context,
				value: values[0]
			};
		}
		/**
		* Fetch the current statuses of a batch of signatures
		*/
		async getSignatureStatuses(signatures, config) {
			const params = [signatures];
			if (config) params.push(config);
			const res = create(await this._rpcRequest("getSignatureStatuses", params), GetSignatureStatusesRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get signature status");
			return res.result;
		}
		/**
		* Fetch the current transaction count of the cluster
		*/
		async getTransactionCount(commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([], commitment, void 0, config);
			const res = create(await this._rpcRequest("getTransactionCount", args), jsonRpcResult(number()));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
			return res.result;
		}
		/**
		* Fetch the current total currency supply of the cluster in lamports
		*
		* @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.
		*/
		async getTotalSupply(commitment) {
			return (await this.getSupply({
				commitment,
				excludeNonCirculatingAccountsList: true
			})).value.total;
		}
		/**
		* Fetch the cluster InflationGovernor parameters
		*/
		async getInflationGovernor(commitment) {
			const args = this._buildArgs([], commitment);
			const res = create(await this._rpcRequest("getInflationGovernor", args), GetInflationGovernorRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get inflation");
			return res.result;
		}
		/**
		* Fetch the inflation reward for a list of addresses for an epoch
		*/
		async getInflationReward(addresses, epoch, commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, void 0, {
				...config,
				epoch: epoch != null ? epoch : config?.epoch
			});
			const res = create(await this._rpcRequest("getInflationReward", args), GetInflationRewardResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
			return res.result;
		}
		/**
		* Fetch the specific inflation values for the current epoch
		*/
		async getInflationRate() {
			const res = create(await this._rpcRequest("getInflationRate", []), GetInflationRateRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
			return res.result;
		}
		/**
		* Fetch the Epoch Info parameters
		*/
		async getEpochInfo(commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([], commitment, void 0, config);
			const res = create(await this._rpcRequest("getEpochInfo", args), GetEpochInfoRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
			return res.result;
		}
		/**
		* Fetch the Epoch Schedule parameters
		*/
		async getEpochSchedule() {
			const res = create(await this._rpcRequest("getEpochSchedule", []), GetEpochScheduleRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
			const epochSchedule = res.result;
			return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
		}
		/**
		* Fetch the leader schedule for the current epoch
		* @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
		*/
		async getLeaderSchedule() {
			const res = create(await this._rpcRequest("getLeaderSchedule", []), GetLeaderScheduleRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
			return res.result;
		}
		/**
		* Fetch the minimum balance needed to exempt an account of `dataLength`
		* size from rent
		*/
		async getMinimumBalanceForRentExemption(dataLength, commitment) {
			const args = this._buildArgs([dataLength], commitment);
			const res = create(await this._rpcRequest("getMinimumBalanceForRentExemption", args), GetMinimumBalanceForRentExemptionRpcResult);
			if ("error" in res) {
				console.warn("Unable to fetch minimum balance for rent exemption");
				return 0;
			}
			return res.result;
		}
		/**
		* Fetch a recent blockhash from the cluster, return with context
		* @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
		*
		* @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.
		*/
		async getRecentBlockhashAndContext(commitment) {
			const { context, value: { blockhash } } = await this.getLatestBlockhashAndContext(commitment);
			return {
				context,
				value: {
					blockhash,
					feeCalculator: {
						get lamportsPerSignature() {
							throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.");
						},
						toJSON() {
							return {};
						}
					}
				}
			};
		}
		/**
		* Fetch recent performance samples
		* @return {Promise<Array<PerfSample>>}
		*/
		async getRecentPerformanceSamples(limit) {
			const res = create(await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []), GetRecentPerformanceSamplesRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
			return res.result;
		}
		/**
		* Fetch the fee calculator for a recent blockhash from the cluster, return with context
		*
		* @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.
		*/
		async getFeeCalculatorForBlockhash(blockhash, commitment) {
			const args = this._buildArgs([blockhash], commitment);
			const res = create(await this._rpcRequest("getFeeCalculatorForBlockhash", args), GetFeeCalculatorRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
			const { context, value } = res.result;
			return {
				context,
				value: value !== null ? value.feeCalculator : null
			};
		}
		/**
		* Fetch the fee for a message from the cluster, return with context
		*/
		async getFeeForMessage(message, commitment) {
			const wireMessage = toBuffer(message.serialize()).toString("base64");
			const args = this._buildArgs([wireMessage], commitment);
			const res = create(await this._rpcRequest("getFeeForMessage", args), jsonRpcResultAndContext(nullable(number())));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
			if (res.result === null) throw new Error("invalid blockhash");
			return res.result;
		}
		/**
		* Fetch a list of prioritization fees from recent blocks.
		*/
		async getRecentPrioritizationFees(config) {
			const accounts = config?.lockedWritableAccounts?.map((key) => key.toBase58());
			const args = accounts?.length ? [accounts] : [];
			const res = create(await this._rpcRequest("getRecentPrioritizationFees", args), GetRecentPrioritizationFeesRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
			return res.result;
		}
		/**
		* Fetch a recent blockhash from the cluster
		* @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
		*
		* @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.
		*/
		async getRecentBlockhash(commitment) {
			try {
				return (await this.getRecentBlockhashAndContext(commitment)).value;
			} catch (e) {
				throw new Error("failed to get recent blockhash: " + e);
			}
		}
		/**
		* Fetch the latest blockhash from the cluster
		* @return {Promise<BlockhashWithExpiryBlockHeight>}
		*/
		async getLatestBlockhash(commitmentOrConfig) {
			try {
				return (await this.getLatestBlockhashAndContext(commitmentOrConfig)).value;
			} catch (e) {
				throw new Error("failed to get recent blockhash: " + e);
			}
		}
		/**
		* Fetch the latest blockhash from the cluster
		* @return {Promise<BlockhashWithExpiryBlockHeight>}
		*/
		async getLatestBlockhashAndContext(commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([], commitment, void 0, config);
			const res = create(await this._rpcRequest("getLatestBlockhash", args), GetLatestBlockhashRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
			return res.result;
		}
		/**
		* Returns whether a blockhash is still valid or not
		*/
		async isBlockhashValid(blockhash, rawConfig) {
			const { commitment, config } = extractCommitmentFromConfig(rawConfig);
			const args = this._buildArgs([blockhash], commitment, void 0, config);
			const res = create(await this._rpcRequest("isBlockhashValid", args), IsBlockhashValidRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
			return res.result;
		}
		/**
		* Fetch the node version
		*/
		async getVersion() {
			const res = create(await this._rpcRequest("getVersion", []), jsonRpcResult(VersionResult));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get version");
			return res.result;
		}
		/**
		* Fetch the genesis hash
		*/
		async getGenesisHash() {
			const res = create(await this._rpcRequest("getGenesisHash", []), jsonRpcResult(string()));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
			return res.result;
		}
		/**
		* Fetch a processed block from the cluster.
		*
		* @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
		* setting the `maxSupportedTransactionVersion` property.
		*/
		/**
		* @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
		* setting the `maxSupportedTransactionVersion` property.
		*/
		/**
		* @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
		* setting the `maxSupportedTransactionVersion` property.
		*/
		/**
		* Fetch a processed block from the cluster.
		*/
		/**
		* Fetch a processed block from the cluster.
		*/
		async getBlock(slot, rawConfig) {
			const { commitment, config } = extractCommitmentFromConfig(rawConfig);
			const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config);
			const unsafeRes = await this._rpcRequest("getBlock", args);
			try {
				switch (config?.transactionDetails) {
					case "accounts": {
						const res = create(unsafeRes, GetAccountsModeBlockRpcResult);
						if ("error" in res) throw res.error;
						return res.result;
					}
					case "none": {
						const res = create(unsafeRes, GetNoneModeBlockRpcResult);
						if ("error" in res) throw res.error;
						return res.result;
					}
					default: {
						const res = create(unsafeRes, GetBlockRpcResult);
						if ("error" in res) throw res.error;
						const { result } = res;
						return result ? {
							...result,
							transactions: result.transactions.map(({ transaction, meta, version: version$1 }) => ({
								meta,
								transaction: {
									...transaction,
									message: versionedMessageFromResponse(version$1, transaction.message)
								},
								version: version$1
							}))
						} : null;
					}
				}
			} catch (e) {
				throw new SolanaJSONRPCError(e, "failed to get confirmed block");
			}
		}
		/**
		* Fetch parsed transaction details for a confirmed or finalized block
		*/
		async getParsedBlock(slot, rawConfig) {
			const { commitment, config } = extractCommitmentFromConfig(rawConfig);
			const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
			const unsafeRes = await this._rpcRequest("getBlock", args);
			try {
				switch (config?.transactionDetails) {
					case "accounts": {
						const res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
						if ("error" in res) throw res.error;
						return res.result;
					}
					case "none": {
						const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult);
						if ("error" in res) throw res.error;
						return res.result;
					}
					default: {
						const res = create(unsafeRes, GetParsedBlockRpcResult);
						if ("error" in res) throw res.error;
						return res.result;
					}
				}
			} catch (e) {
				throw new SolanaJSONRPCError(e, "failed to get block");
			}
		}
		async getBlockProduction(configOrCommitment) {
			let extra;
			let commitment;
			if (typeof configOrCommitment === "string") commitment = configOrCommitment;
			else if (configOrCommitment) {
				const { commitment: c, ...rest } = configOrCommitment;
				commitment = c;
				extra = rest;
			}
			const args = this._buildArgs([], commitment, "base64", extra);
			const res = create(await this._rpcRequest("getBlockProduction", args), BlockProductionResponseStruct);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get block production information");
			return res.result;
		}
		/**
		* Fetch a confirmed or finalized transaction from the cluster.
		*
		* @deprecated Instead, call `getTransaction` using a
		* `GetVersionedTransactionConfig` by setting the
		* `maxSupportedTransactionVersion` property.
		*/
		/**
		* Fetch a confirmed or finalized transaction from the cluster.
		*/
		/**
		* Fetch a confirmed or finalized transaction from the cluster.
		*/
		async getTransaction(signature$1, rawConfig) {
			const { commitment, config } = extractCommitmentFromConfig(rawConfig);
			const args = this._buildArgsAtLeastConfirmed([signature$1], commitment, void 0, config);
			const res = create(await this._rpcRequest("getTransaction", args), GetTransactionRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transaction");
			const result = res.result;
			if (!result) return result;
			return {
				...result,
				transaction: {
					...result.transaction,
					message: versionedMessageFromResponse(result.version, result.transaction.message)
				}
			};
		}
		/**
		* Fetch parsed transaction details for a confirmed or finalized transaction
		*/
		async getParsedTransaction(signature$1, commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgsAtLeastConfirmed([signature$1], commitment, "jsonParsed", config);
			const res = create(await this._rpcRequest("getTransaction", args), GetParsedTransactionRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transaction");
			return res.result;
		}
		/**
		* Fetch parsed transaction details for a batch of confirmed transactions
		*/
		async getParsedTransactions(signatures, commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const batch = signatures.map((signature$1) => {
				return {
					methodName: "getTransaction",
					args: this._buildArgsAtLeastConfirmed([signature$1], commitment, "jsonParsed", config)
				};
			});
			return (await this._rpcBatchRequest(batch)).map((unsafeRes) => {
				const res = create(unsafeRes, GetParsedTransactionRpcResult);
				if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transactions");
				return res.result;
			});
		}
		/**
		* Fetch transaction details for a batch of confirmed transactions.
		* Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
		*
		* @deprecated Instead, call `getTransactions` using a
		* `GetVersionedTransactionConfig` by setting the
		* `maxSupportedTransactionVersion` property.
		*/
		/**
		* Fetch transaction details for a batch of confirmed transactions.
		* Similar to {@link getParsedTransactions} but returns a {@link
		* VersionedTransactionResponse}.
		*/
		/**
		* Fetch transaction details for a batch of confirmed transactions.
		* Similar to {@link getParsedTransactions} but returns a {@link
		* VersionedTransactionResponse}.
		*/
		async getTransactions(signatures, commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const batch = signatures.map((signature$1) => {
				return {
					methodName: "getTransaction",
					args: this._buildArgsAtLeastConfirmed([signature$1], commitment, void 0, config)
				};
			});
			return (await this._rpcBatchRequest(batch)).map((unsafeRes) => {
				const res = create(unsafeRes, GetTransactionRpcResult);
				if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transactions");
				const result = res.result;
				if (!result) return result;
				return {
					...result,
					transaction: {
						...result.transaction,
						message: versionedMessageFromResponse(result.version, result.transaction.message)
					}
				};
			});
		}
		/**
		* Fetch a list of Transactions and transaction statuses from the cluster
		* for a confirmed block.
		*
		* @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.
		*/
		async getConfirmedBlock(slot, commitment) {
			const args = this._buildArgsAtLeastConfirmed([slot], commitment);
			const res = create(await this._rpcRequest("getBlock", args), GetConfirmedBlockRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
			const result = res.result;
			if (!result) throw new Error("Confirmed block " + slot + " not found");
			const block = {
				...result,
				transactions: result.transactions.map(({ transaction, meta }) => {
					const message = new Message(transaction.message);
					return {
						meta,
						transaction: {
							...transaction,
							message
						}
					};
				})
			};
			return {
				...block,
				transactions: block.transactions.map(({ transaction, meta }) => {
					return {
						meta,
						transaction: Transaction.populate(transaction.message, transaction.signatures)
					};
				})
			};
		}
		/**
		* Fetch confirmed blocks between two slots
		*/
		async getBlocks(startSlot, endSlot, commitment) {
			const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
			const res = create(await this._rpcRequest("getBlocks", args), jsonRpcResult(array(number())));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get blocks");
			return res.result;
		}
		/**
		* Fetch a list of Signatures from the cluster for a block, excluding rewards
		*/
		async getBlockSignatures(slot, commitment) {
			const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
				transactionDetails: "signatures",
				rewards: false
			});
			const res = create(await this._rpcRequest("getBlock", args), GetBlockSignaturesRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get block");
			const result = res.result;
			if (!result) throw new Error("Block " + slot + " not found");
			return result;
		}
		/**
		* Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
		*
		* @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.
		*/
		async getConfirmedBlockSignatures(slot, commitment) {
			const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
				transactionDetails: "signatures",
				rewards: false
			});
			const res = create(await this._rpcRequest("getBlock", args), GetBlockSignaturesRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
			const result = res.result;
			if (!result) throw new Error("Confirmed block " + slot + " not found");
			return result;
		}
		/**
		* Fetch a transaction details for a confirmed transaction
		*
		* @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.
		*/
		async getConfirmedTransaction(signature$1, commitment) {
			const args = this._buildArgsAtLeastConfirmed([signature$1], commitment);
			const res = create(await this._rpcRequest("getTransaction", args), GetTransactionRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transaction");
			const result = res.result;
			if (!result) return result;
			const message = new Message(result.transaction.message);
			const signatures = result.transaction.signatures;
			return {
				...result,
				transaction: Transaction.populate(message, signatures)
			};
		}
		/**
		* Fetch parsed transaction details for a confirmed transaction
		*
		* @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.
		*/
		async getParsedConfirmedTransaction(signature$1, commitment) {
			const args = this._buildArgsAtLeastConfirmed([signature$1], commitment, "jsonParsed");
			const res = create(await this._rpcRequest("getTransaction", args), GetParsedTransactionRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
			return res.result;
		}
		/**
		* Fetch parsed transaction details for a batch of confirmed transactions
		*
		* @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.
		*/
		async getParsedConfirmedTransactions(signatures, commitment) {
			const batch = signatures.map((signature$1) => {
				return {
					methodName: "getTransaction",
					args: this._buildArgsAtLeastConfirmed([signature$1], commitment, "jsonParsed")
				};
			});
			return (await this._rpcBatchRequest(batch)).map((unsafeRes) => {
				const res = create(unsafeRes, GetParsedTransactionRpcResult);
				if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get confirmed transactions");
				return res.result;
			});
		}
		/**
		* Fetch a list of all the confirmed signatures for transactions involving an address
		* within a specified slot range. Max range allowed is 10,000 slots.
		*
		* @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
		*
		* @param address queried address
		* @param startSlot start slot, inclusive
		* @param endSlot end slot, inclusive
		*/
		async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
			let options = {};
			let firstAvailableBlock = await this.getFirstAvailableBlock();
			while (!("until" in options)) {
				startSlot--;
				if (startSlot <= 0 || startSlot < firstAvailableBlock) break;
				try {
					const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
					if (block.signatures.length > 0) options.until = block.signatures[block.signatures.length - 1].toString();
				} catch (err) {
					if (err instanceof Error && err.message.includes("skipped")) continue;
					else throw err;
				}
			}
			let highestConfirmedRoot = await this.getSlot("finalized");
			while (!("before" in options)) {
				endSlot++;
				if (endSlot > highestConfirmedRoot) break;
				try {
					const block = await this.getConfirmedBlockSignatures(endSlot);
					if (block.signatures.length > 0) options.before = block.signatures[block.signatures.length - 1].toString();
				} catch (err) {
					if (err instanceof Error && err.message.includes("skipped")) continue;
					else throw err;
				}
			}
			return (await this.getConfirmedSignaturesForAddress2(address, options)).map((info) => info.signature);
		}
		/**
		* Returns confirmed signatures for transactions involving an
		* address backwards in time from the provided signature or most recent confirmed block
		*
		* @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.
		*/
		async getConfirmedSignaturesForAddress2(address, options, commitment) {
			const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
			const res = create(await this._rpcRequest("getConfirmedSignaturesForAddress2", args), GetConfirmedSignaturesForAddress2RpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
			return res.result;
		}
		/**
		* Returns confirmed signatures for transactions involving an
		* address backwards in time from the provided signature or most recent confirmed block
		*
		*
		* @param address queried address
		* @param options
		*/
		async getSignaturesForAddress(address, options, commitment) {
			const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
			const res = create(await this._rpcRequest("getSignaturesForAddress", args), GetSignaturesForAddressRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
			return res.result;
		}
		async getAddressLookupTable(accountKey, config) {
			const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);
			let value = null;
			if (accountInfo !== null) value = new AddressLookupTableAccount({
				key: accountKey,
				state: AddressLookupTableAccount.deserialize(accountInfo.data)
			});
			return {
				context,
				value
			};
		}
		/**
		* Fetch the contents of a Nonce account from the cluster, return with context
		*/
		async getNonceAndContext(nonceAccount, commitmentOrConfig) {
			const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
			let value = null;
			if (accountInfo !== null) value = NonceAccount.fromAccountData(accountInfo.data);
			return {
				context,
				value
			};
		}
		/**
		* Fetch the contents of a Nonce account from the cluster
		*/
		async getNonce(nonceAccount, commitmentOrConfig) {
			return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x) => x.value).catch((e) => {
				throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
			});
		}
		/**
		* Request an allocation of lamports to the specified address
		*
		* ```typescript
		* import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
		*
		* (async () => {
		*   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
		*   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
		*   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
		*   await connection.confirmTransaction(signature);
		* })();
		* ```
		*/
		async requestAirdrop(to, lamports) {
			const res = create(await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]), RequestAirdropRpcResult);
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
			return res.result;
		}
		/**
		* @internal
		*/
		async _blockhashWithExpiryBlockHeight(disableCache) {
			if (!disableCache) {
				while (this._pollingBlockhash) await sleep(100);
				const expired = Date.now() - this._blockhashInfo.lastFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
				if (this._blockhashInfo.latestBlockhash !== null && !expired) return this._blockhashInfo.latestBlockhash;
			}
			return await this._pollNewBlockhash();
		}
		/**
		* @internal
		*/
		async _pollNewBlockhash() {
			this._pollingBlockhash = true;
			try {
				const startTime = Date.now();
				const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
				const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
				for (let i$1 = 0; i$1 < 50; i$1++) {
					const latestBlockhash = await this.getLatestBlockhash("finalized");
					if (cachedBlockhash !== latestBlockhash.blockhash) {
						this._blockhashInfo = {
							latestBlockhash,
							lastFetch: Date.now(),
							transactionSignatures: [],
							simulatedSignatures: []
						};
						return latestBlockhash;
					}
					await sleep(MS_PER_SLOT / 2);
				}
				throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
			} finally {
				this._pollingBlockhash = false;
			}
		}
		/**
		* get the stake minimum delegation
		*/
		async getStakeMinimumDelegation(config) {
			const { commitment, config: configArg } = extractCommitmentFromConfig(config);
			const args = this._buildArgs([], commitment, "base64", configArg);
			const res = create(await this._rpcRequest("getStakeMinimumDelegation", args), jsonRpcResultAndContext(number()));
			if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
			return res.result;
		}
		/**
		* Simulate a transaction
		*
		* @deprecated Instead, call {@link simulateTransaction} with {@link
		* VersionedTransaction} and {@link SimulateTransactionConfig} parameters
		*/
		/**
		* Simulate a transaction
		*/
		/**
		* Simulate a transaction
		*/
		async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
			if ("message" in transactionOrMessage) {
				const wireTransaction = transactionOrMessage.serialize();
				const encodedTransaction$1 = import_buffer.Buffer.from(wireTransaction).toString("base64");
				if (Array.isArray(configOrSigners) || includeAccounts !== void 0) throw new Error("Invalid arguments");
				const config$1 = configOrSigners || {};
				config$1.encoding = "base64";
				if (!("commitment" in config$1)) config$1.commitment = this.commitment;
				if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) config$1.innerInstructions = configOrSigners.innerInstructions;
				const args$1 = [encodedTransaction$1, config$1];
				const res$1 = create(await this._rpcRequest("simulateTransaction", args$1), SimulatedTransactionResponseStruct);
				if ("error" in res$1) throw new Error("failed to simulate transaction: " + res$1.error.message);
				return res$1.result;
			}
			let transaction;
			if (transactionOrMessage instanceof Transaction) {
				let originalTx = transactionOrMessage;
				transaction = new Transaction();
				transaction.feePayer = originalTx.feePayer;
				transaction.instructions = transactionOrMessage.instructions;
				transaction.nonceInfo = originalTx.nonceInfo;
				transaction.signatures = originalTx.signatures;
			} else {
				transaction = Transaction.populate(transactionOrMessage);
				transaction._message = transaction._json = void 0;
			}
			if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) throw new Error("Invalid arguments");
			const signers = configOrSigners;
			if (transaction.nonceInfo && signers) transaction.sign(...signers);
			else {
				let disableCache = this._disableBlockhashCaching;
				for (;;) {
					const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
					transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
					transaction.recentBlockhash = latestBlockhash.blockhash;
					if (!signers) break;
					transaction.sign(...signers);
					if (!transaction.signature) throw new Error("!signature");
					const signature$1 = transaction.signature.toString("base64");
					if (!this._blockhashInfo.simulatedSignatures.includes(signature$1) && !this._blockhashInfo.transactionSignatures.includes(signature$1)) {
						this._blockhashInfo.simulatedSignatures.push(signature$1);
						break;
					} else disableCache = true;
				}
			}
			const message = transaction._compile();
			const signData = message.serialize();
			const encodedTransaction = transaction._serialize(signData).toString("base64");
			const config = {
				encoding: "base64",
				commitment: this.commitment
			};
			if (includeAccounts) config["accounts"] = {
				encoding: "base64",
				addresses: (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58())
			};
			if (signers) config.sigVerify = true;
			if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) config.innerInstructions = configOrSigners.innerInstructions;
			const args = [encodedTransaction, config];
			const res = create(await this._rpcRequest("simulateTransaction", args), SimulatedTransactionResponseStruct);
			if ("error" in res) {
				let logs;
				if ("data" in res.error) {
					logs = res.error.data.logs;
					if (logs && Array.isArray(logs)) {
						const traceIndent = "\n    ";
						const logTrace = traceIndent + logs.join(traceIndent);
						console.error(res.error.message, logTrace);
					}
				}
				throw new SendTransactionError({
					action: "simulate",
					signature: "",
					transactionMessage: res.error.message,
					logs
				});
			}
			return res.result;
		}
		/**
		* Sign and send a transaction
		*
		* @deprecated Instead, call {@link sendTransaction} with a {@link
		* VersionedTransaction}
		*/
		/**
		* Send a signed transaction
		*/
		/**
		* Sign and send a transaction
		*/
		async sendTransaction(transaction, signersOrOptions, options) {
			if ("version" in transaction) {
				if (signersOrOptions && Array.isArray(signersOrOptions)) throw new Error("Invalid arguments");
				const wireTransaction$1 = transaction.serialize();
				return await this.sendRawTransaction(wireTransaction$1, signersOrOptions);
			}
			if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) throw new Error("Invalid arguments");
			const signers = signersOrOptions;
			if (transaction.nonceInfo) transaction.sign(...signers);
			else {
				let disableCache = this._disableBlockhashCaching;
				for (;;) {
					const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
					transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
					transaction.recentBlockhash = latestBlockhash.blockhash;
					transaction.sign(...signers);
					if (!transaction.signature) throw new Error("!signature");
					const signature$1 = transaction.signature.toString("base64");
					if (!this._blockhashInfo.transactionSignatures.includes(signature$1)) {
						this._blockhashInfo.transactionSignatures.push(signature$1);
						break;
					} else disableCache = true;
				}
			}
			const wireTransaction = transaction.serialize();
			return await this.sendRawTransaction(wireTransaction, options);
		}
		/**
		* Send a transaction that has already been signed and serialized into the
		* wire format
		*/
		async sendRawTransaction(rawTransaction, options) {
			const encodedTransaction = toBuffer(rawTransaction).toString("base64");
			return await this.sendEncodedTransaction(encodedTransaction, options);
		}
		/**
		* Send a transaction that has already been signed, serialized into the
		* wire format, and encoded as a base64 string
		*/
		async sendEncodedTransaction(encodedTransaction, options) {
			const config = { encoding: "base64" };
			const skipPreflight = options && options.skipPreflight;
			const preflightCommitment = skipPreflight === true ? "processed" : options && options.preflightCommitment || this.commitment;
			if (options && options.maxRetries != null) config.maxRetries = options.maxRetries;
			if (options && options.minContextSlot != null) config.minContextSlot = options.minContextSlot;
			if (skipPreflight) config.skipPreflight = skipPreflight;
			if (preflightCommitment) config.preflightCommitment = preflightCommitment;
			const args = [encodedTransaction, config];
			const res = create(await this._rpcRequest("sendTransaction", args), SendTransactionRpcResult);
			if ("error" in res) {
				let logs = void 0;
				if ("data" in res.error) logs = res.error.data.logs;
				throw new SendTransactionError({
					action: skipPreflight ? "send" : "simulate",
					signature: "",
					transactionMessage: res.error.message,
					logs
				});
			}
			return res.result;
		}
		/**
		* @internal
		*/
		_wsOnOpen() {
			this._rpcWebSocketConnected = true;
			this._rpcWebSocketHeartbeat = setInterval(() => {
				(async () => {
					try {
						await this._rpcWebSocket.notify("ping");
					} catch {}
				})();
			}, 5e3);
			this._updateSubscriptions();
		}
		/**
		* @internal
		*/
		_wsOnError(err) {
			this._rpcWebSocketConnected = false;
			console.error("ws error:", err.message);
		}
		/**
		* @internal
		*/
		_wsOnClose(code) {
			this._rpcWebSocketConnected = false;
			this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
			if (this._rpcWebSocketIdleTimeout) {
				clearTimeout(this._rpcWebSocketIdleTimeout);
				this._rpcWebSocketIdleTimeout = null;
			}
			if (this._rpcWebSocketHeartbeat) {
				clearInterval(this._rpcWebSocketHeartbeat);
				this._rpcWebSocketHeartbeat = null;
			}
			if (code === 1e3) {
				this._updateSubscriptions();
				return;
			}
			this._subscriptionCallbacksByServerSubscriptionId = {};
			Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {
				this._setSubscription(hash, {
					...subscription,
					state: "pending"
				});
			});
		}
		/**
		* @internal
		*/
		_setSubscription(hash, nextSubscription) {
			const prevState = this._subscriptionsByHash[hash]?.state;
			this._subscriptionsByHash[hash] = nextSubscription;
			if (prevState !== nextSubscription.state) {
				const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];
				if (stateChangeCallbacks) stateChangeCallbacks.forEach((cb) => {
					try {
						cb(nextSubscription.state);
					} catch {}
				});
			}
		}
		/**
		* @internal
		*/
		_onSubscriptionStateChange(clientSubscriptionId, callback) {
			const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
			if (hash == null) return () => {};
			const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= /* @__PURE__ */ new Set();
			stateChangeCallbacks.add(callback);
			return () => {
				stateChangeCallbacks.delete(callback);
				if (stateChangeCallbacks.size === 0) delete this._subscriptionStateChangeCallbacksByHash[hash];
			};
		}
		/**
		* @internal
		*/
		async _updateSubscriptions() {
			if (Object.keys(this._subscriptionsByHash).length === 0) {
				if (this._rpcWebSocketConnected) {
					this._rpcWebSocketConnected = false;
					this._rpcWebSocketIdleTimeout = setTimeout(() => {
						this._rpcWebSocketIdleTimeout = null;
						try {
							this._rpcWebSocket.close();
						} catch (err) {
							if (err instanceof Error) console.log(`Error when closing socket connection: ${err.message}`);
						}
					}, 500);
				}
				return;
			}
			if (this._rpcWebSocketIdleTimeout !== null) {
				clearTimeout(this._rpcWebSocketIdleTimeout);
				this._rpcWebSocketIdleTimeout = null;
				this._rpcWebSocketConnected = true;
			}
			if (!this._rpcWebSocketConnected) {
				this._rpcWebSocket.connect();
				return;
			}
			const activeWebSocketGeneration = this._rpcWebSocketGeneration;
			const isCurrentConnectionStillActive = () => {
				return activeWebSocketGeneration === this._rpcWebSocketGeneration;
			};
			await Promise.all(Object.keys(this._subscriptionsByHash).map(async (hash) => {
				const subscription = this._subscriptionsByHash[hash];
				if (subscription === void 0) return;
				switch (subscription.state) {
					case "pending":
					case "unsubscribed":
						if (subscription.callbacks.size === 0) {
							/**
							* You can end up here when:
							*
							* - a subscription has recently unsubscribed
							*   without having new callbacks added to it
							*   while the unsubscribe was in flight, or
							* - when a pending subscription has its
							*   listeners removed before a request was
							*   sent to the server.
							*
							* Being that nobody is interested in this
							* subscription any longer, delete it.
							*/
							delete this._subscriptionsByHash[hash];
							if (subscription.state === "unsubscribed") delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
							await this._updateSubscriptions();
							return;
						}
						await (async () => {
							const { args, method } = subscription;
							try {
								this._setSubscription(hash, {
									...subscription,
									state: "subscribing"
								});
								const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
								this._setSubscription(hash, {
									...subscription,
									serverSubscriptionId,
									state: "subscribed"
								});
								this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
								await this._updateSubscriptions();
							} catch (e) {
								console.error(`Received ${e instanceof Error ? "" : "JSON-RPC "}error calling \`${method}\``, {
									args,
									error: e
								});
								if (!isCurrentConnectionStillActive()) return;
								this._setSubscription(hash, {
									...subscription,
									state: "pending"
								});
								await this._updateSubscriptions();
							}
						})();
						break;
					case "subscribed":
						if (subscription.callbacks.size === 0) await (async () => {
							const { serverSubscriptionId, unsubscribeMethod } = subscription;
							if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId))
 /**
							* Special case.
							* If we're dealing with a subscription that has been auto-
							* disposed by the RPC, then we can skip the RPC call to
							* tear down the subscription here.
							*
							* NOTE: There is a proposal to eliminate this special case, here:
							* https://github.com/solana-labs/solana/issues/18892
							*/
							this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
							else {
								this._setSubscription(hash, {
									...subscription,
									state: "unsubscribing"
								});
								this._setSubscription(hash, {
									...subscription,
									state: "unsubscribing"
								});
								try {
									await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
								} catch (e) {
									if (e instanceof Error) console.error(`${unsubscribeMethod} error:`, e.message);
									if (!isCurrentConnectionStillActive()) return;
									this._setSubscription(hash, {
										...subscription,
										state: "subscribed"
									});
									await this._updateSubscriptions();
									return;
								}
							}
							this._setSubscription(hash, {
								...subscription,
								state: "unsubscribed"
							});
							await this._updateSubscriptions();
						})();
						break;
				}
			}));
		}
		/**
		* @internal
		*/
		_handleServerNotification(serverSubscriptionId, callbackArgs) {
			const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
			if (callbacks === void 0) return;
			callbacks.forEach((cb) => {
				try {
					cb(...callbackArgs);
				} catch (e) {
					console.error(e);
				}
			});
		}
		/**
		* @internal
		*/
		_wsOnAccountNotification(notification) {
			const { result, subscription } = create(notification, AccountNotificationResult);
			this._handleServerNotification(subscription, [result.value, result.context]);
		}
		/**
		* @internal
		*/
		_makeSubscription(subscriptionConfig, args) {
			const clientSubscriptionId = this._nextClientSubscriptionId++;
			const hash = fastStableStringify([subscriptionConfig.method, args]);
			const existingSubscription = this._subscriptionsByHash[hash];
			if (existingSubscription === void 0) this._subscriptionsByHash[hash] = {
				...subscriptionConfig,
				args,
				callbacks: new Set([subscriptionConfig.callback]),
				state: "pending"
			};
			else existingSubscription.callbacks.add(subscriptionConfig.callback);
			this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
			this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
				delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
				delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
				const subscription = this._subscriptionsByHash[hash];
				assert$1(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
				subscription.callbacks.delete(subscriptionConfig.callback);
				await this._updateSubscriptions();
			};
			this._updateSubscriptions();
			return clientSubscriptionId;
		}
		/**
		* Register a callback to be invoked whenever the specified account changes
		*
		* @param publicKey Public key of the account to monitor
		* @param callback Function to invoke whenever the account is changed
		* @param config
		* @return subscription id
		*/
		/** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */
		onAccountChange(publicKey$1, callback, commitmentOrConfig) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([publicKey$1.toBase58()], commitment || this._commitment || "finalized", "base64", config);
			return this._makeSubscription({
				callback,
				method: "accountSubscribe",
				unsubscribeMethod: "accountUnsubscribe"
			}, args);
		}
		/**
		* Deregister an account notification callback
		*
		* @param clientSubscriptionId client subscription id to deregister
		*/
		async removeAccountChangeListener(clientSubscriptionId) {
			await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
		}
		/**
		* @internal
		*/
		_wsOnProgramAccountNotification(notification) {
			const { result, subscription } = create(notification, ProgramAccountNotificationResult);
			this._handleServerNotification(subscription, [{
				accountId: result.value.pubkey,
				accountInfo: result.value.account
			}, result.context]);
		}
		/**
		* Register a callback to be invoked whenever accounts owned by the
		* specified program change
		*
		* @param programId Public key of the program to monitor
		* @param callback Function to invoke whenever the account is changed
		* @param config
		* @return subscription id
		*/
		/** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */
		onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
			const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
			const args = this._buildArgs([programId.toBase58()], commitment || this._commitment || "finalized", "base64", config ? config : maybeFilters ? { filters: applyDefaultMemcmpEncodingToFilters(maybeFilters) } : void 0);
			return this._makeSubscription({
				callback,
				method: "programSubscribe",
				unsubscribeMethod: "programUnsubscribe"
			}, args);
		}
		/**
		* Deregister an account notification callback
		*
		* @param clientSubscriptionId client subscription id to deregister
		*/
		async removeProgramAccountChangeListener(clientSubscriptionId) {
			await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
		}
		/**
		* Registers a callback to be invoked whenever logs are emitted.
		*/
		onLogs(filter, callback, commitment) {
			const args = this._buildArgs([typeof filter === "object" ? { mentions: [filter.toString()] } : filter], commitment || this._commitment || "finalized");
			return this._makeSubscription({
				callback,
				method: "logsSubscribe",
				unsubscribeMethod: "logsUnsubscribe"
			}, args);
		}
		/**
		* Deregister a logs callback.
		*
		* @param clientSubscriptionId client subscription id to deregister.
		*/
		async removeOnLogsListener(clientSubscriptionId) {
			await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
		}
		/**
		* @internal
		*/
		_wsOnLogsNotification(notification) {
			const { result, subscription } = create(notification, LogsNotificationResult);
			this._handleServerNotification(subscription, [result.value, result.context]);
		}
		/**
		* @internal
		*/
		_wsOnSlotNotification(notification) {
			const { result, subscription } = create(notification, SlotNotificationResult);
			this._handleServerNotification(subscription, [result]);
		}
		/**
		* Register a callback to be invoked upon slot changes
		*
		* @param callback Function to invoke whenever the slot changes
		* @return subscription id
		*/
		onSlotChange(callback) {
			return this._makeSubscription({
				callback,
				method: "slotSubscribe",
				unsubscribeMethod: "slotUnsubscribe"
			}, []);
		}
		/**
		* Deregister a slot notification callback
		*
		* @param clientSubscriptionId client subscription id to deregister
		*/
		async removeSlotChangeListener(clientSubscriptionId) {
			await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
		}
		/**
		* @internal
		*/
		_wsOnSlotUpdatesNotification(notification) {
			const { result, subscription } = create(notification, SlotUpdateNotificationResult);
			this._handleServerNotification(subscription, [result]);
		}
		/**
		* Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
		* may be useful to track live progress of a cluster.
		*
		* @param callback Function to invoke whenever the slot updates
		* @return subscription id
		*/
		onSlotUpdate(callback) {
			return this._makeSubscription({
				callback,
				method: "slotsUpdatesSubscribe",
				unsubscribeMethod: "slotsUpdatesUnsubscribe"
			}, []);
		}
		/**
		* Deregister a slot update notification callback
		*
		* @param clientSubscriptionId client subscription id to deregister
		*/
		async removeSlotUpdateListener(clientSubscriptionId) {
			await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
		}
		/**
		* @internal
		*/
		async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
			const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
			if (dispose) await dispose();
			else console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
		}
		_buildArgs(args, override, encoding$1, extra) {
			const commitment = override || this._commitment;
			if (commitment || encoding$1 || extra) {
				let options = {};
				if (encoding$1) options.encoding = encoding$1;
				if (commitment) options.commitment = commitment;
				if (extra) options = Object.assign(options, extra);
				args.push(options);
			}
			return args;
		}
		/**
		* @internal
		*/
		_buildArgsAtLeastConfirmed(args, override, encoding$1, extra) {
			const commitment = override || this._commitment;
			if (commitment && !["confirmed", "finalized"].includes(commitment)) throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
			return this._buildArgs(args, override, encoding$1, extra);
		}
		/**
		* @internal
		*/
		_wsOnSignatureNotification(notification) {
			const { result, subscription } = create(notification, SignatureNotificationResult);
			if (result.value !== "receivedSignature")
 /**
			* Special case.
			* After a signature is processed, RPCs automatically dispose of the
			* subscription on the server side. We need to track which of these
			* subscriptions have been disposed in such a way, so that we know
			* whether the client is dealing with a not-yet-processed signature
			* (in which case we must tear down the server subscription) or an
			* already-processed signature (in which case the client can simply
			* clear out the subscription locally without telling the server).
			*
			* NOTE: There is a proposal to eliminate this special case, here:
			* https://github.com/solana-labs/solana/issues/18892
			*/
			this._subscriptionsAutoDisposedByRpc.add(subscription);
			this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{ type: "received" }, result.context] : [{
				type: "status",
				result: result.value
			}, result.context]);
		}
		/**
		* Register a callback to be invoked upon signature updates
		*
		* @param signature Transaction signature string in base 58
		* @param callback Function to invoke on signature notifications
		* @param commitment Specify the commitment level signature must reach before notification
		* @return subscription id
		*/
		onSignature(signature$1, callback, commitment) {
			const args = this._buildArgs([signature$1], commitment || this._commitment || "finalized");
			const clientSubscriptionId = this._makeSubscription({
				callback: (notification, context) => {
					if (notification.type === "status") {
						callback(notification.result, context);
						try {
							this.removeSignatureListener(clientSubscriptionId);
						} catch (_err) {}
					}
				},
				method: "signatureSubscribe",
				unsubscribeMethod: "signatureUnsubscribe"
			}, args);
			return clientSubscriptionId;
		}
		/**
		* Register a callback to be invoked when a transaction is
		* received and/or processed.
		*
		* @param signature Transaction signature string in base 58
		* @param callback Function to invoke on signature notifications
		* @param options Enable received notifications and set the commitment
		*   level that signature must reach before notification
		* @return subscription id
		*/
		onSignatureWithOptions(signature$1, callback, options) {
			const { commitment, ...extra } = {
				...options,
				commitment: options && options.commitment || this._commitment || "finalized"
			};
			const args = this._buildArgs([signature$1], commitment, void 0, extra);
			const clientSubscriptionId = this._makeSubscription({
				callback: (notification, context) => {
					callback(notification, context);
					try {
						this.removeSignatureListener(clientSubscriptionId);
					} catch (_err) {}
				},
				method: "signatureSubscribe",
				unsubscribeMethod: "signatureUnsubscribe"
			}, args);
			return clientSubscriptionId;
		}
		/**
		* Deregister a signature notification callback
		*
		* @param clientSubscriptionId client subscription id to deregister
		*/
		async removeSignatureListener(clientSubscriptionId) {
			await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
		}
		/**
		* @internal
		*/
		_wsOnRootNotification(notification) {
			const { result, subscription } = create(notification, RootNotificationResult);
			this._handleServerNotification(subscription, [result]);
		}
		/**
		* Register a callback to be invoked upon root changes
		*
		* @param callback Function to invoke whenever the root changes
		* @return subscription id
		*/
		onRootChange(callback) {
			return this._makeSubscription({
				callback,
				method: "rootSubscribe",
				unsubscribeMethod: "rootUnsubscribe"
			}, []);
		}
		/**
		* Deregister a root notification callback
		*
		* @param clientSubscriptionId client subscription id to deregister
		*/
		async removeRootChangeListener(clientSubscriptionId) {
			await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
		}
	};
	Keypair = class Keypair {
		/**
		* Create a new keypair instance.
		* Generate random keypair if no {@link Ed25519Keypair} is provided.
		*
		* @param {Ed25519Keypair} keypair ed25519 keypair
		*/
		constructor(keypair) {
			this._keypair = void 0;
			this._keypair = keypair ?? generateKeypair();
		}
		/**
		* Generate a new random keypair
		*
		* @returns {Keypair} Keypair
		*/
		static generate() {
			return new Keypair(generateKeypair());
		}
		/**
		* Create a keypair from a raw secret key byte array.
		*
		* This method should only be used to recreate a keypair from a previously
		* generated secret key. Generating keypairs from a random seed should be done
		* with the {@link Keypair.fromSeed} method.
		*
		* @throws error if the provided secret key is invalid and validation is not skipped.
		*
		* @param secretKey secret key byte array
		* @param options skip secret key validation
		*
		* @returns {Keypair} Keypair
		*/
		static fromSecretKey(secretKey, options) {
			if (secretKey.byteLength !== 64) throw new Error("bad secret key size");
			const publicKey$1 = secretKey.slice(32, 64);
			if (!options || !options.skipValidation) {
				const computedPublicKey = getPublicKey(secretKey.slice(0, 32));
				for (let ii = 0; ii < 32; ii++) if (publicKey$1[ii] !== computedPublicKey[ii]) throw new Error("provided secretKey is invalid");
			}
			return new Keypair({
				publicKey: publicKey$1,
				secretKey
			});
		}
		/**
		* Generate a keypair from a 32 byte seed.
		*
		* @param seed seed byte array
		*
		* @returns {Keypair} Keypair
		*/
		static fromSeed(seed) {
			const publicKey$1 = getPublicKey(seed);
			const secretKey = new Uint8Array(64);
			secretKey.set(seed);
			secretKey.set(publicKey$1, 32);
			return new Keypair({
				publicKey: publicKey$1,
				secretKey
			});
		}
		/**
		* The public key for this keypair
		*
		* @returns {PublicKey} PublicKey
		*/
		get publicKey() {
			return new PublicKey(this._keypair.publicKey);
		}
		/**
		* The raw secret key for this keypair
		* @returns {Uint8Array} Secret key in an array of Uint8 bytes
		*/
		get secretKey() {
			return new Uint8Array(this._keypair.secretKey);
		}
	};
	LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
		CreateLookupTable: {
			index: 0,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				u64("recentSlot"),
				import_Layout.u8("bumpSeed")
			])
		},
		FreezeLookupTable: {
			index: 1,
			layout: import_Layout.struct([import_Layout.u32("instruction")])
		},
		ExtendLookupTable: {
			index: 2,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				u64(),
				import_Layout.seq(publicKey(), import_Layout.offset(import_Layout.u32(), -8), "addresses")
			])
		},
		DeactivateLookupTable: {
			index: 3,
			layout: import_Layout.struct([import_Layout.u32("instruction")])
		},
		CloseLookupTable: {
			index: 4,
			layout: import_Layout.struct([import_Layout.u32("instruction")])
		}
	});
	AddressLookupTableInstruction = class {
		/**
		* @internal
		*/
		constructor() {}
		static decodeInstructionType(instruction) {
			this.checkProgramId(instruction.programId);
			const index = import_Layout.u32("instruction").decode(instruction.data);
			let type$1;
			for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) if (layout.index == index) {
				type$1 = layoutType;
				break;
			}
			if (!type$1) throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
			return type$1;
		}
		static decodeCreateLookupTable(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeysLength(instruction.keys, 4);
			const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
			return {
				authority: instruction.keys[1].pubkey,
				payer: instruction.keys[2].pubkey,
				recentSlot: Number(recentSlot)
			};
		}
		static decodeExtendLookupTable(instruction) {
			this.checkProgramId(instruction.programId);
			if (instruction.keys.length < 2) throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
			const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
			return {
				lookupTable: instruction.keys[0].pubkey,
				authority: instruction.keys[1].pubkey,
				payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : void 0,
				addresses: addresses.map((buffer$1) => new PublicKey(buffer$1))
			};
		}
		static decodeCloseLookupTable(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeysLength(instruction.keys, 3);
			return {
				lookupTable: instruction.keys[0].pubkey,
				authority: instruction.keys[1].pubkey,
				recipient: instruction.keys[2].pubkey
			};
		}
		static decodeFreezeLookupTable(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeysLength(instruction.keys, 2);
			return {
				lookupTable: instruction.keys[0].pubkey,
				authority: instruction.keys[1].pubkey
			};
		}
		static decodeDeactivateLookupTable(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeysLength(instruction.keys, 2);
			return {
				lookupTable: instruction.keys[0].pubkey,
				authority: instruction.keys[1].pubkey
			};
		}
		/**
		* @internal
		*/
		static checkProgramId(programId) {
			if (!programId.equals(AddressLookupTableProgram.programId)) throw new Error("invalid instruction; programId is not AddressLookupTable Program");
		}
		/**
		* @internal
		*/
		static checkKeysLength(keys, expectedLength) {
			if (keys.length < expectedLength) throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
		}
	};
	AddressLookupTableProgram = class {
		/**
		* @internal
		*/
		constructor() {}
		static createLookupTable(params) {
			const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder().encode(params.recentSlot)], this.programId);
			const type$1 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
			const data = encodeData(type$1, {
				recentSlot: BigInt(params.recentSlot),
				bumpSeed
			});
			const keys = [
				{
					pubkey: lookupTableAddress,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: params.authority,
					isSigner: true,
					isWritable: false
				},
				{
					pubkey: params.payer,
					isSigner: true,
					isWritable: true
				},
				{
					pubkey: SystemProgram.programId,
					isSigner: false,
					isWritable: false
				}
			];
			return [new TransactionInstruction({
				programId: this.programId,
				keys,
				data
			}), lookupTableAddress];
		}
		static freezeLookupTable(params) {
			const type$1 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
			const data = encodeData(type$1);
			const keys = [{
				pubkey: params.lookupTable,
				isSigner: false,
				isWritable: true
			}, {
				pubkey: params.authority,
				isSigner: true,
				isWritable: false
			}];
			return new TransactionInstruction({
				programId: this.programId,
				keys,
				data
			});
		}
		static extendLookupTable(params) {
			const type$1 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
			const data = encodeData(type$1, { addresses: params.addresses.map((addr) => addr.toBytes()) });
			const keys = [{
				pubkey: params.lookupTable,
				isSigner: false,
				isWritable: true
			}, {
				pubkey: params.authority,
				isSigner: true,
				isWritable: false
			}];
			if (params.payer) keys.push({
				pubkey: params.payer,
				isSigner: true,
				isWritable: true
			}, {
				pubkey: SystemProgram.programId,
				isSigner: false,
				isWritable: false
			});
			return new TransactionInstruction({
				programId: this.programId,
				keys,
				data
			});
		}
		static deactivateLookupTable(params) {
			const type$1 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
			const data = encodeData(type$1);
			const keys = [{
				pubkey: params.lookupTable,
				isSigner: false,
				isWritable: true
			}, {
				pubkey: params.authority,
				isSigner: true,
				isWritable: false
			}];
			return new TransactionInstruction({
				programId: this.programId,
				keys,
				data
			});
		}
		static closeLookupTable(params) {
			const type$1 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
			const data = encodeData(type$1);
			const keys = [
				{
					pubkey: params.lookupTable,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: params.authority,
					isSigner: true,
					isWritable: false
				},
				{
					pubkey: params.recipient,
					isSigner: false,
					isWritable: true
				}
			];
			return new TransactionInstruction({
				programId: this.programId,
				keys,
				data
			});
		}
	};
	AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
	ComputeBudgetInstruction = class {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Decode a compute budget instruction and retrieve the instruction type.
		*/
		static decodeInstructionType(instruction) {
			this.checkProgramId(instruction.programId);
			const typeIndex = import_Layout.u8("instruction").decode(instruction.data);
			let type$1;
			for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) if (layout.index == typeIndex) {
				type$1 = ixType;
				break;
			}
			if (!type$1) throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
			return type$1;
		}
		/**
		* Decode request units compute budget instruction and retrieve the instruction params.
		*/
		static decodeRequestUnits(instruction) {
			this.checkProgramId(instruction.programId);
			const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
			return {
				units,
				additionalFee
			};
		}
		/**
		* Decode request heap frame compute budget instruction and retrieve the instruction params.
		*/
		static decodeRequestHeapFrame(instruction) {
			this.checkProgramId(instruction.programId);
			const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
			return { bytes };
		}
		/**
		* Decode set compute unit limit compute budget instruction and retrieve the instruction params.
		*/
		static decodeSetComputeUnitLimit(instruction) {
			this.checkProgramId(instruction.programId);
			const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
			return { units };
		}
		/**
		* Decode set compute unit price compute budget instruction and retrieve the instruction params.
		*/
		static decodeSetComputeUnitPrice(instruction) {
			this.checkProgramId(instruction.programId);
			const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
			return { microLamports };
		}
		/**
		* @internal
		*/
		static checkProgramId(programId) {
			if (!programId.equals(ComputeBudgetProgram.programId)) throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
		}
	};
	COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
		RequestUnits: {
			index: 0,
			layout: import_Layout.struct([
				import_Layout.u8("instruction"),
				import_Layout.u32("units"),
				import_Layout.u32("additionalFee")
			])
		},
		RequestHeapFrame: {
			index: 1,
			layout: import_Layout.struct([import_Layout.u8("instruction"), import_Layout.u32("bytes")])
		},
		SetComputeUnitLimit: {
			index: 2,
			layout: import_Layout.struct([import_Layout.u8("instruction"), import_Layout.u32("units")])
		},
		SetComputeUnitPrice: {
			index: 3,
			layout: import_Layout.struct([import_Layout.u8("instruction"), u64("microLamports")])
		}
	});
	ComputeBudgetProgram = class {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Public key that identifies the Compute Budget program
		*/
		/**
		* @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
		*/
		static requestUnits(params) {
			const type$1 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
			const data = encodeData(type$1, params);
			return new TransactionInstruction({
				keys: [],
				programId: this.programId,
				data
			});
		}
		static requestHeapFrame(params) {
			const type$1 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
			const data = encodeData(type$1, params);
			return new TransactionInstruction({
				keys: [],
				programId: this.programId,
				data
			});
		}
		static setComputeUnitLimit(params) {
			const type$1 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
			const data = encodeData(type$1, params);
			return new TransactionInstruction({
				keys: [],
				programId: this.programId,
				data
			});
		}
		static setComputeUnitPrice(params) {
			const type$1 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
			const data = encodeData(type$1, { microLamports: BigInt(params.microLamports) });
			return new TransactionInstruction({
				keys: [],
				programId: this.programId,
				data
			});
		}
	};
	ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
	PRIVATE_KEY_BYTES$1 = 64;
	PUBLIC_KEY_BYTES$1 = 32;
	SIGNATURE_BYTES = 64;
	ED25519_INSTRUCTION_LAYOUT = import_Layout.struct([
		import_Layout.u8("numSignatures"),
		import_Layout.u8("padding"),
		import_Layout.u16("signatureOffset"),
		import_Layout.u16("signatureInstructionIndex"),
		import_Layout.u16("publicKeyOffset"),
		import_Layout.u16("publicKeyInstructionIndex"),
		import_Layout.u16("messageDataOffset"),
		import_Layout.u16("messageDataSize"),
		import_Layout.u16("messageInstructionIndex")
	]);
	Ed25519Program = class Ed25519Program {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Public key that identifies the ed25519 program
		*/
		/**
		* Create an ed25519 instruction with a public key and signature. The
		* public key must be a buffer that is 32 bytes long, and the signature
		* must be a buffer of 64 bytes.
		*/
		static createInstructionWithPublicKey(params) {
			const { publicKey: publicKey$1, message, signature: signature$1, instructionIndex } = params;
			assert$1(publicKey$1.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey$1.length} bytes`);
			assert$1(signature$1.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature$1.length} bytes`);
			const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
			const signatureOffset = publicKeyOffset + publicKey$1.length;
			const messageDataOffset = signatureOffset + signature$1.length;
			const numSignatures = 1;
			const instructionData = import_buffer.Buffer.alloc(messageDataOffset + message.length);
			const index = instructionIndex == null ? 65535 : instructionIndex;
			ED25519_INSTRUCTION_LAYOUT.encode({
				numSignatures,
				padding: 0,
				signatureOffset,
				signatureInstructionIndex: index,
				publicKeyOffset,
				publicKeyInstructionIndex: index,
				messageDataOffset,
				messageDataSize: message.length,
				messageInstructionIndex: index
			}, instructionData);
			instructionData.fill(publicKey$1, publicKeyOffset);
			instructionData.fill(signature$1, signatureOffset);
			instructionData.fill(message, messageDataOffset);
			return new TransactionInstruction({
				keys: [],
				programId: Ed25519Program.programId,
				data: instructionData
			});
		}
		/**
		* Create an ed25519 instruction with a private key. The private key
		* must be a buffer that is 64 bytes long.
		*/
		static createInstructionWithPrivateKey(params) {
			const { privateKey, message, instructionIndex } = params;
			assert$1(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
			try {
				const keypair = Keypair.fromSecretKey(privateKey);
				const publicKey$1 = keypair.publicKey.toBytes();
				const signature$1 = sign(message, keypair.secretKey);
				return this.createInstructionWithPublicKey({
					publicKey: publicKey$1,
					message,
					signature: signature$1,
					instructionIndex
				});
			} catch (error) {
				throw new Error(`Error creating instruction; ${error}`);
			}
		}
	};
	Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
	ecdsaSign = (msgHash, privKey) => {
		const signature$1 = secp256k1.sign(msgHash, privKey);
		return [signature$1.toCompactRawBytes(), signature$1.recovery];
	};
	secp256k1.utils.isValidPrivateKey;
	publicKeyCreate = secp256k1.getPublicKey;
	PRIVATE_KEY_BYTES = 32;
	ETHEREUM_ADDRESS_BYTES = 20;
	PUBLIC_KEY_BYTES = 64;
	SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
	SECP256K1_INSTRUCTION_LAYOUT = import_Layout.struct([
		import_Layout.u8("numSignatures"),
		import_Layout.u16("signatureOffset"),
		import_Layout.u8("signatureInstructionIndex"),
		import_Layout.u16("ethAddressOffset"),
		import_Layout.u8("ethAddressInstructionIndex"),
		import_Layout.u16("messageDataOffset"),
		import_Layout.u16("messageDataSize"),
		import_Layout.u8("messageInstructionIndex"),
		import_Layout.blob(20, "ethAddress"),
		import_Layout.blob(64, "signature"),
		import_Layout.u8("recoveryId")
	]);
	Secp256k1Program = class Secp256k1Program {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Public key that identifies the secp256k1 program
		*/
		/**
		* Construct an Ethereum address from a secp256k1 public key buffer.
		* @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
		*/
		static publicKeyToEthAddress(publicKey$1) {
			assert$1(publicKey$1.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey$1.length} bytes`);
			try {
				return import_buffer.Buffer.from(keccak_256(toBuffer(publicKey$1))).slice(-ETHEREUM_ADDRESS_BYTES);
			} catch (error) {
				throw new Error(`Error constructing Ethereum address: ${error}`);
			}
		}
		/**
		* Create an secp256k1 instruction with a public key. The public key
		* must be a buffer that is 64 bytes long.
		*/
		static createInstructionWithPublicKey(params) {
			const { publicKey: publicKey$1, message, signature: signature$1, recoveryId, instructionIndex } = params;
			return Secp256k1Program.createInstructionWithEthAddress({
				ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey$1),
				message,
				signature: signature$1,
				recoveryId,
				instructionIndex
			});
		}
		/**
		* Create an secp256k1 instruction with an Ethereum address. The address
		* must be a hex string or a buffer that is 20 bytes long.
		*/
		static createInstructionWithEthAddress(params) {
			const { ethAddress: rawAddress, message, signature: signature$1, recoveryId, instructionIndex = 0 } = params;
			let ethAddress;
			if (typeof rawAddress === "string") if (rawAddress.startsWith("0x")) ethAddress = import_buffer.Buffer.from(rawAddress.substr(2), "hex");
			else ethAddress = import_buffer.Buffer.from(rawAddress, "hex");
			else ethAddress = rawAddress;
			assert$1(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
			const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
			const ethAddressOffset = dataStart;
			const signatureOffset = dataStart + ethAddress.length;
			const messageDataOffset = signatureOffset + signature$1.length + 1;
			const numSignatures = 1;
			const instructionData = import_buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
			SECP256K1_INSTRUCTION_LAYOUT.encode({
				numSignatures,
				signatureOffset,
				signatureInstructionIndex: instructionIndex,
				ethAddressOffset,
				ethAddressInstructionIndex: instructionIndex,
				messageDataOffset,
				messageDataSize: message.length,
				messageInstructionIndex: instructionIndex,
				signature: toBuffer(signature$1),
				ethAddress: toBuffer(ethAddress),
				recoveryId
			}, instructionData);
			instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
			return new TransactionInstruction({
				keys: [],
				programId: Secp256k1Program.programId,
				data: instructionData
			});
		}
		/**
		* Create an secp256k1 instruction with a private key. The private key
		* must be a buffer that is 32 bytes long.
		*/
		static createInstructionWithPrivateKey(params) {
			const { privateKey: pkey, message, instructionIndex } = params;
			assert$1(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
			try {
				const privateKey = toBuffer(pkey);
				const publicKey$1 = publicKeyCreate(privateKey, false).slice(1);
				const [signature$1, recoveryId] = ecdsaSign(import_buffer.Buffer.from(keccak_256(toBuffer(message))), privateKey);
				return this.createInstructionWithPublicKey({
					publicKey: publicKey$1,
					message,
					signature: signature$1,
					recoveryId,
					instructionIndex
				});
			} catch (error) {
				throw new Error(`Error creating instruction; ${error}`);
			}
		}
	};
	Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
	;
	STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
	Authorized = class {
		/**
		* Create a new Authorized object
		* @param staker the stake authority
		* @param withdrawer the withdraw authority
		*/
		constructor(staker, withdrawer) {
			/** stake authority */
			this.staker = void 0;
			/** withdraw authority */
			this.withdrawer = void 0;
			this.staker = staker;
			this.withdrawer = withdrawer;
		}
	};
	Lockup = class {
		/**
		* Create a new Lockup object
		*/
		constructor(unixTimestamp, epoch, custodian) {
			/** Unix timestamp of lockup expiration */
			this.unixTimestamp = void 0;
			/** Epoch of lockup expiration */
			this.epoch = void 0;
			/** Lockup custodian authority */
			this.custodian = void 0;
			this.unixTimestamp = unixTimestamp;
			this.epoch = epoch;
			this.custodian = custodian;
		}
	};
	_Lockup = Lockup;
	Lockup.default = new _Lockup(0, 0, PublicKey.default);
	StakeInstruction = class {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Decode a stake instruction and retrieve the instruction type.
		*/
		static decodeInstructionType(instruction) {
			this.checkProgramId(instruction.programId);
			const typeIndex = import_Layout.u32("instruction").decode(instruction.data);
			let type$1;
			for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) if (layout.index == typeIndex) {
				type$1 = ixType;
				break;
			}
			if (!type$1) throw new Error("Instruction type incorrect; not a StakeInstruction");
			return type$1;
		}
		/**
		* Decode a initialize stake instruction and retrieve the instruction params.
		*/
		static decodeInitialize(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 2);
			const { authorized: authorized$1, lockup: lockup$1 } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
			return {
				stakePubkey: instruction.keys[0].pubkey,
				authorized: new Authorized(new PublicKey(authorized$1.staker), new PublicKey(authorized$1.withdrawer)),
				lockup: new Lockup(lockup$1.unixTimestamp, lockup$1.epoch, new PublicKey(lockup$1.custodian))
			};
		}
		/**
		* Decode a delegate stake instruction and retrieve the instruction params.
		*/
		static decodeDelegate(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 6);
			decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
			return {
				stakePubkey: instruction.keys[0].pubkey,
				votePubkey: instruction.keys[1].pubkey,
				authorizedPubkey: instruction.keys[5].pubkey
			};
		}
		/**
		* Decode an authorize stake instruction and retrieve the instruction params.
		*/
		static decodeAuthorize(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 3);
			const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
			const o = {
				stakePubkey: instruction.keys[0].pubkey,
				authorizedPubkey: instruction.keys[2].pubkey,
				newAuthorizedPubkey: new PublicKey(newAuthorized),
				stakeAuthorizationType: { index: stakeAuthorizationType }
			};
			if (instruction.keys.length > 3) o.custodianPubkey = instruction.keys[3].pubkey;
			return o;
		}
		/**
		* Decode an authorize-with-seed stake instruction and retrieve the instruction params.
		*/
		static decodeAuthorizeWithSeed(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 2);
			const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
			const o = {
				stakePubkey: instruction.keys[0].pubkey,
				authorityBase: instruction.keys[1].pubkey,
				authoritySeed,
				authorityOwner: new PublicKey(authorityOwner),
				newAuthorizedPubkey: new PublicKey(newAuthorized),
				stakeAuthorizationType: { index: stakeAuthorizationType }
			};
			if (instruction.keys.length > 3) o.custodianPubkey = instruction.keys[3].pubkey;
			return o;
		}
		/**
		* Decode a split stake instruction and retrieve the instruction params.
		*/
		static decodeSplit(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 3);
			const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
			return {
				stakePubkey: instruction.keys[0].pubkey,
				splitStakePubkey: instruction.keys[1].pubkey,
				authorizedPubkey: instruction.keys[2].pubkey,
				lamports
			};
		}
		/**
		* Decode a merge stake instruction and retrieve the instruction params.
		*/
		static decodeMerge(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 3);
			decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
			return {
				stakePubkey: instruction.keys[0].pubkey,
				sourceStakePubKey: instruction.keys[1].pubkey,
				authorizedPubkey: instruction.keys[4].pubkey
			};
		}
		/**
		* Decode a withdraw stake instruction and retrieve the instruction params.
		*/
		static decodeWithdraw(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 5);
			const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
			const o = {
				stakePubkey: instruction.keys[0].pubkey,
				toPubkey: instruction.keys[1].pubkey,
				authorizedPubkey: instruction.keys[4].pubkey,
				lamports
			};
			if (instruction.keys.length > 5) o.custodianPubkey = instruction.keys[5].pubkey;
			return o;
		}
		/**
		* Decode a deactivate stake instruction and retrieve the instruction params.
		*/
		static decodeDeactivate(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 3);
			decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
			return {
				stakePubkey: instruction.keys[0].pubkey,
				authorizedPubkey: instruction.keys[2].pubkey
			};
		}
		/**
		* @internal
		*/
		static checkProgramId(programId) {
			if (!programId.equals(StakeProgram.programId)) throw new Error("invalid instruction; programId is not StakeProgram");
		}
		/**
		* @internal
		*/
		static checkKeyLength(keys, expectedLength) {
			if (keys.length < expectedLength) throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
		}
	};
	STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
		Initialize: {
			index: 0,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				authorized(),
				lockup()
			])
		},
		Authorize: {
			index: 1,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				publicKey("newAuthorized"),
				import_Layout.u32("stakeAuthorizationType")
			])
		},
		Delegate: {
			index: 2,
			layout: import_Layout.struct([import_Layout.u32("instruction")])
		},
		Split: {
			index: 3,
			layout: import_Layout.struct([import_Layout.u32("instruction"), import_Layout.ns64("lamports")])
		},
		Withdraw: {
			index: 4,
			layout: import_Layout.struct([import_Layout.u32("instruction"), import_Layout.ns64("lamports")])
		},
		Deactivate: {
			index: 5,
			layout: import_Layout.struct([import_Layout.u32("instruction")])
		},
		Merge: {
			index: 7,
			layout: import_Layout.struct([import_Layout.u32("instruction")])
		},
		AuthorizeWithSeed: {
			index: 8,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				publicKey("newAuthorized"),
				import_Layout.u32("stakeAuthorizationType"),
				rustString("authoritySeed"),
				publicKey("authorityOwner")
			])
		}
	});
	StakeAuthorizationLayout = Object.freeze({
		Staker: { index: 0 },
		Withdrawer: { index: 1 }
	});
	StakeProgram = class {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Public key that identifies the Stake program
		*/
		/**
		* Generate an Initialize instruction to add to a Stake Create transaction
		*/
		static initialize(params) {
			const { stakePubkey, authorized: authorized$1, lockup: maybeLockup } = params;
			const lockup$1 = maybeLockup || Lockup.default;
			const type$1 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
			const data = encodeData(type$1, {
				authorized: {
					staker: toBuffer(authorized$1.staker.toBuffer()),
					withdrawer: toBuffer(authorized$1.withdrawer.toBuffer())
				},
				lockup: {
					unixTimestamp: lockup$1.unixTimestamp,
					epoch: lockup$1.epoch,
					custodian: toBuffer(lockup$1.custodian.toBuffer())
				}
			});
			return new TransactionInstruction({
				keys: [{
					pubkey: stakePubkey,
					isSigner: false,
					isWritable: true
				}, {
					pubkey: SYSVAR_RENT_PUBKEY,
					isSigner: false,
					isWritable: false
				}],
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a Transaction that creates a new Stake account at
		*   an address generated with `from`, a seed, and the Stake programId
		*/
		static createAccountWithSeed(params) {
			const transaction = new Transaction();
			transaction.add(SystemProgram.createAccountWithSeed({
				fromPubkey: params.fromPubkey,
				newAccountPubkey: params.stakePubkey,
				basePubkey: params.basePubkey,
				seed: params.seed,
				lamports: params.lamports,
				space: this.space,
				programId: this.programId
			}));
			const { stakePubkey, authorized: authorized$1, lockup: lockup$1 } = params;
			return transaction.add(this.initialize({
				stakePubkey,
				authorized: authorized$1,
				lockup: lockup$1
			}));
		}
		/**
		* Generate a Transaction that creates a new Stake account
		*/
		static createAccount(params) {
			const transaction = new Transaction();
			transaction.add(SystemProgram.createAccount({
				fromPubkey: params.fromPubkey,
				newAccountPubkey: params.stakePubkey,
				lamports: params.lamports,
				space: this.space,
				programId: this.programId
			}));
			const { stakePubkey, authorized: authorized$1, lockup: lockup$1 } = params;
			return transaction.add(this.initialize({
				stakePubkey,
				authorized: authorized$1,
				lockup: lockup$1
			}));
		}
		/**
		* Generate a Transaction that delegates Stake tokens to a validator
		* Vote PublicKey. This transaction can also be used to redelegate Stake
		* to a new validator Vote PublicKey.
		*/
		static delegate(params) {
			const { stakePubkey, authorizedPubkey, votePubkey } = params;
			const type$1 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
			const data = encodeData(type$1);
			return new Transaction().add({
				keys: [
					{
						pubkey: stakePubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: votePubkey,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: SYSVAR_CLOCK_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: STAKE_CONFIG_ID,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: authorizedPubkey,
						isSigner: true,
						isWritable: false
					}
				],
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a Transaction that authorizes a new PublicKey as Staker
		* or Withdrawer on the Stake account.
		*/
		static authorize(params) {
			const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;
			const type$1 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
			const data = encodeData(type$1, {
				newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
				stakeAuthorizationType: stakeAuthorizationType.index
			});
			const keys = [
				{
					pubkey: stakePubkey,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: SYSVAR_CLOCK_PUBKEY,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: authorizedPubkey,
					isSigner: true,
					isWritable: false
				}
			];
			if (custodianPubkey) keys.push({
				pubkey: custodianPubkey,
				isSigner: true,
				isWritable: false
			});
			return new Transaction().add({
				keys,
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a Transaction that authorizes a new PublicKey as Staker
		* or Withdrawer on the Stake account.
		*/
		static authorizeWithSeed(params) {
			const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;
			const type$1 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
			const data = encodeData(type$1, {
				newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
				stakeAuthorizationType: stakeAuthorizationType.index,
				authoritySeed,
				authorityOwner: toBuffer(authorityOwner.toBuffer())
			});
			const keys = [
				{
					pubkey: stakePubkey,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: authorityBase,
					isSigner: true,
					isWritable: false
				},
				{
					pubkey: SYSVAR_CLOCK_PUBKEY,
					isSigner: false,
					isWritable: false
				}
			];
			if (custodianPubkey) keys.push({
				pubkey: custodianPubkey,
				isSigner: true,
				isWritable: false
			});
			return new Transaction().add({
				keys,
				programId: this.programId,
				data
			});
		}
		/**
		* @internal
		*/
		static splitInstruction(params) {
			const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;
			const type$1 = STAKE_INSTRUCTION_LAYOUTS.Split;
			const data = encodeData(type$1, { lamports });
			return new TransactionInstruction({
				keys: [
					{
						pubkey: stakePubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: splitStakePubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: authorizedPubkey,
						isSigner: true,
						isWritable: false
					}
				],
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a Transaction that splits Stake tokens into another stake account
		*/
		static split(params, rentExemptReserve) {
			const transaction = new Transaction();
			transaction.add(SystemProgram.createAccount({
				fromPubkey: params.authorizedPubkey,
				newAccountPubkey: params.splitStakePubkey,
				lamports: rentExemptReserve,
				space: this.space,
				programId: this.programId
			}));
			return transaction.add(this.splitInstruction(params));
		}
		/**
		* Generate a Transaction that splits Stake tokens into another account
		* derived from a base public key and seed
		*/
		static splitWithSeed(params, rentExemptReserve) {
			const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;
			const transaction = new Transaction();
			transaction.add(SystemProgram.allocate({
				accountPubkey: splitStakePubkey,
				basePubkey,
				seed,
				space: this.space,
				programId: this.programId
			}));
			if (rentExemptReserve && rentExemptReserve > 0) transaction.add(SystemProgram.transfer({
				fromPubkey: params.authorizedPubkey,
				toPubkey: splitStakePubkey,
				lamports: rentExemptReserve
			}));
			return transaction.add(this.splitInstruction({
				stakePubkey,
				authorizedPubkey,
				splitStakePubkey,
				lamports
			}));
		}
		/**
		* Generate a Transaction that merges Stake accounts.
		*/
		static merge(params) {
			const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;
			const type$1 = STAKE_INSTRUCTION_LAYOUTS.Merge;
			const data = encodeData(type$1);
			return new Transaction().add({
				keys: [
					{
						pubkey: stakePubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: sourceStakePubKey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: SYSVAR_CLOCK_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: authorizedPubkey,
						isSigner: true,
						isWritable: false
					}
				],
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a Transaction that withdraws deactivated Stake tokens.
		*/
		static withdraw(params) {
			const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;
			const type$1 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
			const data = encodeData(type$1, { lamports });
			const keys = [
				{
					pubkey: stakePubkey,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: toPubkey,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: SYSVAR_CLOCK_PUBKEY,
					isSigner: false,
					isWritable: false
				},
				{
					pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
					isSigner: false,
					isWritable: false
				},
				{
					pubkey: authorizedPubkey,
					isSigner: true,
					isWritable: false
				}
			];
			if (custodianPubkey) keys.push({
				pubkey: custodianPubkey,
				isSigner: true,
				isWritable: false
			});
			return new Transaction().add({
				keys,
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a Transaction that deactivates Stake tokens.
		*/
		static deactivate(params) {
			const { stakePubkey, authorizedPubkey } = params;
			const type$1 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
			const data = encodeData(type$1);
			return new Transaction().add({
				keys: [
					{
						pubkey: stakePubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: SYSVAR_CLOCK_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: authorizedPubkey,
						isSigner: true,
						isWritable: false
					}
				],
				programId: this.programId,
				data
			});
		}
	};
	StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
	/**
	* Max space of a Stake account
	*
	* This is generated from the solana-stake-program StakeState struct as
	* `StakeStateV2::size_of()`:
	* https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html
	*/
	StakeProgram.space = 200;
	VoteInit = class {
		/** [0, 100] */
		constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
			this.nodePubkey = void 0;
			this.authorizedVoter = void 0;
			this.authorizedWithdrawer = void 0;
			this.commission = void 0;
			this.nodePubkey = nodePubkey;
			this.authorizedVoter = authorizedVoter;
			this.authorizedWithdrawer = authorizedWithdrawer;
			this.commission = commission;
		}
	};
	VoteInstruction = class {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Decode a vote instruction and retrieve the instruction type.
		*/
		static decodeInstructionType(instruction) {
			this.checkProgramId(instruction.programId);
			const typeIndex = import_Layout.u32("instruction").decode(instruction.data);
			let type$1;
			for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) if (layout.index == typeIndex) {
				type$1 = ixType;
				break;
			}
			if (!type$1) throw new Error("Instruction type incorrect; not a VoteInstruction");
			return type$1;
		}
		/**
		* Decode an initialize vote instruction and retrieve the instruction params.
		*/
		static decodeInitializeAccount(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 4);
			const { voteInit: voteInit$1 } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
			return {
				votePubkey: instruction.keys[0].pubkey,
				nodePubkey: instruction.keys[3].pubkey,
				voteInit: new VoteInit(new PublicKey(voteInit$1.nodePubkey), new PublicKey(voteInit$1.authorizedVoter), new PublicKey(voteInit$1.authorizedWithdrawer), voteInit$1.commission)
			};
		}
		/**
		* Decode an authorize instruction and retrieve the instruction params.
		*/
		static decodeAuthorize(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 3);
			const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
			return {
				votePubkey: instruction.keys[0].pubkey,
				authorizedPubkey: instruction.keys[2].pubkey,
				newAuthorizedPubkey: new PublicKey(newAuthorized),
				voteAuthorizationType: { index: voteAuthorizationType }
			};
		}
		/**
		* Decode an authorize instruction and retrieve the instruction params.
		*/
		static decodeAuthorizeWithSeed(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 3);
			const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
			return {
				currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
				currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
				currentAuthorityDerivedKeySeed,
				newAuthorizedPubkey: new PublicKey(newAuthorized),
				voteAuthorizationType: { index: voteAuthorizationType },
				votePubkey: instruction.keys[0].pubkey
			};
		}
		/**
		* Decode a withdraw instruction and retrieve the instruction params.
		*/
		static decodeWithdraw(instruction) {
			this.checkProgramId(instruction.programId);
			this.checkKeyLength(instruction.keys, 3);
			const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
			return {
				votePubkey: instruction.keys[0].pubkey,
				authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
				lamports,
				toPubkey: instruction.keys[1].pubkey
			};
		}
		/**
		* @internal
		*/
		static checkProgramId(programId) {
			if (!programId.equals(VoteProgram.programId)) throw new Error("invalid instruction; programId is not VoteProgram");
		}
		/**
		* @internal
		*/
		static checkKeyLength(keys, expectedLength) {
			if (keys.length < expectedLength) throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
		}
	};
	VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
		InitializeAccount: {
			index: 0,
			layout: import_Layout.struct([import_Layout.u32("instruction"), voteInit()])
		},
		Authorize: {
			index: 1,
			layout: import_Layout.struct([
				import_Layout.u32("instruction"),
				publicKey("newAuthorized"),
				import_Layout.u32("voteAuthorizationType")
			])
		},
		Withdraw: {
			index: 3,
			layout: import_Layout.struct([import_Layout.u32("instruction"), import_Layout.ns64("lamports")])
		},
		UpdateValidatorIdentity: {
			index: 4,
			layout: import_Layout.struct([import_Layout.u32("instruction")])
		},
		AuthorizeWithSeed: {
			index: 10,
			layout: import_Layout.struct([import_Layout.u32("instruction"), voteAuthorizeWithSeedArgs()])
		}
	});
	VoteAuthorizationLayout = Object.freeze({
		Voter: { index: 0 },
		Withdrawer: { index: 1 }
	});
	VoteProgram = class VoteProgram {
		/**
		* @internal
		*/
		constructor() {}
		/**
		* Public key that identifies the Vote program
		*/
		/**
		* Generate an Initialize instruction.
		*/
		static initializeAccount(params) {
			const { votePubkey, nodePubkey, voteInit: voteInit$1 } = params;
			const type$1 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
			const data = encodeData(type$1, { voteInit: {
				nodePubkey: toBuffer(voteInit$1.nodePubkey.toBuffer()),
				authorizedVoter: toBuffer(voteInit$1.authorizedVoter.toBuffer()),
				authorizedWithdrawer: toBuffer(voteInit$1.authorizedWithdrawer.toBuffer()),
				commission: voteInit$1.commission
			} });
			return new TransactionInstruction({
				keys: [
					{
						pubkey: votePubkey,
						isSigner: false,
						isWritable: true
					},
					{
						pubkey: SYSVAR_RENT_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: SYSVAR_CLOCK_PUBKEY,
						isSigner: false,
						isWritable: false
					},
					{
						pubkey: nodePubkey,
						isSigner: true,
						isWritable: false
					}
				],
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction that creates a new Vote account.
		*/
		static createAccount(params) {
			const transaction = new Transaction();
			transaction.add(SystemProgram.createAccount({
				fromPubkey: params.fromPubkey,
				newAccountPubkey: params.votePubkey,
				lamports: params.lamports,
				space: this.space,
				programId: this.programId
			}));
			return transaction.add(this.initializeAccount({
				votePubkey: params.votePubkey,
				nodePubkey: params.voteInit.nodePubkey,
				voteInit: params.voteInit
			}));
		}
		/**
		* Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
		*/
		static authorize(params) {
			const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;
			const type$1 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
			const data = encodeData(type$1, {
				newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
				voteAuthorizationType: voteAuthorizationType.index
			});
			const keys = [
				{
					pubkey: votePubkey,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: SYSVAR_CLOCK_PUBKEY,
					isSigner: false,
					isWritable: false
				},
				{
					pubkey: authorizedPubkey,
					isSigner: true,
					isWritable: false
				}
			];
			return new Transaction().add({
				keys,
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
		* where the current Voter or Withdrawer authority is a derived key.
		*/
		static authorizeWithSeed(params) {
			const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;
			const type$1 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
			const data = encodeData(type$1, { voteAuthorizeWithSeedArgs: {
				currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
				currentAuthorityDerivedKeySeed,
				newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
				voteAuthorizationType: voteAuthorizationType.index
			} });
			const keys = [
				{
					pubkey: votePubkey,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: SYSVAR_CLOCK_PUBKEY,
					isSigner: false,
					isWritable: false
				},
				{
					pubkey: currentAuthorityDerivedKeyBasePubkey,
					isSigner: true,
					isWritable: false
				}
			];
			return new Transaction().add({
				keys,
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction to withdraw from a Vote account.
		*/
		static withdraw(params) {
			const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;
			const type$1 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
			const data = encodeData(type$1, { lamports });
			const keys = [
				{
					pubkey: votePubkey,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: toPubkey,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: authorizedWithdrawerPubkey,
					isSigner: true,
					isWritable: false
				}
			];
			return new Transaction().add({
				keys,
				programId: this.programId,
				data
			});
		}
		/**
		* Generate a transaction to withdraw safely from a Vote account.
		*
		* This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
		* checks that the withdraw amount will not exceed the specified balance while leaving enough left
		* to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
		* `withdraw` method directly.
		*/
		static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
			if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) throw new Error("Withdraw will leave vote account with insufficient funds.");
			return VoteProgram.withdraw(params);
		}
		/**
		* Generate a transaction to update the validator identity (node pubkey) of a Vote account.
		*/
		static updateValidatorIdentity(params) {
			const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;
			const type$1 = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;
			const data = encodeData(type$1);
			const keys = [
				{
					pubkey: votePubkey,
					isSigner: false,
					isWritable: true
				},
				{
					pubkey: nodePubkey,
					isSigner: true,
					isWritable: false
				},
				{
					pubkey: authorizedWithdrawerPubkey,
					isSigner: true,
					isWritable: false
				}
			];
			return new Transaction().add({
				keys,
				programId: this.programId,
				data
			});
		}
	};
	VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
	/**
	* Max space of a Vote account
	*
	* This is generated from the solana-vote-program VoteState struct as
	* `VoteState::size_of()`:
	* https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of
	*
	* KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342
	*/
	VoteProgram.space = 3762;
	VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
	InfoString = type({
		name: string(),
		website: optional(string()),
		details: optional(string()),
		iconUrl: optional(string()),
		keybaseUsername: optional(string())
	});
	ValidatorInfo = class ValidatorInfo {
		/**
		* Construct a valid ValidatorInfo
		*
		* @param key validator public key
		* @param info validator information
		*/
		constructor(key, info) {
			/**
			* validator public key
			*/
			this.key = void 0;
			/**
			* validator information
			*/
			this.info = void 0;
			this.key = key;
			this.info = info;
		}
		/**
		* Deserialize ValidatorInfo from the config account data. Exactly two config
		* keys are required in the data.
		*
		* @param buffer config account data
		* @return null if info was not found
		*/
		static fromConfigData(buffer$1) {
			let byteArray = [...buffer$1];
			if (decodeLength(byteArray) !== 2) return null;
			const configKeys = [];
			for (let i$1 = 0; i$1 < 2; i$1++) {
				const publicKey$1 = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
				const isSigner = guardedShift(byteArray) === 1;
				configKeys.push({
					publicKey: publicKey$1,
					isSigner
				});
			}
			if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
				if (configKeys[1].isSigner) {
					const rawInfo = rustString().decode(import_buffer.Buffer.from(byteArray));
					const info = JSON.parse(rawInfo);
					assert(info, InfoString);
					return new ValidatorInfo(configKeys[1].publicKey, info);
				}
			}
			return null;
		}
	};
	VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
	VoteAccountLayout = import_Layout.struct([
		publicKey("nodePubkey"),
		publicKey("authorizedWithdrawer"),
		import_Layout.u8("commission"),
		import_Layout.nu64(),
		import_Layout.seq(import_Layout.struct([import_Layout.nu64("slot"), import_Layout.u32("confirmationCount")]), import_Layout.offset(import_Layout.u32(), -8), "votes"),
		import_Layout.u8("rootSlotValid"),
		import_Layout.nu64("rootSlot"),
		import_Layout.nu64(),
		import_Layout.seq(import_Layout.struct([import_Layout.nu64("epoch"), publicKey("authorizedVoter")]), import_Layout.offset(import_Layout.u32(), -8), "authorizedVoters"),
		import_Layout.struct([
			import_Layout.seq(import_Layout.struct([
				publicKey("authorizedPubkey"),
				import_Layout.nu64("epochOfLastAuthorizedSwitch"),
				import_Layout.nu64("targetEpoch")
			]), 32, "buf"),
			import_Layout.nu64("idx"),
			import_Layout.u8("isEmpty")
		], "priorVoters"),
		import_Layout.nu64(),
		import_Layout.seq(import_Layout.struct([
			import_Layout.nu64("epoch"),
			import_Layout.nu64("credits"),
			import_Layout.nu64("prevCredits")
		]), import_Layout.offset(import_Layout.u32(), -8), "epochCredits"),
		import_Layout.struct([import_Layout.nu64("slot"), import_Layout.nu64("timestamp")], "lastTimestamp")
	]);
	VoteAccount = class VoteAccount {
		/**
		* @internal
		*/
		constructor(args) {
			this.nodePubkey = void 0;
			this.authorizedWithdrawer = void 0;
			this.commission = void 0;
			this.rootSlot = void 0;
			this.votes = void 0;
			this.authorizedVoters = void 0;
			this.priorVoters = void 0;
			this.epochCredits = void 0;
			this.lastTimestamp = void 0;
			this.nodePubkey = args.nodePubkey;
			this.authorizedWithdrawer = args.authorizedWithdrawer;
			this.commission = args.commission;
			this.rootSlot = args.rootSlot;
			this.votes = args.votes;
			this.authorizedVoters = args.authorizedVoters;
			this.priorVoters = args.priorVoters;
			this.epochCredits = args.epochCredits;
			this.lastTimestamp = args.lastTimestamp;
		}
		/**
		* Deserialize VoteAccount from the account data.
		*
		* @param buffer account data
		* @return VoteAccount
		*/
		static fromAccountData(buffer$1) {
			const va = VoteAccountLayout.decode(toBuffer(buffer$1), 4);
			let rootSlot = va.rootSlot;
			if (!va.rootSlotValid) rootSlot = null;
			return new VoteAccount({
				nodePubkey: new PublicKey(va.nodePubkey),
				authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
				commission: va.commission,
				votes: va.votes,
				rootSlot,
				authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
				priorVoters: getPriorVoters(va.priorVoters),
				epochCredits: va.epochCredits,
				lastTimestamp: va.lastTimestamp
			});
		}
	};
	endpoint = {
		http: {
			devnet: "http://api.devnet.solana.com",
			testnet: "http://api.testnet.solana.com",
			"mainnet-beta": "http://api.mainnet-beta.solana.com/"
		},
		https: {
			devnet: "https://api.devnet.solana.com",
			testnet: "https://api.testnet.solana.com",
			"mainnet-beta": "https://api.mainnet-beta.solana.com/"
		}
	};
	LAMPORTS_PER_SOL = 1e9;
}) });

//#endregion
export { Struct as $, PUBLIC_KEY_LENGTH as A, require_Layout as At, SYSVAR_RECENT_BLOCKHASHES_PUBKEY as B, MAX_SEED_LENGTH as C, sendAndConfirmRawTransaction as Ct, NONCE_ACCOUNT_LENGTH as D, esm_browser_exports as Dt, MessageV0 as E, init_eventemitter3 as Et, STAKE_INSTRUCTION_LAYOUTS as F, SYSVAR_STAKE_HISTORY_PUBKEY as G, SYSVAR_REWARDS_PUBKEY as H, SYSTEM_INSTRUCTION_LAYOUTS as I, SolanaJSONRPCError as J, Secp256k1Program as K, SYSVAR_CLOCK_PUBKEY as L, SIGNATURE_LENGTH_IN_BYTES as M, ed25519 as Mt, SOLANA_SCHEMA as N, init_ed25519 as Nt, NonceAccount as O, init_esm_browser as Ot, STAKE_CONFIG_ID as P, StakeProgram as Q, SYSVAR_EPOCH_SCHEDULE_PUBKEY as R, Lockup as S, init_index_browser_esm as St, MessageAccountKeys as T, eventemitter3_default as Tt, SYSVAR_SLOT_HASHES_PUBKEY as U, SYSVAR_RENT_PUBKEY as V, SYSVAR_SLOT_HISTORY_PUBKEY as W, StakeAuthorizationLayout as X, SolanaJSONRPCErrorCode as Y, StakeInstruction as Z, FeeCalculatorLayout as _, VoteInit as _t, Authorized as a, TransactionExpiredTimeoutError as at, LOOKUP_TABLE_INSTRUCTION_LAYOUTS as b, clusterApiUrl as bt, BPF_LOADER_PROGRAM_ID as c, TransactionStatus as ct, ComputeBudgetInstruction as d, VOTE_PROGRAM_ID as dt, SystemInstruction as et, ComputeBudgetProgram as f, ValidatorInfo as ft, EpochSchedule as g, VoteAuthorizationLayout as gt, Enum as h, VoteAccount as ht, AddressLookupTableProgram as i, TransactionExpiredNonceInvalidError as it, PublicKey as j, require_safe_buffer as jt, PACKET_DATA_SIZE as k, v4_default as kt, BpfLoader as l, VALIDATOR_INFO_KEY as lt, Ed25519Program as m, VersionedTransaction as mt, AddressLookupTableAccount as n, Transaction as nt, BLOCKHASH_CACHE_TIMEOUT_MS as o, TransactionInstruction as ot, Connection as p, VersionedMessage as pt, SendTransactionError as q, AddressLookupTableInstruction as r, TransactionExpiredBlockheightExceededError as rt, BPF_LOADER_DEPRECATED_PROGRAM_ID as s, TransactionMessage as st, Account as t, SystemProgram as tt, COMPUTE_BUDGET_INSTRUCTION_LAYOUTS as u, VERSION_PREFIX_MASK as ut, Keypair as v, VoteInstruction as vt, Message as w, sendAndConfirmTransaction as wt, Loader as x, index_browser_esm_exports as xt, LAMPORTS_PER_SOL as y, VoteProgram as yt, SYSVAR_INSTRUCTIONS_PUBKEY as z };
//# sourceMappingURL=index.browser.esm-CCXoTR2h.js.map