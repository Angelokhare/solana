import { Et as init_eventemitter3, Tt as eventemitter3_default } from "./index.browser.esm-CCXoTR2h.js";
import { c as WalletNotConnectedError, d as WalletSendTransactionError, m as WalletSignTransactionError } from "./errors-DB0nNAUq.js";

//#region node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js
init_eventemitter3();
/**
* A wallet's readiness describes a series of states that the wallet can be in,
* depending on what kind of wallet it is. An installable wallet (eg. a browser
* extension like Phantom) might be `Installed` if we've found the Phantom API
* in the global scope, or `NotDetected` otherwise. A loadable, zero-install
* runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this
* metadata to personalize the wallet list for each user (eg. to show their
* installed wallets first).
*/
var WalletReadyState;
(function(WalletReadyState$1) {
	/**
	* User-installable wallets can typically be detected by scanning for an API
	* that they've injected into the global context. If such an API is present,
	* we consider the wallet to have been installed.
	*/
	WalletReadyState$1["Installed"] = "Installed";
	WalletReadyState$1["NotDetected"] = "NotDetected";
	/**
	* Loadable wallets are always available to you. Since you can load them at
	* any time, it's meaningless to say that they have been detected.
	*/
	WalletReadyState$1["Loadable"] = "Loadable";
	/**
	* If a wallet is not supported on a given platform (eg. server-rendering, or
	* mobile) then it will stay in the `Unsupported` state.
	*/
	WalletReadyState$1["Unsupported"] = "Unsupported";
})(WalletReadyState || (WalletReadyState = {}));
var BaseWalletAdapter = class extends eventemitter3_default {
	get connected() {
		return !!this.publicKey;
	}
	async autoConnect() {
		await this.connect();
	}
	async prepareTransaction(transaction, connection, options = {}) {
		const publicKey = this.publicKey;
		if (!publicKey) throw new WalletNotConnectedError();
		transaction.feePayer = transaction.feePayer || publicKey;
		transaction.recentBlockhash = transaction.recentBlockhash || (await connection.getLatestBlockhash({
			commitment: options.preflightCommitment,
			minContextSlot: options.minContextSlot
		})).blockhash;
		return transaction;
	}
};
function scopePollingDetectionStrategy(detect) {
	if (typeof window === "undefined" || typeof document === "undefined") return;
	const disposers = [];
	function detectAndDispose() {
		if (detect()) for (const dispose of disposers) dispose();
	}
	const interval = setInterval(detectAndDispose, 1e3);
	disposers.push(() => clearInterval(interval));
	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", detectAndDispose, { once: true });
		disposers.push(() => document.removeEventListener("DOMContentLoaded", detectAndDispose));
	}
	if (document.readyState !== "complete") {
		window.addEventListener("load", detectAndDispose, { once: true });
		disposers.push(() => window.removeEventListener("load", detectAndDispose));
	}
	detectAndDispose();
}
/**
* Users on iOS can be redirected into a wallet's in-app browser automatically,
* if that wallet has a universal link configured to do so
* But should not be redirected from within a webview, eg. if they're already
* inside a wallet's browser
* This function can be used to identify users who are on iOS and can be redirected
*
* @returns true if the user can be redirected
*/
function isIosAndRedirectable() {
	if (!navigator) return false;
	const userAgent = navigator.userAgent.toLowerCase();
	const isIos = userAgent.includes("iphone") || userAgent.includes("ipad");
	const isSafari = userAgent.includes("safari");
	return isIos && isSafari;
}

//#endregion
//#region node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js
function isVersionedTransaction(transaction) {
	return "version" in transaction;
}

//#endregion
//#region node_modules/@solana/wallet-adapter-base/lib/esm/signer.js
var BaseSignerWalletAdapter = class extends BaseWalletAdapter {
	async sendTransaction(transaction, connection, options = {}) {
		let emit = true;
		try {
			if (isVersionedTransaction(transaction)) {
				if (!this.supportedTransactionVersions) throw new WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);
				if (!this.supportedTransactionVersions.has(transaction.version)) throw new WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);
				try {
					transaction = await this.signTransaction(transaction);
					const rawTransaction = transaction.serialize();
					return await connection.sendRawTransaction(rawTransaction, options);
				} catch (error) {
					if (error instanceof WalletSignTransactionError) {
						emit = false;
						throw error;
					}
					throw new WalletSendTransactionError(error?.message, error);
				}
			} else try {
				const { signers, ...sendOptions } = options;
				transaction = await this.prepareTransaction(transaction, connection, sendOptions);
				signers?.length && transaction.partialSign(...signers);
				transaction = await this.signTransaction(transaction);
				const rawTransaction = transaction.serialize();
				return await connection.sendRawTransaction(rawTransaction, sendOptions);
			} catch (error) {
				if (error instanceof WalletSignTransactionError) {
					emit = false;
					throw error;
				}
				throw new WalletSendTransactionError(error?.message, error);
			}
		} catch (error) {
			if (emit) this.emit("error", error);
			throw error;
		}
	}
	async signAllTransactions(transactions) {
		for (const transaction of transactions) if (isVersionedTransaction(transaction)) {
			if (!this.supportedTransactionVersions) throw new WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);
			if (!this.supportedTransactionVersions.has(transaction.version)) throw new WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);
		}
		const signedTransactions = [];
		for (const transaction of transactions) signedTransactions.push(await this.signTransaction(transaction));
		return signedTransactions;
	}
};
var BaseMessageSignerWalletAdapter = class extends BaseSignerWalletAdapter {};
var BaseSignInMessageSignerWalletAdapter = class extends BaseMessageSignerWalletAdapter {};

//#endregion
//#region node_modules/@wallet-standard/features/lib/esm/connect.js
/** Name of the feature. */
const StandardConnect = "standard:connect";

//#endregion
//#region node_modules/@wallet-standard/features/lib/esm/disconnect.js
/** Name of the feature. */
const StandardDisconnect = "standard:disconnect";

//#endregion
//#region node_modules/@wallet-standard/features/lib/esm/events.js
/** Name of the feature. */
const StandardEvents = "standard:events";

//#endregion
//#region node_modules/@solana/wallet-standard-chains/lib/esm/index.js
/** Solana Mainnet (beta) cluster, e.g. https://api.mainnet-beta.solana.com */
const SOLANA_MAINNET_CHAIN = "solana:mainnet";
/** Solana Devnet cluster, e.g. https://api.devnet.solana.com */
const SOLANA_DEVNET_CHAIN = "solana:devnet";
/** Solana Testnet cluster, e.g. https://api.testnet.solana.com */
const SOLANA_TESTNET_CHAIN = "solana:testnet";
/** Solana Localnet cluster, e.g. http://localhost:8899 */
const SOLANA_LOCALNET_CHAIN = "solana:localnet";

//#endregion
//#region node_modules/@solana/wallet-standard-util/lib/esm/signIn.js
/**
* TODO: docs
*/
function createSignInMessage(input) {
	const text = createSignInMessageText(input);
	return new TextEncoder().encode(text);
}
/**
* TODO: docs
*/
function createSignInMessageText(input) {
	let message = `${input.domain} wants you to sign in with your Solana account:\n`;
	message += `${input.address}`;
	if (input.statement) message += `\n\n${input.statement}`;
	const fields = [];
	if (input.uri) fields.push(`URI: ${input.uri}`);
	if (input.version) fields.push(`Version: ${input.version}`);
	if (input.chainId) fields.push(`Chain ID: ${input.chainId}`);
	if (input.nonce) fields.push(`Nonce: ${input.nonce}`);
	if (input.issuedAt) fields.push(`Issued At: ${input.issuedAt}`);
	if (input.expirationTime) fields.push(`Expiration Time: ${input.expirationTime}`);
	if (input.notBefore) fields.push(`Not Before: ${input.notBefore}`);
	if (input.requestId) fields.push(`Request ID: ${input.requestId}`);
	if (input.resources) {
		fields.push(`Resources:`);
		for (const resource of input.resources) fields.push(`- ${resource}`);
	}
	if (fields.length) message += `\n\n${fields.join("\n")}`;
	return message;
}

//#endregion
export { scopePollingDetectionStrategy as _, SOLANA_MAINNET_CHAIN as a, StandardDisconnect as c, BaseSignInMessageSignerWalletAdapter as d, BaseSignerWalletAdapter as f, isIosAndRedirectable as g, WalletReadyState as h, SOLANA_LOCALNET_CHAIN as i, StandardConnect as l, BaseWalletAdapter as m, createSignInMessageText as n, SOLANA_TESTNET_CHAIN as o, isVersionedTransaction as p, SOLANA_DEVNET_CHAIN as r, StandardEvents as s, createSignInMessage as t, BaseMessageSignerWalletAdapter as u };
//# sourceMappingURL=signIn-B6eZQ8-6.js.map